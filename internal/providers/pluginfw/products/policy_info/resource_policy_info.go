// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

package policy_info

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	"github.com/databricks/databricks-sdk-go/apierr"
	"github.com/databricks/databricks-sdk-go/service/catalog"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/autogen"
	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	pluginfwcontext "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/context"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/converters"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"
	"github.com/databricks/terraform-provider-databricks/internal/service/catalog_tf"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

const resourceName = "policy_info"

var _ resource.ResourceWithConfigure = &PolicyInfoResource{}

func ResourcePolicyInfo() resource.Resource {
	return &PolicyInfoResource{}
}

type PolicyInfoResource struct {
	Client *autogen.DatabricksClient
}

// PolicyInfo extends the main model with additional fields.
type PolicyInfo struct {
	// Options for column mask policies. Valid only if `policy_type` is
	// `POLICY_TYPE_COLUMN_MASK`. Required on create and optional on update.
	// When specified on update, the new options will replace the existing
	// options as a whole.
	ColumnMask types.Object `tfsdk:"column_mask"`
	// Optional description of the policy.
	Comment types.String `tfsdk:"comment"`
	// Time at which the policy was created, in epoch milliseconds. Output only.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who created the policy. Output only.
	CreatedBy types.String `tfsdk:"created_by"`
	// Optional list of user or group names that should be excluded from the
	// policy.
	ExceptPrincipals types.List `tfsdk:"except_principals"`
	// Type of securables that the policy should take effect on. Only `TABLE` is
	// supported at this moment. Required on create and optional on update.
	ForSecurableType types.String `tfsdk:"for_securable_type"`
	// Unique identifier of the policy. This field is output only and is
	// generated by the system.
	Id types.String `tfsdk:"id"`
	// Optional list of condition expressions used to match table columns. Only
	// valid when `for_securable_type` is `TABLE`. When specified, the policy
	// only applies to tables whose columns satisfy all match conditions.
	MatchColumns types.List `tfsdk:"match_columns"`
	// Name of the policy. Required on create and optional on update. To rename
	// the policy, set `name` to a different value on update.
	Name types.String `tfsdk:"name"`
	// Full name of the securable on which the policy is defined. Required on
	// create and ignored on update.
	OnSecurableFullname types.String `tfsdk:"on_securable_fullname"`
	// Type of the securable on which the policy is defined. Only `CATALOG`,
	// `SCHEMA` and `TABLE` are supported at this moment. Required on create and
	// ignored on update.
	OnSecurableType types.String `tfsdk:"on_securable_type"`
	// Type of the policy. Required on create and ignored on update.
	PolicyType types.String `tfsdk:"policy_type"`
	// Options for row filter policies. Valid only if `policy_type` is
	// `POLICY_TYPE_ROW_FILTER`. Required on create and optional on update. When
	// specified on update, the new options will replace the existing options as
	// a whole.
	RowFilter types.Object `tfsdk:"row_filter"`
	// List of user or group names that the policy applies to. Required on
	// create and optional on update.
	ToPrincipals types.List `tfsdk:"to_principals"`
	// Time at which the policy was last modified, in epoch milliseconds. Output
	// only.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of the user who last modified the policy. Output only.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Optional condition when the policy should take effect.
	WhenCondition types.String `tfsdk:"when_condition"`
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in the extended
// PolicyInfo struct. Container types (types.Map, types.List, types.Set) and
// object types (types.Object) do not carry the type information of their elements in the Go
// type system. This function provides a way to retrieve the type information of the elements in
// complex fields at runtime. The values of the map are the reflected types of the contained elements.
// They must be either primitive values from the plugin framework type system
// (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF SDK values.
func (m PolicyInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"column_mask":       reflect.TypeOf(catalog_tf.ColumnMaskOptions{}),
		"except_principals": reflect.TypeOf(types.String{}),
		"match_columns":     reflect.TypeOf(catalog_tf.MatchColumn{}),
		"row_filter":        reflect.TypeOf(catalog_tf.RowFilterOptions{}),
		"to_principals":     reflect.TypeOf(types.String{}),
	}
}

// ToObjectValue returns the object value for the resource, combining attributes from the
// embedded TFSDK model and contains additional fields.
//
// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PolicyInfo
// only implements ToObjectValue() and Type().
func (m PolicyInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{"column_mask": m.ColumnMask,
			"comment":               m.Comment,
			"created_at":            m.CreatedAt,
			"created_by":            m.CreatedBy,
			"except_principals":     m.ExceptPrincipals,
			"for_securable_type":    m.ForSecurableType,
			"id":                    m.Id,
			"match_columns":         m.MatchColumns,
			"name":                  m.Name,
			"on_securable_fullname": m.OnSecurableFullname,
			"on_securable_type":     m.OnSecurableType,
			"policy_type":           m.PolicyType,
			"row_filter":            m.RowFilter,
			"to_principals":         m.ToPrincipals,
			"updated_at":            m.UpdatedAt,
			"updated_by":            m.UpdatedBy,
			"when_condition":        m.WhenCondition,
		},
	)
}

// Type returns the object type with attributes from both the embedded TFSDK model
// and contains additional fields.
func (m PolicyInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{"column_mask": catalog_tf.ColumnMaskOptions{}.Type(ctx),
			"comment":    types.StringType,
			"created_at": types.Int64Type,
			"created_by": types.StringType,
			"except_principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"for_securable_type": types.StringType,
			"id":                 types.StringType,
			"match_columns": basetypes.ListType{
				ElemType: catalog_tf.MatchColumn{}.Type(ctx),
			},
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"policy_type":           types.StringType,
			"row_filter":            catalog_tf.RowFilterOptions{}.Type(ctx),
			"to_principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"updated_at":     types.Int64Type,
			"updated_by":     types.StringType,
			"when_condition": types.StringType,
		},
	}
}

// SyncFieldsDuringCreateOrUpdate copies values from the plan into the receiver,
// including both embedded model fields and additional fields. This method is called
// during create and update.
func (to *PolicyInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PolicyInfo) {
	if !from.ColumnMask.IsNull() && !from.ColumnMask.IsUnknown() {
		if toColumnMask, ok := to.GetColumnMask(ctx); ok {
			if fromColumnMask, ok := from.GetColumnMask(ctx); ok {
				// Recursively sync the fields of ColumnMask
				toColumnMask.SyncFieldsDuringCreateOrUpdate(ctx, fromColumnMask)
				to.SetColumnMask(ctx, toColumnMask)
			}
		}
	}
	if !from.ExceptPrincipals.IsNull() && !from.ExceptPrincipals.IsUnknown() && to.ExceptPrincipals.IsNull() && len(from.ExceptPrincipals.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExceptPrincipals, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExceptPrincipals = from.ExceptPrincipals
	}
	if !from.MatchColumns.IsNull() && !from.MatchColumns.IsUnknown() && to.MatchColumns.IsNull() && len(from.MatchColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for MatchColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.MatchColumns = from.MatchColumns
	}
	if !from.RowFilter.IsNull() && !from.RowFilter.IsUnknown() {
		if toRowFilter, ok := to.GetRowFilter(ctx); ok {
			if fromRowFilter, ok := from.GetRowFilter(ctx); ok {
				// Recursively sync the fields of RowFilter
				toRowFilter.SyncFieldsDuringCreateOrUpdate(ctx, fromRowFilter)
				to.SetRowFilter(ctx, toRowFilter)
			}
		}
	}
}

// SyncFieldsDuringRead copies values from the existing state into the receiver,
// including both embedded model fields and additional fields. This method is called
// during read.
func (to *PolicyInfo) SyncFieldsDuringRead(ctx context.Context, from PolicyInfo) {
	if !from.ColumnMask.IsNull() && !from.ColumnMask.IsUnknown() {
		if toColumnMask, ok := to.GetColumnMask(ctx); ok {
			if fromColumnMask, ok := from.GetColumnMask(ctx); ok {
				toColumnMask.SyncFieldsDuringRead(ctx, fromColumnMask)
				to.SetColumnMask(ctx, toColumnMask)
			}
		}
	}
	if !from.ExceptPrincipals.IsNull() && !from.ExceptPrincipals.IsUnknown() && to.ExceptPrincipals.IsNull() && len(from.ExceptPrincipals.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExceptPrincipals, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExceptPrincipals = from.ExceptPrincipals
	}
	if !from.MatchColumns.IsNull() && !from.MatchColumns.IsUnknown() && to.MatchColumns.IsNull() && len(from.MatchColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for MatchColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.MatchColumns = from.MatchColumns
	}
	if !from.RowFilter.IsNull() && !from.RowFilter.IsUnknown() {
		if toRowFilter, ok := to.GetRowFilter(ctx); ok {
			if fromRowFilter, ok := from.GetRowFilter(ctx); ok {
				toRowFilter.SyncFieldsDuringRead(ctx, fromRowFilter)
				to.SetRowFilter(ctx, toRowFilter)
			}
		}
	}
}

func (m PolicyInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["column_mask"] = attrs["column_mask"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["except_principals"] = attrs["except_principals"].SetOptional()
	attrs["for_securable_type"] = attrs["for_securable_type"].SetRequired()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["match_columns"] = attrs["match_columns"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetOptional()
	attrs["on_securable_type"] = attrs["on_securable_type"].SetOptional()
	attrs["policy_type"] = attrs["policy_type"].SetRequired()
	attrs["row_filter"] = attrs["row_filter"].SetOptional()
	attrs["to_principals"] = attrs["to_principals"].SetRequired()
	attrs["updated_at"] = attrs["updated_at"].SetComputed()
	attrs["updated_by"] = attrs["updated_by"].SetComputed()
	attrs["when_condition"] = attrs["when_condition"].SetOptional()

	attrs["on_securable_type"] = attrs["on_securable_type"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	return attrs
}

// GetColumnMask returns the value of the ColumnMask field in PolicyInfo as
// a catalog_tf.ColumnMaskOptions value.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo) GetColumnMask(ctx context.Context) (catalog_tf.ColumnMaskOptions, bool) {
	var e catalog_tf.ColumnMaskOptions
	if m.ColumnMask.IsNull() || m.ColumnMask.IsUnknown() {
		return e, false
	}
	var v catalog_tf.ColumnMaskOptions
	d := m.ColumnMask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumnMask sets the value of the ColumnMask field in PolicyInfo.
func (m *PolicyInfo) SetColumnMask(ctx context.Context, v catalog_tf.ColumnMaskOptions) {
	vs := v.ToObjectValue(ctx)
	m.ColumnMask = vs
}

// GetExceptPrincipals returns the value of the ExceptPrincipals field in PolicyInfo as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo) GetExceptPrincipals(ctx context.Context) ([]types.String, bool) {
	if m.ExceptPrincipals.IsNull() || m.ExceptPrincipals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ExceptPrincipals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExceptPrincipals sets the value of the ExceptPrincipals field in PolicyInfo.
func (m *PolicyInfo) SetExceptPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["except_principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ExceptPrincipals = types.ListValueMust(t, vs)
}

// GetMatchColumns returns the value of the MatchColumns field in PolicyInfo as
// a slice of catalog_tf.MatchColumn values.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo) GetMatchColumns(ctx context.Context) ([]catalog_tf.MatchColumn, bool) {
	if m.MatchColumns.IsNull() || m.MatchColumns.IsUnknown() {
		return nil, false
	}
	var v []catalog_tf.MatchColumn
	d := m.MatchColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMatchColumns sets the value of the MatchColumns field in PolicyInfo.
func (m *PolicyInfo) SetMatchColumns(ctx context.Context, v []catalog_tf.MatchColumn) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["match_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.MatchColumns = types.ListValueMust(t, vs)
}

// GetRowFilter returns the value of the RowFilter field in PolicyInfo as
// a catalog_tf.RowFilterOptions value.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo) GetRowFilter(ctx context.Context) (catalog_tf.RowFilterOptions, bool) {
	var e catalog_tf.RowFilterOptions
	if m.RowFilter.IsNull() || m.RowFilter.IsUnknown() {
		return e, false
	}
	var v catalog_tf.RowFilterOptions
	d := m.RowFilter.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRowFilter sets the value of the RowFilter field in PolicyInfo.
func (m *PolicyInfo) SetRowFilter(ctx context.Context, v catalog_tf.RowFilterOptions) {
	vs := v.ToObjectValue(ctx)
	m.RowFilter = vs
}

// GetToPrincipals returns the value of the ToPrincipals field in PolicyInfo as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo) GetToPrincipals(ctx context.Context) ([]types.String, bool) {
	if m.ToPrincipals.IsNull() || m.ToPrincipals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ToPrincipals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetToPrincipals sets the value of the ToPrincipals field in PolicyInfo.
func (m *PolicyInfo) SetToPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["to_principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ToPrincipals = types.ListValueMust(t, vs)
}

func (r *PolicyInfoResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = autogen.GetDatabricksProductionName(resourceName)
}

func (r *PolicyInfoResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	attrs, blocks := tfschema.ResourceStructToSchemaMap(ctx, PolicyInfo{}, nil)
	resp.Schema = schema.Schema{
		Description: "Terraform schema for Databricks policy_info",
		Attributes:  attrs,
		Blocks:      blocks,
	}
}

func (r *PolicyInfoResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	r.Client = autogen.ConfigureResource(req, resp)
}

func (r *PolicyInfoResource) update(ctx context.Context, plan PolicyInfo, diags *diag.Diagnostics, state *tfsdk.State) {
	var policy_info catalog.PolicyInfo

	diags.Append(converters.TfSdkToGoSdkStruct(ctx, plan, &policy_info)...)
	if diags.HasError() {
		return
	}

	updateRequest := catalog.UpdatePolicyRequest{
		PolicyInfo:          policy_info,
		Name:                plan.Name.ValueString(),
		OnSecurableFullname: plan.OnSecurableFullname.ValueString(),
		OnSecurableType:     plan.OnSecurableType.ValueString(),
		UpdateMask:          "column_mask,comment,except_principals,for_securable_type,match_columns,policy_type,row_filter,to_principals,when_condition",
	}

	client, clientDiags := r.Client.GetWorkspaceClient()

	diags.Append(clientDiags...)
	if diags.HasError() {
		return
	}
	response, err := client.Policies.UpdatePolicy(ctx, updateRequest)
	if err != nil {
		diags.AddError("failed to update policy_info", err.Error())
		return
	}

	var newState PolicyInfo

	diags.Append(converters.GoSdkToTfSdkStruct(ctx, response, &newState)...)

	if diags.HasError() {
		return
	}

	newState.SyncFieldsDuringCreateOrUpdate(ctx, plan)
	diags.Append(state.Set(ctx, newState)...)
}

func (r *PolicyInfoResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	ctx = pluginfwcontext.SetUserAgentInResourceContext(ctx, resourceName)

	var plan PolicyInfo
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var policy_info catalog.PolicyInfo

	resp.Diagnostics.Append(converters.TfSdkToGoSdkStruct(ctx, plan, &policy_info)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createRequest := catalog.CreatePolicyRequest{
		PolicyInfo: policy_info,
	}

	client, clientDiags := r.Client.GetWorkspaceClient()

	resp.Diagnostics.Append(clientDiags...)
	if resp.Diagnostics.HasError() {
		return
	}

	response, err := client.Policies.CreatePolicy(ctx, createRequest)
	if err != nil {
		resp.Diagnostics.AddError("failed to create policy_info", err.Error())
		return
	}

	var newState PolicyInfo

	resp.Diagnostics.Append(converters.GoSdkToTfSdkStruct(ctx, response, &newState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	newState.SyncFieldsDuringCreateOrUpdate(ctx, plan)

	resp.Diagnostics.Append(resp.State.Set(ctx, newState)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

func (r *PolicyInfoResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	ctx = pluginfwcontext.SetUserAgentInResourceContext(ctx, resourceName)

	var existingState PolicyInfo
	resp.Diagnostics.Append(req.State.Get(ctx, &existingState)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var readRequest catalog.GetPolicyRequest
	resp.Diagnostics.Append(converters.TfSdkToGoSdkStruct(ctx, existingState, &readRequest)...)
	if resp.Diagnostics.HasError() {
		return
	}

	client, clientDiags := r.Client.GetWorkspaceClient()

	resp.Diagnostics.Append(clientDiags...)
	if resp.Diagnostics.HasError() {
		return
	}
	response, err := client.Policies.GetPolicy(ctx, readRequest)
	if err != nil {
		if apierr.IsMissing(err) {
			resp.State.RemoveResource(ctx)
			return
		}

		resp.Diagnostics.AddError("failed to get policy_info", err.Error())
		return
	}

	var newState PolicyInfo
	resp.Diagnostics.Append(converters.GoSdkToTfSdkStruct(ctx, response, &newState)...)
	if resp.Diagnostics.HasError() {
		return
	}

	newState.SyncFieldsDuringRead(ctx, existingState)

	resp.Diagnostics.Append(resp.State.Set(ctx, newState)...)
}

func (r *PolicyInfoResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	ctx = pluginfwcontext.SetUserAgentInResourceContext(ctx, resourceName)

	var plan PolicyInfo
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.update(ctx, plan, &resp.Diagnostics, &resp.State)
}

func (r *PolicyInfoResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	ctx = pluginfwcontext.SetUserAgentInResourceContext(ctx, resourceName)

	var state PolicyInfo
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var deleteRequest catalog.DeletePolicyRequest
	resp.Diagnostics.Append(converters.TfSdkToGoSdkStruct(ctx, state, &deleteRequest)...)
	if resp.Diagnostics.HasError() {
		return
	}

	client, clientDiags := r.Client.GetWorkspaceClient()

	resp.Diagnostics.Append(clientDiags...)
	if resp.Diagnostics.HasError() {
		return
	}

	_, err := client.Policies.DeletePolicy(ctx, deleteRequest)
	if err != nil && !apierr.IsMissing(err) {
		resp.Diagnostics.AddError("failed to delete policy_info", err.Error())
		return
	}

}

var _ resource.ResourceWithImportState = &PolicyInfoResource{}

func (r *PolicyInfoResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	parts := strings.Split(req.ID, ",")

	if len(parts) != 3 || parts[0] == "" || parts[1] == "" || parts[2] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf(
				"Expected import identifier with format: on_securable_type,on_securable_fullname,name. Got: %q",
				req.ID,
			),
		)
		return
	}

	onSecurableType := parts[0]
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("on_securable_type"), onSecurableType)...)
	onSecurableFullname := parts[1]
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("on_securable_fullname"), onSecurableFullname)...)
	name := parts[2]
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
}
