// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package catalog_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type AccessRequestDestinations_SdkV2 struct {
	// Indicates whether any destinations are hidden from the caller due to a
	// lack of permissions. This value is true if the caller does not have
	// permission to see all destinations.
	AreAnyDestinationsHidden types.Bool `tfsdk:"are_any_destinations_hidden"`
	// The access request destinations for the securable.
	Destinations types.List `tfsdk:"destinations"`
	// The securable for which the access request destinations are being
	// retrieved.
	Securable types.List `tfsdk:"securable"`
}

func (to *AccessRequestDestinations_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccessRequestDestinations_SdkV2) {
	if !from.Securable.IsNull() && !from.Securable.IsUnknown() {
		if toSecurable, ok := to.GetSecurable(ctx); ok {
			if fromSecurable, ok := from.GetSecurable(ctx); ok {
				// Recursively sync the fields of Securable
				toSecurable.SyncFieldsDuringCreateOrUpdate(ctx, fromSecurable)
				to.SetSecurable(ctx, toSecurable)
			}
		}
	}
}

func (to *AccessRequestDestinations_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccessRequestDestinations_SdkV2) {
	if !from.Securable.IsNull() && !from.Securable.IsUnknown() {
		if toSecurable, ok := to.GetSecurable(ctx); ok {
			if fromSecurable, ok := from.GetSecurable(ctx); ok {
				toSecurable.SyncFieldsDuringRead(ctx, fromSecurable)
				to.SetSecurable(ctx, toSecurable)
			}
		}
	}
}

func (m AccessRequestDestinations_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["are_any_destinations_hidden"] = attrs["are_any_destinations_hidden"].SetComputed()
	attrs["destinations"] = attrs["destinations"].SetRequired()
	attrs["securable"] = attrs["securable"].SetRequired()
	attrs["securable"] = attrs["securable"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccessRequestDestinations.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccessRequestDestinations_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"destinations": reflect.TypeOf(NotificationDestination_SdkV2{}),
		"securable":    reflect.TypeOf(Securable_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccessRequestDestinations_SdkV2
// only implements ToObjectValue() and Type().
func (m AccessRequestDestinations_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"are_any_destinations_hidden": m.AreAnyDestinationsHidden,
			"destinations":                m.Destinations,
			"securable":                   m.Securable,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccessRequestDestinations_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"are_any_destinations_hidden": types.BoolType,
			"destinations": basetypes.ListType{
				ElemType: NotificationDestination_SdkV2{}.Type(ctx),
			},
			"securable": basetypes.ListType{
				ElemType: Securable_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetDestinations returns the value of the Destinations field in AccessRequestDestinations_SdkV2 as
// a slice of NotificationDestination_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *AccessRequestDestinations_SdkV2) GetDestinations(ctx context.Context) ([]NotificationDestination_SdkV2, bool) {
	if m.Destinations.IsNull() || m.Destinations.IsUnknown() {
		return nil, false
	}
	var v []NotificationDestination_SdkV2
	d := m.Destinations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDestinations sets the value of the Destinations field in AccessRequestDestinations_SdkV2.
func (m *AccessRequestDestinations_SdkV2) SetDestinations(ctx context.Context, v []NotificationDestination_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["destinations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Destinations = types.ListValueMust(t, vs)
}

// GetSecurable returns the value of the Securable field in AccessRequestDestinations_SdkV2 as
// a Securable_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccessRequestDestinations_SdkV2) GetSecurable(ctx context.Context) (Securable_SdkV2, bool) {
	var e Securable_SdkV2
	if m.Securable.IsNull() || m.Securable.IsUnknown() {
		return e, false
	}
	var v []Securable_SdkV2
	d := m.Securable.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSecurable sets the value of the Securable field in AccessRequestDestinations_SdkV2.
func (m *AccessRequestDestinations_SdkV2) SetSecurable(ctx context.Context, v Securable_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["securable"]
	m.Securable = types.ListValueMust(t, vs)
}

// Properties of the new metastore.
type AccountsCreateMetastore_SdkV2 struct {
	MetastoreInfo types.List `tfsdk:"metastore_info"`
}

func (to *AccountsCreateMetastore_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsCreateMetastore_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				// Recursively sync the fields of MetastoreInfo
				toMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (to *AccountsCreateMetastore_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsCreateMetastore_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				toMetastoreInfo.SyncFieldsDuringRead(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (m AccountsCreateMetastore_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["metastore_info"] = attrs["metastore_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsCreateMetastore_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(CreateAccountsMetastore_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateMetastore_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsCreateMetastore_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_info": m.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsCreateMetastore_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_info": basetypes.ListType{
				ElemType: CreateAccountsMetastore_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsCreateMetastore_SdkV2 as
// a CreateAccountsMetastore_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsCreateMetastore_SdkV2) GetMetastoreInfo(ctx context.Context) (CreateAccountsMetastore_SdkV2, bool) {
	var e CreateAccountsMetastore_SdkV2
	if m.MetastoreInfo.IsNull() || m.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v []CreateAccountsMetastore_SdkV2
	d := m.MetastoreInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsCreateMetastore_SdkV2.
func (m *AccountsCreateMetastore_SdkV2) SetMetastoreInfo(ctx context.Context, v CreateAccountsMetastore_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_info"]
	m.MetastoreInfo = types.ListValueMust(t, vs)
}

// The mapping from workspace to metastore.
type AccountsCreateMetastoreAssignment_SdkV2 struct {
	MetastoreAssignment types.List `tfsdk:"metastore_assignment"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *AccountsCreateMetastoreAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsCreateMetastoreAssignment_SdkV2) {
	if !from.MetastoreAssignment.IsNull() && !from.MetastoreAssignment.IsUnknown() {
		if toMetastoreAssignment, ok := to.GetMetastoreAssignment(ctx); ok {
			if fromMetastoreAssignment, ok := from.GetMetastoreAssignment(ctx); ok {
				// Recursively sync the fields of MetastoreAssignment
				toMetastoreAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreAssignment)
				to.SetMetastoreAssignment(ctx, toMetastoreAssignment)
			}
		}
	}
}

func (to *AccountsCreateMetastoreAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsCreateMetastoreAssignment_SdkV2) {
	if !from.MetastoreAssignment.IsNull() && !from.MetastoreAssignment.IsUnknown() {
		if toMetastoreAssignment, ok := to.GetMetastoreAssignment(ctx); ok {
			if fromMetastoreAssignment, ok := from.GetMetastoreAssignment(ctx); ok {
				toMetastoreAssignment.SyncFieldsDuringRead(ctx, fromMetastoreAssignment)
				to.SetMetastoreAssignment(ctx, toMetastoreAssignment)
			}
		}
	}
}

func (m AccountsCreateMetastoreAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_assignment"] = attrs["metastore_assignment"].SetOptional()
	attrs["metastore_assignment"] = attrs["metastore_assignment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsCreateMetastoreAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_assignment": reflect.TypeOf(CreateMetastoreAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateMetastoreAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsCreateMetastoreAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_assignment": m.MetastoreAssignment,
			"metastore_id":         m.MetastoreId,
			"workspace_id":         m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsCreateMetastoreAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_assignment": basetypes.ListType{
				ElemType: CreateMetastoreAssignment_SdkV2{}.Type(ctx),
			},
			"metastore_id": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}

// GetMetastoreAssignment returns the value of the MetastoreAssignment field in AccountsCreateMetastoreAssignment_SdkV2 as
// a CreateMetastoreAssignment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsCreateMetastoreAssignment_SdkV2) GetMetastoreAssignment(ctx context.Context) (CreateMetastoreAssignment_SdkV2, bool) {
	var e CreateMetastoreAssignment_SdkV2
	if m.MetastoreAssignment.IsNull() || m.MetastoreAssignment.IsUnknown() {
		return e, false
	}
	var v []CreateMetastoreAssignment_SdkV2
	d := m.MetastoreAssignment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreAssignment sets the value of the MetastoreAssignment field in AccountsCreateMetastoreAssignment_SdkV2.
func (m *AccountsCreateMetastoreAssignment_SdkV2) SetMetastoreAssignment(ctx context.Context, v CreateMetastoreAssignment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_assignment"]
	m.MetastoreAssignment = types.ListValueMust(t, vs)
}

// The metastore assignment was successfully created.
type AccountsCreateMetastoreAssignmentResponse_SdkV2 struct {
}

func (to *AccountsCreateMetastoreAssignmentResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsCreateMetastoreAssignmentResponse_SdkV2) {
}

func (to *AccountsCreateMetastoreAssignmentResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsCreateMetastoreAssignmentResponse_SdkV2) {
}

func (m AccountsCreateMetastoreAssignmentResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateMetastoreAssignmentResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsCreateMetastoreAssignmentResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateMetastoreAssignmentResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsCreateMetastoreAssignmentResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsCreateMetastoreAssignmentResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type AccountsCreateMetastoreResponse_SdkV2 struct {
	MetastoreInfo types.List `tfsdk:"metastore_info"`
}

func (to *AccountsCreateMetastoreResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsCreateMetastoreResponse_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				// Recursively sync the fields of MetastoreInfo
				toMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (to *AccountsCreateMetastoreResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsCreateMetastoreResponse_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				toMetastoreInfo.SyncFieldsDuringRead(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (m AccountsCreateMetastoreResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["metastore_info"] = attrs["metastore_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateMetastoreResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsCreateMetastoreResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(MetastoreInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateMetastoreResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsCreateMetastoreResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_info": m.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsCreateMetastoreResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_info": basetypes.ListType{
				ElemType: MetastoreInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsCreateMetastoreResponse_SdkV2 as
// a MetastoreInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsCreateMetastoreResponse_SdkV2) GetMetastoreInfo(ctx context.Context) (MetastoreInfo_SdkV2, bool) {
	var e MetastoreInfo_SdkV2
	if m.MetastoreInfo.IsNull() || m.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v []MetastoreInfo_SdkV2
	d := m.MetastoreInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsCreateMetastoreResponse_SdkV2.
func (m *AccountsCreateMetastoreResponse_SdkV2) SetMetastoreInfo(ctx context.Context, v MetastoreInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_info"]
	m.MetastoreInfo = types.ListValueMust(t, vs)
}

type AccountsCreateStorageCredential_SdkV2 struct {
	CredentialInfo types.List `tfsdk:"credential_info"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Optional, default false. Supplying true to this argument skips validation
	// of the created set of credentials.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (to *AccountsCreateStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsCreateStorageCredential_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				// Recursively sync the fields of CredentialInfo
				toCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (to *AccountsCreateStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsCreateStorageCredential_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				toCredentialInfo.SyncFieldsDuringRead(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (m AccountsCreateStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["credential_info"] = attrs["credential_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsCreateStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(CreateAccountsStorageCredential_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsCreateStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info": m.CredentialInfo,
			"metastore_id":    m.MetastoreId,
			"skip_validation": m.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsCreateStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": basetypes.ListType{
				ElemType: CreateAccountsStorageCredential_SdkV2{}.Type(ctx),
			},
			"metastore_id":    types.StringType,
			"skip_validation": types.BoolType,
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsCreateStorageCredential_SdkV2 as
// a CreateAccountsStorageCredential_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsCreateStorageCredential_SdkV2) GetCredentialInfo(ctx context.Context) (CreateAccountsStorageCredential_SdkV2, bool) {
	var e CreateAccountsStorageCredential_SdkV2
	if m.CredentialInfo.IsNull() || m.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v []CreateAccountsStorageCredential_SdkV2
	d := m.CredentialInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsCreateStorageCredential_SdkV2.
func (m *AccountsCreateStorageCredential_SdkV2) SetCredentialInfo(ctx context.Context, v CreateAccountsStorageCredential_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credential_info"]
	m.CredentialInfo = types.ListValueMust(t, vs)
}

type AccountsCreateStorageCredentialInfo_SdkV2 struct {
	CredentialInfo types.List `tfsdk:"credential_info"`
}

func (to *AccountsCreateStorageCredentialInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsCreateStorageCredentialInfo_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				// Recursively sync the fields of CredentialInfo
				toCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (to *AccountsCreateStorageCredentialInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsCreateStorageCredentialInfo_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				toCredentialInfo.SyncFieldsDuringRead(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (m AccountsCreateStorageCredentialInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["credential_info"] = attrs["credential_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateStorageCredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsCreateStorageCredentialInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(StorageCredentialInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateStorageCredentialInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsCreateStorageCredentialInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info": m.CredentialInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsCreateStorageCredentialInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": basetypes.ListType{
				ElemType: StorageCredentialInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsCreateStorageCredentialInfo_SdkV2 as
// a StorageCredentialInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsCreateStorageCredentialInfo_SdkV2) GetCredentialInfo(ctx context.Context) (StorageCredentialInfo_SdkV2, bool) {
	var e StorageCredentialInfo_SdkV2
	if m.CredentialInfo.IsNull() || m.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v []StorageCredentialInfo_SdkV2
	d := m.CredentialInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsCreateStorageCredentialInfo_SdkV2.
func (m *AccountsCreateStorageCredentialInfo_SdkV2) SetCredentialInfo(ctx context.Context, v StorageCredentialInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credential_info"]
	m.CredentialInfo = types.ListValueMust(t, vs)
}

// The metastore assignment was successfully deleted.
type AccountsDeleteMetastoreAssignmentResponse_SdkV2 struct {
}

func (to *AccountsDeleteMetastoreAssignmentResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsDeleteMetastoreAssignmentResponse_SdkV2) {
}

func (to *AccountsDeleteMetastoreAssignmentResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsDeleteMetastoreAssignmentResponse_SdkV2) {
}

func (m AccountsDeleteMetastoreAssignmentResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsDeleteMetastoreAssignmentResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsDeleteMetastoreAssignmentResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsDeleteMetastoreAssignmentResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsDeleteMetastoreAssignmentResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsDeleteMetastoreAssignmentResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// The metastore was successfully deleted.
type AccountsDeleteMetastoreResponse_SdkV2 struct {
}

func (to *AccountsDeleteMetastoreResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsDeleteMetastoreResponse_SdkV2) {
}

func (to *AccountsDeleteMetastoreResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsDeleteMetastoreResponse_SdkV2) {
}

func (m AccountsDeleteMetastoreResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsDeleteMetastoreResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsDeleteMetastoreResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsDeleteMetastoreResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsDeleteMetastoreResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsDeleteMetastoreResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// The storage credential was successfully deleted.
type AccountsDeleteStorageCredentialResponse_SdkV2 struct {
}

func (to *AccountsDeleteStorageCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsDeleteStorageCredentialResponse_SdkV2) {
}

func (to *AccountsDeleteStorageCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsDeleteStorageCredentialResponse_SdkV2) {
}

func (m AccountsDeleteStorageCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsDeleteStorageCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsDeleteStorageCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsDeleteStorageCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsDeleteStorageCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsDeleteStorageCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// The metastore was successfully returned.
type AccountsGetMetastoreResponse_SdkV2 struct {
	MetastoreInfo types.List `tfsdk:"metastore_info"`
}

func (to *AccountsGetMetastoreResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsGetMetastoreResponse_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				// Recursively sync the fields of MetastoreInfo
				toMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (to *AccountsGetMetastoreResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsGetMetastoreResponse_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				toMetastoreInfo.SyncFieldsDuringRead(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (m AccountsGetMetastoreResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["metastore_info"] = attrs["metastore_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsGetMetastoreResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsGetMetastoreResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(MetastoreInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsGetMetastoreResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsGetMetastoreResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_info": m.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsGetMetastoreResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_info": basetypes.ListType{
				ElemType: MetastoreInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsGetMetastoreResponse_SdkV2 as
// a MetastoreInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsGetMetastoreResponse_SdkV2) GetMetastoreInfo(ctx context.Context) (MetastoreInfo_SdkV2, bool) {
	var e MetastoreInfo_SdkV2
	if m.MetastoreInfo.IsNull() || m.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v []MetastoreInfo_SdkV2
	d := m.MetastoreInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsGetMetastoreResponse_SdkV2.
func (m *AccountsGetMetastoreResponse_SdkV2) SetMetastoreInfo(ctx context.Context, v MetastoreInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_info"]
	m.MetastoreInfo = types.ListValueMust(t, vs)
}

// Metastores were returned successfully.
type AccountsListMetastoresResponse_SdkV2 struct {
	// An array of metastore information objects.
	Metastores types.List `tfsdk:"metastores"`
}

func (to *AccountsListMetastoresResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsListMetastoresResponse_SdkV2) {
	if !from.Metastores.IsNull() && !from.Metastores.IsUnknown() && to.Metastores.IsNull() && len(from.Metastores.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Metastores, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Metastores = from.Metastores
	}
}

func (to *AccountsListMetastoresResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsListMetastoresResponse_SdkV2) {
	if !from.Metastores.IsNull() && !from.Metastores.IsUnknown() && to.Metastores.IsNull() && len(from.Metastores.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Metastores, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Metastores = from.Metastores
	}
}

func (m AccountsListMetastoresResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastores"] = attrs["metastores"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsListMetastoresResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsListMetastoresResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastores": reflect.TypeOf(MetastoreInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsListMetastoresResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsListMetastoresResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastores": m.Metastores,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsListMetastoresResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastores": basetypes.ListType{
				ElemType: MetastoreInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastores returns the value of the Metastores field in AccountsListMetastoresResponse_SdkV2 as
// a slice of MetastoreInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsListMetastoresResponse_SdkV2) GetMetastores(ctx context.Context) ([]MetastoreInfo_SdkV2, bool) {
	if m.Metastores.IsNull() || m.Metastores.IsUnknown() {
		return nil, false
	}
	var v []MetastoreInfo_SdkV2
	d := m.Metastores.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastores sets the value of the Metastores field in AccountsListMetastoresResponse_SdkV2.
func (m *AccountsListMetastoresResponse_SdkV2) SetMetastores(ctx context.Context, v []MetastoreInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastores"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Metastores = types.ListValueMust(t, vs)
}

// The workspace metastore assignment was successfully returned.
type AccountsMetastoreAssignment_SdkV2 struct {
	MetastoreAssignment types.List `tfsdk:"metastore_assignment"`
}

func (to *AccountsMetastoreAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsMetastoreAssignment_SdkV2) {
	if !from.MetastoreAssignment.IsNull() && !from.MetastoreAssignment.IsUnknown() {
		if toMetastoreAssignment, ok := to.GetMetastoreAssignment(ctx); ok {
			if fromMetastoreAssignment, ok := from.GetMetastoreAssignment(ctx); ok {
				// Recursively sync the fields of MetastoreAssignment
				toMetastoreAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreAssignment)
				to.SetMetastoreAssignment(ctx, toMetastoreAssignment)
			}
		}
	}
}

func (to *AccountsMetastoreAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsMetastoreAssignment_SdkV2) {
	if !from.MetastoreAssignment.IsNull() && !from.MetastoreAssignment.IsUnknown() {
		if toMetastoreAssignment, ok := to.GetMetastoreAssignment(ctx); ok {
			if fromMetastoreAssignment, ok := from.GetMetastoreAssignment(ctx); ok {
				toMetastoreAssignment.SyncFieldsDuringRead(ctx, fromMetastoreAssignment)
				to.SetMetastoreAssignment(ctx, toMetastoreAssignment)
			}
		}
	}
}

func (m AccountsMetastoreAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_assignment"] = attrs["metastore_assignment"].SetOptional()
	attrs["metastore_assignment"] = attrs["metastore_assignment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsMetastoreAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_assignment": reflect.TypeOf(MetastoreAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsMetastoreAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsMetastoreAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_assignment": m.MetastoreAssignment,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsMetastoreAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_assignment": basetypes.ListType{
				ElemType: MetastoreAssignment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastoreAssignment returns the value of the MetastoreAssignment field in AccountsMetastoreAssignment_SdkV2 as
// a MetastoreAssignment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsMetastoreAssignment_SdkV2) GetMetastoreAssignment(ctx context.Context) (MetastoreAssignment_SdkV2, bool) {
	var e MetastoreAssignment_SdkV2
	if m.MetastoreAssignment.IsNull() || m.MetastoreAssignment.IsUnknown() {
		return e, false
	}
	var v []MetastoreAssignment_SdkV2
	d := m.MetastoreAssignment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreAssignment sets the value of the MetastoreAssignment field in AccountsMetastoreAssignment_SdkV2.
func (m *AccountsMetastoreAssignment_SdkV2) SetMetastoreAssignment(ctx context.Context, v MetastoreAssignment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_assignment"]
	m.MetastoreAssignment = types.ListValueMust(t, vs)
}

// The storage credential was successfully retrieved.
type AccountsStorageCredentialInfo_SdkV2 struct {
	CredentialInfo types.List `tfsdk:"credential_info"`
}

func (to *AccountsStorageCredentialInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsStorageCredentialInfo_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				// Recursively sync the fields of CredentialInfo
				toCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (to *AccountsStorageCredentialInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsStorageCredentialInfo_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				toCredentialInfo.SyncFieldsDuringRead(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (m AccountsStorageCredentialInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["credential_info"] = attrs["credential_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsStorageCredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsStorageCredentialInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(StorageCredentialInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsStorageCredentialInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsStorageCredentialInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info": m.CredentialInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsStorageCredentialInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": basetypes.ListType{
				ElemType: StorageCredentialInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsStorageCredentialInfo_SdkV2 as
// a StorageCredentialInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsStorageCredentialInfo_SdkV2) GetCredentialInfo(ctx context.Context) (StorageCredentialInfo_SdkV2, bool) {
	var e StorageCredentialInfo_SdkV2
	if m.CredentialInfo.IsNull() || m.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v []StorageCredentialInfo_SdkV2
	d := m.CredentialInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsStorageCredentialInfo_SdkV2.
func (m *AccountsStorageCredentialInfo_SdkV2) SetCredentialInfo(ctx context.Context, v StorageCredentialInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credential_info"]
	m.CredentialInfo = types.ListValueMust(t, vs)
}

// Properties of the metastore to change.
type AccountsUpdateMetastore_SdkV2 struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Properties of the metastore to change.
	MetastoreInfo types.List `tfsdk:"metastore_info"`
}

func (to *AccountsUpdateMetastore_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsUpdateMetastore_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				// Recursively sync the fields of MetastoreInfo
				toMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (to *AccountsUpdateMetastore_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsUpdateMetastore_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				toMetastoreInfo.SyncFieldsDuringRead(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (m AccountsUpdateMetastore_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["metastore_info"] = attrs["metastore_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsUpdateMetastore_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(UpdateAccountsMetastore_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateMetastore_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsUpdateMetastore_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id":   m.MetastoreId,
			"metastore_info": m.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsUpdateMetastore_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"metastore_info": basetypes.ListType{
				ElemType: UpdateAccountsMetastore_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsUpdateMetastore_SdkV2 as
// a UpdateAccountsMetastore_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsUpdateMetastore_SdkV2) GetMetastoreInfo(ctx context.Context) (UpdateAccountsMetastore_SdkV2, bool) {
	var e UpdateAccountsMetastore_SdkV2
	if m.MetastoreInfo.IsNull() || m.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v []UpdateAccountsMetastore_SdkV2
	d := m.MetastoreInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsUpdateMetastore_SdkV2.
func (m *AccountsUpdateMetastore_SdkV2) SetMetastoreInfo(ctx context.Context, v UpdateAccountsMetastore_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_info"]
	m.MetastoreInfo = types.ListValueMust(t, vs)
}

// The metastore assignment to update.
type AccountsUpdateMetastoreAssignment_SdkV2 struct {
	MetastoreAssignment types.List `tfsdk:"metastore_assignment"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *AccountsUpdateMetastoreAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsUpdateMetastoreAssignment_SdkV2) {
	if !from.MetastoreAssignment.IsNull() && !from.MetastoreAssignment.IsUnknown() {
		if toMetastoreAssignment, ok := to.GetMetastoreAssignment(ctx); ok {
			if fromMetastoreAssignment, ok := from.GetMetastoreAssignment(ctx); ok {
				// Recursively sync the fields of MetastoreAssignment
				toMetastoreAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreAssignment)
				to.SetMetastoreAssignment(ctx, toMetastoreAssignment)
			}
		}
	}
}

func (to *AccountsUpdateMetastoreAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsUpdateMetastoreAssignment_SdkV2) {
	if !from.MetastoreAssignment.IsNull() && !from.MetastoreAssignment.IsUnknown() {
		if toMetastoreAssignment, ok := to.GetMetastoreAssignment(ctx); ok {
			if fromMetastoreAssignment, ok := from.GetMetastoreAssignment(ctx); ok {
				toMetastoreAssignment.SyncFieldsDuringRead(ctx, fromMetastoreAssignment)
				to.SetMetastoreAssignment(ctx, toMetastoreAssignment)
			}
		}
	}
}

func (m AccountsUpdateMetastoreAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_assignment"] = attrs["metastore_assignment"].SetOptional()
	attrs["metastore_assignment"] = attrs["metastore_assignment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsUpdateMetastoreAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_assignment": reflect.TypeOf(UpdateMetastoreAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateMetastoreAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsUpdateMetastoreAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_assignment": m.MetastoreAssignment,
			"metastore_id":         m.MetastoreId,
			"workspace_id":         m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsUpdateMetastoreAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_assignment": basetypes.ListType{
				ElemType: UpdateMetastoreAssignment_SdkV2{}.Type(ctx),
			},
			"metastore_id": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}

// GetMetastoreAssignment returns the value of the MetastoreAssignment field in AccountsUpdateMetastoreAssignment_SdkV2 as
// a UpdateMetastoreAssignment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsUpdateMetastoreAssignment_SdkV2) GetMetastoreAssignment(ctx context.Context) (UpdateMetastoreAssignment_SdkV2, bool) {
	var e UpdateMetastoreAssignment_SdkV2
	if m.MetastoreAssignment.IsNull() || m.MetastoreAssignment.IsUnknown() {
		return e, false
	}
	var v []UpdateMetastoreAssignment_SdkV2
	d := m.MetastoreAssignment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreAssignment sets the value of the MetastoreAssignment field in AccountsUpdateMetastoreAssignment_SdkV2.
func (m *AccountsUpdateMetastoreAssignment_SdkV2) SetMetastoreAssignment(ctx context.Context, v UpdateMetastoreAssignment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_assignment"]
	m.MetastoreAssignment = types.ListValueMust(t, vs)
}

// The metastore assignment was successfully updated.
type AccountsUpdateMetastoreAssignmentResponse_SdkV2 struct {
}

func (to *AccountsUpdateMetastoreAssignmentResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsUpdateMetastoreAssignmentResponse_SdkV2) {
}

func (to *AccountsUpdateMetastoreAssignmentResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsUpdateMetastoreAssignmentResponse_SdkV2) {
}

func (m AccountsUpdateMetastoreAssignmentResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateMetastoreAssignmentResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsUpdateMetastoreAssignmentResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateMetastoreAssignmentResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsUpdateMetastoreAssignmentResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsUpdateMetastoreAssignmentResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// The metastore update request succeeded.
type AccountsUpdateMetastoreResponse_SdkV2 struct {
	MetastoreInfo types.List `tfsdk:"metastore_info"`
}

func (to *AccountsUpdateMetastoreResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsUpdateMetastoreResponse_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				// Recursively sync the fields of MetastoreInfo
				toMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (to *AccountsUpdateMetastoreResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsUpdateMetastoreResponse_SdkV2) {
	if !from.MetastoreInfo.IsNull() && !from.MetastoreInfo.IsUnknown() {
		if toMetastoreInfo, ok := to.GetMetastoreInfo(ctx); ok {
			if fromMetastoreInfo, ok := from.GetMetastoreInfo(ctx); ok {
				toMetastoreInfo.SyncFieldsDuringRead(ctx, fromMetastoreInfo)
				to.SetMetastoreInfo(ctx, toMetastoreInfo)
			}
		}
	}
}

func (m AccountsUpdateMetastoreResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["metastore_info"] = attrs["metastore_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateMetastoreResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsUpdateMetastoreResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(MetastoreInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateMetastoreResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsUpdateMetastoreResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_info": m.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsUpdateMetastoreResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_info": basetypes.ListType{
				ElemType: MetastoreInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsUpdateMetastoreResponse_SdkV2 as
// a MetastoreInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsUpdateMetastoreResponse_SdkV2) GetMetastoreInfo(ctx context.Context) (MetastoreInfo_SdkV2, bool) {
	var e MetastoreInfo_SdkV2
	if m.MetastoreInfo.IsNull() || m.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v []MetastoreInfo_SdkV2
	d := m.MetastoreInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsUpdateMetastoreResponse_SdkV2.
func (m *AccountsUpdateMetastoreResponse_SdkV2) SetMetastoreInfo(ctx context.Context, v MetastoreInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastore_info"]
	m.MetastoreInfo = types.ListValueMust(t, vs)
}

// The storage credential to update.
type AccountsUpdateStorageCredential_SdkV2 struct {
	CredentialInfo types.List `tfsdk:"credential_info"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Optional. Supplying true to this argument skips validation of the updated
	// set of credentials.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
	// Name of the storage credential.
	StorageCredentialName types.String `tfsdk:"-"`
}

func (to *AccountsUpdateStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsUpdateStorageCredential_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				// Recursively sync the fields of CredentialInfo
				toCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (to *AccountsUpdateStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsUpdateStorageCredential_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				toCredentialInfo.SyncFieldsDuringRead(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (m AccountsUpdateStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["credential_info"] = attrs["credential_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsUpdateStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(UpdateAccountsStorageCredential_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsUpdateStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info":         m.CredentialInfo,
			"metastore_id":            m.MetastoreId,
			"skip_validation":         m.SkipValidation,
			"storage_credential_name": m.StorageCredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsUpdateStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": basetypes.ListType{
				ElemType: UpdateAccountsStorageCredential_SdkV2{}.Type(ctx),
			},
			"metastore_id":            types.StringType,
			"skip_validation":         types.BoolType,
			"storage_credential_name": types.StringType,
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsUpdateStorageCredential_SdkV2 as
// a UpdateAccountsStorageCredential_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsUpdateStorageCredential_SdkV2) GetCredentialInfo(ctx context.Context) (UpdateAccountsStorageCredential_SdkV2, bool) {
	var e UpdateAccountsStorageCredential_SdkV2
	if m.CredentialInfo.IsNull() || m.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v []UpdateAccountsStorageCredential_SdkV2
	d := m.CredentialInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsUpdateStorageCredential_SdkV2.
func (m *AccountsUpdateStorageCredential_SdkV2) SetCredentialInfo(ctx context.Context, v UpdateAccountsStorageCredential_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credential_info"]
	m.CredentialInfo = types.ListValueMust(t, vs)
}

// The storage credential was successfully updated.
type AccountsUpdateStorageCredentialResponse_SdkV2 struct {
	CredentialInfo types.List `tfsdk:"credential_info"`
}

func (to *AccountsUpdateStorageCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountsUpdateStorageCredentialResponse_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				// Recursively sync the fields of CredentialInfo
				toCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (to *AccountsUpdateStorageCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AccountsUpdateStorageCredentialResponse_SdkV2) {
	if !from.CredentialInfo.IsNull() && !from.CredentialInfo.IsUnknown() {
		if toCredentialInfo, ok := to.GetCredentialInfo(ctx); ok {
			if fromCredentialInfo, ok := from.GetCredentialInfo(ctx); ok {
				toCredentialInfo.SyncFieldsDuringRead(ctx, fromCredentialInfo)
				to.SetCredentialInfo(ctx, toCredentialInfo)
			}
		}
	}
}

func (m AccountsUpdateStorageCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["credential_info"] = attrs["credential_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateStorageCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AccountsUpdateStorageCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(StorageCredentialInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateStorageCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AccountsUpdateStorageCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info": m.CredentialInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AccountsUpdateStorageCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": basetypes.ListType{
				ElemType: StorageCredentialInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsUpdateStorageCredentialResponse_SdkV2 as
// a StorageCredentialInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *AccountsUpdateStorageCredentialResponse_SdkV2) GetCredentialInfo(ctx context.Context) (StorageCredentialInfo_SdkV2, bool) {
	var e StorageCredentialInfo_SdkV2
	if m.CredentialInfo.IsNull() || m.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v []StorageCredentialInfo_SdkV2
	d := m.CredentialInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsUpdateStorageCredentialResponse_SdkV2.
func (m *AccountsUpdateStorageCredentialResponse_SdkV2) SetCredentialInfo(ctx context.Context, v StorageCredentialInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credential_info"]
	m.CredentialInfo = types.ListValueMust(t, vs)
}

type ArtifactAllowlistInfo_SdkV2 struct {
	// A list of allowed artifact match patterns.
	ArtifactMatchers types.List `tfsdk:"artifact_matchers"`
	// Time at which this artifact allowlist was set, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who set the artifact allowlist.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
}

func (to *ArtifactAllowlistInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ArtifactAllowlistInfo_SdkV2) {
	if !from.ArtifactMatchers.IsNull() && !from.ArtifactMatchers.IsUnknown() && to.ArtifactMatchers.IsNull() && len(from.ArtifactMatchers.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ArtifactMatchers, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ArtifactMatchers = from.ArtifactMatchers
	}
}

func (to *ArtifactAllowlistInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ArtifactAllowlistInfo_SdkV2) {
	if !from.ArtifactMatchers.IsNull() && !from.ArtifactMatchers.IsUnknown() && to.ArtifactMatchers.IsNull() && len(from.ArtifactMatchers.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ArtifactMatchers, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ArtifactMatchers = from.ArtifactMatchers
	}
}

func (m ArtifactAllowlistInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact_matchers"] = attrs["artifact_matchers"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ArtifactAllowlistInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ArtifactAllowlistInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"artifact_matchers": reflect.TypeOf(ArtifactMatcher_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ArtifactAllowlistInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ArtifactAllowlistInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact_matchers": m.ArtifactMatchers,
			"created_at":        m.CreatedAt,
			"created_by":        m.CreatedBy,
			"metastore_id":      m.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ArtifactAllowlistInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact_matchers": basetypes.ListType{
				ElemType: ArtifactMatcher_SdkV2{}.Type(ctx),
			},
			"created_at":   types.Int64Type,
			"created_by":   types.StringType,
			"metastore_id": types.StringType,
		},
	}
}

// GetArtifactMatchers returns the value of the ArtifactMatchers field in ArtifactAllowlistInfo_SdkV2 as
// a slice of ArtifactMatcher_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ArtifactAllowlistInfo_SdkV2) GetArtifactMatchers(ctx context.Context) ([]ArtifactMatcher_SdkV2, bool) {
	if m.ArtifactMatchers.IsNull() || m.ArtifactMatchers.IsUnknown() {
		return nil, false
	}
	var v []ArtifactMatcher_SdkV2
	d := m.ArtifactMatchers.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetArtifactMatchers sets the value of the ArtifactMatchers field in ArtifactAllowlistInfo_SdkV2.
func (m *ArtifactAllowlistInfo_SdkV2) SetArtifactMatchers(ctx context.Context, v []ArtifactMatcher_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["artifact_matchers"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ArtifactMatchers = types.ListValueMust(t, vs)
}

type ArtifactMatcher_SdkV2 struct {
	// The artifact path or maven coordinate
	Artifact types.String `tfsdk:"artifact"`
	// The pattern matching type of the artifact
	MatchType types.String `tfsdk:"match_type"`
}

func (to *ArtifactMatcher_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ArtifactMatcher_SdkV2) {
}

func (to *ArtifactMatcher_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ArtifactMatcher_SdkV2) {
}

func (m ArtifactMatcher_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact"] = attrs["artifact"].SetRequired()
	attrs["match_type"] = attrs["match_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ArtifactMatcher.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ArtifactMatcher_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ArtifactMatcher_SdkV2
// only implements ToObjectValue() and Type().
func (m ArtifactMatcher_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact":   m.Artifact,
			"match_type": m.MatchType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ArtifactMatcher_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact":   types.StringType,
			"match_type": types.StringType,
		},
	}
}

type AssignResponse_SdkV2 struct {
}

func (to *AssignResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AssignResponse_SdkV2) {
}

func (to *AssignResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AssignResponse_SdkV2) {
}

func (m AssignResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AssignResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AssignResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AssignResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AssignResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m AssignResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// AWS temporary credentials for API authentication. Read more at
// https://docs.aws.amazon.com/STS/latest/APIReference/API_Credentials.html.
type AwsCredentials_SdkV2 struct {
	// The access key ID that identifies the temporary credentials.
	AccessKeyId types.String `tfsdk:"access_key_id"`
	// The Amazon Resource Name (ARN) of the S3 access point for temporary
	// credentials related the external location.
	AccessPoint types.String `tfsdk:"access_point"`
	// The secret access key that can be used to sign AWS API requests.
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
	// The token that users must pass to AWS API to use the temporary
	// credentials.
	SessionToken types.String `tfsdk:"session_token"`
}

func (to *AwsCredentials_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AwsCredentials_SdkV2) {
}

func (to *AwsCredentials_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AwsCredentials_SdkV2) {
}

func (m AwsCredentials_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_key_id"] = attrs["access_key_id"].SetOptional()
	attrs["access_point"] = attrs["access_point"].SetOptional()
	attrs["secret_access_key"] = attrs["secret_access_key"].SetOptional()
	attrs["session_token"] = attrs["session_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsCredentials.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AwsCredentials_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsCredentials_SdkV2
// only implements ToObjectValue() and Type().
func (m AwsCredentials_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_key_id":     m.AccessKeyId,
			"access_point":      m.AccessPoint,
			"secret_access_key": m.SecretAccessKey,
			"session_token":     m.SessionToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AwsCredentials_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_key_id":     types.StringType,
			"access_point":      types.StringType,
			"secret_access_key": types.StringType,
			"session_token":     types.StringType,
		},
	}
}

// The AWS IAM role configuration
type AwsIamRole_SdkV2 struct {
	// The external ID used in role assumption to prevent the confused deputy
	// problem.
	ExternalId types.String `tfsdk:"external_id"`
	// The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary
	// credentials.
	RoleArn types.String `tfsdk:"role_arn"`
	// The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks.
	// This is the identity that is going to assume the AWS IAM role.
	UnityCatalogIamArn types.String `tfsdk:"unity_catalog_iam_arn"`
}

func (to *AwsIamRole_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AwsIamRole_SdkV2) {
}

func (to *AwsIamRole_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AwsIamRole_SdkV2) {
}

func (m AwsIamRole_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_id"] = attrs["external_id"].SetComputed()
	attrs["role_arn"] = attrs["role_arn"].SetOptional()
	attrs["unity_catalog_iam_arn"] = attrs["unity_catalog_iam_arn"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsIamRole.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AwsIamRole_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsIamRole_SdkV2
// only implements ToObjectValue() and Type().
func (m AwsIamRole_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_id":           m.ExternalId,
			"role_arn":              m.RoleArn,
			"unity_catalog_iam_arn": m.UnityCatalogIamArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AwsIamRole_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_id":           types.StringType,
			"role_arn":              types.StringType,
			"unity_catalog_iam_arn": types.StringType,
		},
	}
}

// The AWS IAM role configuration
type AwsIamRoleRequest_SdkV2 struct {
	// The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary
	// credentials.
	RoleArn types.String `tfsdk:"role_arn"`
}

func (to *AwsIamRoleRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AwsIamRoleRequest_SdkV2) {
}

func (to *AwsIamRoleRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AwsIamRoleRequest_SdkV2) {
}

func (m AwsIamRoleRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["role_arn"] = attrs["role_arn"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsIamRoleRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AwsIamRoleRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsIamRoleRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m AwsIamRoleRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"role_arn": m.RoleArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AwsIamRoleRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"role_arn": types.StringType,
		},
	}
}

// The AWS IAM role configuration
type AwsIamRoleResponse_SdkV2 struct {
	// The external ID used in role assumption to prevent the confused deputy
	// problem.
	ExternalId types.String `tfsdk:"external_id"`
	// The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary
	// credentials.
	RoleArn types.String `tfsdk:"role_arn"`
	// The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks.
	// This is the identity that is going to assume the AWS IAM role.
	UnityCatalogIamArn types.String `tfsdk:"unity_catalog_iam_arn"`
}

func (to *AwsIamRoleResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AwsIamRoleResponse_SdkV2) {
}

func (to *AwsIamRoleResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AwsIamRoleResponse_SdkV2) {
}

func (m AwsIamRoleResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_id"] = attrs["external_id"].SetComputed()
	attrs["role_arn"] = attrs["role_arn"].SetRequired()
	attrs["unity_catalog_iam_arn"] = attrs["unity_catalog_iam_arn"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsIamRoleResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AwsIamRoleResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsIamRoleResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AwsIamRoleResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_id":           m.ExternalId,
			"role_arn":              m.RoleArn,
			"unity_catalog_iam_arn": m.UnityCatalogIamArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AwsIamRoleResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_id":           types.StringType,
			"role_arn":              types.StringType,
			"unity_catalog_iam_arn": types.StringType,
		},
	}
}

type AwsSqsQueue_SdkV2 struct {
	// Unique identifier included in the name of file events managed cloud
	// resources.
	ManagedResourceId types.String `tfsdk:"managed_resource_id"`
	// The AQS queue url in the format
	// https://sqs.{region}.amazonaws.com/{account id}/{queue name} Required for
	// provided_sqs.
	QueueUrl types.String `tfsdk:"queue_url"`
}

func (to *AwsSqsQueue_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AwsSqsQueue_SdkV2) {
}

func (to *AwsSqsQueue_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AwsSqsQueue_SdkV2) {
}

func (m AwsSqsQueue_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_resource_id"] = attrs["managed_resource_id"].SetComputed()
	attrs["queue_url"] = attrs["queue_url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsSqsQueue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AwsSqsQueue_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsSqsQueue_SdkV2
// only implements ToObjectValue() and Type().
func (m AwsSqsQueue_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_resource_id": m.ManagedResourceId,
			"queue_url":           m.QueueUrl,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AwsSqsQueue_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_resource_id": types.StringType,
			"queue_url":           types.StringType,
		},
	}
}

// Azure Active Directory token, essentially the Oauth token for Azure Service
// Principal or Managed Identity. Read more at
// https://learn.microsoft.com/en-us/azure/databricks/dev-tools/api/latest/aad/service-prin-aad-token
type AzureActiveDirectoryToken_SdkV2 struct {
	// Opaque token that contains claims that you can use in Azure Active
	// Directory to access cloud services.
	AadToken types.String `tfsdk:"aad_token"`
}

func (to *AzureActiveDirectoryToken_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureActiveDirectoryToken_SdkV2) {
}

func (to *AzureActiveDirectoryToken_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureActiveDirectoryToken_SdkV2) {
}

func (m AzureActiveDirectoryToken_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aad_token"] = attrs["aad_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureActiveDirectoryToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureActiveDirectoryToken_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureActiveDirectoryToken_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureActiveDirectoryToken_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aad_token": m.AadToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureActiveDirectoryToken_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aad_token": types.StringType,
		},
	}
}

// The Azure managed identity configuration.
type AzureManagedIdentity_SdkV2 struct {
	// The Azure resource ID of the Azure Databricks Access Connector. Use the
	// format
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`.
	AccessConnectorId types.String `tfsdk:"access_connector_id"`
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The Azure resource ID of the managed identity. Use the format,
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}`
	// This is only available for user-assgined identities. For system-assigned
	// identities, the access_connector_id is used to identify the identity. If
	// this field is not provided, then we assume the AzureManagedIdentity is
	// using the system-assigned identity.
	ManagedIdentityId types.String `tfsdk:"managed_identity_id"`
}

func (to *AzureManagedIdentity_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureManagedIdentity_SdkV2) {
}

func (to *AzureManagedIdentity_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureManagedIdentity_SdkV2) {
}

func (m AzureManagedIdentity_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_connector_id"] = attrs["access_connector_id"].SetRequired()
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["managed_identity_id"] = attrs["managed_identity_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureManagedIdentity.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureManagedIdentity_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureManagedIdentity_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureManagedIdentity_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_connector_id": m.AccessConnectorId,
			"credential_id":       m.CredentialId,
			"managed_identity_id": m.ManagedIdentityId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureManagedIdentity_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_connector_id": types.StringType,
			"credential_id":       types.StringType,
			"managed_identity_id": types.StringType,
		},
	}
}

// The Azure managed identity configuration.
type AzureManagedIdentityRequest_SdkV2 struct {
	// The Azure resource ID of the Azure Databricks Access Connector. Use the
	// format
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`.
	AccessConnectorId types.String `tfsdk:"access_connector_id"`
	// The Azure resource ID of the managed identity. Use the format,
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}`
	// This is only available for user-assgined identities. For system-assigned
	// identities, the access_connector_id is used to identify the identity. If
	// this field is not provided, then we assume the AzureManagedIdentity is
	// using the system-assigned identity.
	ManagedIdentityId types.String `tfsdk:"managed_identity_id"`
}

func (to *AzureManagedIdentityRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureManagedIdentityRequest_SdkV2) {
}

func (to *AzureManagedIdentityRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureManagedIdentityRequest_SdkV2) {
}

func (m AzureManagedIdentityRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_connector_id"] = attrs["access_connector_id"].SetRequired()
	attrs["managed_identity_id"] = attrs["managed_identity_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureManagedIdentityRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureManagedIdentityRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureManagedIdentityRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureManagedIdentityRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_connector_id": m.AccessConnectorId,
			"managed_identity_id": m.ManagedIdentityId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureManagedIdentityRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_connector_id": types.StringType,
			"managed_identity_id": types.StringType,
		},
	}
}

// The Azure managed identity configuration.
type AzureManagedIdentityResponse_SdkV2 struct {
	// The Azure resource ID of the Azure Databricks Access Connector. Use the
	// format
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`.
	AccessConnectorId types.String `tfsdk:"access_connector_id"`
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The Azure resource ID of the managed identity. Use the format,
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}`
	// This is only available for user-assgined identities. For system-assigned
	// identities, the access_connector_id is used to identify the identity. If
	// this field is not provided, then we assume the AzureManagedIdentity is
	// using the system-assigned identity.
	ManagedIdentityId types.String `tfsdk:"managed_identity_id"`
}

func (to *AzureManagedIdentityResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureManagedIdentityResponse_SdkV2) {
}

func (to *AzureManagedIdentityResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureManagedIdentityResponse_SdkV2) {
}

func (m AzureManagedIdentityResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_connector_id"] = attrs["access_connector_id"].SetRequired()
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["managed_identity_id"] = attrs["managed_identity_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureManagedIdentityResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureManagedIdentityResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureManagedIdentityResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureManagedIdentityResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_connector_id": m.AccessConnectorId,
			"credential_id":       m.CredentialId,
			"managed_identity_id": m.ManagedIdentityId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureManagedIdentityResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_connector_id": types.StringType,
			"credential_id":       types.StringType,
			"managed_identity_id": types.StringType,
		},
	}
}

type AzureQueueStorage_SdkV2 struct {
	// Unique identifier included in the name of file events managed cloud
	// resources.
	ManagedResourceId types.String `tfsdk:"managed_resource_id"`
	// The AQS queue url in the format https://{storage
	// account}.queue.core.windows.net/{queue name} Required for provided_aqs.
	QueueUrl types.String `tfsdk:"queue_url"`
	// The resource group for the queue, event grid subscription, and external
	// location storage account. Only required for locations with a service
	// principal storage credential
	ResourceGroup types.String `tfsdk:"resource_group"`
	// Optional subscription id for the queue, event grid subscription, and
	// external location storage account. Required for locations with a service
	// principal storage credential
	SubscriptionId types.String `tfsdk:"subscription_id"`
}

func (to *AzureQueueStorage_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureQueueStorage_SdkV2) {
}

func (to *AzureQueueStorage_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureQueueStorage_SdkV2) {
}

func (m AzureQueueStorage_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_resource_id"] = attrs["managed_resource_id"].SetComputed()
	attrs["queue_url"] = attrs["queue_url"].SetOptional()
	attrs["resource_group"] = attrs["resource_group"].SetOptional()
	attrs["subscription_id"] = attrs["subscription_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureQueueStorage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureQueueStorage_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureQueueStorage_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureQueueStorage_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_resource_id": m.ManagedResourceId,
			"queue_url":           m.QueueUrl,
			"resource_group":      m.ResourceGroup,
			"subscription_id":     m.SubscriptionId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureQueueStorage_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_resource_id": types.StringType,
			"queue_url":           types.StringType,
			"resource_group":      types.StringType,
			"subscription_id":     types.StringType,
		},
	}
}

// The Azure service principal configuration. Only applicable when purpose is
// **STORAGE**.
type AzureServicePrincipal_SdkV2 struct {
	// The application ID of the application registration within the referenced
	// AAD tenant.
	ApplicationId types.String `tfsdk:"application_id"`
	// The client secret generated for the above app ID in AAD.
	ClientSecret types.String `tfsdk:"client_secret"`
	// The directory ID corresponding to the Azure Active Directory (AAD) tenant
	// of the application.
	DirectoryId types.String `tfsdk:"directory_id"`
}

func (to *AzureServicePrincipal_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureServicePrincipal_SdkV2) {
}

func (to *AzureServicePrincipal_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureServicePrincipal_SdkV2) {
}

func (m AzureServicePrincipal_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["application_id"] = attrs["application_id"].SetRequired()
	attrs["client_secret"] = attrs["client_secret"].SetRequired()
	attrs["directory_id"] = attrs["directory_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureServicePrincipal.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureServicePrincipal_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureServicePrincipal_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureServicePrincipal_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"application_id": m.ApplicationId,
			"client_secret":  m.ClientSecret,
			"directory_id":   m.DirectoryId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureServicePrincipal_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"application_id": types.StringType,
			"client_secret":  types.StringType,
			"directory_id":   types.StringType,
		},
	}
}

// Azure temporary credentials for API authentication. Read more at
// https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas
type AzureUserDelegationSas_SdkV2 struct {
	// The signed URI (SAS Token) used to access blob services for a given path
	SasToken types.String `tfsdk:"sas_token"`
}

func (to *AzureUserDelegationSas_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AzureUserDelegationSas_SdkV2) {
}

func (to *AzureUserDelegationSas_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AzureUserDelegationSas_SdkV2) {
}

func (m AzureUserDelegationSas_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["sas_token"] = attrs["sas_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureUserDelegationSas.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AzureUserDelegationSas_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureUserDelegationSas_SdkV2
// only implements ToObjectValue() and Type().
func (m AzureUserDelegationSas_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"sas_token": m.SasToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AzureUserDelegationSas_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"sas_token": types.StringType,
		},
	}
}

type BatchCreateAccessRequestsRequest_SdkV2 struct {
	// A list of individual access requests, where each request corresponds to a
	// set of permissions being requested on a list of securables for a
	// specified principal.
	//
	// At most 30 requests per API call.
	Requests types.List `tfsdk:"requests"`
}

func (to *BatchCreateAccessRequestsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from BatchCreateAccessRequestsRequest_SdkV2) {
	if !from.Requests.IsNull() && !from.Requests.IsUnknown() && to.Requests.IsNull() && len(from.Requests.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Requests, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Requests = from.Requests
	}
}

func (to *BatchCreateAccessRequestsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from BatchCreateAccessRequestsRequest_SdkV2) {
	if !from.Requests.IsNull() && !from.Requests.IsUnknown() && to.Requests.IsNull() && len(from.Requests.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Requests, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Requests = from.Requests
	}
}

func (m BatchCreateAccessRequestsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["requests"] = attrs["requests"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BatchCreateAccessRequestsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m BatchCreateAccessRequestsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"requests": reflect.TypeOf(CreateAccessRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BatchCreateAccessRequestsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m BatchCreateAccessRequestsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"requests": m.Requests,
		})
}

// Type implements basetypes.ObjectValuable.
func (m BatchCreateAccessRequestsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"requests": basetypes.ListType{
				ElemType: CreateAccessRequest_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetRequests returns the value of the Requests field in BatchCreateAccessRequestsRequest_SdkV2 as
// a slice of CreateAccessRequest_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *BatchCreateAccessRequestsRequest_SdkV2) GetRequests(ctx context.Context) ([]CreateAccessRequest_SdkV2, bool) {
	if m.Requests.IsNull() || m.Requests.IsUnknown() {
		return nil, false
	}
	var v []CreateAccessRequest_SdkV2
	d := m.Requests.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRequests sets the value of the Requests field in BatchCreateAccessRequestsRequest_SdkV2.
func (m *BatchCreateAccessRequestsRequest_SdkV2) SetRequests(ctx context.Context, v []CreateAccessRequest_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["requests"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Requests = types.ListValueMust(t, vs)
}

type BatchCreateAccessRequestsResponse_SdkV2 struct {
	// The access request destinations for each securable object the principal
	// requested.
	Responses types.List `tfsdk:"responses"`
}

func (to *BatchCreateAccessRequestsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from BatchCreateAccessRequestsResponse_SdkV2) {
	if !from.Responses.IsNull() && !from.Responses.IsUnknown() && to.Responses.IsNull() && len(from.Responses.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Responses, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Responses = from.Responses
	}
}

func (to *BatchCreateAccessRequestsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from BatchCreateAccessRequestsResponse_SdkV2) {
	if !from.Responses.IsNull() && !from.Responses.IsUnknown() && to.Responses.IsNull() && len(from.Responses.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Responses, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Responses = from.Responses
	}
}

func (m BatchCreateAccessRequestsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["responses"] = attrs["responses"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BatchCreateAccessRequestsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m BatchCreateAccessRequestsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"responses": reflect.TypeOf(CreateAccessRequestResponse_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BatchCreateAccessRequestsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m BatchCreateAccessRequestsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"responses": m.Responses,
		})
}

// Type implements basetypes.ObjectValuable.
func (m BatchCreateAccessRequestsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"responses": basetypes.ListType{
				ElemType: CreateAccessRequestResponse_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetResponses returns the value of the Responses field in BatchCreateAccessRequestsResponse_SdkV2 as
// a slice of CreateAccessRequestResponse_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *BatchCreateAccessRequestsResponse_SdkV2) GetResponses(ctx context.Context) ([]CreateAccessRequestResponse_SdkV2, bool) {
	if m.Responses.IsNull() || m.Responses.IsUnknown() {
		return nil, false
	}
	var v []CreateAccessRequestResponse_SdkV2
	d := m.Responses.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResponses sets the value of the Responses field in BatchCreateAccessRequestsResponse_SdkV2.
func (m *BatchCreateAccessRequestsResponse_SdkV2) SetResponses(ctx context.Context, v []CreateAccessRequestResponse_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["responses"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Responses = types.ListValueMust(t, vs)
}

type CancelRefreshRequest_SdkV2 struct {
	RefreshId types.Int64 `tfsdk:"-"`
	// UC table name in format `catalog.schema.table_name`. table_name is case
	// insensitive and spaces are disallowed.
	TableName types.String `tfsdk:"-"`
}

func (to *CancelRefreshRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelRefreshRequest_SdkV2) {
}

func (to *CancelRefreshRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CancelRefreshRequest_SdkV2) {
}

func (m CancelRefreshRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()
	attrs["refresh_id"] = attrs["refresh_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelRefreshRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelRefreshRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelRefreshRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CancelRefreshRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"refresh_id": m.RefreshId,
			"table_name": m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CancelRefreshRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"refresh_id": types.Int64Type,
			"table_name": types.StringType,
		},
	}
}

type CancelRefreshResponse_SdkV2 struct {
}

func (to *CancelRefreshResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelRefreshResponse_SdkV2) {
}

func (to *CancelRefreshResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CancelRefreshResponse_SdkV2) {
}

func (m CancelRefreshResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelRefreshResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelRefreshResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelRefreshResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m CancelRefreshResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m CancelRefreshResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type CatalogInfo_SdkV2 struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`

	CatalogType types.String `tfsdk:"catalog_type"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// The name of the connection to an external data source.
	ConnectionName types.String `tfsdk:"connection_name"`
	// Time at which this catalog was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of catalog creator.
	CreatedBy types.String `tfsdk:"created_by"`

	EffectivePredictiveOptimizationFlag types.List `tfsdk:"effective_predictive_optimization_flag"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// The full name of the catalog. Corresponds with the name field.
	FullName types.String `tfsdk:"full_name"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of catalog.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of catalog.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// The name of delta sharing provider.
	//
	// A Delta Sharing catalog is a catalog that is based on a Delta share on a
	// remote sharing server.
	ProviderName types.String `tfsdk:"provider_name"`

	ProvisioningInfo types.List `tfsdk:"provisioning_info"`

	SecurableType types.String `tfsdk:"securable_type"`
	// The name of the share under the share provider.
	ShareName types.String `tfsdk:"share_name"`
	// Storage Location URL (full path) for managed tables within catalog.
	StorageLocation types.String `tfsdk:"storage_location"`
	// Storage root URL for managed tables within catalog.
	StorageRoot types.String `tfsdk:"storage_root"`
	// Time at which this catalog was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified catalog.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *CatalogInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CatalogInfo_SdkV2) {
	if !from.EffectivePredictiveOptimizationFlag.IsNull() && !from.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toEffectivePredictiveOptimizationFlag, ok := to.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromEffectivePredictiveOptimizationFlag, ok := from.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				// Recursively sync the fields of EffectivePredictiveOptimizationFlag
				toEffectivePredictiveOptimizationFlag.SyncFieldsDuringCreateOrUpdate(ctx, fromEffectivePredictiveOptimizationFlag)
				to.SetEffectivePredictiveOptimizationFlag(ctx, toEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !from.ProvisioningInfo.IsNull() && !from.ProvisioningInfo.IsUnknown() {
		if toProvisioningInfo, ok := to.GetProvisioningInfo(ctx); ok {
			if fromProvisioningInfo, ok := from.GetProvisioningInfo(ctx); ok {
				// Recursively sync the fields of ProvisioningInfo
				toProvisioningInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromProvisioningInfo)
				to.SetProvisioningInfo(ctx, toProvisioningInfo)
			}
		}
	}
}

func (to *CatalogInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CatalogInfo_SdkV2) {
	if !from.EffectivePredictiveOptimizationFlag.IsNull() && !from.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toEffectivePredictiveOptimizationFlag, ok := to.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromEffectivePredictiveOptimizationFlag, ok := from.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toEffectivePredictiveOptimizationFlag.SyncFieldsDuringRead(ctx, fromEffectivePredictiveOptimizationFlag)
				to.SetEffectivePredictiveOptimizationFlag(ctx, toEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !from.ProvisioningInfo.IsNull() && !from.ProvisioningInfo.IsUnknown() {
		if toProvisioningInfo, ok := to.GetProvisioningInfo(ctx); ok {
			if fromProvisioningInfo, ok := from.GetProvisioningInfo(ctx); ok {
				toProvisioningInfo.SyncFieldsDuringRead(ctx, fromProvisioningInfo)
				to.SetProvisioningInfo(ctx, toProvisioningInfo)
			}
		}
	}
}

func (m CatalogInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_type"] = attrs["catalog_type"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_name"] = attrs["connection_name"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["provider_name"] = attrs["provider_name"].SetOptional()
	attrs["provisioning_info"] = attrs["provisioning_info"].SetOptional()
	attrs["provisioning_info"] = attrs["provisioning_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["securable_type"] = attrs["securable_type"].SetOptional()
	attrs["share_name"] = attrs["share_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CatalogInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CatalogInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"effective_predictive_optimization_flag": reflect.TypeOf(EffectivePredictiveOptimizationFlag_SdkV2{}),
		"options":                                reflect.TypeOf(types.String{}),
		"properties":                             reflect.TypeOf(types.String{}),
		"provisioning_info":                      reflect.TypeOf(ProvisioningInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CatalogInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m CatalogInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":                            m.BrowseOnly,
			"catalog_type":                           m.CatalogType,
			"comment":                                m.Comment,
			"connection_name":                        m.ConnectionName,
			"created_at":                             m.CreatedAt,
			"created_by":                             m.CreatedBy,
			"effective_predictive_optimization_flag": m.EffectivePredictiveOptimizationFlag,
			"enable_predictive_optimization":         m.EnablePredictiveOptimization,
			"full_name":                              m.FullName,
			"isolation_mode":                         m.IsolationMode,
			"metastore_id":                           m.MetastoreId,
			"name":                                   m.Name,
			"options":                                m.Options,
			"owner":                                  m.Owner,
			"properties":                             m.Properties,
			"provider_name":                          m.ProviderName,
			"provisioning_info":                      m.ProvisioningInfo,
			"securable_type":                         m.SecurableType,
			"share_name":                             m.ShareName,
			"storage_location":                       m.StorageLocation,
			"storage_root":                           m.StorageRoot,
			"updated_at":                             m.UpdatedAt,
			"updated_by":                             m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CatalogInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":     types.BoolType,
			"catalog_type":    types.StringType,
			"comment":         types.StringType,
			"connection_name": types.StringType,
			"created_at":      types.Int64Type,
			"created_by":      types.StringType,
			"effective_predictive_optimization_flag": basetypes.ListType{
				ElemType: EffectivePredictiveOptimizationFlag_SdkV2{}.Type(ctx),
			},
			"enable_predictive_optimization": types.StringType,
			"full_name":                      types.StringType,
			"isolation_mode":                 types.StringType,
			"metastore_id":                   types.StringType,
			"name":                           types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"provider_name": types.StringType,
			"provisioning_info": basetypes.ListType{
				ElemType: ProvisioningInfo_SdkV2{}.Type(ctx),
			},
			"securable_type":   types.StringType,
			"share_name":       types.StringType,
			"storage_location": types.StringType,
			"storage_root":     types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetEffectivePredictiveOptimizationFlag returns the value of the EffectivePredictiveOptimizationFlag field in CatalogInfo_SdkV2 as
// a EffectivePredictiveOptimizationFlag_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CatalogInfo_SdkV2) GetEffectivePredictiveOptimizationFlag(ctx context.Context) (EffectivePredictiveOptimizationFlag_SdkV2, bool) {
	var e EffectivePredictiveOptimizationFlag_SdkV2
	if m.EffectivePredictiveOptimizationFlag.IsNull() || m.EffectivePredictiveOptimizationFlag.IsUnknown() {
		return e, false
	}
	var v []EffectivePredictiveOptimizationFlag_SdkV2
	d := m.EffectivePredictiveOptimizationFlag.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEffectivePredictiveOptimizationFlag sets the value of the EffectivePredictiveOptimizationFlag field in CatalogInfo_SdkV2.
func (m *CatalogInfo_SdkV2) SetEffectivePredictiveOptimizationFlag(ctx context.Context, v EffectivePredictiveOptimizationFlag_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["effective_predictive_optimization_flag"]
	m.EffectivePredictiveOptimizationFlag = types.ListValueMust(t, vs)
}

// GetOptions returns the value of the Options field in CatalogInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CatalogInfo_SdkV2) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in CatalogInfo_SdkV2.
func (m *CatalogInfo_SdkV2) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CatalogInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CatalogInfo_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CatalogInfo_SdkV2.
func (m *CatalogInfo_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetProvisioningInfo returns the value of the ProvisioningInfo field in CatalogInfo_SdkV2 as
// a ProvisioningInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CatalogInfo_SdkV2) GetProvisioningInfo(ctx context.Context) (ProvisioningInfo_SdkV2, bool) {
	var e ProvisioningInfo_SdkV2
	if m.ProvisioningInfo.IsNull() || m.ProvisioningInfo.IsUnknown() {
		return e, false
	}
	var v []ProvisioningInfo_SdkV2
	d := m.ProvisioningInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetProvisioningInfo sets the value of the ProvisioningInfo field in CatalogInfo_SdkV2.
func (m *CatalogInfo_SdkV2) SetProvisioningInfo(ctx context.Context, v ProvisioningInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["provisioning_info"]
	m.ProvisioningInfo = types.ListValueMust(t, vs)
}

// The Cloudflare API token configuration. Read more at
// https://developers.cloudflare.com/r2/api/s3/tokens/
type CloudflareApiToken_SdkV2 struct {
	// The access key ID associated with the API token.
	AccessKeyId types.String `tfsdk:"access_key_id"`
	// The ID of the account associated with the API token.
	AccountId types.String `tfsdk:"account_id"`
	// The secret access token generated for the above access key ID.
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
}

func (to *CloudflareApiToken_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CloudflareApiToken_SdkV2) {
}

func (to *CloudflareApiToken_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CloudflareApiToken_SdkV2) {
}

func (m CloudflareApiToken_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_key_id"] = attrs["access_key_id"].SetRequired()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["secret_access_key"] = attrs["secret_access_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CloudflareApiToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CloudflareApiToken_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CloudflareApiToken_SdkV2
// only implements ToObjectValue() and Type().
func (m CloudflareApiToken_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_key_id":     m.AccessKeyId,
			"account_id":        m.AccountId,
			"secret_access_key": m.SecretAccessKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CloudflareApiToken_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_key_id":     types.StringType,
			"account_id":        types.StringType,
			"secret_access_key": types.StringType,
		},
	}
}

type ColumnInfo_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`

	Mask types.List `tfsdk:"mask"`
	// Name of Column.
	Name types.String `tfsdk:"name"`
	// Whether field may be Null (default: true).
	Nullable types.Bool `tfsdk:"nullable"`
	// Partition index for column.
	PartitionIndex types.Int64 `tfsdk:"partition_index"`
	// Ordinal position of column (starting at position 0).
	Position types.Int64 `tfsdk:"position"`
	// Format of IntervalType.
	TypeIntervalType types.String `tfsdk:"type_interval_type"`
	// Full data type specification, JSON-serialized.
	TypeJson types.String `tfsdk:"type_json"`

	TypeName types.String `tfsdk:"type_name"`
	// Digits of precision; required for DecimalTypes.
	TypePrecision types.Int64 `tfsdk:"type_precision"`
	// Digits to right of decimal; Required for DecimalTypes.
	TypeScale types.Int64 `tfsdk:"type_scale"`
	// Full data type specification as SQL/catalogString text.
	TypeText types.String `tfsdk:"type_text"`
}

func (to *ColumnInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ColumnInfo_SdkV2) {
	if !from.Mask.IsNull() && !from.Mask.IsUnknown() {
		if toMask, ok := to.GetMask(ctx); ok {
			if fromMask, ok := from.GetMask(ctx); ok {
				// Recursively sync the fields of Mask
				toMask.SyncFieldsDuringCreateOrUpdate(ctx, fromMask)
				to.SetMask(ctx, toMask)
			}
		}
	}
}

func (to *ColumnInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ColumnInfo_SdkV2) {
	if !from.Mask.IsNull() && !from.Mask.IsUnknown() {
		if toMask, ok := to.GetMask(ctx); ok {
			if fromMask, ok := from.GetMask(ctx); ok {
				toMask.SyncFieldsDuringRead(ctx, fromMask)
				to.SetMask(ctx, toMask)
			}
		}
	}
}

func (m ColumnInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["mask"] = attrs["mask"].SetOptional()
	attrs["mask"] = attrs["mask"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].SetOptional()
	attrs["nullable"] = attrs["nullable"].SetOptional()
	attrs["partition_index"] = attrs["partition_index"].SetOptional()
	attrs["position"] = attrs["position"].SetOptional()
	attrs["type_interval_type"] = attrs["type_interval_type"].SetOptional()
	attrs["type_json"] = attrs["type_json"].SetOptional()
	attrs["type_name"] = attrs["type_name"].SetOptional()
	attrs["type_precision"] = attrs["type_precision"].SetOptional()
	attrs["type_scale"] = attrs["type_scale"].SetOptional()
	attrs["type_text"] = attrs["type_text"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ColumnInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"mask": reflect.TypeOf(ColumnMask_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ColumnInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            m.Comment,
			"mask":               m.Mask,
			"name":               m.Name,
			"nullable":           m.Nullable,
			"partition_index":    m.PartitionIndex,
			"position":           m.Position,
			"type_interval_type": m.TypeIntervalType,
			"type_json":          m.TypeJson,
			"type_name":          m.TypeName,
			"type_precision":     m.TypePrecision,
			"type_scale":         m.TypeScale,
			"type_text":          m.TypeText,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ColumnInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment": types.StringType,
			"mask": basetypes.ListType{
				ElemType: ColumnMask_SdkV2{}.Type(ctx),
			},
			"name":               types.StringType,
			"nullable":           types.BoolType,
			"partition_index":    types.Int64Type,
			"position":           types.Int64Type,
			"type_interval_type": types.StringType,
			"type_json":          types.StringType,
			"type_name":          types.StringType,
			"type_precision":     types.Int64Type,
			"type_scale":         types.Int64Type,
			"type_text":          types.StringType,
		},
	}
}

// GetMask returns the value of the Mask field in ColumnInfo_SdkV2 as
// a ColumnMask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ColumnInfo_SdkV2) GetMask(ctx context.Context) (ColumnMask_SdkV2, bool) {
	var e ColumnMask_SdkV2
	if m.Mask.IsNull() || m.Mask.IsUnknown() {
		return e, false
	}
	var v []ColumnMask_SdkV2
	d := m.Mask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMask sets the value of the Mask field in ColumnInfo_SdkV2.
func (m *ColumnInfo_SdkV2) SetMask(ctx context.Context, v ColumnMask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["mask"]
	m.Mask = types.ListValueMust(t, vs)
}

type ColumnMask_SdkV2 struct {
	// The full name of the column mask SQL UDF.
	FunctionName types.String `tfsdk:"function_name"`
	// The list of additional table columns to be passed as input to the column
	// mask function. The first arg of the mask function should be of the type
	// of the column being masked and the types of the rest of the args should
	// match the types of columns in 'using_column_names'.
	UsingColumnNames types.List `tfsdk:"using_column_names"`
}

func (to *ColumnMask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ColumnMask_SdkV2) {
	if !from.UsingColumnNames.IsNull() && !from.UsingColumnNames.IsUnknown() && to.UsingColumnNames.IsNull() && len(from.UsingColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for UsingColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.UsingColumnNames = from.UsingColumnNames
	}
}

func (to *ColumnMask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ColumnMask_SdkV2) {
	if !from.UsingColumnNames.IsNull() && !from.UsingColumnNames.IsUnknown() && to.UsingColumnNames.IsNull() && len(from.UsingColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for UsingColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.UsingColumnNames = from.UsingColumnNames
	}
}

func (m ColumnMask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetOptional()
	attrs["using_column_names"] = attrs["using_column_names"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnMask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ColumnMask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"using_column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnMask_SdkV2
// only implements ToObjectValue() and Type().
func (m ColumnMask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name":      m.FunctionName,
			"using_column_names": m.UsingColumnNames,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ColumnMask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"using_column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetUsingColumnNames returns the value of the UsingColumnNames field in ColumnMask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ColumnMask_SdkV2) GetUsingColumnNames(ctx context.Context) ([]types.String, bool) {
	if m.UsingColumnNames.IsNull() || m.UsingColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.UsingColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUsingColumnNames sets the value of the UsingColumnNames field in ColumnMask_SdkV2.
func (m *ColumnMask_SdkV2) SetUsingColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["using_column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.UsingColumnNames = types.ListValueMust(t, vs)
}

type ColumnMaskOptions_SdkV2 struct {
	// The fully qualified name of the column mask function. The function is
	// called on each row of the target table. The function's first argument and
	// its return type should match the type of the masked column. Required on
	// create and update.
	FunctionName types.String `tfsdk:"function_name"`
	// The alias of the column to be masked. The alias must refer to one of
	// matched columns. The values of the column is passed to the column mask
	// function as the first argument. Required on create and update.
	OnColumn types.String `tfsdk:"on_column"`
	// Optional list of column aliases or constant literals to be passed as
	// additional arguments to the column mask function. The type of each column
	// should match the positional argument of the column mask function.
	Using types.List `tfsdk:"using"`
}

func (to *ColumnMaskOptions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ColumnMaskOptions_SdkV2) {
	if !from.Using.IsNull() && !from.Using.IsUnknown() && to.Using.IsNull() && len(from.Using.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Using, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Using = from.Using
	}
}

func (to *ColumnMaskOptions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ColumnMaskOptions_SdkV2) {
	if !from.Using.IsNull() && !from.Using.IsUnknown() && to.Using.IsNull() && len(from.Using.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Using, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Using = from.Using
	}
}

func (m ColumnMaskOptions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetRequired()
	attrs["on_column"] = attrs["on_column"].SetRequired()
	attrs["using"] = attrs["using"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnMaskOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ColumnMaskOptions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"using": reflect.TypeOf(FunctionArgument_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnMaskOptions_SdkV2
// only implements ToObjectValue() and Type().
func (m ColumnMaskOptions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name": m.FunctionName,
			"on_column":     m.OnColumn,
			"using":         m.Using,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ColumnMaskOptions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"on_column":     types.StringType,
			"using": basetypes.ListType{
				ElemType: FunctionArgument_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetUsing returns the value of the Using field in ColumnMaskOptions_SdkV2 as
// a slice of FunctionArgument_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ColumnMaskOptions_SdkV2) GetUsing(ctx context.Context) ([]FunctionArgument_SdkV2, bool) {
	if m.Using.IsNull() || m.Using.IsUnknown() {
		return nil, false
	}
	var v []FunctionArgument_SdkV2
	d := m.Using.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUsing sets the value of the Using field in ColumnMaskOptions_SdkV2.
func (m *ColumnMaskOptions_SdkV2) SetUsing(ctx context.Context, v []FunctionArgument_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["using"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Using = types.ListValueMust(t, vs)
}

type ColumnRelationship_SdkV2 struct {
	Source types.String `tfsdk:"source"`

	Target types.String `tfsdk:"target"`
}

func (to *ColumnRelationship_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ColumnRelationship_SdkV2) {
}

func (to *ColumnRelationship_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ColumnRelationship_SdkV2) {
}

func (m ColumnRelationship_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["source"] = attrs["source"].SetOptional()
	attrs["target"] = attrs["target"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnRelationship.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ColumnRelationship_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnRelationship_SdkV2
// only implements ToObjectValue() and Type().
func (m ColumnRelationship_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"source": m.Source,
			"target": m.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ColumnRelationship_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"source": types.StringType,
			"target": types.StringType,
		},
	}
}

// A connection that is dependent on a SQL object.
type ConnectionDependency_SdkV2 struct {
	// Full name of the dependent connection, in the form of
	// __connection_name__.
	ConnectionName types.String `tfsdk:"connection_name"`
}

func (to *ConnectionDependency_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ConnectionDependency_SdkV2) {
}

func (to *ConnectionDependency_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ConnectionDependency_SdkV2) {
}

func (m ConnectionDependency_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_name"] = attrs["connection_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConnectionDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ConnectionDependency_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConnectionDependency_SdkV2
// only implements ToObjectValue() and Type().
func (m ConnectionDependency_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_name": m.ConnectionName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ConnectionDependency_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_name": types.StringType,
		},
	}
}

// Next ID: 23
type ConnectionInfo_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Unique identifier of the Connection.
	ConnectionId types.String `tfsdk:"connection_id"`
	// The type of connection.
	ConnectionType types.String `tfsdk:"connection_type"`
	// Time at which this connection was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of connection creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// The type of credential.
	CredentialType types.String `tfsdk:"credential_type"`
	// Full name of connection.
	FullName types.String `tfsdk:"full_name"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of the connection.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of the connection.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`

	ProvisioningInfo types.List `tfsdk:"provisioning_info"`
	// If the connection is read only.
	ReadOnly types.Bool `tfsdk:"read_only"`

	SecurableType types.String `tfsdk:"securable_type"`
	// Time at which this connection was updated, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified connection.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// URL of the remote data source, extracted from options.
	Url types.String `tfsdk:"url"`
}

func (to *ConnectionInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ConnectionInfo_SdkV2) {
	if !from.ProvisioningInfo.IsNull() && !from.ProvisioningInfo.IsUnknown() {
		if toProvisioningInfo, ok := to.GetProvisioningInfo(ctx); ok {
			if fromProvisioningInfo, ok := from.GetProvisioningInfo(ctx); ok {
				// Recursively sync the fields of ProvisioningInfo
				toProvisioningInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromProvisioningInfo)
				to.SetProvisioningInfo(ctx, toProvisioningInfo)
			}
		}
	}
}

func (to *ConnectionInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ConnectionInfo_SdkV2) {
	if !from.ProvisioningInfo.IsNull() && !from.ProvisioningInfo.IsUnknown() {
		if toProvisioningInfo, ok := to.GetProvisioningInfo(ctx); ok {
			if fromProvisioningInfo, ok := from.GetProvisioningInfo(ctx); ok {
				toProvisioningInfo.SyncFieldsDuringRead(ctx, fromProvisioningInfo)
				to.SetProvisioningInfo(ctx, toProvisioningInfo)
			}
		}
	}
}

func (m ConnectionInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_id"] = attrs["connection_id"].SetOptional()
	attrs["connection_type"] = attrs["connection_type"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["credential_type"] = attrs["credential_type"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["provisioning_info"] = attrs["provisioning_info"].SetOptional()
	attrs["provisioning_info"] = attrs["provisioning_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConnectionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ConnectionInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":           reflect.TypeOf(types.String{}),
		"properties":        reflect.TypeOf(types.String{}),
		"provisioning_info": reflect.TypeOf(ProvisioningInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConnectionInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ConnectionInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":           m.Comment,
			"connection_id":     m.ConnectionId,
			"connection_type":   m.ConnectionType,
			"created_at":        m.CreatedAt,
			"created_by":        m.CreatedBy,
			"credential_type":   m.CredentialType,
			"full_name":         m.FullName,
			"metastore_id":      m.MetastoreId,
			"name":              m.Name,
			"options":           m.Options,
			"owner":             m.Owner,
			"properties":        m.Properties,
			"provisioning_info": m.ProvisioningInfo,
			"read_only":         m.ReadOnly,
			"securable_type":    m.SecurableType,
			"updated_at":        m.UpdatedAt,
			"updated_by":        m.UpdatedBy,
			"url":               m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ConnectionInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":         types.StringType,
			"connection_id":   types.StringType,
			"connection_type": types.StringType,
			"created_at":      types.Int64Type,
			"created_by":      types.StringType,
			"credential_type": types.StringType,
			"full_name":       types.StringType,
			"metastore_id":    types.StringType,
			"name":            types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"provisioning_info": basetypes.ListType{
				ElemType: ProvisioningInfo_SdkV2{}.Type(ctx),
			},
			"read_only":      types.BoolType,
			"securable_type": types.StringType,
			"updated_at":     types.Int64Type,
			"updated_by":     types.StringType,
			"url":            types.StringType,
		},
	}
}

// GetOptions returns the value of the Options field in ConnectionInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ConnectionInfo_SdkV2) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in ConnectionInfo_SdkV2.
func (m *ConnectionInfo_SdkV2) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ConnectionInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ConnectionInfo_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ConnectionInfo_SdkV2.
func (m *ConnectionInfo_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetProvisioningInfo returns the value of the ProvisioningInfo field in ConnectionInfo_SdkV2 as
// a ProvisioningInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ConnectionInfo_SdkV2) GetProvisioningInfo(ctx context.Context) (ProvisioningInfo_SdkV2, bool) {
	var e ProvisioningInfo_SdkV2
	if m.ProvisioningInfo.IsNull() || m.ProvisioningInfo.IsUnknown() {
		return e, false
	}
	var v []ProvisioningInfo_SdkV2
	d := m.ProvisioningInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetProvisioningInfo sets the value of the ProvisioningInfo field in ConnectionInfo_SdkV2.
func (m *ConnectionInfo_SdkV2) SetProvisioningInfo(ctx context.Context, v ProvisioningInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["provisioning_info"]
	m.ProvisioningInfo = types.ListValueMust(t, vs)
}

// Detailed status of an online table. Shown if the online table is in the
// ONLINE_CONTINUOUS_UPDATE or the ONLINE_UPDATING_PIPELINE_RESOURCES state.
type ContinuousUpdateStatus_SdkV2 struct {
	// Progress of the initial data synchronization.
	InitialPipelineSyncProgress types.List `tfsdk:"initial_pipeline_sync_progress"`
	// The last source table Delta version that was synced to the online table.
	// Note that this Delta version may not be completely synced to the online
	// table yet.
	LastProcessedCommitVersion types.Int64 `tfsdk:"last_processed_commit_version"`
	// The timestamp of the last time any data was synchronized from the source
	// table to the online table.
	Timestamp types.String `tfsdk:"timestamp"`
}

func (to *ContinuousUpdateStatus_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ContinuousUpdateStatus_SdkV2) {
	if !from.InitialPipelineSyncProgress.IsNull() && !from.InitialPipelineSyncProgress.IsUnknown() {
		if toInitialPipelineSyncProgress, ok := to.GetInitialPipelineSyncProgress(ctx); ok {
			if fromInitialPipelineSyncProgress, ok := from.GetInitialPipelineSyncProgress(ctx); ok {
				// Recursively sync the fields of InitialPipelineSyncProgress
				toInitialPipelineSyncProgress.SyncFieldsDuringCreateOrUpdate(ctx, fromInitialPipelineSyncProgress)
				to.SetInitialPipelineSyncProgress(ctx, toInitialPipelineSyncProgress)
			}
		}
	}
}

func (to *ContinuousUpdateStatus_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ContinuousUpdateStatus_SdkV2) {
	if !from.InitialPipelineSyncProgress.IsNull() && !from.InitialPipelineSyncProgress.IsUnknown() {
		if toInitialPipelineSyncProgress, ok := to.GetInitialPipelineSyncProgress(ctx); ok {
			if fromInitialPipelineSyncProgress, ok := from.GetInitialPipelineSyncProgress(ctx); ok {
				toInitialPipelineSyncProgress.SyncFieldsDuringRead(ctx, fromInitialPipelineSyncProgress)
				to.SetInitialPipelineSyncProgress(ctx, toInitialPipelineSyncProgress)
			}
		}
	}
}

func (m ContinuousUpdateStatus_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["initial_pipeline_sync_progress"] = attrs["initial_pipeline_sync_progress"].SetOptional()
	attrs["initial_pipeline_sync_progress"] = attrs["initial_pipeline_sync_progress"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["last_processed_commit_version"] = attrs["last_processed_commit_version"].SetOptional()
	attrs["timestamp"] = attrs["timestamp"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ContinuousUpdateStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ContinuousUpdateStatus_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"initial_pipeline_sync_progress": reflect.TypeOf(PipelineProgress_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ContinuousUpdateStatus_SdkV2
// only implements ToObjectValue() and Type().
func (m ContinuousUpdateStatus_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"initial_pipeline_sync_progress": m.InitialPipelineSyncProgress,
			"last_processed_commit_version":  m.LastProcessedCommitVersion,
			"timestamp":                      m.Timestamp,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ContinuousUpdateStatus_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"initial_pipeline_sync_progress": basetypes.ListType{
				ElemType: PipelineProgress_SdkV2{}.Type(ctx),
			},
			"last_processed_commit_version": types.Int64Type,
			"timestamp":                     types.StringType,
		},
	}
}

// GetInitialPipelineSyncProgress returns the value of the InitialPipelineSyncProgress field in ContinuousUpdateStatus_SdkV2 as
// a PipelineProgress_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ContinuousUpdateStatus_SdkV2) GetInitialPipelineSyncProgress(ctx context.Context) (PipelineProgress_SdkV2, bool) {
	var e PipelineProgress_SdkV2
	if m.InitialPipelineSyncProgress.IsNull() || m.InitialPipelineSyncProgress.IsUnknown() {
		return e, false
	}
	var v []PipelineProgress_SdkV2
	d := m.InitialPipelineSyncProgress.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInitialPipelineSyncProgress sets the value of the InitialPipelineSyncProgress field in ContinuousUpdateStatus_SdkV2.
func (m *ContinuousUpdateStatus_SdkV2) SetInitialPipelineSyncProgress(ctx context.Context, v PipelineProgress_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["initial_pipeline_sync_progress"]
	m.InitialPipelineSyncProgress = types.ListValueMust(t, vs)
}

type CreateAccessRequest_SdkV2 struct {
	// Optional. The principal this request is for. Empty `behalf_of` defaults
	// to the requester's identity.
	//
	// Principals must be unique across the API call.
	BehalfOf types.List `tfsdk:"behalf_of"`
	// Optional. Comment associated with the request.
	//
	// At most 200 characters, can only contain lowercase/uppercase letters
	// (a-z, A-Z), numbers (0-9), punctuation, and spaces.
	Comment types.String `tfsdk:"comment"`
	// List of securables and their corresponding requested UC privileges.
	//
	// At most 30 securables can be requested for a principal per batched call.
	// Each securable can only be requested once per principal.
	SecurablePermissions types.List `tfsdk:"securable_permissions"`
}

func (to *CreateAccessRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccessRequest_SdkV2) {
	if !from.BehalfOf.IsNull() && !from.BehalfOf.IsUnknown() {
		if toBehalfOf, ok := to.GetBehalfOf(ctx); ok {
			if fromBehalfOf, ok := from.GetBehalfOf(ctx); ok {
				// Recursively sync the fields of BehalfOf
				toBehalfOf.SyncFieldsDuringCreateOrUpdate(ctx, fromBehalfOf)
				to.SetBehalfOf(ctx, toBehalfOf)
			}
		}
	}
	if !from.SecurablePermissions.IsNull() && !from.SecurablePermissions.IsUnknown() && to.SecurablePermissions.IsNull() && len(from.SecurablePermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SecurablePermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SecurablePermissions = from.SecurablePermissions
	}
}

func (to *CreateAccessRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateAccessRequest_SdkV2) {
	if !from.BehalfOf.IsNull() && !from.BehalfOf.IsUnknown() {
		if toBehalfOf, ok := to.GetBehalfOf(ctx); ok {
			if fromBehalfOf, ok := from.GetBehalfOf(ctx); ok {
				toBehalfOf.SyncFieldsDuringRead(ctx, fromBehalfOf)
				to.SetBehalfOf(ctx, toBehalfOf)
			}
		}
	}
	if !from.SecurablePermissions.IsNull() && !from.SecurablePermissions.IsUnknown() && to.SecurablePermissions.IsNull() && len(from.SecurablePermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SecurablePermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SecurablePermissions = from.SecurablePermissions
	}
}

func (m CreateAccessRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["behalf_of"] = attrs["behalf_of"].SetOptional()
	attrs["behalf_of"] = attrs["behalf_of"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["securable_permissions"] = attrs["securable_permissions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccessRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateAccessRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"behalf_of":             reflect.TypeOf(Principal_SdkV2{}),
		"securable_permissions": reflect.TypeOf(SecurablePermissions_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccessRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateAccessRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"behalf_of":             m.BehalfOf,
			"comment":               m.Comment,
			"securable_permissions": m.SecurablePermissions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateAccessRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"behalf_of": basetypes.ListType{
				ElemType: Principal_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"securable_permissions": basetypes.ListType{
				ElemType: SecurablePermissions_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetBehalfOf returns the value of the BehalfOf field in CreateAccessRequest_SdkV2 as
// a Principal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccessRequest_SdkV2) GetBehalfOf(ctx context.Context) (Principal_SdkV2, bool) {
	var e Principal_SdkV2
	if m.BehalfOf.IsNull() || m.BehalfOf.IsUnknown() {
		return e, false
	}
	var v []Principal_SdkV2
	d := m.BehalfOf.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetBehalfOf sets the value of the BehalfOf field in CreateAccessRequest_SdkV2.
func (m *CreateAccessRequest_SdkV2) SetBehalfOf(ctx context.Context, v Principal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["behalf_of"]
	m.BehalfOf = types.ListValueMust(t, vs)
}

// GetSecurablePermissions returns the value of the SecurablePermissions field in CreateAccessRequest_SdkV2 as
// a slice of SecurablePermissions_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccessRequest_SdkV2) GetSecurablePermissions(ctx context.Context) ([]SecurablePermissions_SdkV2, bool) {
	if m.SecurablePermissions.IsNull() || m.SecurablePermissions.IsUnknown() {
		return nil, false
	}
	var v []SecurablePermissions_SdkV2
	d := m.SecurablePermissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSecurablePermissions sets the value of the SecurablePermissions field in CreateAccessRequest_SdkV2.
func (m *CreateAccessRequest_SdkV2) SetSecurablePermissions(ctx context.Context, v []SecurablePermissions_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["securable_permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SecurablePermissions = types.ListValueMust(t, vs)
}

type CreateAccessRequestResponse_SdkV2 struct {
	// The principal the request was made on behalf of.
	BehalfOf types.List `tfsdk:"behalf_of"`
	// The access request destinations for all the securables the principal
	// requested.
	RequestDestinations types.List `tfsdk:"request_destinations"`
}

func (to *CreateAccessRequestResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccessRequestResponse_SdkV2) {
	if !from.BehalfOf.IsNull() && !from.BehalfOf.IsUnknown() {
		if toBehalfOf, ok := to.GetBehalfOf(ctx); ok {
			if fromBehalfOf, ok := from.GetBehalfOf(ctx); ok {
				// Recursively sync the fields of BehalfOf
				toBehalfOf.SyncFieldsDuringCreateOrUpdate(ctx, fromBehalfOf)
				to.SetBehalfOf(ctx, toBehalfOf)
			}
		}
	}
	if !from.RequestDestinations.IsNull() && !from.RequestDestinations.IsUnknown() && to.RequestDestinations.IsNull() && len(from.RequestDestinations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RequestDestinations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RequestDestinations = from.RequestDestinations
	}
}

func (to *CreateAccessRequestResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateAccessRequestResponse_SdkV2) {
	if !from.BehalfOf.IsNull() && !from.BehalfOf.IsUnknown() {
		if toBehalfOf, ok := to.GetBehalfOf(ctx); ok {
			if fromBehalfOf, ok := from.GetBehalfOf(ctx); ok {
				toBehalfOf.SyncFieldsDuringRead(ctx, fromBehalfOf)
				to.SetBehalfOf(ctx, toBehalfOf)
			}
		}
	}
	if !from.RequestDestinations.IsNull() && !from.RequestDestinations.IsUnknown() && to.RequestDestinations.IsNull() && len(from.RequestDestinations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RequestDestinations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RequestDestinations = from.RequestDestinations
	}
}

func (m CreateAccessRequestResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["behalf_of"] = attrs["behalf_of"].SetOptional()
	attrs["behalf_of"] = attrs["behalf_of"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["request_destinations"] = attrs["request_destinations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccessRequestResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateAccessRequestResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"behalf_of":            reflect.TypeOf(Principal_SdkV2{}),
		"request_destinations": reflect.TypeOf(AccessRequestDestinations_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccessRequestResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateAccessRequestResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"behalf_of":            m.BehalfOf,
			"request_destinations": m.RequestDestinations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateAccessRequestResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"behalf_of": basetypes.ListType{
				ElemType: Principal_SdkV2{}.Type(ctx),
			},
			"request_destinations": basetypes.ListType{
				ElemType: AccessRequestDestinations_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetBehalfOf returns the value of the BehalfOf field in CreateAccessRequestResponse_SdkV2 as
// a Principal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccessRequestResponse_SdkV2) GetBehalfOf(ctx context.Context) (Principal_SdkV2, bool) {
	var e Principal_SdkV2
	if m.BehalfOf.IsNull() || m.BehalfOf.IsUnknown() {
		return e, false
	}
	var v []Principal_SdkV2
	d := m.BehalfOf.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetBehalfOf sets the value of the BehalfOf field in CreateAccessRequestResponse_SdkV2.
func (m *CreateAccessRequestResponse_SdkV2) SetBehalfOf(ctx context.Context, v Principal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["behalf_of"]
	m.BehalfOf = types.ListValueMust(t, vs)
}

// GetRequestDestinations returns the value of the RequestDestinations field in CreateAccessRequestResponse_SdkV2 as
// a slice of AccessRequestDestinations_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccessRequestResponse_SdkV2) GetRequestDestinations(ctx context.Context) ([]AccessRequestDestinations_SdkV2, bool) {
	if m.RequestDestinations.IsNull() || m.RequestDestinations.IsUnknown() {
		return nil, false
	}
	var v []AccessRequestDestinations_SdkV2
	d := m.RequestDestinations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRequestDestinations sets the value of the RequestDestinations field in CreateAccessRequestResponse_SdkV2.
func (m *CreateAccessRequestResponse_SdkV2) SetRequestDestinations(ctx context.Context, v []AccessRequestDestinations_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["request_destinations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RequestDestinations = types.ListValueMust(t, vs)
}

type CreateAccountsMetastore_SdkV2 struct {
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (to *CreateAccountsMetastore_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccountsMetastore_SdkV2) {
}

func (to *CreateAccountsMetastore_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateAccountsMetastore_SdkV2) {
}

func (m CreateAccountsMetastore_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccountsMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateAccountsMetastore_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccountsMetastore_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateAccountsMetastore_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":         m.Name,
			"region":       m.Region,
			"storage_root": m.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateAccountsMetastore_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":         types.StringType,
			"region":       types.StringType,
			"storage_root": types.StringType,
		},
	}
}

type CreateAccountsStorageCredential_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.List `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
}

func (to *CreateAccountsStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccountsStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				// Recursively sync the fields of CloudflareApiToken
				toCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *CreateAccountsStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateAccountsStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				toCloudflareApiToken.SyncFieldsDuringRead(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m CreateAccountsStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].SetRequired()
	attrs["read_only"] = attrs["read_only"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccountsStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateAccountsStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityRequest_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccountsStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateAccountsStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"cloudflare_api_token":           m.CloudflareApiToken,
			"comment":                        m.Comment,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"name":                           m.Name,
			"read_only":                      m.ReadOnly,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateAccountsStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRoleRequest_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentityRequest_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"cloudflare_api_token": basetypes.ListType{
				ElemType: CloudflareApiToken_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccountRequest_SdkV2{}.Type(ctx),
			},
			"name":      types.StringType,
			"read_only": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CreateAccountsStorageCredential_SdkV2 as
// a AwsIamRoleRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccountsStorageCredential_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest_SdkV2, bool) {
	var e AwsIamRoleRequest_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRoleRequest_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CreateAccountsStorageCredential_SdkV2.
func (m *CreateAccountsStorageCredential_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CreateAccountsStorageCredential_SdkV2 as
// a AzureManagedIdentityRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccountsStorageCredential_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityRequest_SdkV2, bool) {
	var e AzureManagedIdentityRequest_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentityRequest_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CreateAccountsStorageCredential_SdkV2.
func (m *CreateAccountsStorageCredential_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CreateAccountsStorageCredential_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccountsStorageCredential_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CreateAccountsStorageCredential_SdkV2.
func (m *CreateAccountsStorageCredential_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in CreateAccountsStorageCredential_SdkV2 as
// a CloudflareApiToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccountsStorageCredential_SdkV2) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken_SdkV2, bool) {
	var e CloudflareApiToken_SdkV2
	if m.CloudflareApiToken.IsNull() || m.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v []CloudflareApiToken_SdkV2
	d := m.CloudflareApiToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in CreateAccountsStorageCredential_SdkV2.
func (m *CreateAccountsStorageCredential_SdkV2) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cloudflare_api_token"]
	m.CloudflareApiToken = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CreateAccountsStorageCredential_SdkV2 as
// a DatabricksGcpServiceAccountRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateAccountsStorageCredential_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest_SdkV2, bool) {
	var e DatabricksGcpServiceAccountRequest_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccountRequest_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CreateAccountsStorageCredential_SdkV2.
func (m *CreateAccountsStorageCredential_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type CreateCatalog_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// The name of the connection to an external data source.
	ConnectionName types.String `tfsdk:"connection_name"`
	// Name of catalog.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// The name of delta sharing provider.
	//
	// A Delta Sharing catalog is a catalog that is based on a Delta share on a
	// remote sharing server.
	ProviderName types.String `tfsdk:"provider_name"`
	// The name of the share under the share provider.
	ShareName types.String `tfsdk:"share_name"`
	// Storage root URL for managed tables within catalog.
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (to *CreateCatalog_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateCatalog_SdkV2) {
}

func (to *CreateCatalog_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateCatalog_SdkV2) {
}

func (m CreateCatalog_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_name"] = attrs["connection_name"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["provider_name"] = attrs["provider_name"].SetOptional()
	attrs["share_name"] = attrs["share_name"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateCatalog.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateCatalog_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateCatalog_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateCatalog_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":         m.Comment,
			"connection_name": m.ConnectionName,
			"name":            m.Name,
			"options":         m.Options,
			"properties":      m.Properties,
			"provider_name":   m.ProviderName,
			"share_name":      m.ShareName,
			"storage_root":    m.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateCatalog_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":         types.StringType,
			"connection_name": types.StringType,
			"name":            types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"provider_name": types.StringType,
			"share_name":    types.StringType,
			"storage_root":  types.StringType,
		},
	}
}

// GetOptions returns the value of the Options field in CreateCatalog_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCatalog_SdkV2) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in CreateCatalog_SdkV2.
func (m *CreateCatalog_SdkV2) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateCatalog_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCatalog_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateCatalog_SdkV2.
func (m *CreateCatalog_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

type CreateConnection_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// The type of connection.
	ConnectionType types.String `tfsdk:"connection_type"`
	// Name of the connection.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// If the connection is read only.
	ReadOnly types.Bool `tfsdk:"read_only"`
}

func (to *CreateConnection_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateConnection_SdkV2) {
}

func (to *CreateConnection_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateConnection_SdkV2) {
}

func (m CreateConnection_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_type"] = attrs["connection_type"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["options"] = attrs["options"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateConnection.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateConnection_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateConnection_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateConnection_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":         m.Comment,
			"connection_type": m.ConnectionType,
			"name":            m.Name,
			"options":         m.Options,
			"properties":      m.Properties,
			"read_only":       m.ReadOnly,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateConnection_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":         types.StringType,
			"connection_type": types.StringType,
			"name":            types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"read_only": types.BoolType,
		},
	}
}

// GetOptions returns the value of the Options field in CreateConnection_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateConnection_SdkV2) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in CreateConnection_SdkV2.
func (m *CreateConnection_SdkV2) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateConnection_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateConnection_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateConnection_SdkV2.
func (m *CreateConnection_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

type CreateCredentialRequest_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Indicates the purpose of the credential.
	Purpose types.String `tfsdk:"purpose"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Optional. Supplying true to this argument skips validation of the created
	// set of credentials.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (to *CreateCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateCredentialRequest_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *CreateCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateCredentialRequest_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m CreateCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].SetRequired()
	attrs["purpose"] = attrs["purpose"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"comment":                        m.Comment,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"name":                           m.Name,
			"purpose":                        m.Purpose,
			"read_only":                      m.ReadOnly,
			"skip_validation":                m.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRole_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentity_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccount_SdkV2{}.Type(ctx),
			},
			"name":            types.StringType,
			"purpose":         types.StringType,
			"read_only":       types.BoolType,
			"skip_validation": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CreateCredentialRequest_SdkV2 as
// a AwsIamRole_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCredentialRequest_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRole_SdkV2, bool) {
	var e AwsIamRole_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRole_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CreateCredentialRequest_SdkV2.
func (m *CreateCredentialRequest_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRole_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CreateCredentialRequest_SdkV2 as
// a AzureManagedIdentity_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCredentialRequest_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity_SdkV2, bool) {
	var e AzureManagedIdentity_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentity_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CreateCredentialRequest_SdkV2.
func (m *CreateCredentialRequest_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CreateCredentialRequest_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCredentialRequest_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CreateCredentialRequest_SdkV2.
func (m *CreateCredentialRequest_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CreateCredentialRequest_SdkV2 as
// a DatabricksGcpServiceAccount_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCredentialRequest_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount_SdkV2, bool) {
	var e DatabricksGcpServiceAccount_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccount_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CreateCredentialRequest_SdkV2.
func (m *CreateCredentialRequest_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type CreateEntityTagAssignmentRequest_SdkV2 struct {
	TagAssignment types.List `tfsdk:"tag_assignment"`
}

func (to *CreateEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateEntityTagAssignmentRequest_SdkV2) {
	if !from.TagAssignment.IsNull() && !from.TagAssignment.IsUnknown() {
		if toTagAssignment, ok := to.GetTagAssignment(ctx); ok {
			if fromTagAssignment, ok := from.GetTagAssignment(ctx); ok {
				// Recursively sync the fields of TagAssignment
				toTagAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromTagAssignment)
				to.SetTagAssignment(ctx, toTagAssignment)
			}
		}
	}
}

func (to *CreateEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateEntityTagAssignmentRequest_SdkV2) {
	if !from.TagAssignment.IsNull() && !from.TagAssignment.IsUnknown() {
		if toTagAssignment, ok := to.GetTagAssignment(ctx); ok {
			if fromTagAssignment, ok := from.GetTagAssignment(ctx); ok {
				toTagAssignment.SyncFieldsDuringRead(ctx, fromTagAssignment)
				to.SetTagAssignment(ctx, toTagAssignment)
			}
		}
	}
}

func (m CreateEntityTagAssignmentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["tag_assignment"] = attrs["tag_assignment"].SetRequired()
	attrs["tag_assignment"] = attrs["tag_assignment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateEntityTagAssignmentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tag_assignment": reflect.TypeOf(EntityTagAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateEntityTagAssignmentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateEntityTagAssignmentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"tag_assignment": m.TagAssignment,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateEntityTagAssignmentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"tag_assignment": basetypes.ListType{
				ElemType: EntityTagAssignment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTagAssignment returns the value of the TagAssignment field in CreateEntityTagAssignmentRequest_SdkV2 as
// a EntityTagAssignment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateEntityTagAssignmentRequest_SdkV2) GetTagAssignment(ctx context.Context) (EntityTagAssignment_SdkV2, bool) {
	var e EntityTagAssignment_SdkV2
	if m.TagAssignment.IsNull() || m.TagAssignment.IsUnknown() {
		return e, false
	}
	var v []EntityTagAssignment_SdkV2
	d := m.TagAssignment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTagAssignment sets the value of the TagAssignment field in CreateEntityTagAssignmentRequest_SdkV2.
func (m *CreateEntityTagAssignmentRequest_SdkV2) SetTagAssignment(ctx context.Context, v EntityTagAssignment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tag_assignment"]
	m.TagAssignment = types.ListValueMust(t, vs)
}

type CreateExternalLineageRelationshipRequest_SdkV2 struct {
	ExternalLineageRelationship types.List `tfsdk:"external_lineage_relationship"`
}

func (to *CreateExternalLineageRelationshipRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateExternalLineageRelationshipRequest_SdkV2) {
	if !from.ExternalLineageRelationship.IsNull() && !from.ExternalLineageRelationship.IsUnknown() {
		if toExternalLineageRelationship, ok := to.GetExternalLineageRelationship(ctx); ok {
			if fromExternalLineageRelationship, ok := from.GetExternalLineageRelationship(ctx); ok {
				// Recursively sync the fields of ExternalLineageRelationship
				toExternalLineageRelationship.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalLineageRelationship)
				to.SetExternalLineageRelationship(ctx, toExternalLineageRelationship)
			}
		}
	}
}

func (to *CreateExternalLineageRelationshipRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateExternalLineageRelationshipRequest_SdkV2) {
	if !from.ExternalLineageRelationship.IsNull() && !from.ExternalLineageRelationship.IsUnknown() {
		if toExternalLineageRelationship, ok := to.GetExternalLineageRelationship(ctx); ok {
			if fromExternalLineageRelationship, ok := from.GetExternalLineageRelationship(ctx); ok {
				toExternalLineageRelationship.SyncFieldsDuringRead(ctx, fromExternalLineageRelationship)
				to.SetExternalLineageRelationship(ctx, toExternalLineageRelationship)
			}
		}
	}
}

func (m CreateExternalLineageRelationshipRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].SetRequired()
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateExternalLineageRelationshipRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateExternalLineageRelationshipRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationship": reflect.TypeOf(CreateRequestExternalLineage_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateExternalLineageRelationshipRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateExternalLineageRelationshipRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationship": m.ExternalLineageRelationship,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateExternalLineageRelationshipRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationship": basetypes.ListType{
				ElemType: CreateRequestExternalLineage_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetExternalLineageRelationship returns the value of the ExternalLineageRelationship field in CreateExternalLineageRelationshipRequest_SdkV2 as
// a CreateRequestExternalLineage_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateExternalLineageRelationshipRequest_SdkV2) GetExternalLineageRelationship(ctx context.Context) (CreateRequestExternalLineage_SdkV2, bool) {
	var e CreateRequestExternalLineage_SdkV2
	if m.ExternalLineageRelationship.IsNull() || m.ExternalLineageRelationship.IsUnknown() {
		return e, false
	}
	var v []CreateRequestExternalLineage_SdkV2
	d := m.ExternalLineageRelationship.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalLineageRelationship sets the value of the ExternalLineageRelationship field in CreateExternalLineageRelationshipRequest_SdkV2.
func (m *CreateExternalLineageRelationshipRequest_SdkV2) SetExternalLineageRelationship(ctx context.Context, v CreateRequestExternalLineage_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_lineage_relationship"]
	m.ExternalLineageRelationship = types.ListValueMust(t, vs)
}

type CreateExternalLocation_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of the storage credential used with this location.
	CredentialName types.String `tfsdk:"credential_name"`
	// Whether to enable file events on this external location.
	EnableFileEvents types.Bool `tfsdk:"enable_file_events"`

	EncryptionDetails types.List `tfsdk:"encryption_details"`
	// Indicates whether fallback mode is enabled for this external location.
	// When fallback mode is enabled, the access to the location falls back to
	// cluster credentials if UC credentials are not sufficient.
	Fallback types.Bool `tfsdk:"fallback"`
	// File event queue settings. If `enable_file_events` is `true`, must be
	// defined and have exactly one of the documented properties.
	FileEventQueue types.List `tfsdk:"file_event_queue"`
	// Name of the external location.
	Name types.String `tfsdk:"name"`
	// Indicates whether the external location is read-only.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Skips validation of the storage credential associated with the external
	// location.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
	// Path URL of the external location.
	Url types.String `tfsdk:"url"`
}

func (to *CreateExternalLocation_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateExternalLocation_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				// Recursively sync the fields of EncryptionDetails
				toEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.FileEventQueue.IsNull() && !from.FileEventQueue.IsUnknown() {
		if toFileEventQueue, ok := to.GetFileEventQueue(ctx); ok {
			if fromFileEventQueue, ok := from.GetFileEventQueue(ctx); ok {
				// Recursively sync the fields of FileEventQueue
				toFileEventQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromFileEventQueue)
				to.SetFileEventQueue(ctx, toFileEventQueue)
			}
		}
	}
}

func (to *CreateExternalLocation_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateExternalLocation_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				toEncryptionDetails.SyncFieldsDuringRead(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.FileEventQueue.IsNull() && !from.FileEventQueue.IsUnknown() {
		if toFileEventQueue, ok := to.GetFileEventQueue(ctx); ok {
			if fromFileEventQueue, ok := from.GetFileEventQueue(ctx); ok {
				toFileEventQueue.SyncFieldsDuringRead(ctx, fromFileEventQueue)
				to.SetFileEventQueue(ctx, toFileEventQueue)
			}
		}
	}
}

func (m CreateExternalLocation_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetRequired()
	attrs["enable_file_events"] = attrs["enable_file_events"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["fallback"] = attrs["fallback"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].SetRequired()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["url"] = attrs["url"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateExternalLocation.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateExternalLocation_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails_SdkV2{}),
		"file_event_queue":   reflect.TypeOf(FileEventQueue_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateExternalLocation_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateExternalLocation_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            m.Comment,
			"credential_name":    m.CredentialName,
			"enable_file_events": m.EnableFileEvents,
			"encryption_details": m.EncryptionDetails,
			"fallback":           m.Fallback,
			"file_event_queue":   m.FileEventQueue,
			"name":               m.Name,
			"read_only":          m.ReadOnly,
			"skip_validation":    m.SkipValidation,
			"url":                m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateExternalLocation_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"credential_name":    types.StringType,
			"enable_file_events": types.BoolType,
			"encryption_details": basetypes.ListType{
				ElemType: EncryptionDetails_SdkV2{}.Type(ctx),
			},
			"fallback": types.BoolType,
			"file_event_queue": basetypes.ListType{
				ElemType: FileEventQueue_SdkV2{}.Type(ctx),
			},
			"name":            types.StringType,
			"read_only":       types.BoolType,
			"skip_validation": types.BoolType,
			"url":             types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in CreateExternalLocation_SdkV2 as
// a EncryptionDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateExternalLocation_SdkV2) GetEncryptionDetails(ctx context.Context) (EncryptionDetails_SdkV2, bool) {
	var e EncryptionDetails_SdkV2
	if m.EncryptionDetails.IsNull() || m.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v []EncryptionDetails_SdkV2
	d := m.EncryptionDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in CreateExternalLocation_SdkV2.
func (m *CreateExternalLocation_SdkV2) SetEncryptionDetails(ctx context.Context, v EncryptionDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["encryption_details"]
	m.EncryptionDetails = types.ListValueMust(t, vs)
}

// GetFileEventQueue returns the value of the FileEventQueue field in CreateExternalLocation_SdkV2 as
// a FileEventQueue_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateExternalLocation_SdkV2) GetFileEventQueue(ctx context.Context) (FileEventQueue_SdkV2, bool) {
	var e FileEventQueue_SdkV2
	if m.FileEventQueue.IsNull() || m.FileEventQueue.IsUnknown() {
		return e, false
	}
	var v []FileEventQueue_SdkV2
	d := m.FileEventQueue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFileEventQueue sets the value of the FileEventQueue field in CreateExternalLocation_SdkV2.
func (m *CreateExternalLocation_SdkV2) SetFileEventQueue(ctx context.Context, v FileEventQueue_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file_event_queue"]
	m.FileEventQueue = types.ListValueMust(t, vs)
}

type CreateExternalMetadataRequest_SdkV2 struct {
	ExternalMetadata types.List `tfsdk:"external_metadata"`
}

func (to *CreateExternalMetadataRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateExternalMetadataRequest_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() {
		if toExternalMetadata, ok := to.GetExternalMetadata(ctx); ok {
			if fromExternalMetadata, ok := from.GetExternalMetadata(ctx); ok {
				// Recursively sync the fields of ExternalMetadata
				toExternalMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalMetadata)
				to.SetExternalMetadata(ctx, toExternalMetadata)
			}
		}
	}
}

func (to *CreateExternalMetadataRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateExternalMetadataRequest_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() {
		if toExternalMetadata, ok := to.GetExternalMetadata(ctx); ok {
			if fromExternalMetadata, ok := from.GetExternalMetadata(ctx); ok {
				toExternalMetadata.SyncFieldsDuringRead(ctx, fromExternalMetadata)
				to.SetExternalMetadata(ctx, toExternalMetadata)
			}
		}
	}
}

func (m CreateExternalMetadataRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetRequired()
	attrs["external_metadata"] = attrs["external_metadata"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateExternalMetadataRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalMetadata_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateExternalMetadataRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateExternalMetadataRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": m.ExternalMetadata,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateExternalMetadataRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": basetypes.ListType{
				ElemType: ExternalMetadata_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in CreateExternalMetadataRequest_SdkV2 as
// a ExternalMetadata_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateExternalMetadataRequest_SdkV2) GetExternalMetadata(ctx context.Context) (ExternalMetadata_SdkV2, bool) {
	var e ExternalMetadata_SdkV2
	if m.ExternalMetadata.IsNull() || m.ExternalMetadata.IsUnknown() {
		return e, false
	}
	var v []ExternalMetadata_SdkV2
	d := m.ExternalMetadata.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in CreateExternalMetadataRequest_SdkV2.
func (m *CreateExternalMetadataRequest_SdkV2) SetExternalMetadata(ctx context.Context, v ExternalMetadata_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_metadata"]
	m.ExternalMetadata = types.ListValueMust(t, vs)
}

type CreateFunction_SdkV2 struct {
	// Name of parent Catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Scalar function return data type.
	DataType types.String `tfsdk:"data_type"`
	// External function language.
	ExternalLanguage types.String `tfsdk:"external_language"`
	// External function name.
	ExternalName types.String `tfsdk:"external_name"`
	// Pretty printed function data type.
	FullDataType types.String `tfsdk:"full_data_type"`
	// Function input parameters.
	InputParams types.List `tfsdk:"input_params"`
	// Whether the function is deterministic.
	IsDeterministic types.Bool `tfsdk:"is_deterministic"`
	// Function null call.
	IsNullCall types.Bool `tfsdk:"is_null_call"`
	// Name of function, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// Function parameter style. **S** is the value for SQL.
	ParameterStyle types.String `tfsdk:"parameter_style"`
	// JSON-serialized key-value pair map, encoded (escaped) as a string.
	Properties types.String `tfsdk:"properties"`
	// Table function return parameters.
	ReturnParams types.List `tfsdk:"return_params"`
	// Function language. When **EXTERNAL** is used, the language of the routine
	// function should be specified in the **external_language** field, and the
	// **return_params** of the function cannot be used (as **TABLE** return
	// type is not supported), and the **sql_data_access** field must be
	// **NO_SQL**.
	RoutineBody types.String `tfsdk:"routine_body"`
	// Function body.
	RoutineDefinition types.String `tfsdk:"routine_definition"`
	// function dependencies.
	RoutineDependencies types.List `tfsdk:"routine_dependencies"`
	// Name of parent Schema relative to its parent Catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// Function security type.
	SecurityType types.String `tfsdk:"security_type"`
	// Specific name of the function; Reserved for future use.
	SpecificName types.String `tfsdk:"specific_name"`
	// Function SQL data access.
	SqlDataAccess types.String `tfsdk:"sql_data_access"`
	// List of schemes whose objects can be referenced without qualification.
	SqlPath types.String `tfsdk:"sql_path"`
}

func (to *CreateFunction_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateFunction_SdkV2) {
	if !from.InputParams.IsNull() && !from.InputParams.IsUnknown() {
		if toInputParams, ok := to.GetInputParams(ctx); ok {
			if fromInputParams, ok := from.GetInputParams(ctx); ok {
				// Recursively sync the fields of InputParams
				toInputParams.SyncFieldsDuringCreateOrUpdate(ctx, fromInputParams)
				to.SetInputParams(ctx, toInputParams)
			}
		}
	}
	if !from.ReturnParams.IsNull() && !from.ReturnParams.IsUnknown() {
		if toReturnParams, ok := to.GetReturnParams(ctx); ok {
			if fromReturnParams, ok := from.GetReturnParams(ctx); ok {
				// Recursively sync the fields of ReturnParams
				toReturnParams.SyncFieldsDuringCreateOrUpdate(ctx, fromReturnParams)
				to.SetReturnParams(ctx, toReturnParams)
			}
		}
	}
	if !from.RoutineDependencies.IsNull() && !from.RoutineDependencies.IsUnknown() {
		if toRoutineDependencies, ok := to.GetRoutineDependencies(ctx); ok {
			if fromRoutineDependencies, ok := from.GetRoutineDependencies(ctx); ok {
				// Recursively sync the fields of RoutineDependencies
				toRoutineDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromRoutineDependencies)
				to.SetRoutineDependencies(ctx, toRoutineDependencies)
			}
		}
	}
}

func (to *CreateFunction_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateFunction_SdkV2) {
	if !from.InputParams.IsNull() && !from.InputParams.IsUnknown() {
		if toInputParams, ok := to.GetInputParams(ctx); ok {
			if fromInputParams, ok := from.GetInputParams(ctx); ok {
				toInputParams.SyncFieldsDuringRead(ctx, fromInputParams)
				to.SetInputParams(ctx, toInputParams)
			}
		}
	}
	if !from.ReturnParams.IsNull() && !from.ReturnParams.IsUnknown() {
		if toReturnParams, ok := to.GetReturnParams(ctx); ok {
			if fromReturnParams, ok := from.GetReturnParams(ctx); ok {
				toReturnParams.SyncFieldsDuringRead(ctx, fromReturnParams)
				to.SetReturnParams(ctx, toReturnParams)
			}
		}
	}
	if !from.RoutineDependencies.IsNull() && !from.RoutineDependencies.IsUnknown() {
		if toRoutineDependencies, ok := to.GetRoutineDependencies(ctx); ok {
			if fromRoutineDependencies, ok := from.GetRoutineDependencies(ctx); ok {
				toRoutineDependencies.SyncFieldsDuringRead(ctx, fromRoutineDependencies)
				to.SetRoutineDependencies(ctx, toRoutineDependencies)
			}
		}
	}
}

func (m CreateFunction_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["data_type"] = attrs["data_type"].SetRequired()
	attrs["external_language"] = attrs["external_language"].SetOptional()
	attrs["external_name"] = attrs["external_name"].SetOptional()
	attrs["full_data_type"] = attrs["full_data_type"].SetRequired()
	attrs["input_params"] = attrs["input_params"].SetRequired()
	attrs["input_params"] = attrs["input_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["is_deterministic"] = attrs["is_deterministic"].SetRequired()
	attrs["is_null_call"] = attrs["is_null_call"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["parameter_style"] = attrs["parameter_style"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["return_params"] = attrs["return_params"].SetOptional()
	attrs["return_params"] = attrs["return_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["routine_body"] = attrs["routine_body"].SetRequired()
	attrs["routine_definition"] = attrs["routine_definition"].SetRequired()
	attrs["routine_dependencies"] = attrs["routine_dependencies"].SetOptional()
	attrs["routine_dependencies"] = attrs["routine_dependencies"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["security_type"] = attrs["security_type"].SetRequired()
	attrs["specific_name"] = attrs["specific_name"].SetRequired()
	attrs["sql_data_access"] = attrs["sql_data_access"].SetRequired()
	attrs["sql_path"] = attrs["sql_path"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateFunction.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateFunction_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_params":         reflect.TypeOf(FunctionParameterInfos_SdkV2{}),
		"return_params":        reflect.TypeOf(FunctionParameterInfos_SdkV2{}),
		"routine_dependencies": reflect.TypeOf(DependencyList_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateFunction_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateFunction_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":         m.CatalogName,
			"comment":              m.Comment,
			"data_type":            m.DataType,
			"external_language":    m.ExternalLanguage,
			"external_name":        m.ExternalName,
			"full_data_type":       m.FullDataType,
			"input_params":         m.InputParams,
			"is_deterministic":     m.IsDeterministic,
			"is_null_call":         m.IsNullCall,
			"name":                 m.Name,
			"parameter_style":      m.ParameterStyle,
			"properties":           m.Properties,
			"return_params":        m.ReturnParams,
			"routine_body":         m.RoutineBody,
			"routine_definition":   m.RoutineDefinition,
			"routine_dependencies": m.RoutineDependencies,
			"schema_name":          m.SchemaName,
			"security_type":        m.SecurityType,
			"specific_name":        m.SpecificName,
			"sql_data_access":      m.SqlDataAccess,
			"sql_path":             m.SqlPath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateFunction_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":      types.StringType,
			"comment":           types.StringType,
			"data_type":         types.StringType,
			"external_language": types.StringType,
			"external_name":     types.StringType,
			"full_data_type":    types.StringType,
			"input_params": basetypes.ListType{
				ElemType: FunctionParameterInfos_SdkV2{}.Type(ctx),
			},
			"is_deterministic": types.BoolType,
			"is_null_call":     types.BoolType,
			"name":             types.StringType,
			"parameter_style":  types.StringType,
			"properties":       types.StringType,
			"return_params": basetypes.ListType{
				ElemType: FunctionParameterInfos_SdkV2{}.Type(ctx),
			},
			"routine_body":       types.StringType,
			"routine_definition": types.StringType,
			"routine_dependencies": basetypes.ListType{
				ElemType: DependencyList_SdkV2{}.Type(ctx),
			},
			"schema_name":     types.StringType,
			"security_type":   types.StringType,
			"specific_name":   types.StringType,
			"sql_data_access": types.StringType,
			"sql_path":        types.StringType,
		},
	}
}

// GetInputParams returns the value of the InputParams field in CreateFunction_SdkV2 as
// a FunctionParameterInfos_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateFunction_SdkV2) GetInputParams(ctx context.Context) (FunctionParameterInfos_SdkV2, bool) {
	var e FunctionParameterInfos_SdkV2
	if m.InputParams.IsNull() || m.InputParams.IsUnknown() {
		return e, false
	}
	var v []FunctionParameterInfos_SdkV2
	d := m.InputParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInputParams sets the value of the InputParams field in CreateFunction_SdkV2.
func (m *CreateFunction_SdkV2) SetInputParams(ctx context.Context, v FunctionParameterInfos_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["input_params"]
	m.InputParams = types.ListValueMust(t, vs)
}

// GetReturnParams returns the value of the ReturnParams field in CreateFunction_SdkV2 as
// a FunctionParameterInfos_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateFunction_SdkV2) GetReturnParams(ctx context.Context) (FunctionParameterInfos_SdkV2, bool) {
	var e FunctionParameterInfos_SdkV2
	if m.ReturnParams.IsNull() || m.ReturnParams.IsUnknown() {
		return e, false
	}
	var v []FunctionParameterInfos_SdkV2
	d := m.ReturnParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetReturnParams sets the value of the ReturnParams field in CreateFunction_SdkV2.
func (m *CreateFunction_SdkV2) SetReturnParams(ctx context.Context, v FunctionParameterInfos_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["return_params"]
	m.ReturnParams = types.ListValueMust(t, vs)
}

// GetRoutineDependencies returns the value of the RoutineDependencies field in CreateFunction_SdkV2 as
// a DependencyList_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateFunction_SdkV2) GetRoutineDependencies(ctx context.Context) (DependencyList_SdkV2, bool) {
	var e DependencyList_SdkV2
	if m.RoutineDependencies.IsNull() || m.RoutineDependencies.IsUnknown() {
		return e, false
	}
	var v []DependencyList_SdkV2
	d := m.RoutineDependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRoutineDependencies sets the value of the RoutineDependencies field in CreateFunction_SdkV2.
func (m *CreateFunction_SdkV2) SetRoutineDependencies(ctx context.Context, v DependencyList_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["routine_dependencies"]
	m.RoutineDependencies = types.ListValueMust(t, vs)
}

type CreateFunctionRequest_SdkV2 struct {
	// Partial __FunctionInfo__ specifying the function to be created.
	FunctionInfo types.List `tfsdk:"function_info"`
}

func (to *CreateFunctionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateFunctionRequest_SdkV2) {
	if !from.FunctionInfo.IsNull() && !from.FunctionInfo.IsUnknown() {
		if toFunctionInfo, ok := to.GetFunctionInfo(ctx); ok {
			if fromFunctionInfo, ok := from.GetFunctionInfo(ctx); ok {
				// Recursively sync the fields of FunctionInfo
				toFunctionInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromFunctionInfo)
				to.SetFunctionInfo(ctx, toFunctionInfo)
			}
		}
	}
}

func (to *CreateFunctionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateFunctionRequest_SdkV2) {
	if !from.FunctionInfo.IsNull() && !from.FunctionInfo.IsUnknown() {
		if toFunctionInfo, ok := to.GetFunctionInfo(ctx); ok {
			if fromFunctionInfo, ok := from.GetFunctionInfo(ctx); ok {
				toFunctionInfo.SyncFieldsDuringRead(ctx, fromFunctionInfo)
				to.SetFunctionInfo(ctx, toFunctionInfo)
			}
		}
	}
}

func (m CreateFunctionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_info"] = attrs["function_info"].SetRequired()
	attrs["function_info"] = attrs["function_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateFunctionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateFunctionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"function_info": reflect.TypeOf(CreateFunction_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateFunctionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateFunctionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_info": m.FunctionInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateFunctionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_info": basetypes.ListType{
				ElemType: CreateFunction_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetFunctionInfo returns the value of the FunctionInfo field in CreateFunctionRequest_SdkV2 as
// a CreateFunction_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateFunctionRequest_SdkV2) GetFunctionInfo(ctx context.Context) (CreateFunction_SdkV2, bool) {
	var e CreateFunction_SdkV2
	if m.FunctionInfo.IsNull() || m.FunctionInfo.IsUnknown() {
		return e, false
	}
	var v []CreateFunction_SdkV2
	d := m.FunctionInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFunctionInfo sets the value of the FunctionInfo field in CreateFunctionRequest_SdkV2.
func (m *CreateFunctionRequest_SdkV2) SetFunctionInfo(ctx context.Context, v CreateFunction_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["function_info"]
	m.FunctionInfo = types.ListValueMust(t, vs)
}

type CreateMetastore_SdkV2 struct {
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (to *CreateMetastore_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateMetastore_SdkV2) {
}

func (to *CreateMetastore_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateMetastore_SdkV2) {
}

func (m CreateMetastore_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateMetastore_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateMetastore_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateMetastore_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":         m.Name,
			"region":       m.Region,
			"storage_root": m.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateMetastore_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":         types.StringType,
			"region":       types.StringType,
			"storage_root": types.StringType,
		},
	}
}

type CreateMetastoreAssignment_SdkV2 struct {
	// The name of the default catalog in the metastore. This field is
	// deprecated. Please use "Default Namespace API" to configure the default
	// catalog for a Databricks workspace.
	DefaultCatalogName types.String `tfsdk:"default_catalog_name"`
	// The unique ID of the metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// A workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *CreateMetastoreAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateMetastoreAssignment_SdkV2) {
}

func (to *CreateMetastoreAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateMetastoreAssignment_SdkV2) {
}

func (m CreateMetastoreAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default_catalog_name"] = attrs["default_catalog_name"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateMetastoreAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateMetastoreAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateMetastoreAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default_catalog_name": m.DefaultCatalogName,
			"metastore_id":         m.MetastoreId,
			"workspace_id":         m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateMetastoreAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default_catalog_name": types.StringType,
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

type CreateMonitor_SdkV2 struct {
	// [Create:REQ Update:IGN] Field for specifying the absolute path to a
	// custom directory to store data-monitoring assets. Normally prepopulated
	// to a default user location via UI and Python APIs.
	AssetsDir types.String `tfsdk:"assets_dir"`
	// [Create:OPT Update:OPT] Baseline table name. Baseline data is used to
	// compute drift from the data in the monitored `table_name`. The baseline
	// table and the monitored table shall have the same schema.
	BaselineTableName types.String `tfsdk:"baseline_table_name"`
	// [Create:OPT Update:OPT] Custom metrics.
	CustomMetrics types.List `tfsdk:"custom_metrics"`
	// [Create:OPT Update:OPT] Data classification related config.
	DataClassificationConfig types.List `tfsdk:"data_classification_config"`

	InferenceLog types.List `tfsdk:"inference_log"`
	// [Create:ERR Update:IGN] The latest error message for a monitor failure.
	LatestMonitorFailureMsg types.String `tfsdk:"latest_monitor_failure_msg"`
	// [Create:OPT Update:OPT] Field for specifying notification settings.
	Notifications types.List `tfsdk:"notifications"`
	// [Create:REQ Update:REQ] Schema where output tables are created. Needs to
	// be in 2-level format {catalog}.{schema}
	OutputSchemaName types.String `tfsdk:"output_schema_name"`
	// [Create:OPT Update:OPT] The monitor schedule.
	Schedule types.List `tfsdk:"schedule"`
	// Whether to skip creating a default dashboard summarizing data quality
	// metrics.
	SkipBuiltinDashboard types.Bool `tfsdk:"skip_builtin_dashboard"`
	// [Create:OPT Update:OPT] List of column expressions to slice data with for
	// targeted analysis. The data is grouped by each expression independently,
	// resulting in a separate slice for each predicate and its complements. For
	// example `slicing_exprs=[col_1, col_2 > 10]` will generate the
	// following slices: two slices for `col_2 > 10` (True and False), and one
	// slice per unique value in `col1`. For high-cardinality columns, only the
	// top 100 unique values by frequency will generate slices.
	SlicingExprs types.List `tfsdk:"slicing_exprs"`
	// Configuration for monitoring snapshot tables.
	Snapshot types.List `tfsdk:"snapshot"`
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
	// Configuration for monitoring time series tables.
	TimeSeries types.List `tfsdk:"time_series"`
	// Optional argument to specify the warehouse for dashboard creation. If not
	// specified, the first running warehouse will be used.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *CreateMonitor_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateMonitor_SdkV2) {
	if !from.CustomMetrics.IsNull() && !from.CustomMetrics.IsUnknown() && to.CustomMetrics.IsNull() && len(from.CustomMetrics.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for CustomMetrics, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.CustomMetrics = from.CustomMetrics
	}
	if !from.DataClassificationConfig.IsNull() && !from.DataClassificationConfig.IsUnknown() {
		if toDataClassificationConfig, ok := to.GetDataClassificationConfig(ctx); ok {
			if fromDataClassificationConfig, ok := from.GetDataClassificationConfig(ctx); ok {
				// Recursively sync the fields of DataClassificationConfig
				toDataClassificationConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromDataClassificationConfig)
				to.SetDataClassificationConfig(ctx, toDataClassificationConfig)
			}
		}
	}
	if !from.InferenceLog.IsNull() && !from.InferenceLog.IsUnknown() {
		if toInferenceLog, ok := to.GetInferenceLog(ctx); ok {
			if fromInferenceLog, ok := from.GetInferenceLog(ctx); ok {
				// Recursively sync the fields of InferenceLog
				toInferenceLog.SyncFieldsDuringCreateOrUpdate(ctx, fromInferenceLog)
				to.SetInferenceLog(ctx, toInferenceLog)
			}
		}
	}
	if !from.Notifications.IsNull() && !from.Notifications.IsUnknown() {
		if toNotifications, ok := to.GetNotifications(ctx); ok {
			if fromNotifications, ok := from.GetNotifications(ctx); ok {
				// Recursively sync the fields of Notifications
				toNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromNotifications)
				to.SetNotifications(ctx, toNotifications)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.SlicingExprs.IsNull() && !from.SlicingExprs.IsUnknown() && to.SlicingExprs.IsNull() && len(from.SlicingExprs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SlicingExprs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SlicingExprs = from.SlicingExprs
	}
	if !from.Snapshot.IsNull() && !from.Snapshot.IsUnknown() {
		if toSnapshot, ok := to.GetSnapshot(ctx); ok {
			if fromSnapshot, ok := from.GetSnapshot(ctx); ok {
				// Recursively sync the fields of Snapshot
				toSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromSnapshot)
				to.SetSnapshot(ctx, toSnapshot)
			}
		}
	}
	if !from.TimeSeries.IsNull() && !from.TimeSeries.IsUnknown() {
		if toTimeSeries, ok := to.GetTimeSeries(ctx); ok {
			if fromTimeSeries, ok := from.GetTimeSeries(ctx); ok {
				// Recursively sync the fields of TimeSeries
				toTimeSeries.SyncFieldsDuringCreateOrUpdate(ctx, fromTimeSeries)
				to.SetTimeSeries(ctx, toTimeSeries)
			}
		}
	}
}

func (to *CreateMonitor_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateMonitor_SdkV2) {
	if !from.CustomMetrics.IsNull() && !from.CustomMetrics.IsUnknown() && to.CustomMetrics.IsNull() && len(from.CustomMetrics.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for CustomMetrics, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.CustomMetrics = from.CustomMetrics
	}
	if !from.DataClassificationConfig.IsNull() && !from.DataClassificationConfig.IsUnknown() {
		if toDataClassificationConfig, ok := to.GetDataClassificationConfig(ctx); ok {
			if fromDataClassificationConfig, ok := from.GetDataClassificationConfig(ctx); ok {
				toDataClassificationConfig.SyncFieldsDuringRead(ctx, fromDataClassificationConfig)
				to.SetDataClassificationConfig(ctx, toDataClassificationConfig)
			}
		}
	}
	if !from.InferenceLog.IsNull() && !from.InferenceLog.IsUnknown() {
		if toInferenceLog, ok := to.GetInferenceLog(ctx); ok {
			if fromInferenceLog, ok := from.GetInferenceLog(ctx); ok {
				toInferenceLog.SyncFieldsDuringRead(ctx, fromInferenceLog)
				to.SetInferenceLog(ctx, toInferenceLog)
			}
		}
	}
	if !from.Notifications.IsNull() && !from.Notifications.IsUnknown() {
		if toNotifications, ok := to.GetNotifications(ctx); ok {
			if fromNotifications, ok := from.GetNotifications(ctx); ok {
				toNotifications.SyncFieldsDuringRead(ctx, fromNotifications)
				to.SetNotifications(ctx, toNotifications)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.SlicingExprs.IsNull() && !from.SlicingExprs.IsUnknown() && to.SlicingExprs.IsNull() && len(from.SlicingExprs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SlicingExprs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SlicingExprs = from.SlicingExprs
	}
	if !from.Snapshot.IsNull() && !from.Snapshot.IsUnknown() {
		if toSnapshot, ok := to.GetSnapshot(ctx); ok {
			if fromSnapshot, ok := from.GetSnapshot(ctx); ok {
				toSnapshot.SyncFieldsDuringRead(ctx, fromSnapshot)
				to.SetSnapshot(ctx, toSnapshot)
			}
		}
	}
	if !from.TimeSeries.IsNull() && !from.TimeSeries.IsUnknown() {
		if toTimeSeries, ok := to.GetTimeSeries(ctx); ok {
			if fromTimeSeries, ok := from.GetTimeSeries(ctx); ok {
				toTimeSeries.SyncFieldsDuringRead(ctx, fromTimeSeries)
				to.SetTimeSeries(ctx, toTimeSeries)
			}
		}
	}
}

func (m CreateMonitor_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assets_dir"] = attrs["assets_dir"].SetRequired()
	attrs["baseline_table_name"] = attrs["baseline_table_name"].SetOptional()
	attrs["custom_metrics"] = attrs["custom_metrics"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["inference_log"] = attrs["inference_log"].SetOptional()
	attrs["inference_log"] = attrs["inference_log"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["latest_monitor_failure_msg"] = attrs["latest_monitor_failure_msg"].SetOptional()
	attrs["notifications"] = attrs["notifications"].SetOptional()
	attrs["notifications"] = attrs["notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["output_schema_name"] = attrs["output_schema_name"].SetRequired()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["skip_builtin_dashboard"] = attrs["skip_builtin_dashboard"].SetOptional()
	attrs["slicing_exprs"] = attrs["slicing_exprs"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["time_series"] = attrs["time_series"].SetOptional()
	attrs["time_series"] = attrs["time_series"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateMonitor.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateMonitor_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_metrics":             reflect.TypeOf(MonitorMetric_SdkV2{}),
		"data_classification_config": reflect.TypeOf(MonitorDataClassificationConfig_SdkV2{}),
		"inference_log":              reflect.TypeOf(MonitorInferenceLog_SdkV2{}),
		"notifications":              reflect.TypeOf(MonitorNotifications_SdkV2{}),
		"schedule":                   reflect.TypeOf(MonitorCronSchedule_SdkV2{}),
		"slicing_exprs":              reflect.TypeOf(types.String{}),
		"snapshot":                   reflect.TypeOf(MonitorSnapshot_SdkV2{}),
		"time_series":                reflect.TypeOf(MonitorTimeSeries_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateMonitor_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateMonitor_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assets_dir":                 m.AssetsDir,
			"baseline_table_name":        m.BaselineTableName,
			"custom_metrics":             m.CustomMetrics,
			"data_classification_config": m.DataClassificationConfig,
			"inference_log":              m.InferenceLog,
			"latest_monitor_failure_msg": m.LatestMonitorFailureMsg,
			"notifications":              m.Notifications,
			"output_schema_name":         m.OutputSchemaName,
			"schedule":                   m.Schedule,
			"skip_builtin_dashboard":     m.SkipBuiltinDashboard,
			"slicing_exprs":              m.SlicingExprs,
			"snapshot":                   m.Snapshot,
			"table_name":                 m.TableName,
			"time_series":                m.TimeSeries,
			"warehouse_id":               m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateMonitor_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assets_dir":          types.StringType,
			"baseline_table_name": types.StringType,
			"custom_metrics": basetypes.ListType{
				ElemType: MonitorMetric_SdkV2{}.Type(ctx),
			},
			"data_classification_config": basetypes.ListType{
				ElemType: MonitorDataClassificationConfig_SdkV2{}.Type(ctx),
			},
			"inference_log": basetypes.ListType{
				ElemType: MonitorInferenceLog_SdkV2{}.Type(ctx),
			},
			"latest_monitor_failure_msg": types.StringType,
			"notifications": basetypes.ListType{
				ElemType: MonitorNotifications_SdkV2{}.Type(ctx),
			},
			"output_schema_name": types.StringType,
			"schedule": basetypes.ListType{
				ElemType: MonitorCronSchedule_SdkV2{}.Type(ctx),
			},
			"skip_builtin_dashboard": types.BoolType,
			"slicing_exprs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"snapshot": basetypes.ListType{
				ElemType: MonitorSnapshot_SdkV2{}.Type(ctx),
			},
			"table_name": types.StringType,
			"time_series": basetypes.ListType{
				ElemType: MonitorTimeSeries_SdkV2{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetCustomMetrics returns the value of the CustomMetrics field in CreateMonitor_SdkV2 as
// a slice of MonitorMetric_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetCustomMetrics(ctx context.Context) ([]MonitorMetric_SdkV2, bool) {
	if m.CustomMetrics.IsNull() || m.CustomMetrics.IsUnknown() {
		return nil, false
	}
	var v []MonitorMetric_SdkV2
	d := m.CustomMetrics.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomMetrics sets the value of the CustomMetrics field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetCustomMetrics(ctx context.Context, v []MonitorMetric_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["custom_metrics"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.CustomMetrics = types.ListValueMust(t, vs)
}

// GetDataClassificationConfig returns the value of the DataClassificationConfig field in CreateMonitor_SdkV2 as
// a MonitorDataClassificationConfig_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetDataClassificationConfig(ctx context.Context) (MonitorDataClassificationConfig_SdkV2, bool) {
	var e MonitorDataClassificationConfig_SdkV2
	if m.DataClassificationConfig.IsNull() || m.DataClassificationConfig.IsUnknown() {
		return e, false
	}
	var v []MonitorDataClassificationConfig_SdkV2
	d := m.DataClassificationConfig.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDataClassificationConfig sets the value of the DataClassificationConfig field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetDataClassificationConfig(ctx context.Context, v MonitorDataClassificationConfig_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["data_classification_config"]
	m.DataClassificationConfig = types.ListValueMust(t, vs)
}

// GetInferenceLog returns the value of the InferenceLog field in CreateMonitor_SdkV2 as
// a MonitorInferenceLog_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetInferenceLog(ctx context.Context) (MonitorInferenceLog_SdkV2, bool) {
	var e MonitorInferenceLog_SdkV2
	if m.InferenceLog.IsNull() || m.InferenceLog.IsUnknown() {
		return e, false
	}
	var v []MonitorInferenceLog_SdkV2
	d := m.InferenceLog.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInferenceLog sets the value of the InferenceLog field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetInferenceLog(ctx context.Context, v MonitorInferenceLog_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["inference_log"]
	m.InferenceLog = types.ListValueMust(t, vs)
}

// GetNotifications returns the value of the Notifications field in CreateMonitor_SdkV2 as
// a MonitorNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetNotifications(ctx context.Context) (MonitorNotifications_SdkV2, bool) {
	var e MonitorNotifications_SdkV2
	if m.Notifications.IsNull() || m.Notifications.IsUnknown() {
		return e, false
	}
	var v []MonitorNotifications_SdkV2
	d := m.Notifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotifications sets the value of the Notifications field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetNotifications(ctx context.Context, v MonitorNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notifications"]
	m.Notifications = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in CreateMonitor_SdkV2 as
// a MonitorCronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetSchedule(ctx context.Context) (MonitorCronSchedule_SdkV2, bool) {
	var e MonitorCronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []MonitorCronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetSchedule(ctx context.Context, v MonitorCronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetSlicingExprs returns the value of the SlicingExprs field in CreateMonitor_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetSlicingExprs(ctx context.Context) ([]types.String, bool) {
	if m.SlicingExprs.IsNull() || m.SlicingExprs.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SlicingExprs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSlicingExprs sets the value of the SlicingExprs field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetSlicingExprs(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["slicing_exprs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SlicingExprs = types.ListValueMust(t, vs)
}

// GetSnapshot returns the value of the Snapshot field in CreateMonitor_SdkV2 as
// a MonitorSnapshot_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetSnapshot(ctx context.Context) (MonitorSnapshot_SdkV2, bool) {
	var e MonitorSnapshot_SdkV2
	if m.Snapshot.IsNull() || m.Snapshot.IsUnknown() {
		return e, false
	}
	var v []MonitorSnapshot_SdkV2
	d := m.Snapshot.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSnapshot sets the value of the Snapshot field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetSnapshot(ctx context.Context, v MonitorSnapshot_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["snapshot"]
	m.Snapshot = types.ListValueMust(t, vs)
}

// GetTimeSeries returns the value of the TimeSeries field in CreateMonitor_SdkV2 as
// a MonitorTimeSeries_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateMonitor_SdkV2) GetTimeSeries(ctx context.Context) (MonitorTimeSeries_SdkV2, bool) {
	var e MonitorTimeSeries_SdkV2
	if m.TimeSeries.IsNull() || m.TimeSeries.IsUnknown() {
		return e, false
	}
	var v []MonitorTimeSeries_SdkV2
	d := m.TimeSeries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTimeSeries sets the value of the TimeSeries field in CreateMonitor_SdkV2.
func (m *CreateMonitor_SdkV2) SetTimeSeries(ctx context.Context, v MonitorTimeSeries_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["time_series"]
	m.TimeSeries = types.ListValueMust(t, vs)
}

type CreateOnlineTableRequest_SdkV2 struct {
	// Specification of the online table to be created.
	Table types.List `tfsdk:"table"`
}

func (to *CreateOnlineTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateOnlineTableRequest_SdkV2) {
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (to *CreateOnlineTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateOnlineTableRequest_SdkV2) {
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (m CreateOnlineTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table"] = attrs["table"].SetRequired()
	attrs["table"] = attrs["table"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateOnlineTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateOnlineTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"table": reflect.TypeOf(OnlineTable_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateOnlineTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateOnlineTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table": m.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateOnlineTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table": basetypes.ListType{
				ElemType: OnlineTable_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTable returns the value of the Table field in CreateOnlineTableRequest_SdkV2 as
// a OnlineTable_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateOnlineTableRequest_SdkV2) GetTable(ctx context.Context) (OnlineTable_SdkV2, bool) {
	var e OnlineTable_SdkV2
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v []OnlineTable_SdkV2
	d := m.Table.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTable sets the value of the Table field in CreateOnlineTableRequest_SdkV2.
func (m *CreateOnlineTableRequest_SdkV2) SetTable(ctx context.Context, v OnlineTable_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table"]
	m.Table = types.ListValueMust(t, vs)
}

type CreatePolicyRequest_SdkV2 struct {
	// Required. The policy to create.
	PolicyInfo types.List `tfsdk:"policy_info"`
}

func (to *CreatePolicyRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreatePolicyRequest_SdkV2) {
	if !from.PolicyInfo.IsNull() && !from.PolicyInfo.IsUnknown() {
		if toPolicyInfo, ok := to.GetPolicyInfo(ctx); ok {
			if fromPolicyInfo, ok := from.GetPolicyInfo(ctx); ok {
				// Recursively sync the fields of PolicyInfo
				toPolicyInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPolicyInfo)
				to.SetPolicyInfo(ctx, toPolicyInfo)
			}
		}
	}
}

func (to *CreatePolicyRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreatePolicyRequest_SdkV2) {
	if !from.PolicyInfo.IsNull() && !from.PolicyInfo.IsUnknown() {
		if toPolicyInfo, ok := to.GetPolicyInfo(ctx); ok {
			if fromPolicyInfo, ok := from.GetPolicyInfo(ctx); ok {
				toPolicyInfo.SyncFieldsDuringRead(ctx, fromPolicyInfo)
				to.SetPolicyInfo(ctx, toPolicyInfo)
			}
		}
	}
}

func (m CreatePolicyRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["policy_info"] = attrs["policy_info"].SetRequired()
	attrs["policy_info"] = attrs["policy_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreatePolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreatePolicyRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"policy_info": reflect.TypeOf(PolicyInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreatePolicyRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreatePolicyRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"policy_info": m.PolicyInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreatePolicyRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"policy_info": basetypes.ListType{
				ElemType: PolicyInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPolicyInfo returns the value of the PolicyInfo field in CreatePolicyRequest_SdkV2 as
// a PolicyInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreatePolicyRequest_SdkV2) GetPolicyInfo(ctx context.Context) (PolicyInfo_SdkV2, bool) {
	var e PolicyInfo_SdkV2
	if m.PolicyInfo.IsNull() || m.PolicyInfo.IsUnknown() {
		return e, false
	}
	var v []PolicyInfo_SdkV2
	d := m.PolicyInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPolicyInfo sets the value of the PolicyInfo field in CreatePolicyRequest_SdkV2.
func (m *CreatePolicyRequest_SdkV2) SetPolicyInfo(ctx context.Context, v PolicyInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["policy_info"]
	m.PolicyInfo = types.ListValueMust(t, vs)
}

type CreateRegisteredModelRequest_SdkV2 struct {
	// List of aliases associated with the registered model
	Aliases types.List `tfsdk:"aliases"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog where the schema and the registered model reside
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the registered model
	Comment types.String `tfsdk:"comment"`
	// Creation timestamp of the registered model in milliseconds since the Unix
	// epoch
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the registered model
	CreatedBy types.String `tfsdk:"created_by"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the metastore
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the registered model
	Name types.String `tfsdk:"name"`
	// The identifier of the user who owns the registered model
	Owner types.String `tfsdk:"owner"`
	// The name of the schema where the registered model resides
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`
	// Last-update timestamp of the registered model in milliseconds since the
	// Unix epoch
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the registered model last time
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *CreateRegisteredModelRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateRegisteredModelRequest_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
}

func (to *CreateRegisteredModelRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateRegisteredModelRequest_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
}

func (m CreateRegisteredModelRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateRegisteredModelRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases": reflect.TypeOf(RegisteredModelAlias_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateRegisteredModelRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateRegisteredModelRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":          m.Aliases,
			"browse_only":      m.BrowseOnly,
			"catalog_name":     m.CatalogName,
			"comment":          m.Comment,
			"created_at":       m.CreatedAt,
			"created_by":       m.CreatedBy,
			"full_name":        m.FullName,
			"metastore_id":     m.MetastoreId,
			"name":             m.Name,
			"owner":            m.Owner,
			"schema_name":      m.SchemaName,
			"storage_location": m.StorageLocation,
			"updated_at":       m.UpdatedAt,
			"updated_by":       m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateRegisteredModelRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias_SdkV2{}.Type(ctx),
			},
			"browse_only":      types.BoolType,
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"created_at":       types.Int64Type,
			"created_by":       types.StringType,
			"full_name":        types.StringType,
			"metastore_id":     types.StringType,
			"name":             types.StringType,
			"owner":            types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetAliases returns the value of the Aliases field in CreateRegisteredModelRequest_SdkV2 as
// a slice of RegisteredModelAlias_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateRegisteredModelRequest_SdkV2) GetAliases(ctx context.Context) ([]RegisteredModelAlias_SdkV2, bool) {
	if m.Aliases.IsNull() || m.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias_SdkV2
	d := m.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in CreateRegisteredModelRequest_SdkV2.
func (m *CreateRegisteredModelRequest_SdkV2) SetAliases(ctx context.Context, v []RegisteredModelAlias_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Aliases = types.ListValueMust(t, vs)
}

type CreateRequestExternalLineage_SdkV2 struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.List `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.List `tfsdk:"target"`
}

func (to *CreateRequestExternalLineage_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateRequestExternalLineage_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				// Recursively sync the fields of Source
				toSource.SyncFieldsDuringCreateOrUpdate(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				// Recursively sync the fields of Target
				toTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (to *CreateRequestExternalLineage_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateRequestExternalLineage_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				toSource.SyncFieldsDuringRead(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				toTarget.SyncFieldsDuringRead(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (m CreateRequestExternalLineage_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["source"] = attrs["source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["target"] = attrs["target"].SetRequired()
	attrs["target"] = attrs["target"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateRequestExternalLineage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateRequestExternalLineage_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship_SdkV2{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
		"target":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateRequestExternalLineage_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateRequestExternalLineage_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    m.Columns,
			"id":         m.Id,
			"properties": m.Properties,
			"source":     m.Source,
			"target":     m.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateRequestExternalLineage_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship_SdkV2{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
			"target": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetColumns returns the value of the Columns field in CreateRequestExternalLineage_SdkV2 as
// a slice of ColumnRelationship_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateRequestExternalLineage_SdkV2) GetColumns(ctx context.Context) ([]ColumnRelationship_SdkV2, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship_SdkV2
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in CreateRequestExternalLineage_SdkV2.
func (m *CreateRequestExternalLineage_SdkV2) SetColumns(ctx context.Context, v []ColumnRelationship_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateRequestExternalLineage_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateRequestExternalLineage_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateRequestExternalLineage_SdkV2.
func (m *CreateRequestExternalLineage_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in CreateRequestExternalLineage_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateRequestExternalLineage_SdkV2) GetSource(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Source.IsNull() || m.Source.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Source.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSource sets the value of the Source field in CreateRequestExternalLineage_SdkV2.
func (m *CreateRequestExternalLineage_SdkV2) SetSource(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["source"]
	m.Source = types.ListValueMust(t, vs)
}

// GetTarget returns the value of the Target field in CreateRequestExternalLineage_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateRequestExternalLineage_SdkV2) GetTarget(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Target.IsNull() || m.Target.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Target.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTarget sets the value of the Target field in CreateRequestExternalLineage_SdkV2.
func (m *CreateRequestExternalLineage_SdkV2) SetTarget(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["target"]
	m.Target = types.ListValueMust(t, vs)
}

type CreateSchema_SdkV2 struct {
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of schema, relative to parent catalog.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// Storage root URL for managed tables within schema.
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (to *CreateSchema_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateSchema_SdkV2) {
}

func (to *CreateSchema_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateSchema_SdkV2) {
}

func (m CreateSchema_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateSchema.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateSchema_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateSchema_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateSchema_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name": m.CatalogName,
			"comment":      m.Comment,
			"name":         m.Name,
			"properties":   m.Properties,
			"storage_root": m.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateSchema_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"comment":      types.StringType,
			"name":         types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"storage_root": types.StringType,
		},
	}
}

// GetProperties returns the value of the Properties field in CreateSchema_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateSchema_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateSchema_SdkV2.
func (m *CreateSchema_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

type CreateStorageCredential_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.List `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Supplying true to this argument skips validation of the created
	// credential.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (to *CreateStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				// Recursively sync the fields of CloudflareApiToken
				toCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *CreateStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				toCloudflareApiToken.SyncFieldsDuringRead(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m CreateStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].SetRequired()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityRequest_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"cloudflare_api_token":           m.CloudflareApiToken,
			"comment":                        m.Comment,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"name":                           m.Name,
			"read_only":                      m.ReadOnly,
			"skip_validation":                m.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRoleRequest_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentityRequest_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"cloudflare_api_token": basetypes.ListType{
				ElemType: CloudflareApiToken_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccountRequest_SdkV2{}.Type(ctx),
			},
			"name":            types.StringType,
			"read_only":       types.BoolType,
			"skip_validation": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CreateStorageCredential_SdkV2 as
// a AwsIamRoleRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateStorageCredential_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest_SdkV2, bool) {
	var e AwsIamRoleRequest_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRoleRequest_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CreateStorageCredential_SdkV2.
func (m *CreateStorageCredential_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CreateStorageCredential_SdkV2 as
// a AzureManagedIdentityRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateStorageCredential_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityRequest_SdkV2, bool) {
	var e AzureManagedIdentityRequest_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentityRequest_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CreateStorageCredential_SdkV2.
func (m *CreateStorageCredential_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CreateStorageCredential_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateStorageCredential_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CreateStorageCredential_SdkV2.
func (m *CreateStorageCredential_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in CreateStorageCredential_SdkV2 as
// a CloudflareApiToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateStorageCredential_SdkV2) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken_SdkV2, bool) {
	var e CloudflareApiToken_SdkV2
	if m.CloudflareApiToken.IsNull() || m.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v []CloudflareApiToken_SdkV2
	d := m.CloudflareApiToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in CreateStorageCredential_SdkV2.
func (m *CreateStorageCredential_SdkV2) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cloudflare_api_token"]
	m.CloudflareApiToken = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CreateStorageCredential_SdkV2 as
// a DatabricksGcpServiceAccountRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateStorageCredential_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest_SdkV2, bool) {
	var e DatabricksGcpServiceAccountRequest_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccountRequest_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CreateStorageCredential_SdkV2.
func (m *CreateStorageCredential_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type CreateTableConstraint_SdkV2 struct {
	Constraint types.List `tfsdk:"constraint"`
	// The full name of the table referenced by the constraint.
	FullNameArg types.String `tfsdk:"full_name_arg"`
}

func (to *CreateTableConstraint_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateTableConstraint_SdkV2) {
	if !from.Constraint.IsNull() && !from.Constraint.IsUnknown() {
		if toConstraint, ok := to.GetConstraint(ctx); ok {
			if fromConstraint, ok := from.GetConstraint(ctx); ok {
				// Recursively sync the fields of Constraint
				toConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromConstraint)
				to.SetConstraint(ctx, toConstraint)
			}
		}
	}
}

func (to *CreateTableConstraint_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateTableConstraint_SdkV2) {
	if !from.Constraint.IsNull() && !from.Constraint.IsUnknown() {
		if toConstraint, ok := to.GetConstraint(ctx); ok {
			if fromConstraint, ok := from.GetConstraint(ctx); ok {
				toConstraint.SyncFieldsDuringRead(ctx, fromConstraint)
				to.SetConstraint(ctx, toConstraint)
			}
		}
	}
}

func (m CreateTableConstraint_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["constraint"] = attrs["constraint"].SetRequired()
	attrs["constraint"] = attrs["constraint"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["full_name_arg"] = attrs["full_name_arg"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateTableConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateTableConstraint_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"constraint": reflect.TypeOf(TableConstraint_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateTableConstraint_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateTableConstraint_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"constraint":    m.Constraint,
			"full_name_arg": m.FullNameArg,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateTableConstraint_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"constraint": basetypes.ListType{
				ElemType: TableConstraint_SdkV2{}.Type(ctx),
			},
			"full_name_arg": types.StringType,
		},
	}
}

// GetConstraint returns the value of the Constraint field in CreateTableConstraint_SdkV2 as
// a TableConstraint_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateTableConstraint_SdkV2) GetConstraint(ctx context.Context) (TableConstraint_SdkV2, bool) {
	var e TableConstraint_SdkV2
	if m.Constraint.IsNull() || m.Constraint.IsUnknown() {
		return e, false
	}
	var v []TableConstraint_SdkV2
	d := m.Constraint.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetConstraint sets the value of the Constraint field in CreateTableConstraint_SdkV2.
func (m *CreateTableConstraint_SdkV2) SetConstraint(ctx context.Context, v TableConstraint_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["constraint"]
	m.Constraint = types.ListValueMust(t, vs)
}

type CreateTableRequest_SdkV2 struct {
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// The array of __ColumnInfo__ definitions of the table's columns.
	Columns types.List `tfsdk:"columns"`

	DataSourceFormat types.String `tfsdk:"data_source_format"`
	// Name of table, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// Name of parent schema relative to its parent catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// Storage root URL for table (for **MANAGED**, **EXTERNAL** tables).
	StorageLocation types.String `tfsdk:"storage_location"`

	TableType types.String `tfsdk:"table_type"`
}

func (to *CreateTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateTableRequest_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
}

func (to *CreateTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateTableRequest_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
}

func (m CreateTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["data_source_format"] = attrs["data_source_format"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["storage_location"] = attrs["storage_location"].SetRequired()
	attrs["table_type"] = attrs["table_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnInfo_SdkV2{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":       m.CatalogName,
			"columns":            m.Columns,
			"data_source_format": m.DataSourceFormat,
			"name":               m.Name,
			"properties":         m.Properties,
			"schema_name":        m.SchemaName,
			"storage_location":   m.StorageLocation,
			"table_type":         m.TableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"columns": basetypes.ListType{
				ElemType: ColumnInfo_SdkV2{}.Type(ctx),
			},
			"data_source_format": types.StringType,
			"name":               types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"table_type":       types.StringType,
		},
	}
}

// GetColumns returns the value of the Columns field in CreateTableRequest_SdkV2 as
// a slice of ColumnInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateTableRequest_SdkV2) GetColumns(ctx context.Context) ([]ColumnInfo_SdkV2, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnInfo_SdkV2
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in CreateTableRequest_SdkV2.
func (m *CreateTableRequest_SdkV2) SetColumns(ctx context.Context, v []ColumnInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateTableRequest_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateTableRequest_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateTableRequest_SdkV2.
func (m *CreateTableRequest_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

type CreateVolumeRequestContent_SdkV2 struct {
	// The name of the catalog where the schema and the volume are
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the volume
	Comment types.String `tfsdk:"comment"`
	// The name of the volume
	Name types.String `tfsdk:"name"`
	// The name of the schema where the volume is
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud
	StorageLocation types.String `tfsdk:"storage_location"`
	// The type of the volume. An external volume is located in the specified
	// external location. A managed volume is located in the default location
	// which is specified by the parent schema, or the parent catalog, or the
	// Metastore. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/aws/en/volumes/managed-vs-external
	VolumeType types.String `tfsdk:"volume_type"`
}

func (to *CreateVolumeRequestContent_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateVolumeRequestContent_SdkV2) {
}

func (to *CreateVolumeRequestContent_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateVolumeRequestContent_SdkV2) {
}

func (m CreateVolumeRequestContent_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["volume_type"] = attrs["volume_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateVolumeRequestContent.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateVolumeRequestContent_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateVolumeRequestContent_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateVolumeRequestContent_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":     m.CatalogName,
			"comment":          m.Comment,
			"name":             m.Name,
			"schema_name":      m.SchemaName,
			"storage_location": m.StorageLocation,
			"volume_type":      m.VolumeType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateVolumeRequestContent_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"name":             types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"volume_type":      types.StringType,
		},
	}
}

// A credential that is dependent on a SQL object.
type CredentialDependency_SdkV2 struct {
	// Full name of the dependent credential, in the form of
	// __credential_name__.
	CredentialName types.String `tfsdk:"credential_name"`
}

func (to *CredentialDependency_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CredentialDependency_SdkV2) {
}

func (to *CredentialDependency_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CredentialDependency_SdkV2) {
}

func (m CredentialDependency_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_name"] = attrs["credential_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CredentialDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CredentialDependency_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CredentialDependency_SdkV2
// only implements ToObjectValue() and Type().
func (m CredentialDependency_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_name": m.CredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CredentialDependency_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_name": types.StringType,
		},
	}
}

type CredentialInfo_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// Time at which this credential was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of credential creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The full name of the credential.
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the credential.
	Id types.String `tfsdk:"id"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of the parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Indicates the purpose of the credential.
	Purpose types.String `tfsdk:"purpose"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Time at which this credential was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the credential.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Whether this credential is the current metastore's root storage
	// credential. Only applicable when purpose is **STORAGE**.
	UsedForManagedStorage types.Bool `tfsdk:"used_for_managed_storage"`
}

func (to *CredentialInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CredentialInfo_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *CredentialInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CredentialInfo_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m CredentialInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["purpose"] = attrs["purpose"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["used_for_managed_storage"] = attrs["used_for_managed_storage"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CredentialInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CredentialInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m CredentialInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"comment":                        m.Comment,
			"created_at":                     m.CreatedAt,
			"created_by":                     m.CreatedBy,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"full_name":                      m.FullName,
			"id":                             m.Id,
			"isolation_mode":                 m.IsolationMode,
			"metastore_id":                   m.MetastoreId,
			"name":                           m.Name,
			"owner":                          m.Owner,
			"purpose":                        m.Purpose,
			"read_only":                      m.ReadOnly,
			"updated_at":                     m.UpdatedAt,
			"updated_by":                     m.UpdatedBy,
			"used_for_managed_storage":       m.UsedForManagedStorage,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CredentialInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRole_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentity_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"comment":    types.StringType,
			"created_at": types.Int64Type,
			"created_by": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccount_SdkV2{}.Type(ctx),
			},
			"full_name":                types.StringType,
			"id":                       types.StringType,
			"isolation_mode":           types.StringType,
			"metastore_id":             types.StringType,
			"name":                     types.StringType,
			"owner":                    types.StringType,
			"purpose":                  types.StringType,
			"read_only":                types.BoolType,
			"updated_at":               types.Int64Type,
			"updated_by":               types.StringType,
			"used_for_managed_storage": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CredentialInfo_SdkV2 as
// a AwsIamRole_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CredentialInfo_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRole_SdkV2, bool) {
	var e AwsIamRole_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRole_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CredentialInfo_SdkV2.
func (m *CredentialInfo_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRole_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CredentialInfo_SdkV2 as
// a AzureManagedIdentity_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CredentialInfo_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity_SdkV2, bool) {
	var e AzureManagedIdentity_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentity_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CredentialInfo_SdkV2.
func (m *CredentialInfo_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CredentialInfo_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CredentialInfo_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CredentialInfo_SdkV2.
func (m *CredentialInfo_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CredentialInfo_SdkV2 as
// a DatabricksGcpServiceAccount_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CredentialInfo_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount_SdkV2, bool) {
	var e DatabricksGcpServiceAccount_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccount_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CredentialInfo_SdkV2.
func (m *CredentialInfo_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type CredentialValidationResult_SdkV2 struct {
	// Error message would exist when the result does not equal to **PASS**.
	Message types.String `tfsdk:"message"`
	// The results of the tested operation.
	Result types.String `tfsdk:"result"`
}

func (to *CredentialValidationResult_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CredentialValidationResult_SdkV2) {
}

func (to *CredentialValidationResult_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CredentialValidationResult_SdkV2) {
}

func (m CredentialValidationResult_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetOptional()
	attrs["result"] = attrs["result"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CredentialValidationResult.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CredentialValidationResult_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CredentialValidationResult_SdkV2
// only implements ToObjectValue() and Type().
func (m CredentialValidationResult_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message": m.Message,
			"result":  m.Result,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CredentialValidationResult_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message": types.StringType,
			"result":  types.StringType,
		},
	}
}

type CurrentRequest_SdkV2 struct {
}

func (to *CurrentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CurrentRequest_SdkV2) {
}

func (to *CurrentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CurrentRequest_SdkV2) {
}

func (m CurrentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CurrentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CurrentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CurrentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CurrentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m CurrentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// GCP long-lived credential. Databricks-created Google Cloud Storage service
// account.
type DatabricksGcpServiceAccount_SdkV2 struct {
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The email of the service account.
	Email types.String `tfsdk:"email"`
	// The ID that represents the private key for this Service Account
	PrivateKeyId types.String `tfsdk:"private_key_id"`
}

func (to *DatabricksGcpServiceAccount_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DatabricksGcpServiceAccount_SdkV2) {
}

func (to *DatabricksGcpServiceAccount_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DatabricksGcpServiceAccount_SdkV2) {
}

func (m DatabricksGcpServiceAccount_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["email"] = attrs["email"].SetComputed()
	attrs["private_key_id"] = attrs["private_key_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DatabricksGcpServiceAccount.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DatabricksGcpServiceAccount_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DatabricksGcpServiceAccount_SdkV2
// only implements ToObjectValue() and Type().
func (m DatabricksGcpServiceAccount_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_id":  m.CredentialId,
			"email":          m.Email,
			"private_key_id": m.PrivateKeyId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DatabricksGcpServiceAccount_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_id":  types.StringType,
			"email":          types.StringType,
			"private_key_id": types.StringType,
		},
	}
}

// GCP long-lived credential. Databricks-created Google Cloud Storage service
// account.
type DatabricksGcpServiceAccountRequest_SdkV2 struct {
}

func (to *DatabricksGcpServiceAccountRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DatabricksGcpServiceAccountRequest_SdkV2) {
}

func (to *DatabricksGcpServiceAccountRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DatabricksGcpServiceAccountRequest_SdkV2) {
}

func (m DatabricksGcpServiceAccountRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DatabricksGcpServiceAccountRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DatabricksGcpServiceAccountRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DatabricksGcpServiceAccountRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DatabricksGcpServiceAccountRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DatabricksGcpServiceAccountRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// GCP long-lived credential. Databricks-created Google Cloud Storage service
// account.
type DatabricksGcpServiceAccountResponse_SdkV2 struct {
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The email of the service account.
	Email types.String `tfsdk:"email"`
}

func (to *DatabricksGcpServiceAccountResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DatabricksGcpServiceAccountResponse_SdkV2) {
}

func (to *DatabricksGcpServiceAccountResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DatabricksGcpServiceAccountResponse_SdkV2) {
}

func (m DatabricksGcpServiceAccountResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["email"] = attrs["email"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DatabricksGcpServiceAccountResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DatabricksGcpServiceAccountResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DatabricksGcpServiceAccountResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DatabricksGcpServiceAccountResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_id": m.CredentialId,
			"email":         m.Email,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DatabricksGcpServiceAccountResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_id": types.StringType,
			"email":         types.StringType,
		},
	}
}

type DeleteAccountMetastoreAssignmentRequest_SdkV2 struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *DeleteAccountMetastoreAssignmentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAccountMetastoreAssignmentRequest_SdkV2) {
}

func (to *DeleteAccountMetastoreAssignmentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteAccountMetastoreAssignmentRequest_SdkV2) {
}

func (m DeleteAccountMetastoreAssignmentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountMetastoreAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteAccountMetastoreAssignmentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountMetastoreAssignmentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteAccountMetastoreAssignmentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": m.MetastoreId,
			"workspace_id": m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteAccountMetastoreAssignmentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}

type DeleteAccountMetastoreRequest_SdkV2 struct {
	// Force deletion even if the metastore is not empty. Default is false.
	Force types.Bool `tfsdk:"-"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (to *DeleteAccountMetastoreRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAccountMetastoreRequest_SdkV2) {
}

func (to *DeleteAccountMetastoreRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteAccountMetastoreRequest_SdkV2) {
}

func (m DeleteAccountMetastoreRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteAccountMetastoreRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountMetastoreRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteAccountMetastoreRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":        m.Force,
			"metastore_id": m.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteAccountMetastoreRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":        types.BoolType,
			"metastore_id": types.StringType,
		},
	}
}

type DeleteAccountStorageCredentialRequest_SdkV2 struct {
	// Force deletion even if the Storage Credential is not empty. Default is
	// false.
	Force types.Bool `tfsdk:"-"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Name of the storage credential.
	StorageCredentialName types.String `tfsdk:"-"`
}

func (to *DeleteAccountStorageCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAccountStorageCredentialRequest_SdkV2) {
}

func (to *DeleteAccountStorageCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteAccountStorageCredentialRequest_SdkV2) {
}

func (m DeleteAccountStorageCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteAccountStorageCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountStorageCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteAccountStorageCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":                   m.Force,
			"metastore_id":            m.MetastoreId,
			"storage_credential_name": m.StorageCredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteAccountStorageCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":                   types.BoolType,
			"metastore_id":            types.StringType,
			"storage_credential_name": types.StringType,
		},
	}
}

type DeleteAliasRequest_SdkV2 struct {
	// The name of the alias
	Alias types.String `tfsdk:"-"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
}

func (to *DeleteAliasRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAliasRequest_SdkV2) {
}

func (to *DeleteAliasRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteAliasRequest_SdkV2) {
}

func (m DeleteAliasRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["alias"] = attrs["alias"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAliasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteAliasRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAliasRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteAliasRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":     m.Alias,
			"full_name": m.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteAliasRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":     types.StringType,
			"full_name": types.StringType,
		},
	}
}

type DeleteCatalogRequest_SdkV2 struct {
	// Force deletion even if the catalog is not empty.
	Force types.Bool `tfsdk:"-"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
}

func (to *DeleteCatalogRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteCatalogRequest_SdkV2) {
}

func (to *DeleteCatalogRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteCatalogRequest_SdkV2) {
}

func (m DeleteCatalogRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCatalogRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteCatalogRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCatalogRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteCatalogRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": m.Force,
			"name":  m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteCatalogRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteConnectionRequest_SdkV2 struct {
	// The name of the connection to be deleted.
	Name types.String `tfsdk:"-"`
}

func (to *DeleteConnectionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteConnectionRequest_SdkV2) {
}

func (to *DeleteConnectionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteConnectionRequest_SdkV2) {
}

func (m DeleteConnectionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteConnectionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteConnectionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteConnectionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteConnectionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteConnectionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type DeleteCredentialRequest_SdkV2 struct {
	// Force an update even if there are dependent services (when purpose is
	// **SERVICE**) or dependent external locations and external tables (when
	// purpose is **STORAGE**).
	Force types.Bool `tfsdk:"-"`
	// Name of the credential.
	NameArg types.String `tfsdk:"-"`
}

func (to *DeleteCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteCredentialRequest_SdkV2) {
}

func (to *DeleteCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteCredentialRequest_SdkV2) {
}

func (m DeleteCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name_arg"] = attrs["name_arg"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":    m.Force,
			"name_arg": m.NameArg,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":    types.BoolType,
			"name_arg": types.StringType,
		},
	}
}

type DeleteCredentialResponse_SdkV2 struct {
}

func (to *DeleteCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteCredentialResponse_SdkV2) {
}

func (to *DeleteCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteCredentialResponse_SdkV2) {
}

func (m DeleteCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteEntityTagAssignmentRequest_SdkV2 struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`
	// Required. The key of the tag to delete
	TagKey types.String `tfsdk:"-"`
}

func (to *DeleteEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteEntityTagAssignmentRequest_SdkV2) {
}

func (to *DeleteEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteEntityTagAssignmentRequest_SdkV2) {
}

func (m DeleteEntityTagAssignmentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteEntityTagAssignmentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteEntityTagAssignmentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteEntityTagAssignmentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": m.EntityName,
			"entity_type": m.EntityType,
			"tag_key":     m.TagKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteEntityTagAssignmentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_key":     types.StringType,
		},
	}
}

type DeleteExternalLineageRelationshipRequest_SdkV2 struct {
	ExternalLineageRelationship types.List `tfsdk:"-"`
}

func (to *DeleteExternalLineageRelationshipRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteExternalLineageRelationshipRequest_SdkV2) {
	if !from.ExternalLineageRelationship.IsNull() && !from.ExternalLineageRelationship.IsUnknown() {
		if toExternalLineageRelationship, ok := to.GetExternalLineageRelationship(ctx); ok {
			if fromExternalLineageRelationship, ok := from.GetExternalLineageRelationship(ctx); ok {
				// Recursively sync the fields of ExternalLineageRelationship
				toExternalLineageRelationship.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalLineageRelationship)
				to.SetExternalLineageRelationship(ctx, toExternalLineageRelationship)
			}
		}
	}
}

func (to *DeleteExternalLineageRelationshipRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteExternalLineageRelationshipRequest_SdkV2) {
	if !from.ExternalLineageRelationship.IsNull() && !from.ExternalLineageRelationship.IsUnknown() {
		if toExternalLineageRelationship, ok := to.GetExternalLineageRelationship(ctx); ok {
			if fromExternalLineageRelationship, ok := from.GetExternalLineageRelationship(ctx); ok {
				toExternalLineageRelationship.SyncFieldsDuringRead(ctx, fromExternalLineageRelationship)
				to.SetExternalLineageRelationship(ctx, toExternalLineageRelationship)
			}
		}
	}
}

func (m DeleteExternalLineageRelationshipRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].SetRequired()
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteExternalLineageRelationshipRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteExternalLineageRelationshipRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationship": reflect.TypeOf(DeleteRequestExternalLineage_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteExternalLineageRelationshipRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteExternalLineageRelationshipRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationship": m.ExternalLineageRelationship,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteExternalLineageRelationshipRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationship": basetypes.ListType{
				ElemType: DeleteRequestExternalLineage_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetExternalLineageRelationship returns the value of the ExternalLineageRelationship field in DeleteExternalLineageRelationshipRequest_SdkV2 as
// a DeleteRequestExternalLineage_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *DeleteExternalLineageRelationshipRequest_SdkV2) GetExternalLineageRelationship(ctx context.Context) (DeleteRequestExternalLineage_SdkV2, bool) {
	var e DeleteRequestExternalLineage_SdkV2
	if m.ExternalLineageRelationship.IsNull() || m.ExternalLineageRelationship.IsUnknown() {
		return e, false
	}
	var v []DeleteRequestExternalLineage_SdkV2
	d := m.ExternalLineageRelationship.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalLineageRelationship sets the value of the ExternalLineageRelationship field in DeleteExternalLineageRelationshipRequest_SdkV2.
func (m *DeleteExternalLineageRelationshipRequest_SdkV2) SetExternalLineageRelationship(ctx context.Context, v DeleteRequestExternalLineage_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_lineage_relationship"]
	m.ExternalLineageRelationship = types.ListValueMust(t, vs)
}

type DeleteExternalLocationRequest_SdkV2 struct {
	// Force deletion even if there are dependent external tables or mounts.
	Force types.Bool `tfsdk:"-"`
	// Name of the external location.
	Name types.String `tfsdk:"-"`
}

func (to *DeleteExternalLocationRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteExternalLocationRequest_SdkV2) {
}

func (to *DeleteExternalLocationRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteExternalLocationRequest_SdkV2) {
}

func (m DeleteExternalLocationRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteExternalLocationRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteExternalLocationRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteExternalLocationRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteExternalLocationRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": m.Force,
			"name":  m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteExternalLocationRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteExternalMetadataRequest_SdkV2 struct {
	Name types.String `tfsdk:"-"`
}

func (to *DeleteExternalMetadataRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteExternalMetadataRequest_SdkV2) {
}

func (to *DeleteExternalMetadataRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteExternalMetadataRequest_SdkV2) {
}

func (m DeleteExternalMetadataRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteExternalMetadataRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteExternalMetadataRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteExternalMetadataRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteExternalMetadataRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type DeleteFunctionRequest_SdkV2 struct {
	// Force deletion even if the function is notempty.
	Force types.Bool `tfsdk:"-"`
	// The fully-qualified name of the function (of the form
	// __catalog_name__.__schema_name__.__function__name__) .
	Name types.String `tfsdk:"-"`
}

func (to *DeleteFunctionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteFunctionRequest_SdkV2) {
}

func (to *DeleteFunctionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteFunctionRequest_SdkV2) {
}

func (m DeleteFunctionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteFunctionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteFunctionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteFunctionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteFunctionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": m.Force,
			"name":  m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteFunctionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteMetastoreRequest_SdkV2 struct {
	// Force deletion even if the metastore is not empty. Default is false.
	Force types.Bool `tfsdk:"-"`
	// Unique ID of the metastore.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteMetastoreRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteMetastoreRequest_SdkV2) {
}

func (to *DeleteMetastoreRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteMetastoreRequest_SdkV2) {
}

func (m DeleteMetastoreRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteMetastoreRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteMetastoreRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteMetastoreRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": m.Force,
			"id":    m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteMetastoreRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"id":    types.StringType,
		},
	}
}

type DeleteModelVersionRequest_SdkV2 struct {
	// The three-level (fully qualified) name of the model version
	FullName types.String `tfsdk:"-"`
	// The integer version number of the model version
	Version types.Int64 `tfsdk:"-"`
}

func (to *DeleteModelVersionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteModelVersionRequest_SdkV2) {
}

func (to *DeleteModelVersionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteModelVersionRequest_SdkV2) {
}

func (m DeleteModelVersionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version"] = attrs["version"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteModelVersionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteModelVersionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteModelVersionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteModelVersionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": m.FullName,
			"version":   m.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteModelVersionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
			"version":   types.Int64Type,
		},
	}
}

type DeleteMonitorResponse_SdkV2 struct {
}

func (to *DeleteMonitorResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteMonitorResponse_SdkV2) {
}

func (to *DeleteMonitorResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteMonitorResponse_SdkV2) {
}

func (m DeleteMonitorResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteMonitorResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteMonitorResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteMonitorResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteMonitorResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteMonitorResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteOnlineTableRequest_SdkV2 struct {
	// Full three-part (catalog, schema, table) name of the table.
	Name types.String `tfsdk:"-"`
}

func (to *DeleteOnlineTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteOnlineTableRequest_SdkV2) {
}

func (to *DeleteOnlineTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteOnlineTableRequest_SdkV2) {
}

func (m DeleteOnlineTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteOnlineTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteOnlineTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteOnlineTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteOnlineTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteOnlineTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type DeletePolicyRequest_SdkV2 struct {
	// Required. The name of the policy to delete
	Name types.String `tfsdk:"-"`
	// Required. The fully qualified name of the securable to delete the policy
	// from.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to delete the policy from.
	OnSecurableType types.String `tfsdk:"-"`
}

func (to *DeletePolicyRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeletePolicyRequest_SdkV2) {
}

func (to *DeletePolicyRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeletePolicyRequest_SdkV2) {
}

func (m DeletePolicyRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeletePolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeletePolicyRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeletePolicyRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeletePolicyRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                  m.Name,
			"on_securable_fullname": m.OnSecurableFullname,
			"on_securable_type":     m.OnSecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeletePolicyRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
		},
	}
}

type DeletePolicyResponse_SdkV2 struct {
}

func (to *DeletePolicyResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeletePolicyResponse_SdkV2) {
}

func (to *DeletePolicyResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeletePolicyResponse_SdkV2) {
}

func (m DeletePolicyResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeletePolicyResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeletePolicyResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeletePolicyResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DeletePolicyResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DeletePolicyResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteQualityMonitorRequest_SdkV2 struct {
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
}

func (to *DeleteQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteQualityMonitorRequest_SdkV2) {
}

func (to *DeleteQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteQualityMonitorRequest_SdkV2) {
}

func (m DeleteQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

type DeleteRegisteredModelRequest_SdkV2 struct {
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
}

func (to *DeleteRegisteredModelRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteRegisteredModelRequest_SdkV2) {
}

func (to *DeleteRegisteredModelRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteRegisteredModelRequest_SdkV2) {
}

func (m DeleteRegisteredModelRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteRegisteredModelRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteRegisteredModelRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteRegisteredModelRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": m.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteRegisteredModelRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
		},
	}
}

type DeleteRequestExternalLineage_SdkV2 struct {
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Source object of the external lineage relationship.
	Source types.List `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.List `tfsdk:"target"`
}

func (to *DeleteRequestExternalLineage_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteRequestExternalLineage_SdkV2) {
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				// Recursively sync the fields of Source
				toSource.SyncFieldsDuringCreateOrUpdate(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				// Recursively sync the fields of Target
				toTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (to *DeleteRequestExternalLineage_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteRequestExternalLineage_SdkV2) {
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				toSource.SyncFieldsDuringRead(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				toTarget.SyncFieldsDuringRead(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (m DeleteRequestExternalLineage_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetComputed()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["source"] = attrs["source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["target"] = attrs["target"].SetRequired()
	attrs["target"] = attrs["target"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteRequestExternalLineage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteRequestExternalLineage_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"source": reflect.TypeOf(ExternalLineageObject_SdkV2{}),
		"target": reflect.TypeOf(ExternalLineageObject_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteRequestExternalLineage_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteRequestExternalLineage_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":     m.Id,
			"source": m.Source,
			"target": m.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteRequestExternalLineage_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"source": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
			"target": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSource returns the value of the Source field in DeleteRequestExternalLineage_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *DeleteRequestExternalLineage_SdkV2) GetSource(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Source.IsNull() || m.Source.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Source.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSource sets the value of the Source field in DeleteRequestExternalLineage_SdkV2.
func (m *DeleteRequestExternalLineage_SdkV2) SetSource(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["source"]
	m.Source = types.ListValueMust(t, vs)
}

// GetTarget returns the value of the Target field in DeleteRequestExternalLineage_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *DeleteRequestExternalLineage_SdkV2) GetTarget(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Target.IsNull() || m.Target.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Target.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTarget sets the value of the Target field in DeleteRequestExternalLineage_SdkV2.
func (m *DeleteRequestExternalLineage_SdkV2) SetTarget(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["target"]
	m.Target = types.ListValueMust(t, vs)
}

type DeleteResponse_SdkV2 struct {
}

func (to *DeleteResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteResponse_SdkV2) {
}

func (to *DeleteResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteResponse_SdkV2) {
}

func (m DeleteResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteSchemaRequest_SdkV2 struct {
	// Force deletion even if the schema is not empty.
	Force types.Bool `tfsdk:"-"`
	// Full name of the schema.
	FullName types.String `tfsdk:"-"`
}

func (to *DeleteSchemaRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteSchemaRequest_SdkV2) {
}

func (to *DeleteSchemaRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteSchemaRequest_SdkV2) {
}

func (m DeleteSchemaRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteSchemaRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteSchemaRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteSchemaRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteSchemaRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":     m.Force,
			"full_name": m.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteSchemaRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":     types.BoolType,
			"full_name": types.StringType,
		},
	}
}

type DeleteStorageCredentialRequest_SdkV2 struct {
	// Force an update even if there are dependent external locations or
	// external tables (when purpose is **STORAGE**) or dependent services (when
	// purpose is **SERVICE**).
	Force types.Bool `tfsdk:"-"`
	// Name of the storage credential.
	Name types.String `tfsdk:"-"`
}

func (to *DeleteStorageCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteStorageCredentialRequest_SdkV2) {
}

func (to *DeleteStorageCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteStorageCredentialRequest_SdkV2) {
}

func (m DeleteStorageCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteStorageCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteStorageCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteStorageCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": m.Force,
			"name":  m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteStorageCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteTableConstraintRequest_SdkV2 struct {
	// If true, try deleting all child constraints of the current constraint. If
	// false, reject this operation if the current constraint has any child
	// constraints.
	Cascade types.Bool `tfsdk:"-"`
	// The name of the constraint to delete.
	ConstraintName types.String `tfsdk:"-"`
	// Full name of the table referenced by the constraint.
	FullName types.String `tfsdk:"-"`
}

func (to *DeleteTableConstraintRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteTableConstraintRequest_SdkV2) {
}

func (to *DeleteTableConstraintRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteTableConstraintRequest_SdkV2) {
}

func (m DeleteTableConstraintRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["constraint_name"] = attrs["constraint_name"].SetRequired()
	attrs["cascade"] = attrs["cascade"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteTableConstraintRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteTableConstraintRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteTableConstraintRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteTableConstraintRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cascade":         m.Cascade,
			"constraint_name": m.ConstraintName,
			"full_name":       m.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteTableConstraintRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cascade":         types.BoolType,
			"constraint_name": types.StringType,
			"full_name":       types.StringType,
		},
	}
}

type DeleteTableConstraintResponse_SdkV2 struct {
}

func (to *DeleteTableConstraintResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteTableConstraintResponse_SdkV2) {
}

func (to *DeleteTableConstraintResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteTableConstraintResponse_SdkV2) {
}

func (m DeleteTableConstraintResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteTableConstraintResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteTableConstraintResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteTableConstraintResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteTableConstraintResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteTableConstraintResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteTableRequest_SdkV2 struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
}

func (to *DeleteTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteTableRequest_SdkV2) {
}

func (to *DeleteTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteTableRequest_SdkV2) {
}

func (m DeleteTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": m.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
		},
	}
}

type DeleteVolumeRequest_SdkV2 struct {
	// The three-level (fully qualified) name of the volume
	Name types.String `tfsdk:"-"`
}

func (to *DeleteVolumeRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteVolumeRequest_SdkV2) {
}

func (to *DeleteVolumeRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteVolumeRequest_SdkV2) {
}

func (m DeleteVolumeRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteVolumeRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteVolumeRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteVolumeRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteVolumeRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteVolumeRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

// Properties pertaining to the current state of the delta table as given by the
// commit server. This does not contain **delta.*** (input) properties in
// __TableInfo.properties__.
type DeltaRuntimePropertiesKvPairs_SdkV2 struct {
	// A map of key-value properties attached to the securable.
	DeltaRuntimeProperties types.Map `tfsdk:"delta_runtime_properties"`
}

func (to *DeltaRuntimePropertiesKvPairs_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeltaRuntimePropertiesKvPairs_SdkV2) {
}

func (to *DeltaRuntimePropertiesKvPairs_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeltaRuntimePropertiesKvPairs_SdkV2) {
}

func (m DeltaRuntimePropertiesKvPairs_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["delta_runtime_properties"] = attrs["delta_runtime_properties"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeltaRuntimePropertiesKvPairs.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeltaRuntimePropertiesKvPairs_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"delta_runtime_properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeltaRuntimePropertiesKvPairs_SdkV2
// only implements ToObjectValue() and Type().
func (m DeltaRuntimePropertiesKvPairs_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"delta_runtime_properties": m.DeltaRuntimeProperties,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeltaRuntimePropertiesKvPairs_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"delta_runtime_properties": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDeltaRuntimeProperties returns the value of the DeltaRuntimeProperties field in DeltaRuntimePropertiesKvPairs_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *DeltaRuntimePropertiesKvPairs_SdkV2) GetDeltaRuntimeProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.DeltaRuntimeProperties.IsNull() || m.DeltaRuntimeProperties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.DeltaRuntimeProperties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDeltaRuntimeProperties sets the value of the DeltaRuntimeProperties field in DeltaRuntimePropertiesKvPairs_SdkV2.
func (m *DeltaRuntimePropertiesKvPairs_SdkV2) SetDeltaRuntimeProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["delta_runtime_properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DeltaRuntimeProperties = types.MapValueMust(t, vs)
}

// A dependency of a SQL object. One of the following fields must be defined:
// __table__, __function__, __connection__, or __credential__.
type Dependency_SdkV2 struct {
	Connection types.List `tfsdk:"connection"`

	Credential types.List `tfsdk:"credential"`

	Function types.List `tfsdk:"function"`

	Table types.List `tfsdk:"table"`
}

func (to *Dependency_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Dependency_SdkV2) {
	if !from.Connection.IsNull() && !from.Connection.IsUnknown() {
		if toConnection, ok := to.GetConnection(ctx); ok {
			if fromConnection, ok := from.GetConnection(ctx); ok {
				// Recursively sync the fields of Connection
				toConnection.SyncFieldsDuringCreateOrUpdate(ctx, fromConnection)
				to.SetConnection(ctx, toConnection)
			}
		}
	}
	if !from.Credential.IsNull() && !from.Credential.IsUnknown() {
		if toCredential, ok := to.GetCredential(ctx); ok {
			if fromCredential, ok := from.GetCredential(ctx); ok {
				// Recursively sync the fields of Credential
				toCredential.SyncFieldsDuringCreateOrUpdate(ctx, fromCredential)
				to.SetCredential(ctx, toCredential)
			}
		}
	}
	if !from.Function.IsNull() && !from.Function.IsUnknown() {
		if toFunction, ok := to.GetFunction(ctx); ok {
			if fromFunction, ok := from.GetFunction(ctx); ok {
				// Recursively sync the fields of Function
				toFunction.SyncFieldsDuringCreateOrUpdate(ctx, fromFunction)
				to.SetFunction(ctx, toFunction)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (to *Dependency_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Dependency_SdkV2) {
	if !from.Connection.IsNull() && !from.Connection.IsUnknown() {
		if toConnection, ok := to.GetConnection(ctx); ok {
			if fromConnection, ok := from.GetConnection(ctx); ok {
				toConnection.SyncFieldsDuringRead(ctx, fromConnection)
				to.SetConnection(ctx, toConnection)
			}
		}
	}
	if !from.Credential.IsNull() && !from.Credential.IsUnknown() {
		if toCredential, ok := to.GetCredential(ctx); ok {
			if fromCredential, ok := from.GetCredential(ctx); ok {
				toCredential.SyncFieldsDuringRead(ctx, fromCredential)
				to.SetCredential(ctx, toCredential)
			}
		}
	}
	if !from.Function.IsNull() && !from.Function.IsUnknown() {
		if toFunction, ok := to.GetFunction(ctx); ok {
			if fromFunction, ok := from.GetFunction(ctx); ok {
				toFunction.SyncFieldsDuringRead(ctx, fromFunction)
				to.SetFunction(ctx, toFunction)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (m Dependency_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection"] = attrs["connection"].SetOptional()
	attrs["connection"] = attrs["connection"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["credential"] = attrs["credential"].SetOptional()
	attrs["credential"] = attrs["credential"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["function"] = attrs["function"].SetOptional()
	attrs["function"] = attrs["function"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table"] = attrs["table"].SetOptional()
	attrs["table"] = attrs["table"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Dependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Dependency_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"connection": reflect.TypeOf(ConnectionDependency_SdkV2{}),
		"credential": reflect.TypeOf(CredentialDependency_SdkV2{}),
		"function":   reflect.TypeOf(FunctionDependency_SdkV2{}),
		"table":      reflect.TypeOf(TableDependency_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Dependency_SdkV2
// only implements ToObjectValue() and Type().
func (m Dependency_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection": m.Connection,
			"credential": m.Credential,
			"function":   m.Function,
			"table":      m.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Dependency_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection": basetypes.ListType{
				ElemType: ConnectionDependency_SdkV2{}.Type(ctx),
			},
			"credential": basetypes.ListType{
				ElemType: CredentialDependency_SdkV2{}.Type(ctx),
			},
			"function": basetypes.ListType{
				ElemType: FunctionDependency_SdkV2{}.Type(ctx),
			},
			"table": basetypes.ListType{
				ElemType: TableDependency_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetConnection returns the value of the Connection field in Dependency_SdkV2 as
// a ConnectionDependency_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Dependency_SdkV2) GetConnection(ctx context.Context) (ConnectionDependency_SdkV2, bool) {
	var e ConnectionDependency_SdkV2
	if m.Connection.IsNull() || m.Connection.IsUnknown() {
		return e, false
	}
	var v []ConnectionDependency_SdkV2
	d := m.Connection.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetConnection sets the value of the Connection field in Dependency_SdkV2.
func (m *Dependency_SdkV2) SetConnection(ctx context.Context, v ConnectionDependency_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["connection"]
	m.Connection = types.ListValueMust(t, vs)
}

// GetCredential returns the value of the Credential field in Dependency_SdkV2 as
// a CredentialDependency_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Dependency_SdkV2) GetCredential(ctx context.Context) (CredentialDependency_SdkV2, bool) {
	var e CredentialDependency_SdkV2
	if m.Credential.IsNull() || m.Credential.IsUnknown() {
		return e, false
	}
	var v []CredentialDependency_SdkV2
	d := m.Credential.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCredential sets the value of the Credential field in Dependency_SdkV2.
func (m *Dependency_SdkV2) SetCredential(ctx context.Context, v CredentialDependency_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credential"]
	m.Credential = types.ListValueMust(t, vs)
}

// GetFunction returns the value of the Function field in Dependency_SdkV2 as
// a FunctionDependency_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Dependency_SdkV2) GetFunction(ctx context.Context) (FunctionDependency_SdkV2, bool) {
	var e FunctionDependency_SdkV2
	if m.Function.IsNull() || m.Function.IsUnknown() {
		return e, false
	}
	var v []FunctionDependency_SdkV2
	d := m.Function.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFunction sets the value of the Function field in Dependency_SdkV2.
func (m *Dependency_SdkV2) SetFunction(ctx context.Context, v FunctionDependency_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["function"]
	m.Function = types.ListValueMust(t, vs)
}

// GetTable returns the value of the Table field in Dependency_SdkV2 as
// a TableDependency_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Dependency_SdkV2) GetTable(ctx context.Context) (TableDependency_SdkV2, bool) {
	var e TableDependency_SdkV2
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v []TableDependency_SdkV2
	d := m.Table.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTable sets the value of the Table field in Dependency_SdkV2.
func (m *Dependency_SdkV2) SetTable(ctx context.Context, v TableDependency_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table"]
	m.Table = types.ListValueMust(t, vs)
}

// A list of dependencies.
type DependencyList_SdkV2 struct {
	// Array of dependencies.
	Dependencies types.List `tfsdk:"dependencies"`
}

func (to *DependencyList_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DependencyList_SdkV2) {
	if !from.Dependencies.IsNull() && !from.Dependencies.IsUnknown() && to.Dependencies.IsNull() && len(from.Dependencies.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Dependencies, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Dependencies = from.Dependencies
	}
}

func (to *DependencyList_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DependencyList_SdkV2) {
	if !from.Dependencies.IsNull() && !from.Dependencies.IsUnknown() && to.Dependencies.IsNull() && len(from.Dependencies.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Dependencies, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Dependencies = from.Dependencies
	}
}

func (m DependencyList_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dependencies"] = attrs["dependencies"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DependencyList.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DependencyList_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dependencies": reflect.TypeOf(Dependency_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DependencyList_SdkV2
// only implements ToObjectValue() and Type().
func (m DependencyList_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dependencies": m.Dependencies,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DependencyList_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dependencies": basetypes.ListType{
				ElemType: Dependency_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetDependencies returns the value of the Dependencies field in DependencyList_SdkV2 as
// a slice of Dependency_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *DependencyList_SdkV2) GetDependencies(ctx context.Context) ([]Dependency_SdkV2, bool) {
	if m.Dependencies.IsNull() || m.Dependencies.IsUnknown() {
		return nil, false
	}
	var v []Dependency_SdkV2
	d := m.Dependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependencies sets the value of the Dependencies field in DependencyList_SdkV2.
func (m *DependencyList_SdkV2) SetDependencies(ctx context.Context, v []Dependency_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dependencies"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Dependencies = types.ListValueMust(t, vs)
}

type DisableRequest_SdkV2 struct {
	// The metastore ID under which the system schema lives.
	MetastoreId types.String `tfsdk:"-"`
	// Full name of the system schema.
	SchemaName types.String `tfsdk:"-"`
}

func (to *DisableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DisableRequest_SdkV2) {
}

func (to *DisableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DisableRequest_SdkV2) {
}

func (m DisableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DisableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DisableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DisableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DisableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": m.MetastoreId,
			"schema_name":  m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DisableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"schema_name":  types.StringType,
		},
	}
}

type DisableResponse_SdkV2 struct {
}

func (to *DisableResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DisableResponse_SdkV2) {
}

func (to *DisableResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DisableResponse_SdkV2) {
}

func (m DisableResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DisableResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DisableResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DisableResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m DisableResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m DisableResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type EffectivePermissionsList_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The privileges conveyed to each principal (either directly or via
	// inheritance)
	PrivilegeAssignments types.List `tfsdk:"privilege_assignments"`
}

func (to *EffectivePermissionsList_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EffectivePermissionsList_SdkV2) {
	if !from.PrivilegeAssignments.IsNull() && !from.PrivilegeAssignments.IsUnknown() && to.PrivilegeAssignments.IsNull() && len(from.PrivilegeAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrivilegeAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrivilegeAssignments = from.PrivilegeAssignments
	}
}

func (to *EffectivePermissionsList_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EffectivePermissionsList_SdkV2) {
	if !from.PrivilegeAssignments.IsNull() && !from.PrivilegeAssignments.IsUnknown() && to.PrivilegeAssignments.IsNull() && len(from.PrivilegeAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrivilegeAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrivilegeAssignments = from.PrivilegeAssignments
	}
}

func (m EffectivePermissionsList_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["privilege_assignments"] = attrs["privilege_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePermissionsList.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EffectivePermissionsList_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privilege_assignments": reflect.TypeOf(EffectivePrivilegeAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePermissionsList_SdkV2
// only implements ToObjectValue() and Type().
func (m EffectivePermissionsList_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":       m.NextPageToken,
			"privilege_assignments": m.PrivilegeAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EffectivePermissionsList_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"privilege_assignments": basetypes.ListType{
				ElemType: EffectivePrivilegeAssignment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPrivilegeAssignments returns the value of the PrivilegeAssignments field in EffectivePermissionsList_SdkV2 as
// a slice of EffectivePrivilegeAssignment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *EffectivePermissionsList_SdkV2) GetPrivilegeAssignments(ctx context.Context) ([]EffectivePrivilegeAssignment_SdkV2, bool) {
	if m.PrivilegeAssignments.IsNull() || m.PrivilegeAssignments.IsUnknown() {
		return nil, false
	}
	var v []EffectivePrivilegeAssignment_SdkV2
	d := m.PrivilegeAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivilegeAssignments sets the value of the PrivilegeAssignments field in EffectivePermissionsList_SdkV2.
func (m *EffectivePermissionsList_SdkV2) SetPrivilegeAssignments(ctx context.Context, v []EffectivePrivilegeAssignment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["privilege_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PrivilegeAssignments = types.ListValueMust(t, vs)
}

type EffectivePredictiveOptimizationFlag_SdkV2 struct {
	// The name of the object from which the flag was inherited. If there was no
	// inheritance, this field is left blank.
	InheritedFromName types.String `tfsdk:"inherited_from_name"`
	// The type of the object from which the flag was inherited. If there was no
	// inheritance, this field is left blank.
	InheritedFromType types.String `tfsdk:"inherited_from_type"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	Value types.String `tfsdk:"value"`
}

func (to *EffectivePredictiveOptimizationFlag_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EffectivePredictiveOptimizationFlag_SdkV2) {
}

func (to *EffectivePredictiveOptimizationFlag_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EffectivePredictiveOptimizationFlag_SdkV2) {
}

func (m EffectivePredictiveOptimizationFlag_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited_from_name"] = attrs["inherited_from_name"].SetOptional()
	attrs["inherited_from_type"] = attrs["inherited_from_type"].SetOptional()
	attrs["value"] = attrs["value"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePredictiveOptimizationFlag.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EffectivePredictiveOptimizationFlag_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePredictiveOptimizationFlag_SdkV2
// only implements ToObjectValue() and Type().
func (m EffectivePredictiveOptimizationFlag_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited_from_name": m.InheritedFromName,
			"inherited_from_type": m.InheritedFromType,
			"value":               m.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EffectivePredictiveOptimizationFlag_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited_from_name": types.StringType,
			"inherited_from_type": types.StringType,
			"value":               types.StringType,
		},
	}
}

type EffectivePrivilege_SdkV2 struct {
	// The full name of the object that conveys this privilege via inheritance.
	// This field is omitted when privilege is not inherited (it's assigned to
	// the securable itself).
	InheritedFromName types.String `tfsdk:"inherited_from_name"`
	// The type of the object that conveys this privilege via inheritance. This
	// field is omitted when privilege is not inherited (it's assigned to the
	// securable itself).
	InheritedFromType types.String `tfsdk:"inherited_from_type"`
	// The privilege assigned to the principal.
	Privilege types.String `tfsdk:"privilege"`
}

func (to *EffectivePrivilege_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EffectivePrivilege_SdkV2) {
}

func (to *EffectivePrivilege_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EffectivePrivilege_SdkV2) {
}

func (m EffectivePrivilege_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited_from_name"] = attrs["inherited_from_name"].SetOptional()
	attrs["inherited_from_type"] = attrs["inherited_from_type"].SetOptional()
	attrs["privilege"] = attrs["privilege"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePrivilege.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EffectivePrivilege_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePrivilege_SdkV2
// only implements ToObjectValue() and Type().
func (m EffectivePrivilege_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited_from_name": m.InheritedFromName,
			"inherited_from_type": m.InheritedFromType,
			"privilege":           m.Privilege,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EffectivePrivilege_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited_from_name": types.StringType,
			"inherited_from_type": types.StringType,
			"privilege":           types.StringType,
		},
	}
}

type EffectivePrivilegeAssignment_SdkV2 struct {
	// The principal (user email address or group name).
	Principal types.String `tfsdk:"principal"`
	// The privileges conveyed to the principal (either directly or via
	// inheritance).
	Privileges types.List `tfsdk:"privileges"`
}

func (to *EffectivePrivilegeAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EffectivePrivilegeAssignment_SdkV2) {
	if !from.Privileges.IsNull() && !from.Privileges.IsUnknown() && to.Privileges.IsNull() && len(from.Privileges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Privileges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Privileges = from.Privileges
	}
}

func (to *EffectivePrivilegeAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EffectivePrivilegeAssignment_SdkV2) {
	if !from.Privileges.IsNull() && !from.Privileges.IsUnknown() && to.Privileges.IsNull() && len(from.Privileges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Privileges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Privileges = from.Privileges
	}
}

func (m EffectivePrivilegeAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["privileges"] = attrs["privileges"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePrivilegeAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EffectivePrivilegeAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privileges": reflect.TypeOf(EffectivePrivilege_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePrivilegeAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m EffectivePrivilegeAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"principal":  m.Principal,
			"privileges": m.Privileges,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EffectivePrivilegeAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"principal": types.StringType,
			"privileges": basetypes.ListType{
				ElemType: EffectivePrivilege_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPrivileges returns the value of the Privileges field in EffectivePrivilegeAssignment_SdkV2 as
// a slice of EffectivePrivilege_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *EffectivePrivilegeAssignment_SdkV2) GetPrivileges(ctx context.Context) ([]EffectivePrivilege_SdkV2, bool) {
	if m.Privileges.IsNull() || m.Privileges.IsUnknown() {
		return nil, false
	}
	var v []EffectivePrivilege_SdkV2
	d := m.Privileges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivileges sets the value of the Privileges field in EffectivePrivilegeAssignment_SdkV2.
func (m *EffectivePrivilegeAssignment_SdkV2) SetPrivileges(ctx context.Context, v []EffectivePrivilege_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["privileges"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Privileges = types.ListValueMust(t, vs)
}

type EnableRequest_SdkV2 struct {
	// the catalog for which the system schema is to enabled in
	CatalogName types.String `tfsdk:"catalog_name"`
	// The metastore ID under which the system schema lives.
	MetastoreId types.String `tfsdk:"-"`
	// Full name of the system schema.
	SchemaName types.String `tfsdk:"-"`
}

func (to *EnableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnableRequest_SdkV2) {
}

func (to *EnableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EnableRequest_SdkV2) {
}

func (m EnableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m EnableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name": m.CatalogName,
			"metastore_id": m.MetastoreId,
			"schema_name":  m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"metastore_id": types.StringType,
			"schema_name":  types.StringType,
		},
	}
}

type EnableResponse_SdkV2 struct {
}

func (to *EnableResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnableResponse_SdkV2) {
}

func (to *EnableResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EnableResponse_SdkV2) {
}

func (m EnableResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnableResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnableResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnableResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m EnableResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m EnableResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// Encryption options that apply to clients connecting to cloud storage.
type EncryptionDetails_SdkV2 struct {
	// Server-Side Encryption properties for clients communicating with AWS s3.
	SseEncryptionDetails types.List `tfsdk:"sse_encryption_details"`
}

func (to *EncryptionDetails_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EncryptionDetails_SdkV2) {
	if !from.SseEncryptionDetails.IsNull() && !from.SseEncryptionDetails.IsUnknown() {
		if toSseEncryptionDetails, ok := to.GetSseEncryptionDetails(ctx); ok {
			if fromSseEncryptionDetails, ok := from.GetSseEncryptionDetails(ctx); ok {
				// Recursively sync the fields of SseEncryptionDetails
				toSseEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromSseEncryptionDetails)
				to.SetSseEncryptionDetails(ctx, toSseEncryptionDetails)
			}
		}
	}
}

func (to *EncryptionDetails_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EncryptionDetails_SdkV2) {
	if !from.SseEncryptionDetails.IsNull() && !from.SseEncryptionDetails.IsUnknown() {
		if toSseEncryptionDetails, ok := to.GetSseEncryptionDetails(ctx); ok {
			if fromSseEncryptionDetails, ok := from.GetSseEncryptionDetails(ctx); ok {
				toSseEncryptionDetails.SyncFieldsDuringRead(ctx, fromSseEncryptionDetails)
				to.SetSseEncryptionDetails(ctx, toSseEncryptionDetails)
			}
		}
	}
}

func (m EncryptionDetails_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["sse_encryption_details"] = attrs["sse_encryption_details"].SetOptional()
	attrs["sse_encryption_details"] = attrs["sse_encryption_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EncryptionDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EncryptionDetails_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"sse_encryption_details": reflect.TypeOf(SseEncryptionDetails_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EncryptionDetails_SdkV2
// only implements ToObjectValue() and Type().
func (m EncryptionDetails_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"sse_encryption_details": m.SseEncryptionDetails,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EncryptionDetails_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"sse_encryption_details": basetypes.ListType{
				ElemType: SseEncryptionDetails_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSseEncryptionDetails returns the value of the SseEncryptionDetails field in EncryptionDetails_SdkV2 as
// a SseEncryptionDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *EncryptionDetails_SdkV2) GetSseEncryptionDetails(ctx context.Context) (SseEncryptionDetails_SdkV2, bool) {
	var e SseEncryptionDetails_SdkV2
	if m.SseEncryptionDetails.IsNull() || m.SseEncryptionDetails.IsUnknown() {
		return e, false
	}
	var v []SseEncryptionDetails_SdkV2
	d := m.SseEncryptionDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSseEncryptionDetails sets the value of the SseEncryptionDetails field in EncryptionDetails_SdkV2.
func (m *EncryptionDetails_SdkV2) SetSseEncryptionDetails(ctx context.Context, v SseEncryptionDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sse_encryption_details"]
	m.SseEncryptionDetails = types.ListValueMust(t, vs)
}

// Represents a tag assignment to an entity
type EntityTagAssignment_SdkV2 struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"entity_name"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"entity_type"`
	// The key of the tag
	TagKey types.String `tfsdk:"tag_key"`
	// The value of the tag
	TagValue types.String `tfsdk:"tag_value"`
}

func (to *EntityTagAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EntityTagAssignment_SdkV2) {
}

func (to *EntityTagAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EntityTagAssignment_SdkV2) {
}

func (m EntityTagAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_type"] = attrs["entity_type"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["tag_key"] = attrs["tag_key"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["tag_value"] = attrs["tag_value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EntityTagAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EntityTagAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EntityTagAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m EntityTagAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": m.EntityName,
			"entity_type": m.EntityType,
			"tag_key":     m.TagKey,
			"tag_value":   m.TagValue,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EntityTagAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_key":     types.StringType,
			"tag_value":   types.StringType,
		},
	}
}

type ExistsRequest_SdkV2 struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
}

func (to *ExistsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExistsRequest_SdkV2) {
}

func (to *ExistsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExistsRequest_SdkV2) {
}

func (m ExistsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExistsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExistsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExistsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ExistsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": m.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExistsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
		},
	}
}

type ExternalLineageExternalMetadata_SdkV2 struct {
	Name types.String `tfsdk:"name"`
}

func (to *ExternalLineageExternalMetadata_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageExternalMetadata_SdkV2) {
}

func (to *ExternalLineageExternalMetadata_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageExternalMetadata_SdkV2) {
}

func (m ExternalLineageExternalMetadata_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageExternalMetadata.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageExternalMetadata_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageExternalMetadata_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageExternalMetadata_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageExternalMetadata_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

// Represents the external metadata object in the lineage event.
type ExternalLineageExternalMetadataInfo_SdkV2 struct {
	// Type of entity represented by the external metadata object.
	EntityType types.String `tfsdk:"entity_type"`
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// Name of the external metadata object.
	Name types.String `tfsdk:"name"`
	// Type of external system.
	SystemType types.String `tfsdk:"system_type"`
}

func (to *ExternalLineageExternalMetadataInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageExternalMetadataInfo_SdkV2) {
}

func (to *ExternalLineageExternalMetadataInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageExternalMetadataInfo_SdkV2) {
}

func (m ExternalLineageExternalMetadataInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetOptional()
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["system_type"] = attrs["system_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageExternalMetadataInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageExternalMetadataInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageExternalMetadataInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageExternalMetadataInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_type": m.EntityType,
			"event_time":  m.EventTime,
			"name":        m.Name,
			"system_type": m.SystemType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageExternalMetadataInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_type": types.StringType,
			"event_time":  types.StringType,
			"name":        types.StringType,
			"system_type": types.StringType,
		},
	}
}

// Represents the path information in the lineage event.
type ExternalLineageFileInfo_SdkV2 struct {
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// URL of the path.
	Path types.String `tfsdk:"path"`
	// The full name of the securable on the path.
	SecurableName types.String `tfsdk:"securable_name"`
	// The securable type of the securable on the path.
	SecurableType types.String `tfsdk:"securable_type"`
	// The storage location associated with securable on the path.
	StorageLocation types.String `tfsdk:"storage_location"`
}

func (to *ExternalLineageFileInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageFileInfo_SdkV2) {
}

func (to *ExternalLineageFileInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageFileInfo_SdkV2) {
}

func (m ExternalLineageFileInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["path"] = attrs["path"].SetOptional()
	attrs["securable_name"] = attrs["securable_name"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageFileInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageFileInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageFileInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageFileInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"event_time":       m.EventTime,
			"path":             m.Path,
			"securable_name":   m.SecurableName,
			"securable_type":   m.SecurableType,
			"storage_location": m.StorageLocation,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageFileInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"event_time":       types.StringType,
			"path":             types.StringType,
			"securable_name":   types.StringType,
			"securable_type":   types.StringType,
			"storage_location": types.StringType,
		},
	}
}

// Lineage response containing lineage information of a data asset.
type ExternalLineageInfo_SdkV2 struct {
	// Information about the edge metadata of the external lineage relationship.
	ExternalLineageInfo types.List `tfsdk:"external_lineage_info"`
	// Information about external metadata involved in the lineage relationship.
	ExternalMetadataInfo types.List `tfsdk:"external_metadata_info"`
	// Information about the file involved in the lineage relationship.
	FileInfo types.List `tfsdk:"file_info"`
	// Information about the model version involved in the lineage relationship.
	ModelInfo types.List `tfsdk:"model_info"`
	// Information about the table involved in the lineage relationship.
	TableInfo types.List `tfsdk:"table_info"`
}

func (to *ExternalLineageInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageInfo_SdkV2) {
	if !from.ExternalLineageInfo.IsNull() && !from.ExternalLineageInfo.IsUnknown() {
		if toExternalLineageInfo, ok := to.GetExternalLineageInfo(ctx); ok {
			if fromExternalLineageInfo, ok := from.GetExternalLineageInfo(ctx); ok {
				// Recursively sync the fields of ExternalLineageInfo
				toExternalLineageInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalLineageInfo)
				to.SetExternalLineageInfo(ctx, toExternalLineageInfo)
			}
		}
	}
	if !from.ExternalMetadataInfo.IsNull() && !from.ExternalMetadataInfo.IsUnknown() {
		if toExternalMetadataInfo, ok := to.GetExternalMetadataInfo(ctx); ok {
			if fromExternalMetadataInfo, ok := from.GetExternalMetadataInfo(ctx); ok {
				// Recursively sync the fields of ExternalMetadataInfo
				toExternalMetadataInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalMetadataInfo)
				to.SetExternalMetadataInfo(ctx, toExternalMetadataInfo)
			}
		}
	}
	if !from.FileInfo.IsNull() && !from.FileInfo.IsUnknown() {
		if toFileInfo, ok := to.GetFileInfo(ctx); ok {
			if fromFileInfo, ok := from.GetFileInfo(ctx); ok {
				// Recursively sync the fields of FileInfo
				toFileInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromFileInfo)
				to.SetFileInfo(ctx, toFileInfo)
			}
		}
	}
	if !from.ModelInfo.IsNull() && !from.ModelInfo.IsUnknown() {
		if toModelInfo, ok := to.GetModelInfo(ctx); ok {
			if fromModelInfo, ok := from.GetModelInfo(ctx); ok {
				// Recursively sync the fields of ModelInfo
				toModelInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromModelInfo)
				to.SetModelInfo(ctx, toModelInfo)
			}
		}
	}
	if !from.TableInfo.IsNull() && !from.TableInfo.IsUnknown() {
		if toTableInfo, ok := to.GetTableInfo(ctx); ok {
			if fromTableInfo, ok := from.GetTableInfo(ctx); ok {
				// Recursively sync the fields of TableInfo
				toTableInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromTableInfo)
				to.SetTableInfo(ctx, toTableInfo)
			}
		}
	}
}

func (to *ExternalLineageInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageInfo_SdkV2) {
	if !from.ExternalLineageInfo.IsNull() && !from.ExternalLineageInfo.IsUnknown() {
		if toExternalLineageInfo, ok := to.GetExternalLineageInfo(ctx); ok {
			if fromExternalLineageInfo, ok := from.GetExternalLineageInfo(ctx); ok {
				toExternalLineageInfo.SyncFieldsDuringRead(ctx, fromExternalLineageInfo)
				to.SetExternalLineageInfo(ctx, toExternalLineageInfo)
			}
		}
	}
	if !from.ExternalMetadataInfo.IsNull() && !from.ExternalMetadataInfo.IsUnknown() {
		if toExternalMetadataInfo, ok := to.GetExternalMetadataInfo(ctx); ok {
			if fromExternalMetadataInfo, ok := from.GetExternalMetadataInfo(ctx); ok {
				toExternalMetadataInfo.SyncFieldsDuringRead(ctx, fromExternalMetadataInfo)
				to.SetExternalMetadataInfo(ctx, toExternalMetadataInfo)
			}
		}
	}
	if !from.FileInfo.IsNull() && !from.FileInfo.IsUnknown() {
		if toFileInfo, ok := to.GetFileInfo(ctx); ok {
			if fromFileInfo, ok := from.GetFileInfo(ctx); ok {
				toFileInfo.SyncFieldsDuringRead(ctx, fromFileInfo)
				to.SetFileInfo(ctx, toFileInfo)
			}
		}
	}
	if !from.ModelInfo.IsNull() && !from.ModelInfo.IsUnknown() {
		if toModelInfo, ok := to.GetModelInfo(ctx); ok {
			if fromModelInfo, ok := from.GetModelInfo(ctx); ok {
				toModelInfo.SyncFieldsDuringRead(ctx, fromModelInfo)
				to.SetModelInfo(ctx, toModelInfo)
			}
		}
	}
	if !from.TableInfo.IsNull() && !from.TableInfo.IsUnknown() {
		if toTableInfo, ok := to.GetTableInfo(ctx); ok {
			if fromTableInfo, ok := from.GetTableInfo(ctx); ok {
				toTableInfo.SyncFieldsDuringRead(ctx, fromTableInfo)
				to.SetTableInfo(ctx, toTableInfo)
			}
		}
	}
}

func (m ExternalLineageInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_info"] = attrs["external_lineage_info"].SetOptional()
	attrs["external_lineage_info"] = attrs["external_lineage_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["external_metadata_info"] = attrs["external_metadata_info"].SetOptional()
	attrs["external_metadata_info"] = attrs["external_metadata_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["file_info"] = attrs["file_info"].SetOptional()
	attrs["file_info"] = attrs["file_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["model_info"] = attrs["model_info"].SetOptional()
	attrs["model_info"] = attrs["model_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table_info"] = attrs["table_info"].SetOptional()
	attrs["table_info"] = attrs["table_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_info":  reflect.TypeOf(ExternalLineageRelationshipInfo_SdkV2{}),
		"external_metadata_info": reflect.TypeOf(ExternalLineageExternalMetadataInfo_SdkV2{}),
		"file_info":              reflect.TypeOf(ExternalLineageFileInfo_SdkV2{}),
		"model_info":             reflect.TypeOf(ExternalLineageModelVersionInfo_SdkV2{}),
		"table_info":             reflect.TypeOf(ExternalLineageTableInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_info":  m.ExternalLineageInfo,
			"external_metadata_info": m.ExternalMetadataInfo,
			"file_info":              m.FileInfo,
			"model_info":             m.ModelInfo,
			"table_info":             m.TableInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_info": basetypes.ListType{
				ElemType: ExternalLineageRelationshipInfo_SdkV2{}.Type(ctx),
			},
			"external_metadata_info": basetypes.ListType{
				ElemType: ExternalLineageExternalMetadataInfo_SdkV2{}.Type(ctx),
			},
			"file_info": basetypes.ListType{
				ElemType: ExternalLineageFileInfo_SdkV2{}.Type(ctx),
			},
			"model_info": basetypes.ListType{
				ElemType: ExternalLineageModelVersionInfo_SdkV2{}.Type(ctx),
			},
			"table_info": basetypes.ListType{
				ElemType: ExternalLineageTableInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetExternalLineageInfo returns the value of the ExternalLineageInfo field in ExternalLineageInfo_SdkV2 as
// a ExternalLineageRelationshipInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageInfo_SdkV2) GetExternalLineageInfo(ctx context.Context) (ExternalLineageRelationshipInfo_SdkV2, bool) {
	var e ExternalLineageRelationshipInfo_SdkV2
	if m.ExternalLineageInfo.IsNull() || m.ExternalLineageInfo.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageRelationshipInfo_SdkV2
	d := m.ExternalLineageInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalLineageInfo sets the value of the ExternalLineageInfo field in ExternalLineageInfo_SdkV2.
func (m *ExternalLineageInfo_SdkV2) SetExternalLineageInfo(ctx context.Context, v ExternalLineageRelationshipInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_lineage_info"]
	m.ExternalLineageInfo = types.ListValueMust(t, vs)
}

// GetExternalMetadataInfo returns the value of the ExternalMetadataInfo field in ExternalLineageInfo_SdkV2 as
// a ExternalLineageExternalMetadataInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageInfo_SdkV2) GetExternalMetadataInfo(ctx context.Context) (ExternalLineageExternalMetadataInfo_SdkV2, bool) {
	var e ExternalLineageExternalMetadataInfo_SdkV2
	if m.ExternalMetadataInfo.IsNull() || m.ExternalMetadataInfo.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageExternalMetadataInfo_SdkV2
	d := m.ExternalMetadataInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalMetadataInfo sets the value of the ExternalMetadataInfo field in ExternalLineageInfo_SdkV2.
func (m *ExternalLineageInfo_SdkV2) SetExternalMetadataInfo(ctx context.Context, v ExternalLineageExternalMetadataInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_metadata_info"]
	m.ExternalMetadataInfo = types.ListValueMust(t, vs)
}

// GetFileInfo returns the value of the FileInfo field in ExternalLineageInfo_SdkV2 as
// a ExternalLineageFileInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageInfo_SdkV2) GetFileInfo(ctx context.Context) (ExternalLineageFileInfo_SdkV2, bool) {
	var e ExternalLineageFileInfo_SdkV2
	if m.FileInfo.IsNull() || m.FileInfo.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageFileInfo_SdkV2
	d := m.FileInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFileInfo sets the value of the FileInfo field in ExternalLineageInfo_SdkV2.
func (m *ExternalLineageInfo_SdkV2) SetFileInfo(ctx context.Context, v ExternalLineageFileInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file_info"]
	m.FileInfo = types.ListValueMust(t, vs)
}

// GetModelInfo returns the value of the ModelInfo field in ExternalLineageInfo_SdkV2 as
// a ExternalLineageModelVersionInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageInfo_SdkV2) GetModelInfo(ctx context.Context) (ExternalLineageModelVersionInfo_SdkV2, bool) {
	var e ExternalLineageModelVersionInfo_SdkV2
	if m.ModelInfo.IsNull() || m.ModelInfo.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageModelVersionInfo_SdkV2
	d := m.ModelInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetModelInfo sets the value of the ModelInfo field in ExternalLineageInfo_SdkV2.
func (m *ExternalLineageInfo_SdkV2) SetModelInfo(ctx context.Context, v ExternalLineageModelVersionInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["model_info"]
	m.ModelInfo = types.ListValueMust(t, vs)
}

// GetTableInfo returns the value of the TableInfo field in ExternalLineageInfo_SdkV2 as
// a ExternalLineageTableInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageInfo_SdkV2) GetTableInfo(ctx context.Context) (ExternalLineageTableInfo_SdkV2, bool) {
	var e ExternalLineageTableInfo_SdkV2
	if m.TableInfo.IsNull() || m.TableInfo.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageTableInfo_SdkV2
	d := m.TableInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTableInfo sets the value of the TableInfo field in ExternalLineageInfo_SdkV2.
func (m *ExternalLineageInfo_SdkV2) SetTableInfo(ctx context.Context, v ExternalLineageTableInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table_info"]
	m.TableInfo = types.ListValueMust(t, vs)
}

type ExternalLineageModelVersion_SdkV2 struct {
	Name types.String `tfsdk:"name"`

	Version types.String `tfsdk:"version"`
}

func (to *ExternalLineageModelVersion_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageModelVersion_SdkV2) {
}

func (to *ExternalLineageModelVersion_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageModelVersion_SdkV2) {
}

func (m ExternalLineageModelVersion_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()
	attrs["version"] = attrs["version"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageModelVersion.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageModelVersion_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageModelVersion_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageModelVersion_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":    m.Name,
			"version": m.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageModelVersion_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":    types.StringType,
			"version": types.StringType,
		},
	}
}

// Represents the model version information in the lineage event.
type ExternalLineageModelVersionInfo_SdkV2 struct {
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// Name of the model.
	ModelName types.String `tfsdk:"model_name"`
	// Version number of the model.
	Version types.Int64 `tfsdk:"version"`
}

func (to *ExternalLineageModelVersionInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageModelVersionInfo_SdkV2) {
}

func (to *ExternalLineageModelVersionInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageModelVersionInfo_SdkV2) {
}

func (m ExternalLineageModelVersionInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["version"] = attrs["version"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageModelVersionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageModelVersionInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageModelVersionInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageModelVersionInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"event_time": m.EventTime,
			"model_name": m.ModelName,
			"version":    m.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageModelVersionInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"event_time": types.StringType,
			"model_name": types.StringType,
			"version":    types.Int64Type,
		},
	}
}

type ExternalLineageObject_SdkV2 struct {
	ExternalMetadata types.List `tfsdk:"external_metadata"`

	ModelVersion types.List `tfsdk:"model_version"`

	Path types.List `tfsdk:"path"`

	Table types.List `tfsdk:"table"`
}

func (to *ExternalLineageObject_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageObject_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() {
		if toExternalMetadata, ok := to.GetExternalMetadata(ctx); ok {
			if fromExternalMetadata, ok := from.GetExternalMetadata(ctx); ok {
				// Recursively sync the fields of ExternalMetadata
				toExternalMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalMetadata)
				to.SetExternalMetadata(ctx, toExternalMetadata)
			}
		}
	}
	if !from.ModelVersion.IsNull() && !from.ModelVersion.IsUnknown() {
		if toModelVersion, ok := to.GetModelVersion(ctx); ok {
			if fromModelVersion, ok := from.GetModelVersion(ctx); ok {
				// Recursively sync the fields of ModelVersion
				toModelVersion.SyncFieldsDuringCreateOrUpdate(ctx, fromModelVersion)
				to.SetModelVersion(ctx, toModelVersion)
			}
		}
	}
	if !from.Path.IsNull() && !from.Path.IsUnknown() {
		if toPath, ok := to.GetPath(ctx); ok {
			if fromPath, ok := from.GetPath(ctx); ok {
				// Recursively sync the fields of Path
				toPath.SyncFieldsDuringCreateOrUpdate(ctx, fromPath)
				to.SetPath(ctx, toPath)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (to *ExternalLineageObject_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageObject_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() {
		if toExternalMetadata, ok := to.GetExternalMetadata(ctx); ok {
			if fromExternalMetadata, ok := from.GetExternalMetadata(ctx); ok {
				toExternalMetadata.SyncFieldsDuringRead(ctx, fromExternalMetadata)
				to.SetExternalMetadata(ctx, toExternalMetadata)
			}
		}
	}
	if !from.ModelVersion.IsNull() && !from.ModelVersion.IsUnknown() {
		if toModelVersion, ok := to.GetModelVersion(ctx); ok {
			if fromModelVersion, ok := from.GetModelVersion(ctx); ok {
				toModelVersion.SyncFieldsDuringRead(ctx, fromModelVersion)
				to.SetModelVersion(ctx, toModelVersion)
			}
		}
	}
	if !from.Path.IsNull() && !from.Path.IsUnknown() {
		if toPath, ok := to.GetPath(ctx); ok {
			if fromPath, ok := from.GetPath(ctx); ok {
				toPath.SyncFieldsDuringRead(ctx, fromPath)
				to.SetPath(ctx, toPath)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (m ExternalLineageObject_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetOptional()
	attrs["external_metadata"] = attrs["external_metadata"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["model_version"] = attrs["model_version"].SetOptional()
	attrs["model_version"] = attrs["model_version"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["path"] = attrs["path"].SetOptional()
	attrs["path"] = attrs["path"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table"] = attrs["table"].SetOptional()
	attrs["table"] = attrs["table"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageObject.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageObject_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalLineageExternalMetadata_SdkV2{}),
		"model_version":     reflect.TypeOf(ExternalLineageModelVersion_SdkV2{}),
		"path":              reflect.TypeOf(ExternalLineagePath_SdkV2{}),
		"table":             reflect.TypeOf(ExternalLineageTable_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageObject_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageObject_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": m.ExternalMetadata,
			"model_version":     m.ModelVersion,
			"path":              m.Path,
			"table":             m.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageObject_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": basetypes.ListType{
				ElemType: ExternalLineageExternalMetadata_SdkV2{}.Type(ctx),
			},
			"model_version": basetypes.ListType{
				ElemType: ExternalLineageModelVersion_SdkV2{}.Type(ctx),
			},
			"path": basetypes.ListType{
				ElemType: ExternalLineagePath_SdkV2{}.Type(ctx),
			},
			"table": basetypes.ListType{
				ElemType: ExternalLineageTable_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in ExternalLineageObject_SdkV2 as
// a ExternalLineageExternalMetadata_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageObject_SdkV2) GetExternalMetadata(ctx context.Context) (ExternalLineageExternalMetadata_SdkV2, bool) {
	var e ExternalLineageExternalMetadata_SdkV2
	if m.ExternalMetadata.IsNull() || m.ExternalMetadata.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageExternalMetadata_SdkV2
	d := m.ExternalMetadata.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in ExternalLineageObject_SdkV2.
func (m *ExternalLineageObject_SdkV2) SetExternalMetadata(ctx context.Context, v ExternalLineageExternalMetadata_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_metadata"]
	m.ExternalMetadata = types.ListValueMust(t, vs)
}

// GetModelVersion returns the value of the ModelVersion field in ExternalLineageObject_SdkV2 as
// a ExternalLineageModelVersion_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageObject_SdkV2) GetModelVersion(ctx context.Context) (ExternalLineageModelVersion_SdkV2, bool) {
	var e ExternalLineageModelVersion_SdkV2
	if m.ModelVersion.IsNull() || m.ModelVersion.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageModelVersion_SdkV2
	d := m.ModelVersion.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetModelVersion sets the value of the ModelVersion field in ExternalLineageObject_SdkV2.
func (m *ExternalLineageObject_SdkV2) SetModelVersion(ctx context.Context, v ExternalLineageModelVersion_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["model_version"]
	m.ModelVersion = types.ListValueMust(t, vs)
}

// GetPath returns the value of the Path field in ExternalLineageObject_SdkV2 as
// a ExternalLineagePath_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageObject_SdkV2) GetPath(ctx context.Context) (ExternalLineagePath_SdkV2, bool) {
	var e ExternalLineagePath_SdkV2
	if m.Path.IsNull() || m.Path.IsUnknown() {
		return e, false
	}
	var v []ExternalLineagePath_SdkV2
	d := m.Path.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPath sets the value of the Path field in ExternalLineageObject_SdkV2.
func (m *ExternalLineageObject_SdkV2) SetPath(ctx context.Context, v ExternalLineagePath_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["path"]
	m.Path = types.ListValueMust(t, vs)
}

// GetTable returns the value of the Table field in ExternalLineageObject_SdkV2 as
// a ExternalLineageTable_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageObject_SdkV2) GetTable(ctx context.Context) (ExternalLineageTable_SdkV2, bool) {
	var e ExternalLineageTable_SdkV2
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageTable_SdkV2
	d := m.Table.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTable sets the value of the Table field in ExternalLineageObject_SdkV2.
func (m *ExternalLineageObject_SdkV2) SetTable(ctx context.Context, v ExternalLineageTable_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table"]
	m.Table = types.ListValueMust(t, vs)
}

type ExternalLineagePath_SdkV2 struct {
	Url types.String `tfsdk:"url"`
}

func (to *ExternalLineagePath_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineagePath_SdkV2) {
}

func (to *ExternalLineagePath_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineagePath_SdkV2) {
}

func (m ExternalLineagePath_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineagePath.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineagePath_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineagePath_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineagePath_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"url": m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineagePath_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"url": types.StringType,
		},
	}
}

type ExternalLineageRelationship_SdkV2 struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.List `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.List `tfsdk:"target"`
}

func (to *ExternalLineageRelationship_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageRelationship_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				// Recursively sync the fields of Source
				toSource.SyncFieldsDuringCreateOrUpdate(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				// Recursively sync the fields of Target
				toTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (to *ExternalLineageRelationship_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageRelationship_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				toSource.SyncFieldsDuringRead(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				toTarget.SyncFieldsDuringRead(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (m ExternalLineageRelationship_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["source"] = attrs["source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["target"] = attrs["target"].SetRequired()
	attrs["target"] = attrs["target"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageRelationship.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageRelationship_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship_SdkV2{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
		"target":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageRelationship_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageRelationship_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    m.Columns,
			"id":         m.Id,
			"properties": m.Properties,
			"source":     m.Source,
			"target":     m.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageRelationship_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship_SdkV2{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
			"target": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetColumns returns the value of the Columns field in ExternalLineageRelationship_SdkV2 as
// a slice of ColumnRelationship_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationship_SdkV2) GetColumns(ctx context.Context) ([]ColumnRelationship_SdkV2, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship_SdkV2
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in ExternalLineageRelationship_SdkV2.
func (m *ExternalLineageRelationship_SdkV2) SetColumns(ctx context.Context, v []ColumnRelationship_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ExternalLineageRelationship_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationship_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ExternalLineageRelationship_SdkV2.
func (m *ExternalLineageRelationship_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in ExternalLineageRelationship_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationship_SdkV2) GetSource(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Source.IsNull() || m.Source.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Source.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSource sets the value of the Source field in ExternalLineageRelationship_SdkV2.
func (m *ExternalLineageRelationship_SdkV2) SetSource(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["source"]
	m.Source = types.ListValueMust(t, vs)
}

// GetTarget returns the value of the Target field in ExternalLineageRelationship_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationship_SdkV2) GetTarget(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Target.IsNull() || m.Target.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Target.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTarget sets the value of the Target field in ExternalLineageRelationship_SdkV2.
func (m *ExternalLineageRelationship_SdkV2) SetTarget(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["target"]
	m.Target = types.ListValueMust(t, vs)
}

type ExternalLineageRelationshipInfo_SdkV2 struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.List `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.List `tfsdk:"target"`
}

func (to *ExternalLineageRelationshipInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageRelationshipInfo_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				// Recursively sync the fields of Source
				toSource.SyncFieldsDuringCreateOrUpdate(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				// Recursively sync the fields of Target
				toTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (to *ExternalLineageRelationshipInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageRelationshipInfo_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				toSource.SyncFieldsDuringRead(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				toTarget.SyncFieldsDuringRead(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (m ExternalLineageRelationshipInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["source"] = attrs["source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["target"] = attrs["target"].SetRequired()
	attrs["target"] = attrs["target"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageRelationshipInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageRelationshipInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship_SdkV2{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
		"target":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageRelationshipInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageRelationshipInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    m.Columns,
			"id":         m.Id,
			"properties": m.Properties,
			"source":     m.Source,
			"target":     m.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageRelationshipInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship_SdkV2{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
			"target": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetColumns returns the value of the Columns field in ExternalLineageRelationshipInfo_SdkV2 as
// a slice of ColumnRelationship_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationshipInfo_SdkV2) GetColumns(ctx context.Context) ([]ColumnRelationship_SdkV2, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship_SdkV2
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in ExternalLineageRelationshipInfo_SdkV2.
func (m *ExternalLineageRelationshipInfo_SdkV2) SetColumns(ctx context.Context, v []ColumnRelationship_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ExternalLineageRelationshipInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationshipInfo_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ExternalLineageRelationshipInfo_SdkV2.
func (m *ExternalLineageRelationshipInfo_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in ExternalLineageRelationshipInfo_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationshipInfo_SdkV2) GetSource(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Source.IsNull() || m.Source.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Source.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSource sets the value of the Source field in ExternalLineageRelationshipInfo_SdkV2.
func (m *ExternalLineageRelationshipInfo_SdkV2) SetSource(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["source"]
	m.Source = types.ListValueMust(t, vs)
}

// GetTarget returns the value of the Target field in ExternalLineageRelationshipInfo_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLineageRelationshipInfo_SdkV2) GetTarget(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Target.IsNull() || m.Target.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Target.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTarget sets the value of the Target field in ExternalLineageRelationshipInfo_SdkV2.
func (m *ExternalLineageRelationshipInfo_SdkV2) SetTarget(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["target"]
	m.Target = types.ListValueMust(t, vs)
}

type ExternalLineageTable_SdkV2 struct {
	Name types.String `tfsdk:"name"`
}

func (to *ExternalLineageTable_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageTable_SdkV2) {
}

func (to *ExternalLineageTable_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageTable_SdkV2) {
}

func (m ExternalLineageTable_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageTable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageTable_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageTable_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageTable_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageTable_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

// Represents the table information in the lineage event.
type ExternalLineageTableInfo_SdkV2 struct {
	// Name of Catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// Name of Table.
	Name types.String `tfsdk:"name"`
	// Name of Schema.
	SchemaName types.String `tfsdk:"schema_name"`
}

func (to *ExternalLineageTableInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLineageTableInfo_SdkV2) {
}

func (to *ExternalLineageTableInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLineageTableInfo_SdkV2) {
}

func (m ExternalLineageTableInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageTableInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLineageTableInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageTableInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLineageTableInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name": m.CatalogName,
			"event_time":   m.EventTime,
			"name":         m.Name,
			"schema_name":  m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLineageTableInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"event_time":   types.StringType,
			"name":         types.StringType,
			"schema_name":  types.StringType,
		},
	}
}

type ExternalLocationInfo_SdkV2 struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this external location was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of external location creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique ID of the location's storage credential.
	CredentialId types.String `tfsdk:"credential_id"`
	// Name of the storage credential used with this location.
	CredentialName types.String `tfsdk:"credential_name"`
	// Whether to enable file events on this external location.
	EnableFileEvents types.Bool `tfsdk:"enable_file_events"`

	EncryptionDetails types.List `tfsdk:"encryption_details"`
	// Indicates whether fallback mode is enabled for this external location.
	// When fallback mode is enabled, the access to the location falls back to
	// cluster credentials if UC credentials are not sufficient.
	Fallback types.Bool `tfsdk:"fallback"`
	// File event queue settings. If `enable_file_events` is `true`, must be
	// defined and have exactly one of the documented properties.
	FileEventQueue types.List `tfsdk:"file_event_queue"`

	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of metastore hosting the external location.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of the external location.
	Name types.String `tfsdk:"name"`
	// The owner of the external location.
	Owner types.String `tfsdk:"owner"`
	// Indicates whether the external location is read-only.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Time at which external location this was last modified, in epoch
	// milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the external location.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Path URL of the external location.
	Url types.String `tfsdk:"url"`
}

func (to *ExternalLocationInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalLocationInfo_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				// Recursively sync the fields of EncryptionDetails
				toEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.FileEventQueue.IsNull() && !from.FileEventQueue.IsUnknown() {
		if toFileEventQueue, ok := to.GetFileEventQueue(ctx); ok {
			if fromFileEventQueue, ok := from.GetFileEventQueue(ctx); ok {
				// Recursively sync the fields of FileEventQueue
				toFileEventQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromFileEventQueue)
				to.SetFileEventQueue(ctx, toFileEventQueue)
			}
		}
	}
}

func (to *ExternalLocationInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalLocationInfo_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				toEncryptionDetails.SyncFieldsDuringRead(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.FileEventQueue.IsNull() && !from.FileEventQueue.IsUnknown() {
		if toFileEventQueue, ok := to.GetFileEventQueue(ctx); ok {
			if fromFileEventQueue, ok := from.GetFileEventQueue(ctx); ok {
				toFileEventQueue.SyncFieldsDuringRead(ctx, fromFileEventQueue)
				to.SetFileEventQueue(ctx, toFileEventQueue)
			}
		}
	}
}

func (m ExternalLocationInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["credential_id"] = attrs["credential_id"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetOptional()
	attrs["enable_file_events"] = attrs["enable_file_events"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["fallback"] = attrs["fallback"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLocationInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalLocationInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails_SdkV2{}),
		"file_event_queue":   reflect.TypeOf(FileEventQueue_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLocationInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalLocationInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":        m.BrowseOnly,
			"comment":            m.Comment,
			"created_at":         m.CreatedAt,
			"created_by":         m.CreatedBy,
			"credential_id":      m.CredentialId,
			"credential_name":    m.CredentialName,
			"enable_file_events": m.EnableFileEvents,
			"encryption_details": m.EncryptionDetails,
			"fallback":           m.Fallback,
			"file_event_queue":   m.FileEventQueue,
			"isolation_mode":     m.IsolationMode,
			"metastore_id":       m.MetastoreId,
			"name":               m.Name,
			"owner":              m.Owner,
			"read_only":          m.ReadOnly,
			"updated_at":         m.UpdatedAt,
			"updated_by":         m.UpdatedBy,
			"url":                m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalLocationInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":        types.BoolType,
			"comment":            types.StringType,
			"created_at":         types.Int64Type,
			"created_by":         types.StringType,
			"credential_id":      types.StringType,
			"credential_name":    types.StringType,
			"enable_file_events": types.BoolType,
			"encryption_details": basetypes.ListType{
				ElemType: EncryptionDetails_SdkV2{}.Type(ctx),
			},
			"fallback": types.BoolType,
			"file_event_queue": basetypes.ListType{
				ElemType: FileEventQueue_SdkV2{}.Type(ctx),
			},
			"isolation_mode": types.StringType,
			"metastore_id":   types.StringType,
			"name":           types.StringType,
			"owner":          types.StringType,
			"read_only":      types.BoolType,
			"updated_at":     types.Int64Type,
			"updated_by":     types.StringType,
			"url":            types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in ExternalLocationInfo_SdkV2 as
// a EncryptionDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLocationInfo_SdkV2) GetEncryptionDetails(ctx context.Context) (EncryptionDetails_SdkV2, bool) {
	var e EncryptionDetails_SdkV2
	if m.EncryptionDetails.IsNull() || m.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v []EncryptionDetails_SdkV2
	d := m.EncryptionDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in ExternalLocationInfo_SdkV2.
func (m *ExternalLocationInfo_SdkV2) SetEncryptionDetails(ctx context.Context, v EncryptionDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["encryption_details"]
	m.EncryptionDetails = types.ListValueMust(t, vs)
}

// GetFileEventQueue returns the value of the FileEventQueue field in ExternalLocationInfo_SdkV2 as
// a FileEventQueue_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalLocationInfo_SdkV2) GetFileEventQueue(ctx context.Context) (FileEventQueue_SdkV2, bool) {
	var e FileEventQueue_SdkV2
	if m.FileEventQueue.IsNull() || m.FileEventQueue.IsUnknown() {
		return e, false
	}
	var v []FileEventQueue_SdkV2
	d := m.FileEventQueue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFileEventQueue sets the value of the FileEventQueue field in ExternalLocationInfo_SdkV2.
func (m *ExternalLocationInfo_SdkV2) SetFileEventQueue(ctx context.Context, v FileEventQueue_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file_event_queue"]
	m.FileEventQueue = types.ListValueMust(t, vs)
}

type ExternalMetadata_SdkV2 struct {
	// List of columns associated with the external metadata object.
	Columns types.List `tfsdk:"columns"`
	// Time at which this external metadata object was created.
	CreateTime types.String `tfsdk:"create_time"`
	// Username of external metadata object creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// User-provided free-form text description.
	Description types.String `tfsdk:"description"`
	// Type of entity within the external system.
	EntityType types.String `tfsdk:"entity_type"`
	// Unique identifier of the external metadata object.
	Id types.String `tfsdk:"id"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of the external metadata object.
	Name types.String `tfsdk:"name"`
	// Owner of the external metadata object.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the external metadata object.
	Properties types.Map `tfsdk:"properties"`
	// Type of external system.
	SystemType types.String `tfsdk:"system_type"`
	// Time at which this external metadata object was last modified.
	UpdateTime types.String `tfsdk:"update_time"`
	// Username of user who last modified external metadata object.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// URL associated with the external metadata object.
	Url types.String `tfsdk:"url"`
}

func (to *ExternalMetadata_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExternalMetadata_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
}

func (to *ExternalMetadata_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExternalMetadata_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
}

func (m ExternalMetadata_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["create_time"] = attrs["create_time"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["system_type"] = attrs["system_type"].SetRequired()
	attrs["update_time"] = attrs["update_time"].SetComputed()
	attrs["updated_by"] = attrs["updated_by"].SetComputed()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalMetadata.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExternalMetadata_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalMetadata_SdkV2
// only implements ToObjectValue() and Type().
func (m ExternalMetadata_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":      m.Columns,
			"create_time":  m.CreateTime,
			"created_by":   m.CreatedBy,
			"description":  m.Description,
			"entity_type":  m.EntityType,
			"id":           m.Id,
			"metastore_id": m.MetastoreId,
			"name":         m.Name,
			"owner":        m.Owner,
			"properties":   m.Properties,
			"system_type":  m.SystemType,
			"update_time":  m.UpdateTime,
			"updated_by":   m.UpdatedBy,
			"url":          m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExternalMetadata_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"create_time":  types.StringType,
			"created_by":   types.StringType,
			"description":  types.StringType,
			"entity_type":  types.StringType,
			"id":           types.StringType,
			"metastore_id": types.StringType,
			"name":         types.StringType,
			"owner":        types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"system_type": types.StringType,
			"update_time": types.StringType,
			"updated_by":  types.StringType,
			"url":         types.StringType,
		},
	}
}

// GetColumns returns the value of the Columns field in ExternalMetadata_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalMetadata_SdkV2) GetColumns(ctx context.Context) ([]types.String, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in ExternalMetadata_SdkV2.
func (m *ExternalMetadata_SdkV2) SetColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ExternalMetadata_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExternalMetadata_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ExternalMetadata_SdkV2.
func (m *ExternalMetadata_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// Detailed status of an online table. Shown if the online table is in the
// OFFLINE_FAILED or the ONLINE_PIPELINE_FAILED state.
type FailedStatus_SdkV2 struct {
	// The last source table Delta version that was synced to the online table.
	// Note that this Delta version may only be partially synced to the online
	// table. Only populated if the table is still online and available for
	// serving.
	LastProcessedCommitVersion types.Int64 `tfsdk:"last_processed_commit_version"`
	// The timestamp of the last time any data was synchronized from the source
	// table to the online table. Only populated if the table is still online
	// and available for serving.
	Timestamp types.String `tfsdk:"timestamp"`
}

func (to *FailedStatus_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FailedStatus_SdkV2) {
}

func (to *FailedStatus_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FailedStatus_SdkV2) {
}

func (m FailedStatus_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_processed_commit_version"] = attrs["last_processed_commit_version"].SetOptional()
	attrs["timestamp"] = attrs["timestamp"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FailedStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FailedStatus_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FailedStatus_SdkV2
// only implements ToObjectValue() and Type().
func (m FailedStatus_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_processed_commit_version": m.LastProcessedCommitVersion,
			"timestamp":                     m.Timestamp,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FailedStatus_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_processed_commit_version": types.Int64Type,
			"timestamp":                     types.StringType,
		},
	}
}

type FileEventQueue_SdkV2 struct {
	ManagedAqs types.List `tfsdk:"managed_aqs"`

	ManagedPubsub types.List `tfsdk:"managed_pubsub"`

	ManagedSqs types.List `tfsdk:"managed_sqs"`

	ProvidedAqs types.List `tfsdk:"provided_aqs"`

	ProvidedPubsub types.List `tfsdk:"provided_pubsub"`

	ProvidedSqs types.List `tfsdk:"provided_sqs"`
}

func (to *FileEventQueue_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FileEventQueue_SdkV2) {
	if !from.ManagedAqs.IsNull() && !from.ManagedAqs.IsUnknown() {
		if toManagedAqs, ok := to.GetManagedAqs(ctx); ok {
			if fromManagedAqs, ok := from.GetManagedAqs(ctx); ok {
				// Recursively sync the fields of ManagedAqs
				toManagedAqs.SyncFieldsDuringCreateOrUpdate(ctx, fromManagedAqs)
				to.SetManagedAqs(ctx, toManagedAqs)
			}
		}
	}
	if !from.ManagedPubsub.IsNull() && !from.ManagedPubsub.IsUnknown() {
		if toManagedPubsub, ok := to.GetManagedPubsub(ctx); ok {
			if fromManagedPubsub, ok := from.GetManagedPubsub(ctx); ok {
				// Recursively sync the fields of ManagedPubsub
				toManagedPubsub.SyncFieldsDuringCreateOrUpdate(ctx, fromManagedPubsub)
				to.SetManagedPubsub(ctx, toManagedPubsub)
			}
		}
	}
	if !from.ManagedSqs.IsNull() && !from.ManagedSqs.IsUnknown() {
		if toManagedSqs, ok := to.GetManagedSqs(ctx); ok {
			if fromManagedSqs, ok := from.GetManagedSqs(ctx); ok {
				// Recursively sync the fields of ManagedSqs
				toManagedSqs.SyncFieldsDuringCreateOrUpdate(ctx, fromManagedSqs)
				to.SetManagedSqs(ctx, toManagedSqs)
			}
		}
	}
	if !from.ProvidedAqs.IsNull() && !from.ProvidedAqs.IsUnknown() {
		if toProvidedAqs, ok := to.GetProvidedAqs(ctx); ok {
			if fromProvidedAqs, ok := from.GetProvidedAqs(ctx); ok {
				// Recursively sync the fields of ProvidedAqs
				toProvidedAqs.SyncFieldsDuringCreateOrUpdate(ctx, fromProvidedAqs)
				to.SetProvidedAqs(ctx, toProvidedAqs)
			}
		}
	}
	if !from.ProvidedPubsub.IsNull() && !from.ProvidedPubsub.IsUnknown() {
		if toProvidedPubsub, ok := to.GetProvidedPubsub(ctx); ok {
			if fromProvidedPubsub, ok := from.GetProvidedPubsub(ctx); ok {
				// Recursively sync the fields of ProvidedPubsub
				toProvidedPubsub.SyncFieldsDuringCreateOrUpdate(ctx, fromProvidedPubsub)
				to.SetProvidedPubsub(ctx, toProvidedPubsub)
			}
		}
	}
	if !from.ProvidedSqs.IsNull() && !from.ProvidedSqs.IsUnknown() {
		if toProvidedSqs, ok := to.GetProvidedSqs(ctx); ok {
			if fromProvidedSqs, ok := from.GetProvidedSqs(ctx); ok {
				// Recursively sync the fields of ProvidedSqs
				toProvidedSqs.SyncFieldsDuringCreateOrUpdate(ctx, fromProvidedSqs)
				to.SetProvidedSqs(ctx, toProvidedSqs)
			}
		}
	}
}

func (to *FileEventQueue_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FileEventQueue_SdkV2) {
	if !from.ManagedAqs.IsNull() && !from.ManagedAqs.IsUnknown() {
		if toManagedAqs, ok := to.GetManagedAqs(ctx); ok {
			if fromManagedAqs, ok := from.GetManagedAqs(ctx); ok {
				toManagedAqs.SyncFieldsDuringRead(ctx, fromManagedAqs)
				to.SetManagedAqs(ctx, toManagedAqs)
			}
		}
	}
	if !from.ManagedPubsub.IsNull() && !from.ManagedPubsub.IsUnknown() {
		if toManagedPubsub, ok := to.GetManagedPubsub(ctx); ok {
			if fromManagedPubsub, ok := from.GetManagedPubsub(ctx); ok {
				toManagedPubsub.SyncFieldsDuringRead(ctx, fromManagedPubsub)
				to.SetManagedPubsub(ctx, toManagedPubsub)
			}
		}
	}
	if !from.ManagedSqs.IsNull() && !from.ManagedSqs.IsUnknown() {
		if toManagedSqs, ok := to.GetManagedSqs(ctx); ok {
			if fromManagedSqs, ok := from.GetManagedSqs(ctx); ok {
				toManagedSqs.SyncFieldsDuringRead(ctx, fromManagedSqs)
				to.SetManagedSqs(ctx, toManagedSqs)
			}
		}
	}
	if !from.ProvidedAqs.IsNull() && !from.ProvidedAqs.IsUnknown() {
		if toProvidedAqs, ok := to.GetProvidedAqs(ctx); ok {
			if fromProvidedAqs, ok := from.GetProvidedAqs(ctx); ok {
				toProvidedAqs.SyncFieldsDuringRead(ctx, fromProvidedAqs)
				to.SetProvidedAqs(ctx, toProvidedAqs)
			}
		}
	}
	if !from.ProvidedPubsub.IsNull() && !from.ProvidedPubsub.IsUnknown() {
		if toProvidedPubsub, ok := to.GetProvidedPubsub(ctx); ok {
			if fromProvidedPubsub, ok := from.GetProvidedPubsub(ctx); ok {
				toProvidedPubsub.SyncFieldsDuringRead(ctx, fromProvidedPubsub)
				to.SetProvidedPubsub(ctx, toProvidedPubsub)
			}
		}
	}
	if !from.ProvidedSqs.IsNull() && !from.ProvidedSqs.IsUnknown() {
		if toProvidedSqs, ok := to.GetProvidedSqs(ctx); ok {
			if fromProvidedSqs, ok := from.GetProvidedSqs(ctx); ok {
				toProvidedSqs.SyncFieldsDuringRead(ctx, fromProvidedSqs)
				to.SetProvidedSqs(ctx, toProvidedSqs)
			}
		}
	}
}

func (m FileEventQueue_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_aqs"] = attrs["managed_aqs"].SetOptional()
	attrs["managed_aqs"] = attrs["managed_aqs"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["managed_pubsub"] = attrs["managed_pubsub"].SetOptional()
	attrs["managed_pubsub"] = attrs["managed_pubsub"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["managed_sqs"] = attrs["managed_sqs"].SetOptional()
	attrs["managed_sqs"] = attrs["managed_sqs"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["provided_aqs"] = attrs["provided_aqs"].SetOptional()
	attrs["provided_aqs"] = attrs["provided_aqs"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["provided_pubsub"] = attrs["provided_pubsub"].SetOptional()
	attrs["provided_pubsub"] = attrs["provided_pubsub"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["provided_sqs"] = attrs["provided_sqs"].SetOptional()
	attrs["provided_sqs"] = attrs["provided_sqs"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FileEventQueue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FileEventQueue_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"managed_aqs":     reflect.TypeOf(AzureQueueStorage_SdkV2{}),
		"managed_pubsub":  reflect.TypeOf(GcpPubsub_SdkV2{}),
		"managed_sqs":     reflect.TypeOf(AwsSqsQueue_SdkV2{}),
		"provided_aqs":    reflect.TypeOf(AzureQueueStorage_SdkV2{}),
		"provided_pubsub": reflect.TypeOf(GcpPubsub_SdkV2{}),
		"provided_sqs":    reflect.TypeOf(AwsSqsQueue_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FileEventQueue_SdkV2
// only implements ToObjectValue() and Type().
func (m FileEventQueue_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_aqs":     m.ManagedAqs,
			"managed_pubsub":  m.ManagedPubsub,
			"managed_sqs":     m.ManagedSqs,
			"provided_aqs":    m.ProvidedAqs,
			"provided_pubsub": m.ProvidedPubsub,
			"provided_sqs":    m.ProvidedSqs,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FileEventQueue_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_aqs": basetypes.ListType{
				ElemType: AzureQueueStorage_SdkV2{}.Type(ctx),
			},
			"managed_pubsub": basetypes.ListType{
				ElemType: GcpPubsub_SdkV2{}.Type(ctx),
			},
			"managed_sqs": basetypes.ListType{
				ElemType: AwsSqsQueue_SdkV2{}.Type(ctx),
			},
			"provided_aqs": basetypes.ListType{
				ElemType: AzureQueueStorage_SdkV2{}.Type(ctx),
			},
			"provided_pubsub": basetypes.ListType{
				ElemType: GcpPubsub_SdkV2{}.Type(ctx),
			},
			"provided_sqs": basetypes.ListType{
				ElemType: AwsSqsQueue_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetManagedAqs returns the value of the ManagedAqs field in FileEventQueue_SdkV2 as
// a AzureQueueStorage_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FileEventQueue_SdkV2) GetManagedAqs(ctx context.Context) (AzureQueueStorage_SdkV2, bool) {
	var e AzureQueueStorage_SdkV2
	if m.ManagedAqs.IsNull() || m.ManagedAqs.IsUnknown() {
		return e, false
	}
	var v []AzureQueueStorage_SdkV2
	d := m.ManagedAqs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetManagedAqs sets the value of the ManagedAqs field in FileEventQueue_SdkV2.
func (m *FileEventQueue_SdkV2) SetManagedAqs(ctx context.Context, v AzureQueueStorage_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["managed_aqs"]
	m.ManagedAqs = types.ListValueMust(t, vs)
}

// GetManagedPubsub returns the value of the ManagedPubsub field in FileEventQueue_SdkV2 as
// a GcpPubsub_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FileEventQueue_SdkV2) GetManagedPubsub(ctx context.Context) (GcpPubsub_SdkV2, bool) {
	var e GcpPubsub_SdkV2
	if m.ManagedPubsub.IsNull() || m.ManagedPubsub.IsUnknown() {
		return e, false
	}
	var v []GcpPubsub_SdkV2
	d := m.ManagedPubsub.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetManagedPubsub sets the value of the ManagedPubsub field in FileEventQueue_SdkV2.
func (m *FileEventQueue_SdkV2) SetManagedPubsub(ctx context.Context, v GcpPubsub_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["managed_pubsub"]
	m.ManagedPubsub = types.ListValueMust(t, vs)
}

// GetManagedSqs returns the value of the ManagedSqs field in FileEventQueue_SdkV2 as
// a AwsSqsQueue_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FileEventQueue_SdkV2) GetManagedSqs(ctx context.Context) (AwsSqsQueue_SdkV2, bool) {
	var e AwsSqsQueue_SdkV2
	if m.ManagedSqs.IsNull() || m.ManagedSqs.IsUnknown() {
		return e, false
	}
	var v []AwsSqsQueue_SdkV2
	d := m.ManagedSqs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetManagedSqs sets the value of the ManagedSqs field in FileEventQueue_SdkV2.
func (m *FileEventQueue_SdkV2) SetManagedSqs(ctx context.Context, v AwsSqsQueue_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["managed_sqs"]
	m.ManagedSqs = types.ListValueMust(t, vs)
}

// GetProvidedAqs returns the value of the ProvidedAqs field in FileEventQueue_SdkV2 as
// a AzureQueueStorage_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FileEventQueue_SdkV2) GetProvidedAqs(ctx context.Context) (AzureQueueStorage_SdkV2, bool) {
	var e AzureQueueStorage_SdkV2
	if m.ProvidedAqs.IsNull() || m.ProvidedAqs.IsUnknown() {
		return e, false
	}
	var v []AzureQueueStorage_SdkV2
	d := m.ProvidedAqs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetProvidedAqs sets the value of the ProvidedAqs field in FileEventQueue_SdkV2.
func (m *FileEventQueue_SdkV2) SetProvidedAqs(ctx context.Context, v AzureQueueStorage_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["provided_aqs"]
	m.ProvidedAqs = types.ListValueMust(t, vs)
}

// GetProvidedPubsub returns the value of the ProvidedPubsub field in FileEventQueue_SdkV2 as
// a GcpPubsub_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FileEventQueue_SdkV2) GetProvidedPubsub(ctx context.Context) (GcpPubsub_SdkV2, bool) {
	var e GcpPubsub_SdkV2
	if m.ProvidedPubsub.IsNull() || m.ProvidedPubsub.IsUnknown() {
		return e, false
	}
	var v []GcpPubsub_SdkV2
	d := m.ProvidedPubsub.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetProvidedPubsub sets the value of the ProvidedPubsub field in FileEventQueue_SdkV2.
func (m *FileEventQueue_SdkV2) SetProvidedPubsub(ctx context.Context, v GcpPubsub_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["provided_pubsub"]
	m.ProvidedPubsub = types.ListValueMust(t, vs)
}

// GetProvidedSqs returns the value of the ProvidedSqs field in FileEventQueue_SdkV2 as
// a AwsSqsQueue_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FileEventQueue_SdkV2) GetProvidedSqs(ctx context.Context) (AwsSqsQueue_SdkV2, bool) {
	var e AwsSqsQueue_SdkV2
	if m.ProvidedSqs.IsNull() || m.ProvidedSqs.IsUnknown() {
		return e, false
	}
	var v []AwsSqsQueue_SdkV2
	d := m.ProvidedSqs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetProvidedSqs sets the value of the ProvidedSqs field in FileEventQueue_SdkV2.
func (m *FileEventQueue_SdkV2) SetProvidedSqs(ctx context.Context, v AwsSqsQueue_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["provided_sqs"]
	m.ProvidedSqs = types.ListValueMust(t, vs)
}

type ForeignKeyConstraint_SdkV2 struct {
	// Column names for this constraint.
	ChildColumns types.List `tfsdk:"child_columns"`
	// The name of the constraint.
	Name types.String `tfsdk:"name"`
	// Column names for this constraint.
	ParentColumns types.List `tfsdk:"parent_columns"`
	// The full name of the parent constraint.
	ParentTable types.String `tfsdk:"parent_table"`
	// True if the constraint is RELY, false or unset if NORELY.
	Rely types.Bool `tfsdk:"rely"`
}

func (to *ForeignKeyConstraint_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForeignKeyConstraint_SdkV2) {
}

func (to *ForeignKeyConstraint_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ForeignKeyConstraint_SdkV2) {
}

func (m ForeignKeyConstraint_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["child_columns"] = attrs["child_columns"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["parent_columns"] = attrs["parent_columns"].SetRequired()
	attrs["parent_table"] = attrs["parent_table"].SetRequired()
	attrs["rely"] = attrs["rely"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForeignKeyConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForeignKeyConstraint_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"child_columns":  reflect.TypeOf(types.String{}),
		"parent_columns": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForeignKeyConstraint_SdkV2
// only implements ToObjectValue() and Type().
func (m ForeignKeyConstraint_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"child_columns":  m.ChildColumns,
			"name":           m.Name,
			"parent_columns": m.ParentColumns,
			"parent_table":   m.ParentTable,
			"rely":           m.Rely,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForeignKeyConstraint_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"child_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": types.StringType,
			"parent_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"parent_table": types.StringType,
			"rely":         types.BoolType,
		},
	}
}

// GetChildColumns returns the value of the ChildColumns field in ForeignKeyConstraint_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ForeignKeyConstraint_SdkV2) GetChildColumns(ctx context.Context) ([]types.String, bool) {
	if m.ChildColumns.IsNull() || m.ChildColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ChildColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetChildColumns sets the value of the ChildColumns field in ForeignKeyConstraint_SdkV2.
func (m *ForeignKeyConstraint_SdkV2) SetChildColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["child_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ChildColumns = types.ListValueMust(t, vs)
}

// GetParentColumns returns the value of the ParentColumns field in ForeignKeyConstraint_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ForeignKeyConstraint_SdkV2) GetParentColumns(ctx context.Context) ([]types.String, bool) {
	if m.ParentColumns.IsNull() || m.ParentColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ParentColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParentColumns sets the value of the ParentColumns field in ForeignKeyConstraint_SdkV2.
func (m *ForeignKeyConstraint_SdkV2) SetParentColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parent_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ParentColumns = types.ListValueMust(t, vs)
}

type FunctionArgument_SdkV2 struct {
	// The alias of a matched column.
	Alias types.String `tfsdk:"alias"`
	// A constant literal.
	Constant types.String `tfsdk:"constant"`
}

func (to *FunctionArgument_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FunctionArgument_SdkV2) {
}

func (to *FunctionArgument_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FunctionArgument_SdkV2) {
}

func (m FunctionArgument_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias"] = attrs["alias"].SetOptional()
	attrs["constant"] = attrs["constant"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionArgument.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FunctionArgument_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionArgument_SdkV2
// only implements ToObjectValue() and Type().
func (m FunctionArgument_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":    m.Alias,
			"constant": m.Constant,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FunctionArgument_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":    types.StringType,
			"constant": types.StringType,
		},
	}
}

// A function that is dependent on a SQL object.
type FunctionDependency_SdkV2 struct {
	// Full name of the dependent function, in the form of
	// __catalog_name__.__schema_name__.__function_name__.
	FunctionFullName types.String `tfsdk:"function_full_name"`
}

func (to *FunctionDependency_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FunctionDependency_SdkV2) {
}

func (to *FunctionDependency_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FunctionDependency_SdkV2) {
}

func (m FunctionDependency_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_full_name"] = attrs["function_full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FunctionDependency_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionDependency_SdkV2
// only implements ToObjectValue() and Type().
func (m FunctionDependency_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_full_name": m.FunctionFullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FunctionDependency_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_full_name": types.StringType,
		},
	}
}

type FunctionInfo_SdkV2 struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// Name of parent Catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this function was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of function creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Scalar function return data type.
	DataType types.String `tfsdk:"data_type"`
	// External function language.
	ExternalLanguage types.String `tfsdk:"external_language"`
	// External function name.
	ExternalName types.String `tfsdk:"external_name"`
	// Pretty printed function data type.
	FullDataType types.String `tfsdk:"full_data_type"`
	// Full name of Function, in form of
	// **catalog_name**.**schema_name**.**function_name**
	FullName types.String `tfsdk:"full_name"`
	// Id of Function, relative to parent schema.
	FunctionId types.String `tfsdk:"function_id"`
	// Function input parameters.
	InputParams types.List `tfsdk:"input_params"`
	// Whether the function is deterministic.
	IsDeterministic types.Bool `tfsdk:"is_deterministic"`
	// Function null call.
	IsNullCall types.Bool `tfsdk:"is_null_call"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of function, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// Username of current owner of the function.
	Owner types.String `tfsdk:"owner"`
	// Function parameter style. **S** is the value for SQL.
	ParameterStyle types.String `tfsdk:"parameter_style"`
	// JSON-serialized key-value pair map, encoded (escaped) as a string.
	Properties types.String `tfsdk:"properties"`
	// Table function return parameters.
	ReturnParams types.List `tfsdk:"return_params"`
	// Function language. When **EXTERNAL** is used, the language of the routine
	// function should be specified in the **external_language** field, and the
	// **return_params** of the function cannot be used (as **TABLE** return
	// type is not supported), and the **sql_data_access** field must be
	// **NO_SQL**.
	RoutineBody types.String `tfsdk:"routine_body"`
	// Function body.
	RoutineDefinition types.String `tfsdk:"routine_definition"`
	// function dependencies.
	RoutineDependencies types.List `tfsdk:"routine_dependencies"`
	// Name of parent Schema relative to its parent Catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// Function security type.
	SecurityType types.String `tfsdk:"security_type"`
	// Specific name of the function; Reserved for future use.
	SpecificName types.String `tfsdk:"specific_name"`
	// Function SQL data access.
	SqlDataAccess types.String `tfsdk:"sql_data_access"`
	// List of schemes whose objects can be referenced without qualification.
	SqlPath types.String `tfsdk:"sql_path"`
	// Time at which this function was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the function.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *FunctionInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FunctionInfo_SdkV2) {
	if !from.InputParams.IsNull() && !from.InputParams.IsUnknown() {
		if toInputParams, ok := to.GetInputParams(ctx); ok {
			if fromInputParams, ok := from.GetInputParams(ctx); ok {
				// Recursively sync the fields of InputParams
				toInputParams.SyncFieldsDuringCreateOrUpdate(ctx, fromInputParams)
				to.SetInputParams(ctx, toInputParams)
			}
		}
	}
	if !from.ReturnParams.IsNull() && !from.ReturnParams.IsUnknown() {
		if toReturnParams, ok := to.GetReturnParams(ctx); ok {
			if fromReturnParams, ok := from.GetReturnParams(ctx); ok {
				// Recursively sync the fields of ReturnParams
				toReturnParams.SyncFieldsDuringCreateOrUpdate(ctx, fromReturnParams)
				to.SetReturnParams(ctx, toReturnParams)
			}
		}
	}
	if !from.RoutineDependencies.IsNull() && !from.RoutineDependencies.IsUnknown() {
		if toRoutineDependencies, ok := to.GetRoutineDependencies(ctx); ok {
			if fromRoutineDependencies, ok := from.GetRoutineDependencies(ctx); ok {
				// Recursively sync the fields of RoutineDependencies
				toRoutineDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromRoutineDependencies)
				to.SetRoutineDependencies(ctx, toRoutineDependencies)
			}
		}
	}
}

func (to *FunctionInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FunctionInfo_SdkV2) {
	if !from.InputParams.IsNull() && !from.InputParams.IsUnknown() {
		if toInputParams, ok := to.GetInputParams(ctx); ok {
			if fromInputParams, ok := from.GetInputParams(ctx); ok {
				toInputParams.SyncFieldsDuringRead(ctx, fromInputParams)
				to.SetInputParams(ctx, toInputParams)
			}
		}
	}
	if !from.ReturnParams.IsNull() && !from.ReturnParams.IsUnknown() {
		if toReturnParams, ok := to.GetReturnParams(ctx); ok {
			if fromReturnParams, ok := from.GetReturnParams(ctx); ok {
				toReturnParams.SyncFieldsDuringRead(ctx, fromReturnParams)
				to.SetReturnParams(ctx, toReturnParams)
			}
		}
	}
	if !from.RoutineDependencies.IsNull() && !from.RoutineDependencies.IsUnknown() {
		if toRoutineDependencies, ok := to.GetRoutineDependencies(ctx); ok {
			if fromRoutineDependencies, ok := from.GetRoutineDependencies(ctx); ok {
				toRoutineDependencies.SyncFieldsDuringRead(ctx, fromRoutineDependencies)
				to.SetRoutineDependencies(ctx, toRoutineDependencies)
			}
		}
	}
}

func (m FunctionInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["data_type"] = attrs["data_type"].SetOptional()
	attrs["external_language"] = attrs["external_language"].SetOptional()
	attrs["external_name"] = attrs["external_name"].SetOptional()
	attrs["full_data_type"] = attrs["full_data_type"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["function_id"] = attrs["function_id"].SetOptional()
	attrs["input_params"] = attrs["input_params"].SetOptional()
	attrs["input_params"] = attrs["input_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["is_deterministic"] = attrs["is_deterministic"].SetOptional()
	attrs["is_null_call"] = attrs["is_null_call"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["parameter_style"] = attrs["parameter_style"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["return_params"] = attrs["return_params"].SetOptional()
	attrs["return_params"] = attrs["return_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["routine_body"] = attrs["routine_body"].SetOptional()
	attrs["routine_definition"] = attrs["routine_definition"].SetOptional()
	attrs["routine_dependencies"] = attrs["routine_dependencies"].SetOptional()
	attrs["routine_dependencies"] = attrs["routine_dependencies"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["security_type"] = attrs["security_type"].SetOptional()
	attrs["specific_name"] = attrs["specific_name"].SetOptional()
	attrs["sql_data_access"] = attrs["sql_data_access"].SetOptional()
	attrs["sql_path"] = attrs["sql_path"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FunctionInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_params":         reflect.TypeOf(FunctionParameterInfos_SdkV2{}),
		"return_params":        reflect.TypeOf(FunctionParameterInfos_SdkV2{}),
		"routine_dependencies": reflect.TypeOf(DependencyList_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m FunctionInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":          m.BrowseOnly,
			"catalog_name":         m.CatalogName,
			"comment":              m.Comment,
			"created_at":           m.CreatedAt,
			"created_by":           m.CreatedBy,
			"data_type":            m.DataType,
			"external_language":    m.ExternalLanguage,
			"external_name":        m.ExternalName,
			"full_data_type":       m.FullDataType,
			"full_name":            m.FullName,
			"function_id":          m.FunctionId,
			"input_params":         m.InputParams,
			"is_deterministic":     m.IsDeterministic,
			"is_null_call":         m.IsNullCall,
			"metastore_id":         m.MetastoreId,
			"name":                 m.Name,
			"owner":                m.Owner,
			"parameter_style":      m.ParameterStyle,
			"properties":           m.Properties,
			"return_params":        m.ReturnParams,
			"routine_body":         m.RoutineBody,
			"routine_definition":   m.RoutineDefinition,
			"routine_dependencies": m.RoutineDependencies,
			"schema_name":          m.SchemaName,
			"security_type":        m.SecurityType,
			"specific_name":        m.SpecificName,
			"sql_data_access":      m.SqlDataAccess,
			"sql_path":             m.SqlPath,
			"updated_at":           m.UpdatedAt,
			"updated_by":           m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FunctionInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":       types.BoolType,
			"catalog_name":      types.StringType,
			"comment":           types.StringType,
			"created_at":        types.Int64Type,
			"created_by":        types.StringType,
			"data_type":         types.StringType,
			"external_language": types.StringType,
			"external_name":     types.StringType,
			"full_data_type":    types.StringType,
			"full_name":         types.StringType,
			"function_id":       types.StringType,
			"input_params": basetypes.ListType{
				ElemType: FunctionParameterInfos_SdkV2{}.Type(ctx),
			},
			"is_deterministic": types.BoolType,
			"is_null_call":     types.BoolType,
			"metastore_id":     types.StringType,
			"name":             types.StringType,
			"owner":            types.StringType,
			"parameter_style":  types.StringType,
			"properties":       types.StringType,
			"return_params": basetypes.ListType{
				ElemType: FunctionParameterInfos_SdkV2{}.Type(ctx),
			},
			"routine_body":       types.StringType,
			"routine_definition": types.StringType,
			"routine_dependencies": basetypes.ListType{
				ElemType: DependencyList_SdkV2{}.Type(ctx),
			},
			"schema_name":     types.StringType,
			"security_type":   types.StringType,
			"specific_name":   types.StringType,
			"sql_data_access": types.StringType,
			"sql_path":        types.StringType,
			"updated_at":      types.Int64Type,
			"updated_by":      types.StringType,
		},
	}
}

// GetInputParams returns the value of the InputParams field in FunctionInfo_SdkV2 as
// a FunctionParameterInfos_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FunctionInfo_SdkV2) GetInputParams(ctx context.Context) (FunctionParameterInfos_SdkV2, bool) {
	var e FunctionParameterInfos_SdkV2
	if m.InputParams.IsNull() || m.InputParams.IsUnknown() {
		return e, false
	}
	var v []FunctionParameterInfos_SdkV2
	d := m.InputParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInputParams sets the value of the InputParams field in FunctionInfo_SdkV2.
func (m *FunctionInfo_SdkV2) SetInputParams(ctx context.Context, v FunctionParameterInfos_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["input_params"]
	m.InputParams = types.ListValueMust(t, vs)
}

// GetReturnParams returns the value of the ReturnParams field in FunctionInfo_SdkV2 as
// a FunctionParameterInfos_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FunctionInfo_SdkV2) GetReturnParams(ctx context.Context) (FunctionParameterInfos_SdkV2, bool) {
	var e FunctionParameterInfos_SdkV2
	if m.ReturnParams.IsNull() || m.ReturnParams.IsUnknown() {
		return e, false
	}
	var v []FunctionParameterInfos_SdkV2
	d := m.ReturnParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetReturnParams sets the value of the ReturnParams field in FunctionInfo_SdkV2.
func (m *FunctionInfo_SdkV2) SetReturnParams(ctx context.Context, v FunctionParameterInfos_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["return_params"]
	m.ReturnParams = types.ListValueMust(t, vs)
}

// GetRoutineDependencies returns the value of the RoutineDependencies field in FunctionInfo_SdkV2 as
// a DependencyList_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *FunctionInfo_SdkV2) GetRoutineDependencies(ctx context.Context) (DependencyList_SdkV2, bool) {
	var e DependencyList_SdkV2
	if m.RoutineDependencies.IsNull() || m.RoutineDependencies.IsUnknown() {
		return e, false
	}
	var v []DependencyList_SdkV2
	d := m.RoutineDependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRoutineDependencies sets the value of the RoutineDependencies field in FunctionInfo_SdkV2.
func (m *FunctionInfo_SdkV2) SetRoutineDependencies(ctx context.Context, v DependencyList_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["routine_dependencies"]
	m.RoutineDependencies = types.ListValueMust(t, vs)
}

type FunctionParameterInfo_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of Parameter.
	Name types.String `tfsdk:"name"`
	// Default value of the parameter.
	ParameterDefault types.String `tfsdk:"parameter_default"`
	// Function parameter mode.
	ParameterMode types.String `tfsdk:"parameter_mode"`
	// Function parameter type.
	ParameterType types.String `tfsdk:"parameter_type"`
	// Ordinal position of column (starting at position 0).
	Position types.Int64 `tfsdk:"position"`
	// Format of IntervalType.
	TypeIntervalType types.String `tfsdk:"type_interval_type"`
	// Full data type spec, JSON-serialized.
	TypeJson types.String `tfsdk:"type_json"`
	// Name of type (INT, STRUCT, MAP, etc.)
	TypeName types.String `tfsdk:"type_name"`
	// Digits of precision; required on Create for DecimalTypes.
	TypePrecision types.Int64 `tfsdk:"type_precision"`
	// Digits to right of decimal; Required on Create for DecimalTypes.
	TypeScale types.Int64 `tfsdk:"type_scale"`
	// Full data type spec, SQL/catalogString text.
	TypeText types.String `tfsdk:"type_text"`
}

func (to *FunctionParameterInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FunctionParameterInfo_SdkV2) {
}

func (to *FunctionParameterInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FunctionParameterInfo_SdkV2) {
}

func (m FunctionParameterInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["parameter_default"] = attrs["parameter_default"].SetOptional()
	attrs["parameter_mode"] = attrs["parameter_mode"].SetOptional()
	attrs["parameter_type"] = attrs["parameter_type"].SetOptional()
	attrs["position"] = attrs["position"].SetRequired()
	attrs["type_interval_type"] = attrs["type_interval_type"].SetOptional()
	attrs["type_json"] = attrs["type_json"].SetOptional()
	attrs["type_name"] = attrs["type_name"].SetRequired()
	attrs["type_precision"] = attrs["type_precision"].SetOptional()
	attrs["type_scale"] = attrs["type_scale"].SetOptional()
	attrs["type_text"] = attrs["type_text"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionParameterInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FunctionParameterInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionParameterInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m FunctionParameterInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            m.Comment,
			"name":               m.Name,
			"parameter_default":  m.ParameterDefault,
			"parameter_mode":     m.ParameterMode,
			"parameter_type":     m.ParameterType,
			"position":           m.Position,
			"type_interval_type": m.TypeIntervalType,
			"type_json":          m.TypeJson,
			"type_name":          m.TypeName,
			"type_precision":     m.TypePrecision,
			"type_scale":         m.TypeScale,
			"type_text":          m.TypeText,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FunctionParameterInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"name":               types.StringType,
			"parameter_default":  types.StringType,
			"parameter_mode":     types.StringType,
			"parameter_type":     types.StringType,
			"position":           types.Int64Type,
			"type_interval_type": types.StringType,
			"type_json":          types.StringType,
			"type_name":          types.StringType,
			"type_precision":     types.Int64Type,
			"type_scale":         types.Int64Type,
			"type_text":          types.StringType,
		},
	}
}

type FunctionParameterInfos_SdkV2 struct {
	Parameters types.List `tfsdk:"parameters"`
}

func (to *FunctionParameterInfos_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FunctionParameterInfos_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *FunctionParameterInfos_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FunctionParameterInfos_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m FunctionParameterInfos_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionParameterInfos.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FunctionParameterInfos_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(FunctionParameterInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionParameterInfos_SdkV2
// only implements ToObjectValue() and Type().
func (m FunctionParameterInfos_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FunctionParameterInfos_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: FunctionParameterInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in FunctionParameterInfos_SdkV2 as
// a slice of FunctionParameterInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *FunctionParameterInfos_SdkV2) GetParameters(ctx context.Context) ([]FunctionParameterInfo_SdkV2, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []FunctionParameterInfo_SdkV2
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in FunctionParameterInfos_SdkV2.
func (m *FunctionParameterInfos_SdkV2) SetParameters(ctx context.Context, v []FunctionParameterInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

// GCP temporary credentials for API authentication. Read more at
// https://developers.google.com/identity/protocols/oauth2/service-account
type GcpOauthToken_SdkV2 struct {
	OauthToken types.String `tfsdk:"oauth_token"`
}

func (to *GcpOauthToken_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GcpOauthToken_SdkV2) {
}

func (to *GcpOauthToken_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GcpOauthToken_SdkV2) {
}

func (m GcpOauthToken_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["oauth_token"] = attrs["oauth_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GcpOauthToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GcpOauthToken_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GcpOauthToken_SdkV2
// only implements ToObjectValue() and Type().
func (m GcpOauthToken_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"oauth_token": m.OauthToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GcpOauthToken_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"oauth_token": types.StringType,
		},
	}
}

type GcpPubsub_SdkV2 struct {
	// Unique identifier included in the name of file events managed cloud
	// resources.
	ManagedResourceId types.String `tfsdk:"managed_resource_id"`
	// The Pub/Sub subscription name in the format
	// projects/{project}/subscriptions/{subscription name} Required for
	// provided_pubsub.
	SubscriptionName types.String `tfsdk:"subscription_name"`
}

func (to *GcpPubsub_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GcpPubsub_SdkV2) {
}

func (to *GcpPubsub_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GcpPubsub_SdkV2) {
}

func (m GcpPubsub_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_resource_id"] = attrs["managed_resource_id"].SetComputed()
	attrs["subscription_name"] = attrs["subscription_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GcpPubsub.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GcpPubsub_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GcpPubsub_SdkV2
// only implements ToObjectValue() and Type().
func (m GcpPubsub_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_resource_id": m.ManagedResourceId,
			"subscription_name":   m.SubscriptionName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GcpPubsub_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_resource_id": types.StringType,
			"subscription_name":   types.StringType,
		},
	}
}

type GenerateTemporaryPathCredentialRequest_SdkV2 struct {
	// Optional. When set to true, the service will not validate that the
	// generated credentials can perform write operations, therefore no new
	// paths will be created and the response will not contain valid
	// credentials. Defaults to false.
	DryRun types.Bool `tfsdk:"dry_run"`
	// The operation being performed on the path.
	Operation types.String `tfsdk:"operation"`
	// URL for path-based access.
	Url types.String `tfsdk:"url"`
}

func (to *GenerateTemporaryPathCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryPathCredentialRequest_SdkV2) {
}

func (to *GenerateTemporaryPathCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryPathCredentialRequest_SdkV2) {
}

func (m GenerateTemporaryPathCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dry_run"] = attrs["dry_run"].SetOptional()
	attrs["operation"] = attrs["operation"].SetRequired()
	attrs["url"] = attrs["url"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryPathCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryPathCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryPathCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryPathCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dry_run":   m.DryRun,
			"operation": m.Operation,
			"url":       m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryPathCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dry_run":   types.BoolType,
			"operation": types.StringType,
			"url":       types.StringType,
		},
	}
}

type GenerateTemporaryPathCredentialResponse_SdkV2 struct {
	AwsTempCredentials types.List `tfsdk:"aws_temp_credentials"`

	AzureAad types.List `tfsdk:"azure_aad"`

	AzureUserDelegationSas types.List `tfsdk:"azure_user_delegation_sas"`
	// Server time when the credential will expire, in epoch milliseconds. The
	// API client is advised to cache the credential given this expiration time.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	GcpOauthToken types.List `tfsdk:"gcp_oauth_token"`

	R2TempCredentials types.List `tfsdk:"r2_temp_credentials"`
	// The URL of the storage path accessible by the temporary credential.
	Url types.String `tfsdk:"url"`
}

func (to *GenerateTemporaryPathCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryPathCredentialResponse_SdkV2) {
	if !from.AwsTempCredentials.IsNull() && !from.AwsTempCredentials.IsUnknown() {
		if toAwsTempCredentials, ok := to.GetAwsTempCredentials(ctx); ok {
			if fromAwsTempCredentials, ok := from.GetAwsTempCredentials(ctx); ok {
				// Recursively sync the fields of AwsTempCredentials
				toAwsTempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsTempCredentials)
				to.SetAwsTempCredentials(ctx, toAwsTempCredentials)
			}
		}
	}
	if !from.AzureAad.IsNull() && !from.AzureAad.IsUnknown() {
		if toAzureAad, ok := to.GetAzureAad(ctx); ok {
			if fromAzureAad, ok := from.GetAzureAad(ctx); ok {
				// Recursively sync the fields of AzureAad
				toAzureAad.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureAad)
				to.SetAzureAad(ctx, toAzureAad)
			}
		}
	}
	if !from.AzureUserDelegationSas.IsNull() && !from.AzureUserDelegationSas.IsUnknown() {
		if toAzureUserDelegationSas, ok := to.GetAzureUserDelegationSas(ctx); ok {
			if fromAzureUserDelegationSas, ok := from.GetAzureUserDelegationSas(ctx); ok {
				// Recursively sync the fields of AzureUserDelegationSas
				toAzureUserDelegationSas.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureUserDelegationSas)
				to.SetAzureUserDelegationSas(ctx, toAzureUserDelegationSas)
			}
		}
	}
	if !from.GcpOauthToken.IsNull() && !from.GcpOauthToken.IsUnknown() {
		if toGcpOauthToken, ok := to.GetGcpOauthToken(ctx); ok {
			if fromGcpOauthToken, ok := from.GetGcpOauthToken(ctx); ok {
				// Recursively sync the fields of GcpOauthToken
				toGcpOauthToken.SyncFieldsDuringCreateOrUpdate(ctx, fromGcpOauthToken)
				to.SetGcpOauthToken(ctx, toGcpOauthToken)
			}
		}
	}
	if !from.R2TempCredentials.IsNull() && !from.R2TempCredentials.IsUnknown() {
		if toR2TempCredentials, ok := to.GetR2TempCredentials(ctx); ok {
			if fromR2TempCredentials, ok := from.GetR2TempCredentials(ctx); ok {
				// Recursively sync the fields of R2TempCredentials
				toR2TempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromR2TempCredentials)
				to.SetR2TempCredentials(ctx, toR2TempCredentials)
			}
		}
	}
}

func (to *GenerateTemporaryPathCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryPathCredentialResponse_SdkV2) {
	if !from.AwsTempCredentials.IsNull() && !from.AwsTempCredentials.IsUnknown() {
		if toAwsTempCredentials, ok := to.GetAwsTempCredentials(ctx); ok {
			if fromAwsTempCredentials, ok := from.GetAwsTempCredentials(ctx); ok {
				toAwsTempCredentials.SyncFieldsDuringRead(ctx, fromAwsTempCredentials)
				to.SetAwsTempCredentials(ctx, toAwsTempCredentials)
			}
		}
	}
	if !from.AzureAad.IsNull() && !from.AzureAad.IsUnknown() {
		if toAzureAad, ok := to.GetAzureAad(ctx); ok {
			if fromAzureAad, ok := from.GetAzureAad(ctx); ok {
				toAzureAad.SyncFieldsDuringRead(ctx, fromAzureAad)
				to.SetAzureAad(ctx, toAzureAad)
			}
		}
	}
	if !from.AzureUserDelegationSas.IsNull() && !from.AzureUserDelegationSas.IsUnknown() {
		if toAzureUserDelegationSas, ok := to.GetAzureUserDelegationSas(ctx); ok {
			if fromAzureUserDelegationSas, ok := from.GetAzureUserDelegationSas(ctx); ok {
				toAzureUserDelegationSas.SyncFieldsDuringRead(ctx, fromAzureUserDelegationSas)
				to.SetAzureUserDelegationSas(ctx, toAzureUserDelegationSas)
			}
		}
	}
	if !from.GcpOauthToken.IsNull() && !from.GcpOauthToken.IsUnknown() {
		if toGcpOauthToken, ok := to.GetGcpOauthToken(ctx); ok {
			if fromGcpOauthToken, ok := from.GetGcpOauthToken(ctx); ok {
				toGcpOauthToken.SyncFieldsDuringRead(ctx, fromGcpOauthToken)
				to.SetGcpOauthToken(ctx, toGcpOauthToken)
			}
		}
	}
	if !from.R2TempCredentials.IsNull() && !from.R2TempCredentials.IsUnknown() {
		if toR2TempCredentials, ok := to.GetR2TempCredentials(ctx); ok {
			if fromR2TempCredentials, ok := from.GetR2TempCredentials(ctx); ok {
				toR2TempCredentials.SyncFieldsDuringRead(ctx, fromR2TempCredentials)
				to.SetR2TempCredentials(ctx, toR2TempCredentials)
			}
		}
	}
}

func (m GenerateTemporaryPathCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].SetOptional()
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_aad"] = attrs["azure_aad"].SetOptional()
	attrs["azure_aad"] = attrs["azure_aad"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_user_delegation_sas"] = attrs["azure_user_delegation_sas"].SetOptional()
	attrs["azure_user_delegation_sas"] = attrs["azure_user_delegation_sas"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["r2_temp_credentials"] = attrs["r2_temp_credentials"].SetOptional()
	attrs["r2_temp_credentials"] = attrs["r2_temp_credentials"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryPathCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryPathCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_temp_credentials":      reflect.TypeOf(AwsCredentials_SdkV2{}),
		"azure_aad":                 reflect.TypeOf(AzureActiveDirectoryToken_SdkV2{}),
		"azure_user_delegation_sas": reflect.TypeOf(AzureUserDelegationSas_SdkV2{}),
		"gcp_oauth_token":           reflect.TypeOf(GcpOauthToken_SdkV2{}),
		"r2_temp_credentials":       reflect.TypeOf(R2Credentials_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryPathCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryPathCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_temp_credentials":      m.AwsTempCredentials,
			"azure_aad":                 m.AzureAad,
			"azure_user_delegation_sas": m.AzureUserDelegationSas,
			"expiration_time":           m.ExpirationTime,
			"gcp_oauth_token":           m.GcpOauthToken,
			"r2_temp_credentials":       m.R2TempCredentials,
			"url":                       m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryPathCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_temp_credentials": basetypes.ListType{
				ElemType: AwsCredentials_SdkV2{}.Type(ctx),
			},
			"azure_aad": basetypes.ListType{
				ElemType: AzureActiveDirectoryToken_SdkV2{}.Type(ctx),
			},
			"azure_user_delegation_sas": basetypes.ListType{
				ElemType: AzureUserDelegationSas_SdkV2{}.Type(ctx),
			},
			"expiration_time": types.Int64Type,
			"gcp_oauth_token": basetypes.ListType{
				ElemType: GcpOauthToken_SdkV2{}.Type(ctx),
			},
			"r2_temp_credentials": basetypes.ListType{
				ElemType: R2Credentials_SdkV2{}.Type(ctx),
			},
			"url": types.StringType,
		},
	}
}

// GetAwsTempCredentials returns the value of the AwsTempCredentials field in GenerateTemporaryPathCredentialResponse_SdkV2 as
// a AwsCredentials_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) GetAwsTempCredentials(ctx context.Context) (AwsCredentials_SdkV2, bool) {
	var e AwsCredentials_SdkV2
	if m.AwsTempCredentials.IsNull() || m.AwsTempCredentials.IsUnknown() {
		return e, false
	}
	var v []AwsCredentials_SdkV2
	d := m.AwsTempCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsTempCredentials sets the value of the AwsTempCredentials field in GenerateTemporaryPathCredentialResponse_SdkV2.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) SetAwsTempCredentials(ctx context.Context, v AwsCredentials_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_temp_credentials"]
	m.AwsTempCredentials = types.ListValueMust(t, vs)
}

// GetAzureAad returns the value of the AzureAad field in GenerateTemporaryPathCredentialResponse_SdkV2 as
// a AzureActiveDirectoryToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) GetAzureAad(ctx context.Context) (AzureActiveDirectoryToken_SdkV2, bool) {
	var e AzureActiveDirectoryToken_SdkV2
	if m.AzureAad.IsNull() || m.AzureAad.IsUnknown() {
		return e, false
	}
	var v []AzureActiveDirectoryToken_SdkV2
	d := m.AzureAad.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureAad sets the value of the AzureAad field in GenerateTemporaryPathCredentialResponse_SdkV2.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) SetAzureAad(ctx context.Context, v AzureActiveDirectoryToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_aad"]
	m.AzureAad = types.ListValueMust(t, vs)
}

// GetAzureUserDelegationSas returns the value of the AzureUserDelegationSas field in GenerateTemporaryPathCredentialResponse_SdkV2 as
// a AzureUserDelegationSas_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) GetAzureUserDelegationSas(ctx context.Context) (AzureUserDelegationSas_SdkV2, bool) {
	var e AzureUserDelegationSas_SdkV2
	if m.AzureUserDelegationSas.IsNull() || m.AzureUserDelegationSas.IsUnknown() {
		return e, false
	}
	var v []AzureUserDelegationSas_SdkV2
	d := m.AzureUserDelegationSas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureUserDelegationSas sets the value of the AzureUserDelegationSas field in GenerateTemporaryPathCredentialResponse_SdkV2.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) SetAzureUserDelegationSas(ctx context.Context, v AzureUserDelegationSas_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_user_delegation_sas"]
	m.AzureUserDelegationSas = types.ListValueMust(t, vs)
}

// GetGcpOauthToken returns the value of the GcpOauthToken field in GenerateTemporaryPathCredentialResponse_SdkV2 as
// a GcpOauthToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) GetGcpOauthToken(ctx context.Context) (GcpOauthToken_SdkV2, bool) {
	var e GcpOauthToken_SdkV2
	if m.GcpOauthToken.IsNull() || m.GcpOauthToken.IsUnknown() {
		return e, false
	}
	var v []GcpOauthToken_SdkV2
	d := m.GcpOauthToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGcpOauthToken sets the value of the GcpOauthToken field in GenerateTemporaryPathCredentialResponse_SdkV2.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) SetGcpOauthToken(ctx context.Context, v GcpOauthToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gcp_oauth_token"]
	m.GcpOauthToken = types.ListValueMust(t, vs)
}

// GetR2TempCredentials returns the value of the R2TempCredentials field in GenerateTemporaryPathCredentialResponse_SdkV2 as
// a R2Credentials_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) GetR2TempCredentials(ctx context.Context) (R2Credentials_SdkV2, bool) {
	var e R2Credentials_SdkV2
	if m.R2TempCredentials.IsNull() || m.R2TempCredentials.IsUnknown() {
		return e, false
	}
	var v []R2Credentials_SdkV2
	d := m.R2TempCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetR2TempCredentials sets the value of the R2TempCredentials field in GenerateTemporaryPathCredentialResponse_SdkV2.
func (m *GenerateTemporaryPathCredentialResponse_SdkV2) SetR2TempCredentials(ctx context.Context, v R2Credentials_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["r2_temp_credentials"]
	m.R2TempCredentials = types.ListValueMust(t, vs)
}

// The Azure cloud options to customize the requested temporary credential
type GenerateTemporaryServiceCredentialAzureOptions_SdkV2 struct {
	// The resources to which the temporary Azure credential should apply. These
	// resources are the scopes that are passed to the token provider (see
	// https://learn.microsoft.com/python/api/azure-core/azure.core.credentials.tokencredential?view=azure-python)
	Resources types.List `tfsdk:"resources"`
}

func (to *GenerateTemporaryServiceCredentialAzureOptions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryServiceCredentialAzureOptions_SdkV2) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (to *GenerateTemporaryServiceCredentialAzureOptions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryServiceCredentialAzureOptions_SdkV2) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (m GenerateTemporaryServiceCredentialAzureOptions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryServiceCredentialAzureOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryServiceCredentialAzureOptions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryServiceCredentialAzureOptions_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryServiceCredentialAzureOptions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"resources": m.Resources,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryServiceCredentialAzureOptions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"resources": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetResources returns the value of the Resources field in GenerateTemporaryServiceCredentialAzureOptions_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryServiceCredentialAzureOptions_SdkV2) GetResources(ctx context.Context) ([]types.String, bool) {
	if m.Resources.IsNull() || m.Resources.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in GenerateTemporaryServiceCredentialAzureOptions_SdkV2.
func (m *GenerateTemporaryServiceCredentialAzureOptions_SdkV2) SetResources(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Resources = types.ListValueMust(t, vs)
}

// The GCP cloud options to customize the requested temporary credential
type GenerateTemporaryServiceCredentialGcpOptions_SdkV2 struct {
	// The scopes to which the temporary GCP credential should apply. These
	// resources are the scopes that are passed to the token provider (see
	// https://google-auth.readthedocs.io/en/latest/reference/google.auth.html#google.auth.credentials.Credentials)
	Scopes types.List `tfsdk:"scopes"`
}

func (to *GenerateTemporaryServiceCredentialGcpOptions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryServiceCredentialGcpOptions_SdkV2) {
	if !from.Scopes.IsNull() && !from.Scopes.IsUnknown() && to.Scopes.IsNull() && len(from.Scopes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Scopes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Scopes = from.Scopes
	}
}

func (to *GenerateTemporaryServiceCredentialGcpOptions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryServiceCredentialGcpOptions_SdkV2) {
	if !from.Scopes.IsNull() && !from.Scopes.IsUnknown() && to.Scopes.IsNull() && len(from.Scopes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Scopes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Scopes = from.Scopes
	}
}

func (m GenerateTemporaryServiceCredentialGcpOptions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["scopes"] = attrs["scopes"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryServiceCredentialGcpOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryServiceCredentialGcpOptions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"scopes": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryServiceCredentialGcpOptions_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryServiceCredentialGcpOptions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"scopes": m.Scopes,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryServiceCredentialGcpOptions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"scopes": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetScopes returns the value of the Scopes field in GenerateTemporaryServiceCredentialGcpOptions_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryServiceCredentialGcpOptions_SdkV2) GetScopes(ctx context.Context) ([]types.String, bool) {
	if m.Scopes.IsNull() || m.Scopes.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Scopes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetScopes sets the value of the Scopes field in GenerateTemporaryServiceCredentialGcpOptions_SdkV2.
func (m *GenerateTemporaryServiceCredentialGcpOptions_SdkV2) SetScopes(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["scopes"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Scopes = types.ListValueMust(t, vs)
}

type GenerateTemporaryServiceCredentialRequest_SdkV2 struct {
	AzureOptions types.List `tfsdk:"azure_options"`
	// The name of the service credential used to generate a temporary
	// credential
	CredentialName types.String `tfsdk:"credential_name"`

	GcpOptions types.List `tfsdk:"gcp_options"`
}

func (to *GenerateTemporaryServiceCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryServiceCredentialRequest_SdkV2) {
	if !from.AzureOptions.IsNull() && !from.AzureOptions.IsUnknown() {
		if toAzureOptions, ok := to.GetAzureOptions(ctx); ok {
			if fromAzureOptions, ok := from.GetAzureOptions(ctx); ok {
				// Recursively sync the fields of AzureOptions
				toAzureOptions.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureOptions)
				to.SetAzureOptions(ctx, toAzureOptions)
			}
		}
	}
	if !from.GcpOptions.IsNull() && !from.GcpOptions.IsUnknown() {
		if toGcpOptions, ok := to.GetGcpOptions(ctx); ok {
			if fromGcpOptions, ok := from.GetGcpOptions(ctx); ok {
				// Recursively sync the fields of GcpOptions
				toGcpOptions.SyncFieldsDuringCreateOrUpdate(ctx, fromGcpOptions)
				to.SetGcpOptions(ctx, toGcpOptions)
			}
		}
	}
}

func (to *GenerateTemporaryServiceCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryServiceCredentialRequest_SdkV2) {
	if !from.AzureOptions.IsNull() && !from.AzureOptions.IsUnknown() {
		if toAzureOptions, ok := to.GetAzureOptions(ctx); ok {
			if fromAzureOptions, ok := from.GetAzureOptions(ctx); ok {
				toAzureOptions.SyncFieldsDuringRead(ctx, fromAzureOptions)
				to.SetAzureOptions(ctx, toAzureOptions)
			}
		}
	}
	if !from.GcpOptions.IsNull() && !from.GcpOptions.IsUnknown() {
		if toGcpOptions, ok := to.GetGcpOptions(ctx); ok {
			if fromGcpOptions, ok := from.GetGcpOptions(ctx); ok {
				toGcpOptions.SyncFieldsDuringRead(ctx, fromGcpOptions)
				to.SetGcpOptions(ctx, toGcpOptions)
			}
		}
	}
}

func (m GenerateTemporaryServiceCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["azure_options"] = attrs["azure_options"].SetOptional()
	attrs["azure_options"] = attrs["azure_options"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["credential_name"] = attrs["credential_name"].SetRequired()
	attrs["gcp_options"] = attrs["gcp_options"].SetOptional()
	attrs["gcp_options"] = attrs["gcp_options"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryServiceCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryServiceCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"azure_options": reflect.TypeOf(GenerateTemporaryServiceCredentialAzureOptions_SdkV2{}),
		"gcp_options":   reflect.TypeOf(GenerateTemporaryServiceCredentialGcpOptions_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryServiceCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryServiceCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"azure_options":   m.AzureOptions,
			"credential_name": m.CredentialName,
			"gcp_options":     m.GcpOptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryServiceCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"azure_options": basetypes.ListType{
				ElemType: GenerateTemporaryServiceCredentialAzureOptions_SdkV2{}.Type(ctx),
			},
			"credential_name": types.StringType,
			"gcp_options": basetypes.ListType{
				ElemType: GenerateTemporaryServiceCredentialGcpOptions_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetAzureOptions returns the value of the AzureOptions field in GenerateTemporaryServiceCredentialRequest_SdkV2 as
// a GenerateTemporaryServiceCredentialAzureOptions_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryServiceCredentialRequest_SdkV2) GetAzureOptions(ctx context.Context) (GenerateTemporaryServiceCredentialAzureOptions_SdkV2, bool) {
	var e GenerateTemporaryServiceCredentialAzureOptions_SdkV2
	if m.AzureOptions.IsNull() || m.AzureOptions.IsUnknown() {
		return e, false
	}
	var v []GenerateTemporaryServiceCredentialAzureOptions_SdkV2
	d := m.AzureOptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureOptions sets the value of the AzureOptions field in GenerateTemporaryServiceCredentialRequest_SdkV2.
func (m *GenerateTemporaryServiceCredentialRequest_SdkV2) SetAzureOptions(ctx context.Context, v GenerateTemporaryServiceCredentialAzureOptions_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_options"]
	m.AzureOptions = types.ListValueMust(t, vs)
}

// GetGcpOptions returns the value of the GcpOptions field in GenerateTemporaryServiceCredentialRequest_SdkV2 as
// a GenerateTemporaryServiceCredentialGcpOptions_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryServiceCredentialRequest_SdkV2) GetGcpOptions(ctx context.Context) (GenerateTemporaryServiceCredentialGcpOptions_SdkV2, bool) {
	var e GenerateTemporaryServiceCredentialGcpOptions_SdkV2
	if m.GcpOptions.IsNull() || m.GcpOptions.IsUnknown() {
		return e, false
	}
	var v []GenerateTemporaryServiceCredentialGcpOptions_SdkV2
	d := m.GcpOptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGcpOptions sets the value of the GcpOptions field in GenerateTemporaryServiceCredentialRequest_SdkV2.
func (m *GenerateTemporaryServiceCredentialRequest_SdkV2) SetGcpOptions(ctx context.Context, v GenerateTemporaryServiceCredentialGcpOptions_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gcp_options"]
	m.GcpOptions = types.ListValueMust(t, vs)
}

type GenerateTemporaryTableCredentialRequest_SdkV2 struct {
	// The operation performed against the table data, either READ or
	// READ_WRITE. If READ_WRITE is specified, the credentials returned will
	// have write permissions, otherwise, it will be read only.
	Operation types.String `tfsdk:"operation"`
	// UUID of the table to read or write.
	TableId types.String `tfsdk:"table_id"`
}

func (to *GenerateTemporaryTableCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryTableCredentialRequest_SdkV2) {
}

func (to *GenerateTemporaryTableCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryTableCredentialRequest_SdkV2) {
}

func (m GenerateTemporaryTableCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operation"] = attrs["operation"].SetOptional()
	attrs["table_id"] = attrs["table_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryTableCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryTableCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryTableCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryTableCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"operation": m.Operation,
			"table_id":  m.TableId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryTableCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"operation": types.StringType,
			"table_id":  types.StringType,
		},
	}
}

type GenerateTemporaryTableCredentialResponse_SdkV2 struct {
	AwsTempCredentials types.List `tfsdk:"aws_temp_credentials"`

	AzureAad types.List `tfsdk:"azure_aad"`

	AzureUserDelegationSas types.List `tfsdk:"azure_user_delegation_sas"`
	// Server time when the credential will expire, in epoch milliseconds. The
	// API client is advised to cache the credential given this expiration time.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	GcpOauthToken types.List `tfsdk:"gcp_oauth_token"`

	R2TempCredentials types.List `tfsdk:"r2_temp_credentials"`
	// The URL of the storage path accessible by the temporary credential.
	Url types.String `tfsdk:"url"`
}

func (to *GenerateTemporaryTableCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenerateTemporaryTableCredentialResponse_SdkV2) {
	if !from.AwsTempCredentials.IsNull() && !from.AwsTempCredentials.IsUnknown() {
		if toAwsTempCredentials, ok := to.GetAwsTempCredentials(ctx); ok {
			if fromAwsTempCredentials, ok := from.GetAwsTempCredentials(ctx); ok {
				// Recursively sync the fields of AwsTempCredentials
				toAwsTempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsTempCredentials)
				to.SetAwsTempCredentials(ctx, toAwsTempCredentials)
			}
		}
	}
	if !from.AzureAad.IsNull() && !from.AzureAad.IsUnknown() {
		if toAzureAad, ok := to.GetAzureAad(ctx); ok {
			if fromAzureAad, ok := from.GetAzureAad(ctx); ok {
				// Recursively sync the fields of AzureAad
				toAzureAad.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureAad)
				to.SetAzureAad(ctx, toAzureAad)
			}
		}
	}
	if !from.AzureUserDelegationSas.IsNull() && !from.AzureUserDelegationSas.IsUnknown() {
		if toAzureUserDelegationSas, ok := to.GetAzureUserDelegationSas(ctx); ok {
			if fromAzureUserDelegationSas, ok := from.GetAzureUserDelegationSas(ctx); ok {
				// Recursively sync the fields of AzureUserDelegationSas
				toAzureUserDelegationSas.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureUserDelegationSas)
				to.SetAzureUserDelegationSas(ctx, toAzureUserDelegationSas)
			}
		}
	}
	if !from.GcpOauthToken.IsNull() && !from.GcpOauthToken.IsUnknown() {
		if toGcpOauthToken, ok := to.GetGcpOauthToken(ctx); ok {
			if fromGcpOauthToken, ok := from.GetGcpOauthToken(ctx); ok {
				// Recursively sync the fields of GcpOauthToken
				toGcpOauthToken.SyncFieldsDuringCreateOrUpdate(ctx, fromGcpOauthToken)
				to.SetGcpOauthToken(ctx, toGcpOauthToken)
			}
		}
	}
	if !from.R2TempCredentials.IsNull() && !from.R2TempCredentials.IsUnknown() {
		if toR2TempCredentials, ok := to.GetR2TempCredentials(ctx); ok {
			if fromR2TempCredentials, ok := from.GetR2TempCredentials(ctx); ok {
				// Recursively sync the fields of R2TempCredentials
				toR2TempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromR2TempCredentials)
				to.SetR2TempCredentials(ctx, toR2TempCredentials)
			}
		}
	}
}

func (to *GenerateTemporaryTableCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenerateTemporaryTableCredentialResponse_SdkV2) {
	if !from.AwsTempCredentials.IsNull() && !from.AwsTempCredentials.IsUnknown() {
		if toAwsTempCredentials, ok := to.GetAwsTempCredentials(ctx); ok {
			if fromAwsTempCredentials, ok := from.GetAwsTempCredentials(ctx); ok {
				toAwsTempCredentials.SyncFieldsDuringRead(ctx, fromAwsTempCredentials)
				to.SetAwsTempCredentials(ctx, toAwsTempCredentials)
			}
		}
	}
	if !from.AzureAad.IsNull() && !from.AzureAad.IsUnknown() {
		if toAzureAad, ok := to.GetAzureAad(ctx); ok {
			if fromAzureAad, ok := from.GetAzureAad(ctx); ok {
				toAzureAad.SyncFieldsDuringRead(ctx, fromAzureAad)
				to.SetAzureAad(ctx, toAzureAad)
			}
		}
	}
	if !from.AzureUserDelegationSas.IsNull() && !from.AzureUserDelegationSas.IsUnknown() {
		if toAzureUserDelegationSas, ok := to.GetAzureUserDelegationSas(ctx); ok {
			if fromAzureUserDelegationSas, ok := from.GetAzureUserDelegationSas(ctx); ok {
				toAzureUserDelegationSas.SyncFieldsDuringRead(ctx, fromAzureUserDelegationSas)
				to.SetAzureUserDelegationSas(ctx, toAzureUserDelegationSas)
			}
		}
	}
	if !from.GcpOauthToken.IsNull() && !from.GcpOauthToken.IsUnknown() {
		if toGcpOauthToken, ok := to.GetGcpOauthToken(ctx); ok {
			if fromGcpOauthToken, ok := from.GetGcpOauthToken(ctx); ok {
				toGcpOauthToken.SyncFieldsDuringRead(ctx, fromGcpOauthToken)
				to.SetGcpOauthToken(ctx, toGcpOauthToken)
			}
		}
	}
	if !from.R2TempCredentials.IsNull() && !from.R2TempCredentials.IsUnknown() {
		if toR2TempCredentials, ok := to.GetR2TempCredentials(ctx); ok {
			if fromR2TempCredentials, ok := from.GetR2TempCredentials(ctx); ok {
				toR2TempCredentials.SyncFieldsDuringRead(ctx, fromR2TempCredentials)
				to.SetR2TempCredentials(ctx, toR2TempCredentials)
			}
		}
	}
}

func (m GenerateTemporaryTableCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].SetOptional()
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_aad"] = attrs["azure_aad"].SetOptional()
	attrs["azure_aad"] = attrs["azure_aad"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_user_delegation_sas"] = attrs["azure_user_delegation_sas"].SetOptional()
	attrs["azure_user_delegation_sas"] = attrs["azure_user_delegation_sas"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["r2_temp_credentials"] = attrs["r2_temp_credentials"].SetOptional()
	attrs["r2_temp_credentials"] = attrs["r2_temp_credentials"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryTableCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenerateTemporaryTableCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_temp_credentials":      reflect.TypeOf(AwsCredentials_SdkV2{}),
		"azure_aad":                 reflect.TypeOf(AzureActiveDirectoryToken_SdkV2{}),
		"azure_user_delegation_sas": reflect.TypeOf(AzureUserDelegationSas_SdkV2{}),
		"gcp_oauth_token":           reflect.TypeOf(GcpOauthToken_SdkV2{}),
		"r2_temp_credentials":       reflect.TypeOf(R2Credentials_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryTableCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GenerateTemporaryTableCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_temp_credentials":      m.AwsTempCredentials,
			"azure_aad":                 m.AzureAad,
			"azure_user_delegation_sas": m.AzureUserDelegationSas,
			"expiration_time":           m.ExpirationTime,
			"gcp_oauth_token":           m.GcpOauthToken,
			"r2_temp_credentials":       m.R2TempCredentials,
			"url":                       m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenerateTemporaryTableCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_temp_credentials": basetypes.ListType{
				ElemType: AwsCredentials_SdkV2{}.Type(ctx),
			},
			"azure_aad": basetypes.ListType{
				ElemType: AzureActiveDirectoryToken_SdkV2{}.Type(ctx),
			},
			"azure_user_delegation_sas": basetypes.ListType{
				ElemType: AzureUserDelegationSas_SdkV2{}.Type(ctx),
			},
			"expiration_time": types.Int64Type,
			"gcp_oauth_token": basetypes.ListType{
				ElemType: GcpOauthToken_SdkV2{}.Type(ctx),
			},
			"r2_temp_credentials": basetypes.ListType{
				ElemType: R2Credentials_SdkV2{}.Type(ctx),
			},
			"url": types.StringType,
		},
	}
}

// GetAwsTempCredentials returns the value of the AwsTempCredentials field in GenerateTemporaryTableCredentialResponse_SdkV2 as
// a AwsCredentials_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) GetAwsTempCredentials(ctx context.Context) (AwsCredentials_SdkV2, bool) {
	var e AwsCredentials_SdkV2
	if m.AwsTempCredentials.IsNull() || m.AwsTempCredentials.IsUnknown() {
		return e, false
	}
	var v []AwsCredentials_SdkV2
	d := m.AwsTempCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsTempCredentials sets the value of the AwsTempCredentials field in GenerateTemporaryTableCredentialResponse_SdkV2.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) SetAwsTempCredentials(ctx context.Context, v AwsCredentials_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_temp_credentials"]
	m.AwsTempCredentials = types.ListValueMust(t, vs)
}

// GetAzureAad returns the value of the AzureAad field in GenerateTemporaryTableCredentialResponse_SdkV2 as
// a AzureActiveDirectoryToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) GetAzureAad(ctx context.Context) (AzureActiveDirectoryToken_SdkV2, bool) {
	var e AzureActiveDirectoryToken_SdkV2
	if m.AzureAad.IsNull() || m.AzureAad.IsUnknown() {
		return e, false
	}
	var v []AzureActiveDirectoryToken_SdkV2
	d := m.AzureAad.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureAad sets the value of the AzureAad field in GenerateTemporaryTableCredentialResponse_SdkV2.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) SetAzureAad(ctx context.Context, v AzureActiveDirectoryToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_aad"]
	m.AzureAad = types.ListValueMust(t, vs)
}

// GetAzureUserDelegationSas returns the value of the AzureUserDelegationSas field in GenerateTemporaryTableCredentialResponse_SdkV2 as
// a AzureUserDelegationSas_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) GetAzureUserDelegationSas(ctx context.Context) (AzureUserDelegationSas_SdkV2, bool) {
	var e AzureUserDelegationSas_SdkV2
	if m.AzureUserDelegationSas.IsNull() || m.AzureUserDelegationSas.IsUnknown() {
		return e, false
	}
	var v []AzureUserDelegationSas_SdkV2
	d := m.AzureUserDelegationSas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureUserDelegationSas sets the value of the AzureUserDelegationSas field in GenerateTemporaryTableCredentialResponse_SdkV2.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) SetAzureUserDelegationSas(ctx context.Context, v AzureUserDelegationSas_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_user_delegation_sas"]
	m.AzureUserDelegationSas = types.ListValueMust(t, vs)
}

// GetGcpOauthToken returns the value of the GcpOauthToken field in GenerateTemporaryTableCredentialResponse_SdkV2 as
// a GcpOauthToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) GetGcpOauthToken(ctx context.Context) (GcpOauthToken_SdkV2, bool) {
	var e GcpOauthToken_SdkV2
	if m.GcpOauthToken.IsNull() || m.GcpOauthToken.IsUnknown() {
		return e, false
	}
	var v []GcpOauthToken_SdkV2
	d := m.GcpOauthToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGcpOauthToken sets the value of the GcpOauthToken field in GenerateTemporaryTableCredentialResponse_SdkV2.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) SetGcpOauthToken(ctx context.Context, v GcpOauthToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gcp_oauth_token"]
	m.GcpOauthToken = types.ListValueMust(t, vs)
}

// GetR2TempCredentials returns the value of the R2TempCredentials field in GenerateTemporaryTableCredentialResponse_SdkV2 as
// a R2Credentials_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) GetR2TempCredentials(ctx context.Context) (R2Credentials_SdkV2, bool) {
	var e R2Credentials_SdkV2
	if m.R2TempCredentials.IsNull() || m.R2TempCredentials.IsUnknown() {
		return e, false
	}
	var v []R2Credentials_SdkV2
	d := m.R2TempCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetR2TempCredentials sets the value of the R2TempCredentials field in GenerateTemporaryTableCredentialResponse_SdkV2.
func (m *GenerateTemporaryTableCredentialResponse_SdkV2) SetR2TempCredentials(ctx context.Context, v R2Credentials_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["r2_temp_credentials"]
	m.R2TempCredentials = types.ListValueMust(t, vs)
}

type GetAccessRequestDestinationsRequest_SdkV2 struct {
	// The full name of the securable.
	FullName types.String `tfsdk:"-"`
	// The type of the securable.
	SecurableType types.String `tfsdk:"-"`
}

func (to *GetAccessRequestDestinationsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccessRequestDestinationsRequest_SdkV2) {
}

func (to *GetAccessRequestDestinationsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetAccessRequestDestinationsRequest_SdkV2) {
}

func (m GetAccessRequestDestinationsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccessRequestDestinationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetAccessRequestDestinationsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccessRequestDestinationsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetAccessRequestDestinationsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      m.FullName,
			"securable_type": m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetAccessRequestDestinationsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetAccountMetastoreAssignmentRequest_SdkV2 struct {
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *GetAccountMetastoreAssignmentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccountMetastoreAssignmentRequest_SdkV2) {
}

func (to *GetAccountMetastoreAssignmentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetAccountMetastoreAssignmentRequest_SdkV2) {
}

func (m GetAccountMetastoreAssignmentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountMetastoreAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetAccountMetastoreAssignmentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountMetastoreAssignmentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetAccountMetastoreAssignmentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspace_id": m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetAccountMetastoreAssignmentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspace_id": types.Int64Type,
		},
	}
}

type GetAccountMetastoreRequest_SdkV2 struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (to *GetAccountMetastoreRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccountMetastoreRequest_SdkV2) {
}

func (to *GetAccountMetastoreRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetAccountMetastoreRequest_SdkV2) {
}

func (m GetAccountMetastoreRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetAccountMetastoreRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountMetastoreRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetAccountMetastoreRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": m.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetAccountMetastoreRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
		},
	}
}

type GetAccountStorageCredentialRequest_SdkV2 struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Required. Name of the storage credential.
	StorageCredentialName types.String `tfsdk:"-"`
}

func (to *GetAccountStorageCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccountStorageCredentialRequest_SdkV2) {
}

func (to *GetAccountStorageCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetAccountStorageCredentialRequest_SdkV2) {
}

func (m GetAccountStorageCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetAccountStorageCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountStorageCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetAccountStorageCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id":            m.MetastoreId,
			"storage_credential_name": m.StorageCredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetAccountStorageCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id":            types.StringType,
			"storage_credential_name": types.StringType,
		},
	}
}

type GetArtifactAllowlistRequest_SdkV2 struct {
	// The artifact type of the allowlist.
	ArtifactType types.String `tfsdk:"-"`
}

func (to *GetArtifactAllowlistRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetArtifactAllowlistRequest_SdkV2) {
}

func (to *GetArtifactAllowlistRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetArtifactAllowlistRequest_SdkV2) {
}

func (m GetArtifactAllowlistRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact_type"] = attrs["artifact_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetArtifactAllowlistRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetArtifactAllowlistRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetArtifactAllowlistRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetArtifactAllowlistRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact_type": m.ArtifactType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetArtifactAllowlistRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact_type": types.StringType,
		},
	}
}

type GetBindingsRequest_SdkV2 struct {
	// Maximum number of workspace bindings to return. - When set to 0, the page
	// length is set to a server configured value (recommended); - When set to a
	// value greater than 0, the page length is the minimum of this value and a
	// server configured value; - When set to a value less than 0, an invalid
	// parameter error is returned; - If not set, all the workspace bindings are
	// returned (not recommended).
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// The name of the securable.
	SecurableName types.String `tfsdk:"-"`
	// The type of the securable to bind to a workspace (catalog,
	// storage_credential, credential, or external_location).
	SecurableType types.String `tfsdk:"-"`
}

func (to *GetBindingsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetBindingsRequest_SdkV2) {
}

func (to *GetBindingsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetBindingsRequest_SdkV2) {
}

func (m GetBindingsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["securable_name"] = attrs["securable_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetBindingsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetBindingsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetBindingsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetBindingsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
			"securable_name": m.SecurableName,
			"securable_type": m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetBindingsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"securable_name": types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetByAliasRequest_SdkV2 struct {
	// The name of the alias
	Alias types.String `tfsdk:"-"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// Whether to include aliases associated with the model version in the
	// response
	IncludeAliases types.Bool `tfsdk:"-"`
}

func (to *GetByAliasRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetByAliasRequest_SdkV2) {
}

func (to *GetByAliasRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetByAliasRequest_SdkV2) {
}

func (m GetByAliasRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["alias"] = attrs["alias"].SetRequired()
	attrs["include_aliases"] = attrs["include_aliases"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetByAliasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetByAliasRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetByAliasRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetByAliasRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":           m.Alias,
			"full_name":       m.FullName,
			"include_aliases": m.IncludeAliases,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetByAliasRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":           types.StringType,
			"full_name":       types.StringType,
			"include_aliases": types.BoolType,
		},
	}
}

type GetCatalogRequest_SdkV2 struct {
	// Whether to include catalogs in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
}

func (to *GetCatalogRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetCatalogRequest_SdkV2) {
}

func (to *GetCatalogRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetCatalogRequest_SdkV2) {
}

func (m GetCatalogRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCatalogRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetCatalogRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCatalogRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetCatalogRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": m.IncludeBrowse,
			"name":           m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetCatalogRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type GetCatalogWorkspaceBindingsResponse_SdkV2 struct {
	// A list of workspace IDs
	Workspaces types.List `tfsdk:"workspaces"`
}

func (to *GetCatalogWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetCatalogWorkspaceBindingsResponse_SdkV2) {
	if !from.Workspaces.IsNull() && !from.Workspaces.IsUnknown() && to.Workspaces.IsNull() && len(from.Workspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Workspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Workspaces = from.Workspaces
	}
}

func (to *GetCatalogWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetCatalogWorkspaceBindingsResponse_SdkV2) {
	if !from.Workspaces.IsNull() && !from.Workspaces.IsUnknown() && to.Workspaces.IsNull() && len(from.Workspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Workspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Workspaces = from.Workspaces
	}
}

func (m GetCatalogWorkspaceBindingsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspaces"] = attrs["workspaces"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCatalogWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetCatalogWorkspaceBindingsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"workspaces": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCatalogWorkspaceBindingsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetCatalogWorkspaceBindingsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspaces": m.Workspaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetCatalogWorkspaceBindingsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetWorkspaces returns the value of the Workspaces field in GetCatalogWorkspaceBindingsResponse_SdkV2 as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetCatalogWorkspaceBindingsResponse_SdkV2) GetWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if m.Workspaces.IsNull() || m.Workspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.Workspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWorkspaces sets the value of the Workspaces field in GetCatalogWorkspaceBindingsResponse_SdkV2.
func (m *GetCatalogWorkspaceBindingsResponse_SdkV2) SetWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Workspaces = types.ListValueMust(t, vs)
}

type GetConnectionRequest_SdkV2 struct {
	// Name of the connection.
	Name types.String `tfsdk:"-"`
}

func (to *GetConnectionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetConnectionRequest_SdkV2) {
}

func (to *GetConnectionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetConnectionRequest_SdkV2) {
}

func (m GetConnectionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetConnectionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetConnectionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetConnectionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetConnectionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetConnectionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetCredentialRequest_SdkV2 struct {
	// Name of the credential.
	NameArg types.String `tfsdk:"-"`
}

func (to *GetCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetCredentialRequest_SdkV2) {
}

func (to *GetCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetCredentialRequest_SdkV2) {
}

func (m GetCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name_arg"] = attrs["name_arg"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name_arg": m.NameArg,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name_arg": types.StringType,
		},
	}
}

type GetEffectiveRequest_SdkV2 struct {
	// Full name of securable.
	FullName types.String `tfsdk:"-"`
	// Specifies the maximum number of privileges to return (page length). Every
	// EffectivePrivilegeAssignment present in a single page response is
	// guaranteed to contain all the effective privileges granted on (or
	// inherited by) the requested Securable for the respective principal.
	//
	// If not set, all the effective permissions are returned. If set to -
	// lesser than 0: invalid parameter error - 0: page length is set to a
	// server configured value - lesser than 150 but greater than 0: invalid
	// parameter error (this is to ensure that server is able to return at least
	// one complete EffectivePrivilegeAssignment in a single page response) -
	// greater than (or equal to) 150: page length is the minimum of this value
	// and a server configured value
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token for the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// If provided, only the effective permissions for the specified principal
	// (user or group) are returned.
	Principal types.String `tfsdk:"-"`
	// Type of securable.
	SecurableType types.String `tfsdk:"-"`
}

func (to *GetEffectiveRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetEffectiveRequest_SdkV2) {
}

func (to *GetEffectiveRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetEffectiveRequest_SdkV2) {
}

func (m GetEffectiveRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetEffectiveRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetEffectiveRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetEffectiveRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetEffectiveRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      m.FullName,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
			"principal":      m.Principal,
			"securable_type": m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetEffectiveRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"principal":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetEntityTagAssignmentRequest_SdkV2 struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`
	// Required. The key of the tag
	TagKey types.String `tfsdk:"-"`
}

func (to *GetEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetEntityTagAssignmentRequest_SdkV2) {
}

func (to *GetEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetEntityTagAssignmentRequest_SdkV2) {
}

func (m GetEntityTagAssignmentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetEntityTagAssignmentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetEntityTagAssignmentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetEntityTagAssignmentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": m.EntityName,
			"entity_type": m.EntityType,
			"tag_key":     m.TagKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetEntityTagAssignmentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_key":     types.StringType,
		},
	}
}

type GetExternalLocationRequest_SdkV2 struct {
	// Whether to include external locations in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Name of the external location.
	Name types.String `tfsdk:"-"`
}

func (to *GetExternalLocationRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetExternalLocationRequest_SdkV2) {
}

func (to *GetExternalLocationRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetExternalLocationRequest_SdkV2) {
}

func (m GetExternalLocationRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetExternalLocationRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetExternalLocationRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetExternalLocationRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetExternalLocationRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": m.IncludeBrowse,
			"name":           m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetExternalLocationRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type GetExternalMetadataRequest_SdkV2 struct {
	Name types.String `tfsdk:"-"`
}

func (to *GetExternalMetadataRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetExternalMetadataRequest_SdkV2) {
}

func (to *GetExternalMetadataRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetExternalMetadataRequest_SdkV2) {
}

func (m GetExternalMetadataRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetExternalMetadataRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetExternalMetadataRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetExternalMetadataRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetExternalMetadataRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetFunctionRequest_SdkV2 struct {
	// Whether to include functions in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The fully-qualified name of the function (of the form
	// __catalog_name__.__schema_name__.__function__name__).
	Name types.String `tfsdk:"-"`
}

func (to *GetFunctionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetFunctionRequest_SdkV2) {
}

func (to *GetFunctionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetFunctionRequest_SdkV2) {
}

func (m GetFunctionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetFunctionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetFunctionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetFunctionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetFunctionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": m.IncludeBrowse,
			"name":           m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetFunctionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type GetGrantRequest_SdkV2 struct {
	// Full name of securable.
	FullName types.String `tfsdk:"-"`
	// Specifies the maximum number of privileges to return (page length). Every
	// PrivilegeAssignment present in a single page response is guaranteed to
	// contain all the privileges granted on the requested Securable for the
	// respective principal.
	//
	// If not set, all the permissions are returned. If set to - lesser than 0:
	// invalid parameter error - 0: page length is set to a server configured
	// value - lesser than 150 but greater than 0: invalid parameter error (this
	// is to ensure that server is able to return at least one complete
	// PrivilegeAssignment in a single page response) - greater than (or equal
	// to) 150: page length is the minimum of this value and a server configured
	// value
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// If provided, only the permissions for the specified principal (user or
	// group) are returned.
	Principal types.String `tfsdk:"-"`
	// Type of securable.
	SecurableType types.String `tfsdk:"-"`
}

func (to *GetGrantRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetGrantRequest_SdkV2) {
}

func (to *GetGrantRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetGrantRequest_SdkV2) {
}

func (m GetGrantRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetGrantRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetGrantRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetGrantRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetGrantRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      m.FullName,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
			"principal":      m.Principal,
			"securable_type": m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetGrantRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"principal":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetMetastoreRequest_SdkV2 struct {
	// Unique ID of the metastore.
	Id types.String `tfsdk:"-"`
}

func (to *GetMetastoreRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetMetastoreRequest_SdkV2) {
}

func (to *GetMetastoreRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetMetastoreRequest_SdkV2) {
}

func (m GetMetastoreRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetMetastoreRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetMetastoreRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetMetastoreRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetMetastoreRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetMetastoreSummaryResponse_SdkV2 struct {
	// Cloud vendor of the metastore home shard (e.g., `aws`, `azure`, `gcp`).
	Cloud types.String `tfsdk:"cloud"`
	// Time at which this metastore was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of metastore creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of the metastore's (Default) Data Access Configuration.
	DefaultDataAccessConfigId types.String `tfsdk:"default_data_access_config_id"`
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// Whether to allow non-DBR clients to directly access entities under the
	// metastore.
	ExternalAccessEnabled types.Bool `tfsdk:"external_access_enabled"`
	// Globally unique metastore ID across clouds and regions, of the form
	// `cloud:region:metastore_id`.
	GlobalMetastoreId types.String `tfsdk:"global_metastore_id"`
	// Unique identifier of metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
	// Name of the storage credential to access the metastore storage_root.
	StorageRootCredentialName types.String `tfsdk:"storage_root_credential_name"`
	// Time at which the metastore was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the metastore.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *GetMetastoreSummaryResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetMetastoreSummaryResponse_SdkV2) {
}

func (to *GetMetastoreSummaryResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetMetastoreSummaryResponse_SdkV2) {
}

func (m GetMetastoreSummaryResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["cloud"] = attrs["cloud"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["default_data_access_config_id"] = attrs["default_data_access_config_id"].SetOptional()
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["external_access_enabled"] = attrs["external_access_enabled"].SetOptional()
	attrs["global_metastore_id"] = attrs["global_metastore_id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()
	attrs["storage_root_credential_name"] = attrs["storage_root_credential_name"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetMetastoreSummaryResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetMetastoreSummaryResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetMetastoreSummaryResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetMetastoreSummaryResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cloud":                           m.Cloud,
			"created_at":                      m.CreatedAt,
			"created_by":                      m.CreatedBy,
			"default_data_access_config_id":   m.DefaultDataAccessConfigId,
			"delta_sharing_organization_name": m.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": m.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               m.DeltaSharingScope,
			"external_access_enabled":                           m.ExternalAccessEnabled,
			"global_metastore_id":                               m.GlobalMetastoreId,
			"metastore_id":                                      m.MetastoreId,
			"name":                                              m.Name,
			"owner":                                             m.Owner,
			"privilege_model_version":                           m.PrivilegeModelVersion,
			"region":                                            m.Region,
			"storage_root":                                      m.StorageRoot,
			"storage_root_credential_id":                        m.StorageRootCredentialId,
			"storage_root_credential_name":                      m.StorageRootCredentialName,
			"updated_at":                                        m.UpdatedAt,
			"updated_by":                                        m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetMetastoreSummaryResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cloud":                           types.StringType,
			"created_at":                      types.Int64Type,
			"created_by":                      types.StringType,
			"default_data_access_config_id":   types.StringType,
			"delta_sharing_organization_name": types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"external_access_enabled":                           types.BoolType,
			"global_metastore_id":                               types.StringType,
			"metastore_id":                                      types.StringType,
			"name":                                              types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"region":                                            types.StringType,
			"storage_root":                                      types.StringType,
			"storage_root_credential_id":                        types.StringType,
			"storage_root_credential_name":                      types.StringType,
			"updated_at":                                        types.Int64Type,
			"updated_by":                                        types.StringType,
		},
	}
}

type GetModelVersionRequest_SdkV2 struct {
	// The three-level (fully qualified) name of the model version
	FullName types.String `tfsdk:"-"`
	// Whether to include aliases associated with the model version in the
	// response
	IncludeAliases types.Bool `tfsdk:"-"`
	// Whether to include model versions in the response for which the principal
	// can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The integer version number of the model version
	Version types.Int64 `tfsdk:"-"`
}

func (to *GetModelVersionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetModelVersionRequest_SdkV2) {
}

func (to *GetModelVersionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetModelVersionRequest_SdkV2) {
}

func (m GetModelVersionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version"] = attrs["version"].SetRequired()
	attrs["include_aliases"] = attrs["include_aliases"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetModelVersionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetModelVersionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetModelVersionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetModelVersionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":       m.FullName,
			"include_aliases": m.IncludeAliases,
			"include_browse":  m.IncludeBrowse,
			"version":         m.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetModelVersionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":       types.StringType,
			"include_aliases": types.BoolType,
			"include_browse":  types.BoolType,
			"version":         types.Int64Type,
		},
	}
}

type GetOnlineTableRequest_SdkV2 struct {
	// Full three-part (catalog, schema, table) name of the table.
	Name types.String `tfsdk:"-"`
}

func (to *GetOnlineTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetOnlineTableRequest_SdkV2) {
}

func (to *GetOnlineTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetOnlineTableRequest_SdkV2) {
}

func (m GetOnlineTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetOnlineTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetOnlineTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetOnlineTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetOnlineTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetOnlineTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetPermissionsResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The privileges assigned to each principal
	PrivilegeAssignments types.List `tfsdk:"privilege_assignments"`
}

func (to *GetPermissionsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPermissionsResponse_SdkV2) {
	if !from.PrivilegeAssignments.IsNull() && !from.PrivilegeAssignments.IsUnknown() && to.PrivilegeAssignments.IsNull() && len(from.PrivilegeAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrivilegeAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrivilegeAssignments = from.PrivilegeAssignments
	}
}

func (to *GetPermissionsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetPermissionsResponse_SdkV2) {
	if !from.PrivilegeAssignments.IsNull() && !from.PrivilegeAssignments.IsUnknown() && to.PrivilegeAssignments.IsNull() && len(from.PrivilegeAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrivilegeAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrivilegeAssignments = from.PrivilegeAssignments
	}
}

func (m GetPermissionsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["privilege_assignments"] = attrs["privilege_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPermissionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPermissionsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privilege_assignments": reflect.TypeOf(PrivilegeAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPermissionsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetPermissionsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":       m.NextPageToken,
			"privilege_assignments": m.PrivilegeAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPermissionsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"privilege_assignments": basetypes.ListType{
				ElemType: PrivilegeAssignment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPrivilegeAssignments returns the value of the PrivilegeAssignments field in GetPermissionsResponse_SdkV2 as
// a slice of PrivilegeAssignment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetPermissionsResponse_SdkV2) GetPrivilegeAssignments(ctx context.Context) ([]PrivilegeAssignment_SdkV2, bool) {
	if m.PrivilegeAssignments.IsNull() || m.PrivilegeAssignments.IsUnknown() {
		return nil, false
	}
	var v []PrivilegeAssignment_SdkV2
	d := m.PrivilegeAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivilegeAssignments sets the value of the PrivilegeAssignments field in GetPermissionsResponse_SdkV2.
func (m *GetPermissionsResponse_SdkV2) SetPrivilegeAssignments(ctx context.Context, v []PrivilegeAssignment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["privilege_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PrivilegeAssignments = types.ListValueMust(t, vs)
}

type GetPolicyRequest_SdkV2 struct {
	// Required. The name of the policy to retrieve.
	Name types.String `tfsdk:"-"`
	// Required. The fully qualified name of securable to retrieve policy for.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to retrieve the policy for.
	OnSecurableType types.String `tfsdk:"-"`
}

func (to *GetPolicyRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPolicyRequest_SdkV2) {
}

func (to *GetPolicyRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetPolicyRequest_SdkV2) {
}

func (m GetPolicyRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPolicyRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPolicyRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetPolicyRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                  m.Name,
			"on_securable_fullname": m.OnSecurableFullname,
			"on_securable_type":     m.OnSecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPolicyRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
		},
	}
}

type GetQualityMonitorRequest_SdkV2 struct {
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
}

func (to *GetQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetQualityMonitorRequest_SdkV2) {
}

func (to *GetQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetQualityMonitorRequest_SdkV2) {
}

func (m GetQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

type GetQuotaRequest_SdkV2 struct {
	// Full name of the parent resource. Provide the metastore ID if the parent
	// is a metastore.
	ParentFullName types.String `tfsdk:"-"`
	// Securable type of the quota parent.
	ParentSecurableType types.String `tfsdk:"-"`
	// Name of the quota. Follows the pattern of the quota type, with "-quota"
	// added as a suffix.
	QuotaName types.String `tfsdk:"-"`
}

func (to *GetQuotaRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetQuotaRequest_SdkV2) {
}

func (to *GetQuotaRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetQuotaRequest_SdkV2) {
}

func (m GetQuotaRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parent_securable_type"] = attrs["parent_securable_type"].SetRequired()
	attrs["parent_full_name"] = attrs["parent_full_name"].SetRequired()
	attrs["quota_name"] = attrs["quota_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQuotaRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetQuotaRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQuotaRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetQuotaRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parent_full_name":      m.ParentFullName,
			"parent_securable_type": m.ParentSecurableType,
			"quota_name":            m.QuotaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetQuotaRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parent_full_name":      types.StringType,
			"parent_securable_type": types.StringType,
			"quota_name":            types.StringType,
		},
	}
}

type GetQuotaResponse_SdkV2 struct {
	// The returned QuotaInfo.
	QuotaInfo types.List `tfsdk:"quota_info"`
}

func (to *GetQuotaResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetQuotaResponse_SdkV2) {
	if !from.QuotaInfo.IsNull() && !from.QuotaInfo.IsUnknown() {
		if toQuotaInfo, ok := to.GetQuotaInfo(ctx); ok {
			if fromQuotaInfo, ok := from.GetQuotaInfo(ctx); ok {
				// Recursively sync the fields of QuotaInfo
				toQuotaInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromQuotaInfo)
				to.SetQuotaInfo(ctx, toQuotaInfo)
			}
		}
	}
}

func (to *GetQuotaResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetQuotaResponse_SdkV2) {
	if !from.QuotaInfo.IsNull() && !from.QuotaInfo.IsUnknown() {
		if toQuotaInfo, ok := to.GetQuotaInfo(ctx); ok {
			if fromQuotaInfo, ok := from.GetQuotaInfo(ctx); ok {
				toQuotaInfo.SyncFieldsDuringRead(ctx, fromQuotaInfo)
				to.SetQuotaInfo(ctx, toQuotaInfo)
			}
		}
	}
}

func (m GetQuotaResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["quota_info"] = attrs["quota_info"].SetOptional()
	attrs["quota_info"] = attrs["quota_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQuotaResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetQuotaResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quota_info": reflect.TypeOf(QuotaInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQuotaResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetQuotaResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"quota_info": m.QuotaInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetQuotaResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"quota_info": basetypes.ListType{
				ElemType: QuotaInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetQuotaInfo returns the value of the QuotaInfo field in GetQuotaResponse_SdkV2 as
// a QuotaInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GetQuotaResponse_SdkV2) GetQuotaInfo(ctx context.Context) (QuotaInfo_SdkV2, bool) {
	var e QuotaInfo_SdkV2
	if m.QuotaInfo.IsNull() || m.QuotaInfo.IsUnknown() {
		return e, false
	}
	var v []QuotaInfo_SdkV2
	d := m.QuotaInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQuotaInfo sets the value of the QuotaInfo field in GetQuotaResponse_SdkV2.
func (m *GetQuotaResponse_SdkV2) SetQuotaInfo(ctx context.Context, v QuotaInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["quota_info"]
	m.QuotaInfo = types.ListValueMust(t, vs)
}

type GetRefreshRequest_SdkV2 struct {
	// ID of the refresh.
	RefreshId types.Int64 `tfsdk:"-"`
	// Full name of the table.
	TableName types.String `tfsdk:"-"`
}

func (to *GetRefreshRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRefreshRequest_SdkV2) {
}

func (to *GetRefreshRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetRefreshRequest_SdkV2) {
}

func (m GetRefreshRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()
	attrs["refresh_id"] = attrs["refresh_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRefreshRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetRefreshRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRefreshRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetRefreshRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"refresh_id": m.RefreshId,
			"table_name": m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetRefreshRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"refresh_id": types.Int64Type,
			"table_name": types.StringType,
		},
	}
}

type GetRegisteredModelRequest_SdkV2 struct {
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// Whether to include registered model aliases in the response
	IncludeAliases types.Bool `tfsdk:"-"`
	// Whether to include registered models in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
}

func (to *GetRegisteredModelRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRegisteredModelRequest_SdkV2) {
}

func (to *GetRegisteredModelRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetRegisteredModelRequest_SdkV2) {
}

func (m GetRegisteredModelRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["include_aliases"] = attrs["include_aliases"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetRegisteredModelRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRegisteredModelRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetRegisteredModelRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":       m.FullName,
			"include_aliases": m.IncludeAliases,
			"include_browse":  m.IncludeBrowse,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetRegisteredModelRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":       types.StringType,
			"include_aliases": types.BoolType,
			"include_browse":  types.BoolType,
		},
	}
}

type GetSchemaRequest_SdkV2 struct {
	// Full name of the schema.
	FullName types.String `tfsdk:"-"`
	// Whether to include schemas in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
}

func (to *GetSchemaRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetSchemaRequest_SdkV2) {
}

func (to *GetSchemaRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetSchemaRequest_SdkV2) {
}

func (m GetSchemaRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetSchemaRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetSchemaRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetSchemaRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetSchemaRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      m.FullName,
			"include_browse": m.IncludeBrowse,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetSchemaRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"include_browse": types.BoolType,
		},
	}
}

type GetStorageCredentialRequest_SdkV2 struct {
	// Name of the storage credential.
	Name types.String `tfsdk:"-"`
}

func (to *GetStorageCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetStorageCredentialRequest_SdkV2) {
}

func (to *GetStorageCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetStorageCredentialRequest_SdkV2) {
}

func (m GetStorageCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetStorageCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetStorageCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetStorageCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetStorageCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetTableRequest_SdkV2 struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
	// Whether to include tables in the response for which the principal can
	// only access selective metadata for.
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Whether delta metadata should be included in the response.
	IncludeDeltaMetadata types.Bool `tfsdk:"-"`
	// Whether to include a manifest containing table capabilities in the
	// response.
	IncludeManifestCapabilities types.Bool `tfsdk:"-"`
}

func (to *GetTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetTableRequest_SdkV2) {
}

func (to *GetTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetTableRequest_SdkV2) {
}

func (m GetTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["include_delta_metadata"] = attrs["include_delta_metadata"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["include_manifest_capabilities"] = attrs["include_manifest_capabilities"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":                     m.FullName,
			"include_browse":                m.IncludeBrowse,
			"include_delta_metadata":        m.IncludeDeltaMetadata,
			"include_manifest_capabilities": m.IncludeManifestCapabilities,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":                     types.StringType,
			"include_browse":                types.BoolType,
			"include_delta_metadata":        types.BoolType,
			"include_manifest_capabilities": types.BoolType,
		},
	}
}

type GetWorkspaceBindingRequest_SdkV2 struct {
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
}

func (to *GetWorkspaceBindingRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetWorkspaceBindingRequest_SdkV2) {
}

func (to *GetWorkspaceBindingRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetWorkspaceBindingRequest_SdkV2) {
}

func (m GetWorkspaceBindingRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetWorkspaceBindingRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetWorkspaceBindingRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetWorkspaceBindingRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetWorkspaceBindingRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetWorkspaceBindingRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetWorkspaceBindingsResponse_SdkV2 struct {
	// List of workspace bindings
	Bindings types.List `tfsdk:"bindings"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *GetWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetWorkspaceBindingsResponse_SdkV2) {
	if !from.Bindings.IsNull() && !from.Bindings.IsUnknown() && to.Bindings.IsNull() && len(from.Bindings.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Bindings, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Bindings = from.Bindings
	}
}

func (to *GetWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetWorkspaceBindingsResponse_SdkV2) {
	if !from.Bindings.IsNull() && !from.Bindings.IsUnknown() && to.Bindings.IsNull() && len(from.Bindings.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Bindings, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Bindings = from.Bindings
	}
}

func (m GetWorkspaceBindingsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["bindings"] = attrs["bindings"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetWorkspaceBindingsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"bindings": reflect.TypeOf(WorkspaceBinding_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetWorkspaceBindingsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetWorkspaceBindingsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"bindings":        m.Bindings,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetWorkspaceBindingsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"bindings": basetypes.ListType{
				ElemType: WorkspaceBinding_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetBindings returns the value of the Bindings field in GetWorkspaceBindingsResponse_SdkV2 as
// a slice of WorkspaceBinding_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetWorkspaceBindingsResponse_SdkV2) GetBindings(ctx context.Context) ([]WorkspaceBinding_SdkV2, bool) {
	if m.Bindings.IsNull() || m.Bindings.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding_SdkV2
	d := m.Bindings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBindings sets the value of the Bindings field in GetWorkspaceBindingsResponse_SdkV2.
func (m *GetWorkspaceBindingsResponse_SdkV2) SetBindings(ctx context.Context, v []WorkspaceBinding_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["bindings"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Bindings = types.ListValueMust(t, vs)
}

type ListAccountMetastoreAssignmentsRequest_SdkV2 struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (to *ListAccountMetastoreAssignmentsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountMetastoreAssignmentsRequest_SdkV2) {
}

func (to *ListAccountMetastoreAssignmentsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListAccountMetastoreAssignmentsRequest_SdkV2) {
}

func (m ListAccountMetastoreAssignmentsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountMetastoreAssignmentsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListAccountMetastoreAssignmentsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountMetastoreAssignmentsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListAccountMetastoreAssignmentsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": m.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListAccountMetastoreAssignmentsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
		},
	}
}

// The metastore assignments were successfully returned.
type ListAccountMetastoreAssignmentsResponse_SdkV2 struct {
	WorkspaceIds types.List `tfsdk:"workspace_ids"`
}

func (to *ListAccountMetastoreAssignmentsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountMetastoreAssignmentsResponse_SdkV2) {
	if !from.WorkspaceIds.IsNull() && !from.WorkspaceIds.IsUnknown() && to.WorkspaceIds.IsNull() && len(from.WorkspaceIds.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for WorkspaceIds, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.WorkspaceIds = from.WorkspaceIds
	}
}

func (to *ListAccountMetastoreAssignmentsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListAccountMetastoreAssignmentsResponse_SdkV2) {
	if !from.WorkspaceIds.IsNull() && !from.WorkspaceIds.IsUnknown() && to.WorkspaceIds.IsNull() && len(from.WorkspaceIds.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for WorkspaceIds, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.WorkspaceIds = from.WorkspaceIds
	}
}

func (m ListAccountMetastoreAssignmentsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspace_ids"] = attrs["workspace_ids"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountMetastoreAssignmentsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListAccountMetastoreAssignmentsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"workspace_ids": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountMetastoreAssignmentsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListAccountMetastoreAssignmentsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspace_ids": m.WorkspaceIds,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListAccountMetastoreAssignmentsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspace_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetWorkspaceIds returns the value of the WorkspaceIds field in ListAccountMetastoreAssignmentsResponse_SdkV2 as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListAccountMetastoreAssignmentsResponse_SdkV2) GetWorkspaceIds(ctx context.Context) ([]types.Int64, bool) {
	if m.WorkspaceIds.IsNull() || m.WorkspaceIds.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.WorkspaceIds.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWorkspaceIds sets the value of the WorkspaceIds field in ListAccountMetastoreAssignmentsResponse_SdkV2.
func (m *ListAccountMetastoreAssignmentsResponse_SdkV2) SetWorkspaceIds(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["workspace_ids"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.WorkspaceIds = types.ListValueMust(t, vs)
}

type ListAccountMetastoresRequest_SdkV2 struct {
}

func (to *ListAccountMetastoresRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountMetastoresRequest_SdkV2) {
}

func (to *ListAccountMetastoresRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListAccountMetastoresRequest_SdkV2) {
}

func (m ListAccountMetastoresRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountMetastoresRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListAccountMetastoresRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountMetastoresRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListAccountMetastoresRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m ListAccountMetastoresRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type ListAccountStorageCredentialsRequest_SdkV2 struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (to *ListAccountStorageCredentialsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountStorageCredentialsRequest_SdkV2) {
}

func (to *ListAccountStorageCredentialsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListAccountStorageCredentialsRequest_SdkV2) {
}

func (m ListAccountStorageCredentialsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountStorageCredentialsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListAccountStorageCredentialsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountStorageCredentialsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListAccountStorageCredentialsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": m.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListAccountStorageCredentialsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
		},
	}
}

// The metastore storage credentials were successfully returned.
type ListAccountStorageCredentialsResponse_SdkV2 struct {
	// An array of metastore storage credentials.
	StorageCredentials types.List `tfsdk:"storage_credentials"`
}

func (to *ListAccountStorageCredentialsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountStorageCredentialsResponse_SdkV2) {
	if !from.StorageCredentials.IsNull() && !from.StorageCredentials.IsUnknown() && to.StorageCredentials.IsNull() && len(from.StorageCredentials.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for StorageCredentials, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.StorageCredentials = from.StorageCredentials
	}
}

func (to *ListAccountStorageCredentialsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListAccountStorageCredentialsResponse_SdkV2) {
	if !from.StorageCredentials.IsNull() && !from.StorageCredentials.IsUnknown() && to.StorageCredentials.IsNull() && len(from.StorageCredentials.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for StorageCredentials, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.StorageCredentials = from.StorageCredentials
	}
}

func (m ListAccountStorageCredentialsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["storage_credentials"] = attrs["storage_credentials"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountStorageCredentialsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListAccountStorageCredentialsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"storage_credentials": reflect.TypeOf(StorageCredentialInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountStorageCredentialsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListAccountStorageCredentialsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"storage_credentials": m.StorageCredentials,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListAccountStorageCredentialsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"storage_credentials": basetypes.ListType{
				ElemType: StorageCredentialInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetStorageCredentials returns the value of the StorageCredentials field in ListAccountStorageCredentialsResponse_SdkV2 as
// a slice of StorageCredentialInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListAccountStorageCredentialsResponse_SdkV2) GetStorageCredentials(ctx context.Context) ([]StorageCredentialInfo_SdkV2, bool) {
	if m.StorageCredentials.IsNull() || m.StorageCredentials.IsUnknown() {
		return nil, false
	}
	var v []StorageCredentialInfo_SdkV2
	d := m.StorageCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStorageCredentials sets the value of the StorageCredentials field in ListAccountStorageCredentialsResponse_SdkV2.
func (m *ListAccountStorageCredentialsResponse_SdkV2) SetStorageCredentials(ctx context.Context, v []StorageCredentialInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["storage_credentials"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.StorageCredentials = types.ListValueMust(t, vs)
}

type ListCatalogsRequest_SdkV2 struct {
	// Whether to include catalogs in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Whether to include catalogs not bound to the workspace. Effective only if
	// the user has permission to update the catalogworkspace binding.
	IncludeUnbound types.Bool `tfsdk:"-"`
	// Maximum number of catalogs to return. - when set to 0, the page length is
	// set to a server configured value (recommended); - when set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - when set to a value less than 0, an invalid parameter
	// error is returned; - If not set, all valid catalogs are returned (not
	// recommended). - Note: The number of returned catalogs might be less than
	// the specified max_results size, even zero. The only definitive indication
	// that no further catalogs can be fetched is when the next_page_token is
	// unset from the response.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListCatalogsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListCatalogsRequest_SdkV2) {
}

func (to *ListCatalogsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListCatalogsRequest_SdkV2) {
}

func (m ListCatalogsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_unbound"] = attrs["include_unbound"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCatalogsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListCatalogsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCatalogsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListCatalogsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse":  m.IncludeBrowse,
			"include_unbound": m.IncludeUnbound,
			"max_results":     m.MaxResults,
			"page_token":      m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListCatalogsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse":  types.BoolType,
			"include_unbound": types.BoolType,
			"max_results":     types.Int64Type,
			"page_token":      types.StringType,
		},
	}
}

type ListCatalogsResponse_SdkV2 struct {
	// An array of catalog information objects.
	Catalogs types.List `tfsdk:"catalogs"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListCatalogsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListCatalogsResponse_SdkV2) {
	if !from.Catalogs.IsNull() && !from.Catalogs.IsUnknown() && to.Catalogs.IsNull() && len(from.Catalogs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Catalogs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Catalogs = from.Catalogs
	}
}

func (to *ListCatalogsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListCatalogsResponse_SdkV2) {
	if !from.Catalogs.IsNull() && !from.Catalogs.IsUnknown() && to.Catalogs.IsNull() && len(from.Catalogs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Catalogs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Catalogs = from.Catalogs
	}
}

func (m ListCatalogsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalogs"] = attrs["catalogs"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCatalogsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListCatalogsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"catalogs": reflect.TypeOf(CatalogInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCatalogsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListCatalogsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalogs":        m.Catalogs,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListCatalogsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalogs": basetypes.ListType{
				ElemType: CatalogInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetCatalogs returns the value of the Catalogs field in ListCatalogsResponse_SdkV2 as
// a slice of CatalogInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListCatalogsResponse_SdkV2) GetCatalogs(ctx context.Context) ([]CatalogInfo_SdkV2, bool) {
	if m.Catalogs.IsNull() || m.Catalogs.IsUnknown() {
		return nil, false
	}
	var v []CatalogInfo_SdkV2
	d := m.Catalogs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCatalogs sets the value of the Catalogs field in ListCatalogsResponse_SdkV2.
func (m *ListCatalogsResponse_SdkV2) SetCatalogs(ctx context.Context, v []CatalogInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["catalogs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Catalogs = types.ListValueMust(t, vs)
}

type ListConnectionsRequest_SdkV2 struct {
	// Maximum number of connections to return. - If not set, all connections
	// are returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListConnectionsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListConnectionsRequest_SdkV2) {
}

func (to *ListConnectionsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListConnectionsRequest_SdkV2) {
}

func (m ListConnectionsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListConnectionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListConnectionsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListConnectionsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListConnectionsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": m.MaxResults,
			"page_token":  m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListConnectionsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListConnectionsResponse_SdkV2 struct {
	// An array of connection information objects.
	Connections types.List `tfsdk:"connections"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListConnectionsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListConnectionsResponse_SdkV2) {
	if !from.Connections.IsNull() && !from.Connections.IsUnknown() && to.Connections.IsNull() && len(from.Connections.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Connections, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Connections = from.Connections
	}
}

func (to *ListConnectionsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListConnectionsResponse_SdkV2) {
	if !from.Connections.IsNull() && !from.Connections.IsUnknown() && to.Connections.IsNull() && len(from.Connections.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Connections, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Connections = from.Connections
	}
}

func (m ListConnectionsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connections"] = attrs["connections"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListConnectionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListConnectionsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"connections": reflect.TypeOf(ConnectionInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListConnectionsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListConnectionsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connections":     m.Connections,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListConnectionsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connections": basetypes.ListType{
				ElemType: ConnectionInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetConnections returns the value of the Connections field in ListConnectionsResponse_SdkV2 as
// a slice of ConnectionInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListConnectionsResponse_SdkV2) GetConnections(ctx context.Context) ([]ConnectionInfo_SdkV2, bool) {
	if m.Connections.IsNull() || m.Connections.IsUnknown() {
		return nil, false
	}
	var v []ConnectionInfo_SdkV2
	d := m.Connections.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConnections sets the value of the Connections field in ListConnectionsResponse_SdkV2.
func (m *ListConnectionsResponse_SdkV2) SetConnections(ctx context.Context, v []ConnectionInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["connections"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Connections = types.ListValueMust(t, vs)
}

type ListCredentialsRequest_SdkV2 struct {
	// Whether to include credentials not bound to the workspace. Effective only
	// if the user has permission to update the credentialworkspace binding.
	IncludeUnbound types.Bool `tfsdk:"-"`
	// Maximum number of credentials to return. - If not set, the default max
	// page size is used. - When set to a value greater than 0, the page length
	// is the minimum of this value and a server-configured value. - When set to
	// 0, the page length is set to a server-configured value (recommended). -
	// When set to a value less than 0, an invalid parameter error is returned.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token to retrieve the next page of results.
	PageToken types.String `tfsdk:"-"`
	// Return only credentials for the specified purpose.
	Purpose types.String `tfsdk:"-"`
}

func (to *ListCredentialsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListCredentialsRequest_SdkV2) {
}

func (to *ListCredentialsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListCredentialsRequest_SdkV2) {
}

func (m ListCredentialsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["include_unbound"] = attrs["include_unbound"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["purpose"] = attrs["purpose"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCredentialsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListCredentialsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCredentialsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListCredentialsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_unbound": m.IncludeUnbound,
			"max_results":     m.MaxResults,
			"page_token":      m.PageToken,
			"purpose":         m.Purpose,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListCredentialsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_unbound": types.BoolType,
			"max_results":     types.Int64Type,
			"page_token":      types.StringType,
			"purpose":         types.StringType,
		},
	}
}

type ListCredentialsResponse_SdkV2 struct {
	Credentials types.List `tfsdk:"credentials"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListCredentialsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListCredentialsResponse_SdkV2) {
	if !from.Credentials.IsNull() && !from.Credentials.IsUnknown() && to.Credentials.IsNull() && len(from.Credentials.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Credentials, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Credentials = from.Credentials
	}
}

func (to *ListCredentialsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListCredentialsResponse_SdkV2) {
	if !from.Credentials.IsNull() && !from.Credentials.IsUnknown() && to.Credentials.IsNull() && len(from.Credentials.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Credentials, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Credentials = from.Credentials
	}
}

func (m ListCredentialsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credentials"] = attrs["credentials"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCredentialsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListCredentialsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credentials": reflect.TypeOf(CredentialInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCredentialsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListCredentialsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credentials":     m.Credentials,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListCredentialsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credentials": basetypes.ListType{
				ElemType: CredentialInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetCredentials returns the value of the Credentials field in ListCredentialsResponse_SdkV2 as
// a slice of CredentialInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListCredentialsResponse_SdkV2) GetCredentials(ctx context.Context) ([]CredentialInfo_SdkV2, bool) {
	if m.Credentials.IsNull() || m.Credentials.IsUnknown() {
		return nil, false
	}
	var v []CredentialInfo_SdkV2
	d := m.Credentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCredentials sets the value of the Credentials field in ListCredentialsResponse_SdkV2.
func (m *ListCredentialsResponse_SdkV2) SetCredentials(ctx context.Context, v []CredentialInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["credentials"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Credentials = types.ListValueMust(t, vs)
}

type ListEntityTagAssignmentsRequest_SdkV2 struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`
	// Optional. Maximum number of tag assignments to return in a single page
	MaxResults types.Int64 `tfsdk:"-"`
	// Optional. Pagination token to retrieve the next page of results
	PageToken types.String `tfsdk:"-"`
}

func (to *ListEntityTagAssignmentsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListEntityTagAssignmentsRequest_SdkV2) {
}

func (to *ListEntityTagAssignmentsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListEntityTagAssignmentsRequest_SdkV2) {
}

func (m ListEntityTagAssignmentsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListEntityTagAssignmentsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListEntityTagAssignmentsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListEntityTagAssignmentsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListEntityTagAssignmentsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": m.EntityName,
			"entity_type": m.EntityType,
			"max_results": m.MaxResults,
			"page_token":  m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListEntityTagAssignmentsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListEntityTagAssignmentsResponse_SdkV2 struct {
	// Optional. Pagination token for retrieving the next page of results
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The list of tag assignments
	TagAssignments types.List `tfsdk:"tag_assignments"`
}

func (to *ListEntityTagAssignmentsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListEntityTagAssignmentsResponse_SdkV2) {
	if !from.TagAssignments.IsNull() && !from.TagAssignments.IsUnknown() && to.TagAssignments.IsNull() && len(from.TagAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TagAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TagAssignments = from.TagAssignments
	}
}

func (to *ListEntityTagAssignmentsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListEntityTagAssignmentsResponse_SdkV2) {
	if !from.TagAssignments.IsNull() && !from.TagAssignments.IsUnknown() && to.TagAssignments.IsNull() && len(from.TagAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TagAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TagAssignments = from.TagAssignments
	}
}

func (m ListEntityTagAssignmentsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["tag_assignments"] = attrs["tag_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListEntityTagAssignmentsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListEntityTagAssignmentsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tag_assignments": reflect.TypeOf(EntityTagAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListEntityTagAssignmentsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListEntityTagAssignmentsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"tag_assignments": m.TagAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListEntityTagAssignmentsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"tag_assignments": basetypes.ListType{
				ElemType: EntityTagAssignment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTagAssignments returns the value of the TagAssignments field in ListEntityTagAssignmentsResponse_SdkV2 as
// a slice of EntityTagAssignment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListEntityTagAssignmentsResponse_SdkV2) GetTagAssignments(ctx context.Context) ([]EntityTagAssignment_SdkV2, bool) {
	if m.TagAssignments.IsNull() || m.TagAssignments.IsUnknown() {
		return nil, false
	}
	var v []EntityTagAssignment_SdkV2
	d := m.TagAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTagAssignments sets the value of the TagAssignments field in ListEntityTagAssignmentsResponse_SdkV2.
func (m *ListEntityTagAssignmentsResponse_SdkV2) SetTagAssignments(ctx context.Context, v []EntityTagAssignment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tag_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TagAssignments = types.ListValueMust(t, vs)
}

type ListExternalLineageRelationshipsRequest_SdkV2 struct {
	// The lineage direction to filter on.
	LineageDirection types.String `tfsdk:"-"`
	// The object to query external lineage relationships for. Since this field
	// is a query parameter, please flatten the nested fields. For example, if
	// the object is a table, the query parameter should look like:
	// `object_info.table.name=main.sales.customers`
	ObjectInfo types.List `tfsdk:"-"`
	// Specifies the maximum number of external lineage relationships to return
	// in a single response. The value must be less than or equal to 1000.
	PageSize types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListExternalLineageRelationshipsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListExternalLineageRelationshipsRequest_SdkV2) {
	if !from.ObjectInfo.IsNull() && !from.ObjectInfo.IsUnknown() {
		if toObjectInfo, ok := to.GetObjectInfo(ctx); ok {
			if fromObjectInfo, ok := from.GetObjectInfo(ctx); ok {
				// Recursively sync the fields of ObjectInfo
				toObjectInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromObjectInfo)
				to.SetObjectInfo(ctx, toObjectInfo)
			}
		}
	}
}

func (to *ListExternalLineageRelationshipsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListExternalLineageRelationshipsRequest_SdkV2) {
	if !from.ObjectInfo.IsNull() && !from.ObjectInfo.IsUnknown() {
		if toObjectInfo, ok := to.GetObjectInfo(ctx); ok {
			if fromObjectInfo, ok := from.GetObjectInfo(ctx); ok {
				toObjectInfo.SyncFieldsDuringRead(ctx, fromObjectInfo)
				to.SetObjectInfo(ctx, toObjectInfo)
			}
		}
	}
}

func (m ListExternalLineageRelationshipsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["object_info"] = attrs["object_info"].SetRequired()
	attrs["object_info"] = attrs["object_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["lineage_direction"] = attrs["lineage_direction"].SetRequired()
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLineageRelationshipsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListExternalLineageRelationshipsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"object_info": reflect.TypeOf(ExternalLineageObject_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLineageRelationshipsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListExternalLineageRelationshipsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"lineage_direction": m.LineageDirection,
			"object_info":       m.ObjectInfo,
			"page_size":         m.PageSize,
			"page_token":        m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListExternalLineageRelationshipsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"lineage_direction": types.StringType,
			"object_info": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

// GetObjectInfo returns the value of the ObjectInfo field in ListExternalLineageRelationshipsRequest_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ListExternalLineageRelationshipsRequest_SdkV2) GetObjectInfo(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.ObjectInfo.IsNull() || m.ObjectInfo.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.ObjectInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetObjectInfo sets the value of the ObjectInfo field in ListExternalLineageRelationshipsRequest_SdkV2.
func (m *ListExternalLineageRelationshipsRequest_SdkV2) SetObjectInfo(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["object_info"]
	m.ObjectInfo = types.ListValueMust(t, vs)
}

type ListExternalLineageRelationshipsResponse_SdkV2 struct {
	ExternalLineageRelationships types.List `tfsdk:"external_lineage_relationships"`

	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListExternalLineageRelationshipsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListExternalLineageRelationshipsResponse_SdkV2) {
	if !from.ExternalLineageRelationships.IsNull() && !from.ExternalLineageRelationships.IsUnknown() && to.ExternalLineageRelationships.IsNull() && len(from.ExternalLineageRelationships.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExternalLineageRelationships, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExternalLineageRelationships = from.ExternalLineageRelationships
	}
}

func (to *ListExternalLineageRelationshipsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListExternalLineageRelationshipsResponse_SdkV2) {
	if !from.ExternalLineageRelationships.IsNull() && !from.ExternalLineageRelationships.IsUnknown() && to.ExternalLineageRelationships.IsNull() && len(from.ExternalLineageRelationships.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExternalLineageRelationships, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExternalLineageRelationships = from.ExternalLineageRelationships
	}
}

func (m ListExternalLineageRelationshipsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationships"] = attrs["external_lineage_relationships"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLineageRelationshipsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListExternalLineageRelationshipsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationships": reflect.TypeOf(ExternalLineageInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLineageRelationshipsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListExternalLineageRelationshipsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationships": m.ExternalLineageRelationships,
			"next_page_token":                m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListExternalLineageRelationshipsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationships": basetypes.ListType{
				ElemType: ExternalLineageInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetExternalLineageRelationships returns the value of the ExternalLineageRelationships field in ListExternalLineageRelationshipsResponse_SdkV2 as
// a slice of ExternalLineageInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListExternalLineageRelationshipsResponse_SdkV2) GetExternalLineageRelationships(ctx context.Context) ([]ExternalLineageInfo_SdkV2, bool) {
	if m.ExternalLineageRelationships.IsNull() || m.ExternalLineageRelationships.IsUnknown() {
		return nil, false
	}
	var v []ExternalLineageInfo_SdkV2
	d := m.ExternalLineageRelationships.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLineageRelationships sets the value of the ExternalLineageRelationships field in ListExternalLineageRelationshipsResponse_SdkV2.
func (m *ListExternalLineageRelationshipsResponse_SdkV2) SetExternalLineageRelationships(ctx context.Context, v []ExternalLineageInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_lineage_relationships"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ExternalLineageRelationships = types.ListValueMust(t, vs)
}

type ListExternalLocationsRequest_SdkV2 struct {
	// Whether to include external locations in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Whether to include external locations not bound to the workspace.
	// Effective only if the user has permission to update the
	// locationworkspace binding.
	IncludeUnbound types.Bool `tfsdk:"-"`
	// Maximum number of external locations to return. If not set, all the
	// external locations are returned (not recommended). - when set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - when set to 0, the page length is set to a server
	// configured value (recommended); - when set to a value less than 0, an
	// invalid parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListExternalLocationsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListExternalLocationsRequest_SdkV2) {
}

func (to *ListExternalLocationsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListExternalLocationsRequest_SdkV2) {
}

func (m ListExternalLocationsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_unbound"] = attrs["include_unbound"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLocationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListExternalLocationsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLocationsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListExternalLocationsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse":  m.IncludeBrowse,
			"include_unbound": m.IncludeUnbound,
			"max_results":     m.MaxResults,
			"page_token":      m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListExternalLocationsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse":  types.BoolType,
			"include_unbound": types.BoolType,
			"max_results":     types.Int64Type,
			"page_token":      types.StringType,
		},
	}
}

type ListExternalLocationsResponse_SdkV2 struct {
	// An array of external locations.
	ExternalLocations types.List `tfsdk:"external_locations"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListExternalLocationsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListExternalLocationsResponse_SdkV2) {
	if !from.ExternalLocations.IsNull() && !from.ExternalLocations.IsUnknown() && to.ExternalLocations.IsNull() && len(from.ExternalLocations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExternalLocations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExternalLocations = from.ExternalLocations
	}
}

func (to *ListExternalLocationsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListExternalLocationsResponse_SdkV2) {
	if !from.ExternalLocations.IsNull() && !from.ExternalLocations.IsUnknown() && to.ExternalLocations.IsNull() && len(from.ExternalLocations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExternalLocations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExternalLocations = from.ExternalLocations
	}
}

func (m ListExternalLocationsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_locations"] = attrs["external_locations"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLocationsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListExternalLocationsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_locations": reflect.TypeOf(ExternalLocationInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLocationsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListExternalLocationsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_locations": m.ExternalLocations,
			"next_page_token":    m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListExternalLocationsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_locations": basetypes.ListType{
				ElemType: ExternalLocationInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetExternalLocations returns the value of the ExternalLocations field in ListExternalLocationsResponse_SdkV2 as
// a slice of ExternalLocationInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListExternalLocationsResponse_SdkV2) GetExternalLocations(ctx context.Context) ([]ExternalLocationInfo_SdkV2, bool) {
	if m.ExternalLocations.IsNull() || m.ExternalLocations.IsUnknown() {
		return nil, false
	}
	var v []ExternalLocationInfo_SdkV2
	d := m.ExternalLocations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLocations sets the value of the ExternalLocations field in ListExternalLocationsResponse_SdkV2.
func (m *ListExternalLocationsResponse_SdkV2) SetExternalLocations(ctx context.Context, v []ExternalLocationInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_locations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ExternalLocations = types.ListValueMust(t, vs)
}

type ListExternalMetadataRequest_SdkV2 struct {
	// Specifies the maximum number of external metadata objects to return in a
	// single response. The value must be less than or equal to 1000.
	PageSize types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListExternalMetadataRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListExternalMetadataRequest_SdkV2) {
}

func (to *ListExternalMetadataRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListExternalMetadataRequest_SdkV2) {
}

func (m ListExternalMetadataRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListExternalMetadataRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalMetadataRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListExternalMetadataRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":  m.PageSize,
			"page_token": m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListExternalMetadataRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

type ListExternalMetadataResponse_SdkV2 struct {
	ExternalMetadata types.List `tfsdk:"external_metadata"`

	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListExternalMetadataResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListExternalMetadataResponse_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() && to.ExternalMetadata.IsNull() && len(from.ExternalMetadata.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExternalMetadata, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExternalMetadata = from.ExternalMetadata
	}
}

func (to *ListExternalMetadataResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListExternalMetadataResponse_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() && to.ExternalMetadata.IsNull() && len(from.ExternalMetadata.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExternalMetadata, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExternalMetadata = from.ExternalMetadata
	}
}

func (m ListExternalMetadataResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalMetadataResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListExternalMetadataResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalMetadata_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalMetadataResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListExternalMetadataResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": m.ExternalMetadata,
			"next_page_token":   m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListExternalMetadataResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": basetypes.ListType{
				ElemType: ExternalMetadata_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in ListExternalMetadataResponse_SdkV2 as
// a slice of ExternalMetadata_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListExternalMetadataResponse_SdkV2) GetExternalMetadata(ctx context.Context) ([]ExternalMetadata_SdkV2, bool) {
	if m.ExternalMetadata.IsNull() || m.ExternalMetadata.IsUnknown() {
		return nil, false
	}
	var v []ExternalMetadata_SdkV2
	d := m.ExternalMetadata.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in ListExternalMetadataResponse_SdkV2.
func (m *ListExternalMetadataResponse_SdkV2) SetExternalMetadata(ctx context.Context, v []ExternalMetadata_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_metadata"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ExternalMetadata = types.ListValueMust(t, vs)
}

type ListFunctionsRequest_SdkV2 struct {
	// Name of parent catalog for functions of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include functions in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of functions to return. If not set, all the functions are
	// returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// Parent schema of functions.
	SchemaName types.String `tfsdk:"-"`
}

func (to *ListFunctionsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListFunctionsRequest_SdkV2) {
}

func (to *ListFunctionsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListFunctionsRequest_SdkV2) {
}

func (m ListFunctionsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListFunctionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListFunctionsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListFunctionsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListFunctionsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   m.CatalogName,
			"include_browse": m.IncludeBrowse,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
			"schema_name":    m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListFunctionsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"schema_name":    types.StringType,
		},
	}
}

type ListFunctionsResponse_SdkV2 struct {
	// An array of function information objects.
	Functions types.List `tfsdk:"functions"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListFunctionsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListFunctionsResponse_SdkV2) {
	if !from.Functions.IsNull() && !from.Functions.IsUnknown() && to.Functions.IsNull() && len(from.Functions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Functions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Functions = from.Functions
	}
}

func (to *ListFunctionsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListFunctionsResponse_SdkV2) {
	if !from.Functions.IsNull() && !from.Functions.IsUnknown() && to.Functions.IsNull() && len(from.Functions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Functions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Functions = from.Functions
	}
}

func (m ListFunctionsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["functions"] = attrs["functions"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListFunctionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListFunctionsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"functions": reflect.TypeOf(FunctionInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListFunctionsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListFunctionsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"functions":       m.Functions,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListFunctionsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"functions": basetypes.ListType{
				ElemType: FunctionInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetFunctions returns the value of the Functions field in ListFunctionsResponse_SdkV2 as
// a slice of FunctionInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListFunctionsResponse_SdkV2) GetFunctions(ctx context.Context) ([]FunctionInfo_SdkV2, bool) {
	if m.Functions.IsNull() || m.Functions.IsUnknown() {
		return nil, false
	}
	var v []FunctionInfo_SdkV2
	d := m.Functions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFunctions sets the value of the Functions field in ListFunctionsResponse_SdkV2.
func (m *ListFunctionsResponse_SdkV2) SetFunctions(ctx context.Context, v []FunctionInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["functions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Functions = types.ListValueMust(t, vs)
}

type ListMetastoresRequest_SdkV2 struct {
	// Maximum number of metastores to return. - when set to a value greater
	// than 0, the page length is the minimum of this value and a server
	// configured value; - when set to 0, the page length is set to a server
	// configured value (recommended); - when set to a value less than 0, an
	// invalid parameter error is returned; - If not set, all the metastores are
	// returned (not recommended). - Note: The number of returned metastores
	// might be less than the specified max_results size, even zero. The only
	// definitive indication that no further metastores can be fetched is when
	// the next_page_token is unset from the response.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListMetastoresRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListMetastoresRequest_SdkV2) {
}

func (to *ListMetastoresRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListMetastoresRequest_SdkV2) {
}

func (m ListMetastoresRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListMetastoresRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListMetastoresRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListMetastoresRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListMetastoresRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": m.MaxResults,
			"page_token":  m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListMetastoresRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListMetastoresResponse_SdkV2 struct {
	// An array of metastore information objects.
	Metastores types.List `tfsdk:"metastores"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListMetastoresResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListMetastoresResponse_SdkV2) {
	if !from.Metastores.IsNull() && !from.Metastores.IsUnknown() && to.Metastores.IsNull() && len(from.Metastores.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Metastores, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Metastores = from.Metastores
	}
}

func (to *ListMetastoresResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListMetastoresResponse_SdkV2) {
	if !from.Metastores.IsNull() && !from.Metastores.IsUnknown() && to.Metastores.IsNull() && len(from.Metastores.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Metastores, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Metastores = from.Metastores
	}
}

func (m ListMetastoresResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastores"] = attrs["metastores"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListMetastoresResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListMetastoresResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastores": reflect.TypeOf(MetastoreInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListMetastoresResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListMetastoresResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastores":      m.Metastores,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListMetastoresResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastores": basetypes.ListType{
				ElemType: MetastoreInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetMetastores returns the value of the Metastores field in ListMetastoresResponse_SdkV2 as
// a slice of MetastoreInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListMetastoresResponse_SdkV2) GetMetastores(ctx context.Context) ([]MetastoreInfo_SdkV2, bool) {
	if m.Metastores.IsNull() || m.Metastores.IsUnknown() {
		return nil, false
	}
	var v []MetastoreInfo_SdkV2
	d := m.Metastores.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastores sets the value of the Metastores field in ListMetastoresResponse_SdkV2.
func (m *ListMetastoresResponse_SdkV2) SetMetastores(ctx context.Context, v []MetastoreInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metastores"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Metastores = types.ListValueMust(t, vs)
}

type ListModelVersionsRequest_SdkV2 struct {
	// The full three-level name of the registered model under which to list
	// model versions
	FullName types.String `tfsdk:"-"`
	// Whether to include model versions in the response for which the principal
	// can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of model versions to return. If not set, the page length
	// is set to a server configured value (100, as of 1/3/2024). - when set to
	// a value greater than 0, the page length is the minimum of this value and
	// a server configured value(1000, as of 1/3/2024); - when set to 0, the
	// page length is set to a server configured value (100, as of 1/3/2024)
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListModelVersionsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListModelVersionsRequest_SdkV2) {
}

func (to *ListModelVersionsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListModelVersionsRequest_SdkV2) {
}

func (m ListModelVersionsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListModelVersionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListModelVersionsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListModelVersionsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListModelVersionsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      m.FullName,
			"include_browse": m.IncludeBrowse,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListModelVersionsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
		},
	}
}

type ListModelVersionsResponse_SdkV2 struct {
	ModelVersions types.List `tfsdk:"model_versions"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListModelVersionsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListModelVersionsResponse_SdkV2) {
	if !from.ModelVersions.IsNull() && !from.ModelVersions.IsUnknown() && to.ModelVersions.IsNull() && len(from.ModelVersions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ModelVersions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ModelVersions = from.ModelVersions
	}
}

func (to *ListModelVersionsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListModelVersionsResponse_SdkV2) {
	if !from.ModelVersions.IsNull() && !from.ModelVersions.IsUnknown() && to.ModelVersions.IsNull() && len(from.ModelVersions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ModelVersions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ModelVersions = from.ModelVersions
	}
}

func (m ListModelVersionsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["model_versions"] = attrs["model_versions"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListModelVersionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListModelVersionsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"model_versions": reflect.TypeOf(ModelVersionInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListModelVersionsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListModelVersionsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"model_versions":  m.ModelVersions,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListModelVersionsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"model_versions": basetypes.ListType{
				ElemType: ModelVersionInfo_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetModelVersions returns the value of the ModelVersions field in ListModelVersionsResponse_SdkV2 as
// a slice of ModelVersionInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListModelVersionsResponse_SdkV2) GetModelVersions(ctx context.Context) ([]ModelVersionInfo_SdkV2, bool) {
	if m.ModelVersions.IsNull() || m.ModelVersions.IsUnknown() {
		return nil, false
	}
	var v []ModelVersionInfo_SdkV2
	d := m.ModelVersions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetModelVersions sets the value of the ModelVersions field in ListModelVersionsResponse_SdkV2.
func (m *ListModelVersionsResponse_SdkV2) SetModelVersions(ctx context.Context, v []ModelVersionInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["model_versions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ModelVersions = types.ListValueMust(t, vs)
}

type ListPoliciesRequest_SdkV2 struct {
	// Optional. Whether to include policies defined on parent securables. By
	// default, the inherited policies are not included.
	IncludeInherited types.Bool `tfsdk:"-"`
	// Optional. Maximum number of policies to return on a single page (page
	// length). - When not set or set to 0, the page length is set to a server
	// configured value (recommended); - When set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value;
	MaxResults types.Int64 `tfsdk:"-"`
	// Required. The fully qualified name of securable to list policies for.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to list policies for.
	OnSecurableType types.String `tfsdk:"-"`
	// Optional. Opaque pagination token to go to next page based on previous
	// query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListPoliciesRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListPoliciesRequest_SdkV2) {
}

func (to *ListPoliciesRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListPoliciesRequest_SdkV2) {
}

func (m ListPoliciesRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["include_inherited"] = attrs["include_inherited"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListPoliciesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListPoliciesRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListPoliciesRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListPoliciesRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_inherited":     m.IncludeInherited,
			"max_results":           m.MaxResults,
			"on_securable_fullname": m.OnSecurableFullname,
			"on_securable_type":     m.OnSecurableType,
			"page_token":            m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListPoliciesRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_inherited":     types.BoolType,
			"max_results":           types.Int64Type,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"page_token":            types.StringType,
		},
	}
}

type ListPoliciesResponse_SdkV2 struct {
	// Optional opaque token for continuing pagination. `page_token` should be
	// set to this value for the next request to retrieve the next page of
	// results.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The list of retrieved policies.
	Policies types.List `tfsdk:"policies"`
}

func (to *ListPoliciesResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListPoliciesResponse_SdkV2) {
	if !from.Policies.IsNull() && !from.Policies.IsUnknown() && to.Policies.IsNull() && len(from.Policies.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Policies, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Policies = from.Policies
	}
}

func (to *ListPoliciesResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListPoliciesResponse_SdkV2) {
	if !from.Policies.IsNull() && !from.Policies.IsUnknown() && to.Policies.IsNull() && len(from.Policies.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Policies, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Policies = from.Policies
	}
}

func (m ListPoliciesResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetComputed()
	attrs["policies"] = attrs["policies"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListPoliciesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListPoliciesResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"policies": reflect.TypeOf(PolicyInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListPoliciesResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListPoliciesResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"policies":        m.Policies,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListPoliciesResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"policies": basetypes.ListType{
				ElemType: PolicyInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPolicies returns the value of the Policies field in ListPoliciesResponse_SdkV2 as
// a slice of PolicyInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListPoliciesResponse_SdkV2) GetPolicies(ctx context.Context) ([]PolicyInfo_SdkV2, bool) {
	if m.Policies.IsNull() || m.Policies.IsUnknown() {
		return nil, false
	}
	var v []PolicyInfo_SdkV2
	d := m.Policies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPolicies sets the value of the Policies field in ListPoliciesResponse_SdkV2.
func (m *ListPoliciesResponse_SdkV2) SetPolicies(ctx context.Context, v []PolicyInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["policies"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Policies = types.ListValueMust(t, vs)
}

type ListQuotasRequest_SdkV2 struct {
	// The number of quotas to return.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token for the next page of results.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListQuotasRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListQuotasRequest_SdkV2) {
}

func (to *ListQuotasRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListQuotasRequest_SdkV2) {
}

func (m ListQuotasRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListQuotasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListQuotasRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListQuotasRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListQuotasRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": m.MaxResults,
			"page_token":  m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListQuotasRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListQuotasResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of returned QuotaInfos.
	Quotas types.List `tfsdk:"quotas"`
}

func (to *ListQuotasResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListQuotasResponse_SdkV2) {
	if !from.Quotas.IsNull() && !from.Quotas.IsUnknown() && to.Quotas.IsNull() && len(from.Quotas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Quotas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Quotas = from.Quotas
	}
}

func (to *ListQuotasResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListQuotasResponse_SdkV2) {
	if !from.Quotas.IsNull() && !from.Quotas.IsUnknown() && to.Quotas.IsNull() && len(from.Quotas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Quotas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Quotas = from.Quotas
	}
}

func (m ListQuotasResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["quotas"] = attrs["quotas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListQuotasResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListQuotasResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quotas": reflect.TypeOf(QuotaInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListQuotasResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListQuotasResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"quotas":          m.Quotas,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListQuotasResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"quotas": basetypes.ListType{
				ElemType: QuotaInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetQuotas returns the value of the Quotas field in ListQuotasResponse_SdkV2 as
// a slice of QuotaInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListQuotasResponse_SdkV2) GetQuotas(ctx context.Context) ([]QuotaInfo_SdkV2, bool) {
	if m.Quotas.IsNull() || m.Quotas.IsUnknown() {
		return nil, false
	}
	var v []QuotaInfo_SdkV2
	d := m.Quotas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQuotas sets the value of the Quotas field in ListQuotasResponse_SdkV2.
func (m *ListQuotasResponse_SdkV2) SetQuotas(ctx context.Context, v []QuotaInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["quotas"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Quotas = types.ListValueMust(t, vs)
}

type ListRefreshesRequest_SdkV2 struct {
	// UC table name in format `catalog.schema.table_name`. table_name is case
	// insensitive and spaces are disallowed.
	TableName types.String `tfsdk:"-"`
}

func (to *ListRefreshesRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRefreshesRequest_SdkV2) {
}

func (to *ListRefreshesRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListRefreshesRequest_SdkV2) {
}

func (m ListRefreshesRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRefreshesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRefreshesRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRefreshesRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListRefreshesRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRefreshesRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

type ListRegisteredModelsRequest_SdkV2 struct {
	// The identifier of the catalog under which to list registered models. If
	// specified, schema_name must be specified.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include registered models in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Max number of registered models to return.
	//
	// If both catalog and schema are specified: - when max_results is not
	// specified, the page length is set to a server configured value (10000, as
	// of 4/2/2024). - when set to a value greater than 0, the page length is
	// the minimum of this value and a server configured value (10000, as of
	// 4/2/2024); - when set to 0, the page length is set to a server configured
	// value (10000, as of 4/2/2024); - when set to a value less than 0, an
	// invalid parameter error is returned;
	//
	// If neither schema nor catalog is specified: - when max_results is not
	// specified, the page length is set to a server configured value (100, as
	// of 4/2/2024). - when set to a value greater than 0, the page length is
	// the minimum of this value and a server configured value (1000, as of
	// 4/2/2024); - when set to 0, the page length is set to a server configured
	// value (100, as of 4/2/2024); - when set to a value less than 0, an
	// invalid parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token to send for the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// The identifier of the schema under which to list registered models. If
	// specified, catalog_name must be specified.
	SchemaName types.String `tfsdk:"-"`
}

func (to *ListRegisteredModelsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRegisteredModelsRequest_SdkV2) {
}

func (to *ListRegisteredModelsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListRegisteredModelsRequest_SdkV2) {
}

func (m ListRegisteredModelsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRegisteredModelsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRegisteredModelsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRegisteredModelsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListRegisteredModelsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   m.CatalogName,
			"include_browse": m.IncludeBrowse,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
			"schema_name":    m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRegisteredModelsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"schema_name":    types.StringType,
		},
	}
}

type ListRegisteredModelsResponse_SdkV2 struct {
	// Opaque token for pagination. Omitted if there are no more results.
	// page_token should be set to this value for fetching the next page.
	NextPageToken types.String `tfsdk:"next_page_token"`

	RegisteredModels types.List `tfsdk:"registered_models"`
}

func (to *ListRegisteredModelsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRegisteredModelsResponse_SdkV2) {
	if !from.RegisteredModels.IsNull() && !from.RegisteredModels.IsUnknown() && to.RegisteredModels.IsNull() && len(from.RegisteredModels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RegisteredModels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RegisteredModels = from.RegisteredModels
	}
}

func (to *ListRegisteredModelsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListRegisteredModelsResponse_SdkV2) {
	if !from.RegisteredModels.IsNull() && !from.RegisteredModels.IsUnknown() && to.RegisteredModels.IsNull() && len(from.RegisteredModels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RegisteredModels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RegisteredModels = from.RegisteredModels
	}
}

func (m ListRegisteredModelsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["registered_models"] = attrs["registered_models"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRegisteredModelsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRegisteredModelsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"registered_models": reflect.TypeOf(RegisteredModelInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRegisteredModelsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListRegisteredModelsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":   m.NextPageToken,
			"registered_models": m.RegisteredModels,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRegisteredModelsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"registered_models": basetypes.ListType{
				ElemType: RegisteredModelInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetRegisteredModels returns the value of the RegisteredModels field in ListRegisteredModelsResponse_SdkV2 as
// a slice of RegisteredModelInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListRegisteredModelsResponse_SdkV2) GetRegisteredModels(ctx context.Context) ([]RegisteredModelInfo_SdkV2, bool) {
	if m.RegisteredModels.IsNull() || m.RegisteredModels.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelInfo_SdkV2
	d := m.RegisteredModels.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRegisteredModels sets the value of the RegisteredModels field in ListRegisteredModelsResponse_SdkV2.
func (m *ListRegisteredModelsResponse_SdkV2) SetRegisteredModels(ctx context.Context, v []RegisteredModelInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["registered_models"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RegisteredModels = types.ListValueMust(t, vs)
}

type ListSchemasRequest_SdkV2 struct {
	// Parent catalog for schemas of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include schemas in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of schemas to return. If not set, all the schemas are
	// returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListSchemasRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSchemasRequest_SdkV2) {
}

func (to *ListSchemasRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListSchemasRequest_SdkV2) {
}

func (m ListSchemasRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSchemasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSchemasRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSchemasRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListSchemasRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   m.CatalogName,
			"include_browse": m.IncludeBrowse,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSchemasRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
		},
	}
}

type ListSchemasResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of schema information objects.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *ListSchemasResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSchemasResponse_SdkV2) {
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *ListSchemasResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListSchemasResponse_SdkV2) {
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (m ListSchemasResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSchemasResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSchemasResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schemas": reflect.TypeOf(SchemaInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSchemasResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListSchemasResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"schemas":         m.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSchemasResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"schemas": basetypes.ListType{
				ElemType: SchemaInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSchemas returns the value of the Schemas field in ListSchemasResponse_SdkV2 as
// a slice of SchemaInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListSchemasResponse_SdkV2) GetSchemas(ctx context.Context) ([]SchemaInfo_SdkV2, bool) {
	if m.Schemas.IsNull() || m.Schemas.IsUnknown() {
		return nil, false
	}
	var v []SchemaInfo_SdkV2
	d := m.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListSchemasResponse_SdkV2.
func (m *ListSchemasResponse_SdkV2) SetSchemas(ctx context.Context, v []SchemaInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Schemas = types.ListValueMust(t, vs)
}

type ListStorageCredentialsRequest_SdkV2 struct {
	// Whether to include credentials not bound to the workspace. Effective only
	// if the user has permission to update the credentialworkspace binding.
	IncludeUnbound types.Bool `tfsdk:"-"`
	// Maximum number of storage credentials to return. If not set, all the
	// storage credentials are returned (not recommended). - when set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - when set to 0, the page length is set to a server
	// configured value (recommended); - when set to a value less than 0, an
	// invalid parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListStorageCredentialsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListStorageCredentialsRequest_SdkV2) {
}

func (to *ListStorageCredentialsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListStorageCredentialsRequest_SdkV2) {
}

func (m ListStorageCredentialsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["include_unbound"] = attrs["include_unbound"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListStorageCredentialsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListStorageCredentialsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListStorageCredentialsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListStorageCredentialsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_unbound": m.IncludeUnbound,
			"max_results":     m.MaxResults,
			"page_token":      m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListStorageCredentialsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_unbound": types.BoolType,
			"max_results":     types.Int64Type,
			"page_token":      types.StringType,
		},
	}
}

type ListStorageCredentialsResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`

	StorageCredentials types.List `tfsdk:"storage_credentials"`
}

func (to *ListStorageCredentialsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListStorageCredentialsResponse_SdkV2) {
	if !from.StorageCredentials.IsNull() && !from.StorageCredentials.IsUnknown() && to.StorageCredentials.IsNull() && len(from.StorageCredentials.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for StorageCredentials, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.StorageCredentials = from.StorageCredentials
	}
}

func (to *ListStorageCredentialsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListStorageCredentialsResponse_SdkV2) {
	if !from.StorageCredentials.IsNull() && !from.StorageCredentials.IsUnknown() && to.StorageCredentials.IsNull() && len(from.StorageCredentials.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for StorageCredentials, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.StorageCredentials = from.StorageCredentials
	}
}

func (m ListStorageCredentialsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["storage_credentials"] = attrs["storage_credentials"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListStorageCredentialsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListStorageCredentialsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"storage_credentials": reflect.TypeOf(StorageCredentialInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListStorageCredentialsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListStorageCredentialsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":     m.NextPageToken,
			"storage_credentials": m.StorageCredentials,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListStorageCredentialsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"storage_credentials": basetypes.ListType{
				ElemType: StorageCredentialInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetStorageCredentials returns the value of the StorageCredentials field in ListStorageCredentialsResponse_SdkV2 as
// a slice of StorageCredentialInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListStorageCredentialsResponse_SdkV2) GetStorageCredentials(ctx context.Context) ([]StorageCredentialInfo_SdkV2, bool) {
	if m.StorageCredentials.IsNull() || m.StorageCredentials.IsUnknown() {
		return nil, false
	}
	var v []StorageCredentialInfo_SdkV2
	d := m.StorageCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStorageCredentials sets the value of the StorageCredentials field in ListStorageCredentialsResponse_SdkV2.
func (m *ListStorageCredentialsResponse_SdkV2) SetStorageCredentials(ctx context.Context, v []StorageCredentialInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["storage_credentials"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.StorageCredentials = types.ListValueMust(t, vs)
}

type ListSummariesRequest_SdkV2 struct {
	// Name of parent catalog for tables of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include a manifest containing table capabilities in the
	// response.
	IncludeManifestCapabilities types.Bool `tfsdk:"-"`
	// Maximum number of summaries for tables to return. If not set, the page
	// length is set to a server configured value (10000, as of 1/5/2024). -
	// when set to a value greater than 0, the page length is the minimum of
	// this value and a server configured value (10000, as of 1/5/2024); - when
	// set to 0, the page length is set to a server configured value (10000, as
	// of 1/5/2024) (recommended); - when set to a value less than 0, an invalid
	// parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// A sql LIKE pattern (% and _) for schema names. All schemas will be
	// returned if not set or empty.
	SchemaNamePattern types.String `tfsdk:"-"`
	// A sql LIKE pattern (% and _) for table names. All tables will be returned
	// if not set or empty.
	TableNamePattern types.String `tfsdk:"-"`
}

func (to *ListSummariesRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSummariesRequest_SdkV2) {
}

func (to *ListSummariesRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListSummariesRequest_SdkV2) {
}

func (m ListSummariesRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name_pattern"] = attrs["schema_name_pattern"].SetOptional()
	attrs["table_name_pattern"] = attrs["table_name_pattern"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_manifest_capabilities"] = attrs["include_manifest_capabilities"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSummariesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSummariesRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSummariesRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListSummariesRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":                  m.CatalogName,
			"include_manifest_capabilities": m.IncludeManifestCapabilities,
			"max_results":                   m.MaxResults,
			"page_token":                    m.PageToken,
			"schema_name_pattern":           m.SchemaNamePattern,
			"table_name_pattern":            m.TableNamePattern,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSummariesRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":                  types.StringType,
			"include_manifest_capabilities": types.BoolType,
			"max_results":                   types.Int64Type,
			"page_token":                    types.StringType,
			"schema_name_pattern":           types.StringType,
			"table_name_pattern":            types.StringType,
		},
	}
}

type ListSystemSchemasRequest_SdkV2 struct {
	// Maximum number of schemas to return. - When set to 0, the page length is
	// set to a server configured value (recommended); - When set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - When set to a value less than 0, an invalid parameter
	// error is returned; - If not set, all the schemas are returned (not
	// recommended).
	MaxResults types.Int64 `tfsdk:"-"`
	// The ID for the metastore in which the system schema resides.
	MetastoreId types.String `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListSystemSchemasRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSystemSchemasRequest_SdkV2) {
}

func (to *ListSystemSchemasRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListSystemSchemasRequest_SdkV2) {
}

func (m ListSystemSchemasRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSystemSchemasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSystemSchemasRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSystemSchemasRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListSystemSchemasRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results":  m.MaxResults,
			"metastore_id": m.MetastoreId,
			"page_token":   m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSystemSchemasRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results":  types.Int64Type,
			"metastore_id": types.StringType,
			"page_token":   types.StringType,
		},
	}
}

type ListSystemSchemasResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of system schema information objects.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *ListSystemSchemasResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSystemSchemasResponse_SdkV2) {
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *ListSystemSchemasResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListSystemSchemasResponse_SdkV2) {
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (m ListSystemSchemasResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSystemSchemasResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSystemSchemasResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schemas": reflect.TypeOf(SystemSchemaInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSystemSchemasResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListSystemSchemasResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"schemas":         m.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSystemSchemasResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"schemas": basetypes.ListType{
				ElemType: SystemSchemaInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSchemas returns the value of the Schemas field in ListSystemSchemasResponse_SdkV2 as
// a slice of SystemSchemaInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListSystemSchemasResponse_SdkV2) GetSchemas(ctx context.Context) ([]SystemSchemaInfo_SdkV2, bool) {
	if m.Schemas.IsNull() || m.Schemas.IsUnknown() {
		return nil, false
	}
	var v []SystemSchemaInfo_SdkV2
	d := m.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListSystemSchemasResponse_SdkV2.
func (m *ListSystemSchemasResponse_SdkV2) SetSchemas(ctx context.Context, v []SystemSchemaInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Schemas = types.ListValueMust(t, vs)
}

type ListTableSummariesResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// List of table summaries.
	Tables types.List `tfsdk:"tables"`
}

func (to *ListTableSummariesResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListTableSummariesResponse_SdkV2) {
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (to *ListTableSummariesResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListTableSummariesResponse_SdkV2) {
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (m ListTableSummariesResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["tables"] = attrs["tables"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListTableSummariesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListTableSummariesResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tables": reflect.TypeOf(TableSummary_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListTableSummariesResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListTableSummariesResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"tables":          m.Tables,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListTableSummariesResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"tables": basetypes.ListType{
				ElemType: TableSummary_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTables returns the value of the Tables field in ListTableSummariesResponse_SdkV2 as
// a slice of TableSummary_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListTableSummariesResponse_SdkV2) GetTables(ctx context.Context) ([]TableSummary_SdkV2, bool) {
	if m.Tables.IsNull() || m.Tables.IsUnknown() {
		return nil, false
	}
	var v []TableSummary_SdkV2
	d := m.Tables.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTables sets the value of the Tables field in ListTableSummariesResponse_SdkV2.
func (m *ListTableSummariesResponse_SdkV2) SetTables(ctx context.Context, v []TableSummary_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tables"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tables = types.ListValueMust(t, vs)
}

type ListTablesRequest_SdkV2 struct {
	// Name of parent catalog for tables of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include tables in the response for which the principal can
	// only access selective metadata for.
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Whether to include a manifest containing table capabilities in the
	// response.
	IncludeManifestCapabilities types.Bool `tfsdk:"-"`
	// Maximum number of tables to return. If not set, all the tables are
	// returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Whether to omit the columns of the table from the response or not.
	OmitColumns types.Bool `tfsdk:"-"`
	// Whether to omit the properties of the table from the response or not.
	OmitProperties types.Bool `tfsdk:"-"`
	// Whether to omit the username of the table (e.g. owner, updated_by,
	// created_by) from the response or not.
	OmitUsername types.Bool `tfsdk:"-"`
	// Opaque token to send for the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// Parent schema of tables.
	SchemaName types.String `tfsdk:"-"`
}

func (to *ListTablesRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListTablesRequest_SdkV2) {
}

func (to *ListTablesRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListTablesRequest_SdkV2) {
}

func (m ListTablesRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["omit_columns"] = attrs["omit_columns"].SetOptional()
	attrs["omit_properties"] = attrs["omit_properties"].SetOptional()
	attrs["omit_username"] = attrs["omit_username"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["include_manifest_capabilities"] = attrs["include_manifest_capabilities"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListTablesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListTablesRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListTablesRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListTablesRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":                  m.CatalogName,
			"include_browse":                m.IncludeBrowse,
			"include_manifest_capabilities": m.IncludeManifestCapabilities,
			"max_results":                   m.MaxResults,
			"omit_columns":                  m.OmitColumns,
			"omit_properties":               m.OmitProperties,
			"omit_username":                 m.OmitUsername,
			"page_token":                    m.PageToken,
			"schema_name":                   m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListTablesRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":                  types.StringType,
			"include_browse":                types.BoolType,
			"include_manifest_capabilities": types.BoolType,
			"max_results":                   types.Int64Type,
			"omit_columns":                  types.BoolType,
			"omit_properties":               types.BoolType,
			"omit_username":                 types.BoolType,
			"page_token":                    types.StringType,
			"schema_name":                   types.StringType,
		},
	}
}

type ListTablesResponse_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of table information objects.
	Tables types.List `tfsdk:"tables"`
}

func (to *ListTablesResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListTablesResponse_SdkV2) {
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (to *ListTablesResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListTablesResponse_SdkV2) {
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (m ListTablesResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["tables"] = attrs["tables"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListTablesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListTablesResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tables": reflect.TypeOf(TableInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListTablesResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListTablesResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"tables":          m.Tables,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListTablesResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"tables": basetypes.ListType{
				ElemType: TableInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTables returns the value of the Tables field in ListTablesResponse_SdkV2 as
// a slice of TableInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListTablesResponse_SdkV2) GetTables(ctx context.Context) ([]TableInfo_SdkV2, bool) {
	if m.Tables.IsNull() || m.Tables.IsUnknown() {
		return nil, false
	}
	var v []TableInfo_SdkV2
	d := m.Tables.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTables sets the value of the Tables field in ListTablesResponse_SdkV2.
func (m *ListTablesResponse_SdkV2) SetTables(ctx context.Context, v []TableInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tables"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tables = types.ListValueMust(t, vs)
}

type ListVolumesRequest_SdkV2 struct {
	// The identifier of the catalog
	CatalogName types.String `tfsdk:"-"`
	// Whether to include volumes in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of volumes to return (page length).
	//
	// If not set, the page length is set to a server configured value (10000,
	// as of 1/29/2024). - when set to a value greater than 0, the page length
	// is the minimum of this value and a server configured value (10000, as of
	// 1/29/2024); - when set to 0, the page length is set to a server
	// configured value (10000, as of 1/29/2024) (recommended); - when set to a
	// value less than 0, an invalid parameter error is returned;
	//
	// Note: this parameter controls only the maximum number of volumes to
	// return. The actual number of volumes returned in a page may be smaller
	// than this value, including 0, even if there are more pages.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token returned by a previous request. It must be included in the
	// request to retrieve the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// The identifier of the schema
	SchemaName types.String `tfsdk:"-"`
}

func (to *ListVolumesRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListVolumesRequest_SdkV2) {
}

func (to *ListVolumesRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListVolumesRequest_SdkV2) {
}

func (m ListVolumesRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListVolumesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListVolumesRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListVolumesRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListVolumesRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   m.CatalogName,
			"include_browse": m.IncludeBrowse,
			"max_results":    m.MaxResults,
			"page_token":     m.PageToken,
			"schema_name":    m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListVolumesRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"schema_name":    types.StringType,
		},
	}
}

type ListVolumesResponseContent_SdkV2 struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request to retrieve the next page of results.
	NextPageToken types.String `tfsdk:"next_page_token"`

	Volumes types.List `tfsdk:"volumes"`
}

func (to *ListVolumesResponseContent_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListVolumesResponseContent_SdkV2) {
	if !from.Volumes.IsNull() && !from.Volumes.IsUnknown() && to.Volumes.IsNull() && len(from.Volumes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Volumes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Volumes = from.Volumes
	}
}

func (to *ListVolumesResponseContent_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListVolumesResponseContent_SdkV2) {
	if !from.Volumes.IsNull() && !from.Volumes.IsUnknown() && to.Volumes.IsNull() && len(from.Volumes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Volumes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Volumes = from.Volumes
	}
}

func (m ListVolumesResponseContent_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["volumes"] = attrs["volumes"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListVolumesResponseContent.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListVolumesResponseContent_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"volumes": reflect.TypeOf(VolumeInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListVolumesResponseContent_SdkV2
// only implements ToObjectValue() and Type().
func (m ListVolumesResponseContent_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"volumes":         m.Volumes,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListVolumesResponseContent_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"volumes": basetypes.ListType{
				ElemType: VolumeInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetVolumes returns the value of the Volumes field in ListVolumesResponseContent_SdkV2 as
// a slice of VolumeInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListVolumesResponseContent_SdkV2) GetVolumes(ctx context.Context) ([]VolumeInfo_SdkV2, bool) {
	if m.Volumes.IsNull() || m.Volumes.IsUnknown() {
		return nil, false
	}
	var v []VolumeInfo_SdkV2
	d := m.Volumes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetVolumes sets the value of the Volumes field in ListVolumesResponseContent_SdkV2.
func (m *ListVolumesResponseContent_SdkV2) SetVolumes(ctx context.Context, v []VolumeInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["volumes"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Volumes = types.ListValueMust(t, vs)
}

type MatchColumn_SdkV2 struct {
	// Optional alias of the matched column.
	Alias types.String `tfsdk:"alias"`
	// The condition expression used to match a table column.
	Condition types.String `tfsdk:"condition"`
}

func (to *MatchColumn_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MatchColumn_SdkV2) {
}

func (to *MatchColumn_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MatchColumn_SdkV2) {
}

func (m MatchColumn_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias"] = attrs["alias"].SetOptional()
	attrs["condition"] = attrs["condition"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MatchColumn.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MatchColumn_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MatchColumn_SdkV2
// only implements ToObjectValue() and Type().
func (m MatchColumn_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":     m.Alias,
			"condition": m.Condition,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MatchColumn_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":     types.StringType,
			"condition": types.StringType,
		},
	}
}

type MetastoreAssignment_SdkV2 struct {
	// The name of the default catalog in the metastore. This field is
	// deprecated. Please use "Default Namespace API" to configure the default
	// catalog for a Databricks workspace.
	DefaultCatalogName types.String `tfsdk:"default_catalog_name"`
	// The unique ID of the metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The unique ID of the Databricks workspace.
	WorkspaceId types.Int64 `tfsdk:"workspace_id"`
}

func (to *MetastoreAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MetastoreAssignment_SdkV2) {
}

func (to *MetastoreAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MetastoreAssignment_SdkV2) {
}

func (m MetastoreAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default_catalog_name"] = attrs["default_catalog_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MetastoreAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MetastoreAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m MetastoreAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default_catalog_name": m.DefaultCatalogName,
			"metastore_id":         m.MetastoreId,
			"workspace_id":         m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MetastoreAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default_catalog_name": types.StringType,
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

type MetastoreInfo_SdkV2 struct {
	// Cloud vendor of the metastore home shard (e.g., `aws`, `azure`, `gcp`).
	Cloud types.String `tfsdk:"cloud"`
	// Time at which this metastore was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of metastore creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of the metastore's (Default) Data Access Configuration.
	DefaultDataAccessConfigId types.String `tfsdk:"default_data_access_config_id"`
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// Whether to allow non-DBR clients to directly access entities under the
	// metastore.
	ExternalAccessEnabled types.Bool `tfsdk:"external_access_enabled"`
	// Globally unique metastore ID across clouds and regions, of the form
	// `cloud:region:metastore_id`.
	GlobalMetastoreId types.String `tfsdk:"global_metastore_id"`
	// Unique identifier of metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
	// Name of the storage credential to access the metastore storage_root.
	StorageRootCredentialName types.String `tfsdk:"storage_root_credential_name"`
	// Time at which the metastore was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the metastore.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *MetastoreInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MetastoreInfo_SdkV2) {
}

func (to *MetastoreInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MetastoreInfo_SdkV2) {
}

func (m MetastoreInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["cloud"] = attrs["cloud"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["default_data_access_config_id"] = attrs["default_data_access_config_id"].SetOptional()
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["external_access_enabled"] = attrs["external_access_enabled"].SetOptional()
	attrs["global_metastore_id"] = attrs["global_metastore_id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()
	attrs["storage_root_credential_name"] = attrs["storage_root_credential_name"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MetastoreInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MetastoreInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MetastoreInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m MetastoreInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cloud":                           m.Cloud,
			"created_at":                      m.CreatedAt,
			"created_by":                      m.CreatedBy,
			"default_data_access_config_id":   m.DefaultDataAccessConfigId,
			"delta_sharing_organization_name": m.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": m.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               m.DeltaSharingScope,
			"external_access_enabled":                           m.ExternalAccessEnabled,
			"global_metastore_id":                               m.GlobalMetastoreId,
			"metastore_id":                                      m.MetastoreId,
			"name":                                              m.Name,
			"owner":                                             m.Owner,
			"privilege_model_version":                           m.PrivilegeModelVersion,
			"region":                                            m.Region,
			"storage_root":                                      m.StorageRoot,
			"storage_root_credential_id":                        m.StorageRootCredentialId,
			"storage_root_credential_name":                      m.StorageRootCredentialName,
			"updated_at":                                        m.UpdatedAt,
			"updated_by":                                        m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MetastoreInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cloud":                           types.StringType,
			"created_at":                      types.Int64Type,
			"created_by":                      types.StringType,
			"default_data_access_config_id":   types.StringType,
			"delta_sharing_organization_name": types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"external_access_enabled":                           types.BoolType,
			"global_metastore_id":                               types.StringType,
			"metastore_id":                                      types.StringType,
			"name":                                              types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"region":                                            types.StringType,
			"storage_root":                                      types.StringType,
			"storage_root_credential_id":                        types.StringType,
			"storage_root_credential_name":                      types.StringType,
			"updated_at":                                        types.Int64Type,
			"updated_by":                                        types.StringType,
		},
	}
}

type ModelVersionInfo_SdkV2 struct {
	// List of aliases associated with the model version
	Aliases types.List `tfsdk:"aliases"`
	// The name of the catalog containing the model version
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the model version
	Comment types.String `tfsdk:"comment"`

	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the model version
	CreatedBy types.String `tfsdk:"created_by"`
	// The unique identifier of the model version
	Id types.String `tfsdk:"id"`
	// The unique identifier of the metastore containing the model version
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the parent registered model of the model version, relative to
	// parent schema
	ModelName types.String `tfsdk:"model_name"`
	// Model version dependencies, for feature-store packaged models
	ModelVersionDependencies types.List `tfsdk:"model_version_dependencies"`
	// MLflow run ID used when creating the model version, if ``source`` was
	// generated by an experiment run stored in an MLflow tracking server
	RunId types.String `tfsdk:"run_id"`
	// ID of the Databricks workspace containing the MLflow run that generated
	// this model version, if applicable
	RunWorkspaceId types.Int64 `tfsdk:"run_workspace_id"`
	// The name of the schema containing the model version, relative to parent
	// catalog
	SchemaName types.String `tfsdk:"schema_name"`
	// URI indicating the location of the source artifacts (files) for the model
	// version
	Source types.String `tfsdk:"source"`
	// Current status of the model version. Newly created model versions start
	// in PENDING_REGISTRATION status, then move to READY status once the model
	// version files are uploaded and the model version is finalized. Only model
	// versions in READY status can be loaded for inference or served.
	Status types.String `tfsdk:"status"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`

	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the model version last time
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Integer model version number, used to reference the model version in API
	// requests.
	Version types.Int64 `tfsdk:"version"`
}

func (to *ModelVersionInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ModelVersionInfo_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
	if !from.ModelVersionDependencies.IsNull() && !from.ModelVersionDependencies.IsUnknown() {
		if toModelVersionDependencies, ok := to.GetModelVersionDependencies(ctx); ok {
			if fromModelVersionDependencies, ok := from.GetModelVersionDependencies(ctx); ok {
				// Recursively sync the fields of ModelVersionDependencies
				toModelVersionDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromModelVersionDependencies)
				to.SetModelVersionDependencies(ctx, toModelVersionDependencies)
			}
		}
	}
}

func (to *ModelVersionInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ModelVersionInfo_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
	if !from.ModelVersionDependencies.IsNull() && !from.ModelVersionDependencies.IsUnknown() {
		if toModelVersionDependencies, ok := to.GetModelVersionDependencies(ctx); ok {
			if fromModelVersionDependencies, ok := from.GetModelVersionDependencies(ctx); ok {
				toModelVersionDependencies.SyncFieldsDuringRead(ctx, fromModelVersionDependencies)
				to.SetModelVersionDependencies(ctx, toModelVersionDependencies)
			}
		}
	}
}

func (m ModelVersionInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["model_version_dependencies"] = attrs["model_version_dependencies"].SetOptional()
	attrs["model_version_dependencies"] = attrs["model_version_dependencies"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_workspace_id"] = attrs["run_workspace_id"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["version"] = attrs["version"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ModelVersionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ModelVersionInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases":                    reflect.TypeOf(RegisteredModelAlias_SdkV2{}),
		"model_version_dependencies": reflect.TypeOf(DependencyList_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ModelVersionInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ModelVersionInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":                    m.Aliases,
			"catalog_name":               m.CatalogName,
			"comment":                    m.Comment,
			"created_at":                 m.CreatedAt,
			"created_by":                 m.CreatedBy,
			"id":                         m.Id,
			"metastore_id":               m.MetastoreId,
			"model_name":                 m.ModelName,
			"model_version_dependencies": m.ModelVersionDependencies,
			"run_id":                     m.RunId,
			"run_workspace_id":           m.RunWorkspaceId,
			"schema_name":                m.SchemaName,
			"source":                     m.Source,
			"status":                     m.Status,
			"storage_location":           m.StorageLocation,
			"updated_at":                 m.UpdatedAt,
			"updated_by":                 m.UpdatedBy,
			"version":                    m.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ModelVersionInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias_SdkV2{}.Type(ctx),
			},
			"catalog_name": types.StringType,
			"comment":      types.StringType,
			"created_at":   types.Int64Type,
			"created_by":   types.StringType,
			"id":           types.StringType,
			"metastore_id": types.StringType,
			"model_name":   types.StringType,
			"model_version_dependencies": basetypes.ListType{
				ElemType: DependencyList_SdkV2{}.Type(ctx),
			},
			"run_id":           types.StringType,
			"run_workspace_id": types.Int64Type,
			"schema_name":      types.StringType,
			"source":           types.StringType,
			"status":           types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
			"version":          types.Int64Type,
		},
	}
}

// GetAliases returns the value of the Aliases field in ModelVersionInfo_SdkV2 as
// a slice of RegisteredModelAlias_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ModelVersionInfo_SdkV2) GetAliases(ctx context.Context) ([]RegisteredModelAlias_SdkV2, bool) {
	if m.Aliases.IsNull() || m.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias_SdkV2
	d := m.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in ModelVersionInfo_SdkV2.
func (m *ModelVersionInfo_SdkV2) SetAliases(ctx context.Context, v []RegisteredModelAlias_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Aliases = types.ListValueMust(t, vs)
}

// GetModelVersionDependencies returns the value of the ModelVersionDependencies field in ModelVersionInfo_SdkV2 as
// a DependencyList_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ModelVersionInfo_SdkV2) GetModelVersionDependencies(ctx context.Context) (DependencyList_SdkV2, bool) {
	var e DependencyList_SdkV2
	if m.ModelVersionDependencies.IsNull() || m.ModelVersionDependencies.IsUnknown() {
		return e, false
	}
	var v []DependencyList_SdkV2
	d := m.ModelVersionDependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetModelVersionDependencies sets the value of the ModelVersionDependencies field in ModelVersionInfo_SdkV2.
func (m *ModelVersionInfo_SdkV2) SetModelVersionDependencies(ctx context.Context, v DependencyList_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["model_version_dependencies"]
	m.ModelVersionDependencies = types.ListValueMust(t, vs)
}

type MonitorCronSchedule_SdkV2 struct {
	// Read only field that indicates whether a schedule is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// The expression that determines when to run the monitor. See [examples].
	//
	// [examples]: https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html
	QuartzCronExpression types.String `tfsdk:"quartz_cron_expression"`
	// The timezone id (e.g., ``PST``) in which to evaluate the quartz
	// expression.
	TimezoneId types.String `tfsdk:"timezone_id"`
}

func (to *MonitorCronSchedule_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorCronSchedule_SdkV2) {
}

func (to *MonitorCronSchedule_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorCronSchedule_SdkV2) {
}

func (m MonitorCronSchedule_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["quartz_cron_expression"] = attrs["quartz_cron_expression"].SetRequired()
	attrs["timezone_id"] = attrs["timezone_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorCronSchedule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorCronSchedule_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorCronSchedule_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorCronSchedule_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"pause_status":           m.PauseStatus,
			"quartz_cron_expression": m.QuartzCronExpression,
			"timezone_id":            m.TimezoneId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorCronSchedule_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"pause_status":           types.StringType,
			"quartz_cron_expression": types.StringType,
			"timezone_id":            types.StringType,
		},
	}
}

// Data classification related configuration.
type MonitorDataClassificationConfig_SdkV2 struct {
	// Whether to enable data classification.
	Enabled types.Bool `tfsdk:"enabled"`
}

func (to *MonitorDataClassificationConfig_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorDataClassificationConfig_SdkV2) {
}

func (to *MonitorDataClassificationConfig_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorDataClassificationConfig_SdkV2) {
}

func (m MonitorDataClassificationConfig_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["enabled"] = attrs["enabled"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorDataClassificationConfig.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorDataClassificationConfig_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorDataClassificationConfig_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorDataClassificationConfig_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"enabled": m.Enabled,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorDataClassificationConfig_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"enabled": types.BoolType,
		},
	}
}

type MonitorDestination_SdkV2 struct {
	// The list of email addresses to send the notification to. A maximum of 5
	// email addresses is supported.
	EmailAddresses types.List `tfsdk:"email_addresses"`
}

func (to *MonitorDestination_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorDestination_SdkV2) {
	if !from.EmailAddresses.IsNull() && !from.EmailAddresses.IsUnknown() && to.EmailAddresses.IsNull() && len(from.EmailAddresses.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for EmailAddresses, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.EmailAddresses = from.EmailAddresses
	}
}

func (to *MonitorDestination_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorDestination_SdkV2) {
	if !from.EmailAddresses.IsNull() && !from.EmailAddresses.IsUnknown() && to.EmailAddresses.IsNull() && len(from.EmailAddresses.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for EmailAddresses, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.EmailAddresses = from.EmailAddresses
	}
}

func (m MonitorDestination_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["email_addresses"] = attrs["email_addresses"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorDestination.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorDestination_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"email_addresses": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorDestination_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorDestination_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"email_addresses": m.EmailAddresses,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorDestination_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"email_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEmailAddresses returns the value of the EmailAddresses field in MonitorDestination_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorDestination_SdkV2) GetEmailAddresses(ctx context.Context) ([]types.String, bool) {
	if m.EmailAddresses.IsNull() || m.EmailAddresses.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.EmailAddresses.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailAddresses sets the value of the EmailAddresses field in MonitorDestination_SdkV2.
func (m *MonitorDestination_SdkV2) SetEmailAddresses(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_addresses"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.EmailAddresses = types.ListValueMust(t, vs)
}

type MonitorInferenceLog_SdkV2 struct {
	// List of granularities to use when aggregating data into time windows
	// based on their timestamp.
	Granularities types.List `tfsdk:"granularities"`
	// Column for the label.
	LabelCol types.String `tfsdk:"label_col"`
	// Column for the model identifier.
	ModelIdCol types.String `tfsdk:"model_id_col"`
	// Column for the prediction.
	PredictionCol types.String `tfsdk:"prediction_col"`
	// Column for prediction probabilities
	PredictionProbaCol types.String `tfsdk:"prediction_proba_col"`
	// Problem type the model aims to solve.
	ProblemType types.String `tfsdk:"problem_type"`
	// Column for the timestamp.
	TimestampCol types.String `tfsdk:"timestamp_col"`
}

func (to *MonitorInferenceLog_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorInferenceLog_SdkV2) {
}

func (to *MonitorInferenceLog_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorInferenceLog_SdkV2) {
}

func (m MonitorInferenceLog_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["granularities"] = attrs["granularities"].SetRequired()
	attrs["label_col"] = attrs["label_col"].SetOptional()
	attrs["model_id_col"] = attrs["model_id_col"].SetRequired()
	attrs["prediction_col"] = attrs["prediction_col"].SetRequired()
	attrs["prediction_proba_col"] = attrs["prediction_proba_col"].SetOptional()
	attrs["problem_type"] = attrs["problem_type"].SetRequired()
	attrs["timestamp_col"] = attrs["timestamp_col"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorInferenceLog.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorInferenceLog_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"granularities": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorInferenceLog_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorInferenceLog_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"granularities":        m.Granularities,
			"label_col":            m.LabelCol,
			"model_id_col":         m.ModelIdCol,
			"prediction_col":       m.PredictionCol,
			"prediction_proba_col": m.PredictionProbaCol,
			"problem_type":         m.ProblemType,
			"timestamp_col":        m.TimestampCol,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorInferenceLog_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"granularities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"label_col":            types.StringType,
			"model_id_col":         types.StringType,
			"prediction_col":       types.StringType,
			"prediction_proba_col": types.StringType,
			"problem_type":         types.StringType,
			"timestamp_col":        types.StringType,
		},
	}
}

// GetGranularities returns the value of the Granularities field in MonitorInferenceLog_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInferenceLog_SdkV2) GetGranularities(ctx context.Context) ([]types.String, bool) {
	if m.Granularities.IsNull() || m.Granularities.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Granularities.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGranularities sets the value of the Granularities field in MonitorInferenceLog_SdkV2.
func (m *MonitorInferenceLog_SdkV2) SetGranularities(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["granularities"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Granularities = types.ListValueMust(t, vs)
}

type MonitorInfo_SdkV2 struct {
	// [Create:REQ Update:IGN] Field for specifying the absolute path to a
	// custom directory to store data-monitoring assets. Normally prepopulated
	// to a default user location via UI and Python APIs.
	AssetsDir types.String `tfsdk:"assets_dir"`
	// [Create:OPT Update:OPT] Baseline table name. Baseline data is used to
	// compute drift from the data in the monitored `table_name`. The baseline
	// table and the monitored table shall have the same schema.
	BaselineTableName types.String `tfsdk:"baseline_table_name"`
	// [Create:OPT Update:OPT] Custom metrics.
	CustomMetrics types.List `tfsdk:"custom_metrics"`
	// [Create:ERR Update:OPT] Id of dashboard that visualizes the computed
	// metrics. This can be empty if the monitor is in PENDING state.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// [Create:OPT Update:OPT] Data classification related config.
	DataClassificationConfig types.List `tfsdk:"data_classification_config"`
	// [Create:ERR Update:IGN] Table that stores drift metrics data. Format:
	// `catalog.schema.table_name`.
	DriftMetricsTableName types.String `tfsdk:"drift_metrics_table_name"`

	InferenceLog types.List `tfsdk:"inference_log"`
	// [Create:ERR Update:IGN] The latest error message for a monitor failure.
	LatestMonitorFailureMsg types.String `tfsdk:"latest_monitor_failure_msg"`
	// [Create:ERR Update:IGN] Represents the current monitor configuration
	// version in use. The version will be represented in a numeric fashion
	// (1,2,3...). The field has flexibility to take on negative values, which
	// can indicate corrupted monitor_version numbers.
	MonitorVersion types.Int64 `tfsdk:"monitor_version"`
	// [Create:OPT Update:OPT] Field for specifying notification settings.
	Notifications types.List `tfsdk:"notifications"`
	// [Create:REQ Update:REQ] Schema where output tables are created. Needs to
	// be in 2-level format {catalog}.{schema}
	OutputSchemaName types.String `tfsdk:"output_schema_name"`
	// [Create:ERR Update:IGN] Table that stores profile metrics data. Format:
	// `catalog.schema.table_name`.
	ProfileMetricsTableName types.String `tfsdk:"profile_metrics_table_name"`
	// [Create:OPT Update:OPT] The monitor schedule.
	Schedule types.List `tfsdk:"schedule"`
	// [Create:OPT Update:OPT] List of column expressions to slice data with for
	// targeted analysis. The data is grouped by each expression independently,
	// resulting in a separate slice for each predicate and its complements. For
	// example `slicing_exprs=[col_1, col_2 > 10]` will generate the
	// following slices: two slices for `col_2 > 10` (True and False), and one
	// slice per unique value in `col1`. For high-cardinality columns, only the
	// top 100 unique values by frequency will generate slices.
	SlicingExprs types.List `tfsdk:"slicing_exprs"`
	// Configuration for monitoring snapshot tables.
	Snapshot types.List `tfsdk:"snapshot"`
	// [Create:ERR Update:IGN] The monitor status.
	Status types.String `tfsdk:"status"`
	// [Create:ERR Update:IGN] UC table to monitor. Format:
	// `catalog.schema.table_name`
	TableName types.String `tfsdk:"table_name"`
	// Configuration for monitoring time series tables.
	TimeSeries types.List `tfsdk:"time_series"`
}

func (to *MonitorInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorInfo_SdkV2) {
	if !from.CustomMetrics.IsNull() && !from.CustomMetrics.IsUnknown() && to.CustomMetrics.IsNull() && len(from.CustomMetrics.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for CustomMetrics, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.CustomMetrics = from.CustomMetrics
	}
	if !from.DataClassificationConfig.IsNull() && !from.DataClassificationConfig.IsUnknown() {
		if toDataClassificationConfig, ok := to.GetDataClassificationConfig(ctx); ok {
			if fromDataClassificationConfig, ok := from.GetDataClassificationConfig(ctx); ok {
				// Recursively sync the fields of DataClassificationConfig
				toDataClassificationConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromDataClassificationConfig)
				to.SetDataClassificationConfig(ctx, toDataClassificationConfig)
			}
		}
	}
	if !from.InferenceLog.IsNull() && !from.InferenceLog.IsUnknown() {
		if toInferenceLog, ok := to.GetInferenceLog(ctx); ok {
			if fromInferenceLog, ok := from.GetInferenceLog(ctx); ok {
				// Recursively sync the fields of InferenceLog
				toInferenceLog.SyncFieldsDuringCreateOrUpdate(ctx, fromInferenceLog)
				to.SetInferenceLog(ctx, toInferenceLog)
			}
		}
	}
	if !from.Notifications.IsNull() && !from.Notifications.IsUnknown() {
		if toNotifications, ok := to.GetNotifications(ctx); ok {
			if fromNotifications, ok := from.GetNotifications(ctx); ok {
				// Recursively sync the fields of Notifications
				toNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromNotifications)
				to.SetNotifications(ctx, toNotifications)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.SlicingExprs.IsNull() && !from.SlicingExprs.IsUnknown() && to.SlicingExprs.IsNull() && len(from.SlicingExprs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SlicingExprs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SlicingExprs = from.SlicingExprs
	}
	if !from.Snapshot.IsNull() && !from.Snapshot.IsUnknown() {
		if toSnapshot, ok := to.GetSnapshot(ctx); ok {
			if fromSnapshot, ok := from.GetSnapshot(ctx); ok {
				// Recursively sync the fields of Snapshot
				toSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromSnapshot)
				to.SetSnapshot(ctx, toSnapshot)
			}
		}
	}
	if !from.TimeSeries.IsNull() && !from.TimeSeries.IsUnknown() {
		if toTimeSeries, ok := to.GetTimeSeries(ctx); ok {
			if fromTimeSeries, ok := from.GetTimeSeries(ctx); ok {
				// Recursively sync the fields of TimeSeries
				toTimeSeries.SyncFieldsDuringCreateOrUpdate(ctx, fromTimeSeries)
				to.SetTimeSeries(ctx, toTimeSeries)
			}
		}
	}
}

func (to *MonitorInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorInfo_SdkV2) {
	if !from.CustomMetrics.IsNull() && !from.CustomMetrics.IsUnknown() && to.CustomMetrics.IsNull() && len(from.CustomMetrics.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for CustomMetrics, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.CustomMetrics = from.CustomMetrics
	}
	if !from.DataClassificationConfig.IsNull() && !from.DataClassificationConfig.IsUnknown() {
		if toDataClassificationConfig, ok := to.GetDataClassificationConfig(ctx); ok {
			if fromDataClassificationConfig, ok := from.GetDataClassificationConfig(ctx); ok {
				toDataClassificationConfig.SyncFieldsDuringRead(ctx, fromDataClassificationConfig)
				to.SetDataClassificationConfig(ctx, toDataClassificationConfig)
			}
		}
	}
	if !from.InferenceLog.IsNull() && !from.InferenceLog.IsUnknown() {
		if toInferenceLog, ok := to.GetInferenceLog(ctx); ok {
			if fromInferenceLog, ok := from.GetInferenceLog(ctx); ok {
				toInferenceLog.SyncFieldsDuringRead(ctx, fromInferenceLog)
				to.SetInferenceLog(ctx, toInferenceLog)
			}
		}
	}
	if !from.Notifications.IsNull() && !from.Notifications.IsUnknown() {
		if toNotifications, ok := to.GetNotifications(ctx); ok {
			if fromNotifications, ok := from.GetNotifications(ctx); ok {
				toNotifications.SyncFieldsDuringRead(ctx, fromNotifications)
				to.SetNotifications(ctx, toNotifications)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.SlicingExprs.IsNull() && !from.SlicingExprs.IsUnknown() && to.SlicingExprs.IsNull() && len(from.SlicingExprs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SlicingExprs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SlicingExprs = from.SlicingExprs
	}
	if !from.Snapshot.IsNull() && !from.Snapshot.IsUnknown() {
		if toSnapshot, ok := to.GetSnapshot(ctx); ok {
			if fromSnapshot, ok := from.GetSnapshot(ctx); ok {
				toSnapshot.SyncFieldsDuringRead(ctx, fromSnapshot)
				to.SetSnapshot(ctx, toSnapshot)
			}
		}
	}
	if !from.TimeSeries.IsNull() && !from.TimeSeries.IsUnknown() {
		if toTimeSeries, ok := to.GetTimeSeries(ctx); ok {
			if fromTimeSeries, ok := from.GetTimeSeries(ctx); ok {
				toTimeSeries.SyncFieldsDuringRead(ctx, fromTimeSeries)
				to.SetTimeSeries(ctx, toTimeSeries)
			}
		}
	}
}

func (m MonitorInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assets_dir"] = attrs["assets_dir"].SetOptional()
	attrs["baseline_table_name"] = attrs["baseline_table_name"].SetOptional()
	attrs["custom_metrics"] = attrs["custom_metrics"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["drift_metrics_table_name"] = attrs["drift_metrics_table_name"].SetRequired()
	attrs["inference_log"] = attrs["inference_log"].SetOptional()
	attrs["inference_log"] = attrs["inference_log"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["latest_monitor_failure_msg"] = attrs["latest_monitor_failure_msg"].SetOptional()
	attrs["monitor_version"] = attrs["monitor_version"].SetRequired()
	attrs["notifications"] = attrs["notifications"].SetOptional()
	attrs["notifications"] = attrs["notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["output_schema_name"] = attrs["output_schema_name"].SetRequired()
	attrs["profile_metrics_table_name"] = attrs["profile_metrics_table_name"].SetRequired()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["slicing_exprs"] = attrs["slicing_exprs"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["status"] = attrs["status"].SetRequired()
	attrs["table_name"] = attrs["table_name"].SetRequired()
	attrs["time_series"] = attrs["time_series"].SetOptional()
	attrs["time_series"] = attrs["time_series"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_metrics":             reflect.TypeOf(MonitorMetric_SdkV2{}),
		"data_classification_config": reflect.TypeOf(MonitorDataClassificationConfig_SdkV2{}),
		"inference_log":              reflect.TypeOf(MonitorInferenceLog_SdkV2{}),
		"notifications":              reflect.TypeOf(MonitorNotifications_SdkV2{}),
		"schedule":                   reflect.TypeOf(MonitorCronSchedule_SdkV2{}),
		"slicing_exprs":              reflect.TypeOf(types.String{}),
		"snapshot":                   reflect.TypeOf(MonitorSnapshot_SdkV2{}),
		"time_series":                reflect.TypeOf(MonitorTimeSeries_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assets_dir":                 m.AssetsDir,
			"baseline_table_name":        m.BaselineTableName,
			"custom_metrics":             m.CustomMetrics,
			"dashboard_id":               m.DashboardId,
			"data_classification_config": m.DataClassificationConfig,
			"drift_metrics_table_name":   m.DriftMetricsTableName,
			"inference_log":              m.InferenceLog,
			"latest_monitor_failure_msg": m.LatestMonitorFailureMsg,
			"monitor_version":            m.MonitorVersion,
			"notifications":              m.Notifications,
			"output_schema_name":         m.OutputSchemaName,
			"profile_metrics_table_name": m.ProfileMetricsTableName,
			"schedule":                   m.Schedule,
			"slicing_exprs":              m.SlicingExprs,
			"snapshot":                   m.Snapshot,
			"status":                     m.Status,
			"table_name":                 m.TableName,
			"time_series":                m.TimeSeries,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assets_dir":          types.StringType,
			"baseline_table_name": types.StringType,
			"custom_metrics": basetypes.ListType{
				ElemType: MonitorMetric_SdkV2{}.Type(ctx),
			},
			"dashboard_id": types.StringType,
			"data_classification_config": basetypes.ListType{
				ElemType: MonitorDataClassificationConfig_SdkV2{}.Type(ctx),
			},
			"drift_metrics_table_name": types.StringType,
			"inference_log": basetypes.ListType{
				ElemType: MonitorInferenceLog_SdkV2{}.Type(ctx),
			},
			"latest_monitor_failure_msg": types.StringType,
			"monitor_version":            types.Int64Type,
			"notifications": basetypes.ListType{
				ElemType: MonitorNotifications_SdkV2{}.Type(ctx),
			},
			"output_schema_name":         types.StringType,
			"profile_metrics_table_name": types.StringType,
			"schedule": basetypes.ListType{
				ElemType: MonitorCronSchedule_SdkV2{}.Type(ctx),
			},
			"slicing_exprs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"snapshot": basetypes.ListType{
				ElemType: MonitorSnapshot_SdkV2{}.Type(ctx),
			},
			"status":     types.StringType,
			"table_name": types.StringType,
			"time_series": basetypes.ListType{
				ElemType: MonitorTimeSeries_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCustomMetrics returns the value of the CustomMetrics field in MonitorInfo_SdkV2 as
// a slice of MonitorMetric_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetCustomMetrics(ctx context.Context) ([]MonitorMetric_SdkV2, bool) {
	if m.CustomMetrics.IsNull() || m.CustomMetrics.IsUnknown() {
		return nil, false
	}
	var v []MonitorMetric_SdkV2
	d := m.CustomMetrics.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomMetrics sets the value of the CustomMetrics field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetCustomMetrics(ctx context.Context, v []MonitorMetric_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["custom_metrics"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.CustomMetrics = types.ListValueMust(t, vs)
}

// GetDataClassificationConfig returns the value of the DataClassificationConfig field in MonitorInfo_SdkV2 as
// a MonitorDataClassificationConfig_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetDataClassificationConfig(ctx context.Context) (MonitorDataClassificationConfig_SdkV2, bool) {
	var e MonitorDataClassificationConfig_SdkV2
	if m.DataClassificationConfig.IsNull() || m.DataClassificationConfig.IsUnknown() {
		return e, false
	}
	var v []MonitorDataClassificationConfig_SdkV2
	d := m.DataClassificationConfig.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDataClassificationConfig sets the value of the DataClassificationConfig field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetDataClassificationConfig(ctx context.Context, v MonitorDataClassificationConfig_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["data_classification_config"]
	m.DataClassificationConfig = types.ListValueMust(t, vs)
}

// GetInferenceLog returns the value of the InferenceLog field in MonitorInfo_SdkV2 as
// a MonitorInferenceLog_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetInferenceLog(ctx context.Context) (MonitorInferenceLog_SdkV2, bool) {
	var e MonitorInferenceLog_SdkV2
	if m.InferenceLog.IsNull() || m.InferenceLog.IsUnknown() {
		return e, false
	}
	var v []MonitorInferenceLog_SdkV2
	d := m.InferenceLog.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInferenceLog sets the value of the InferenceLog field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetInferenceLog(ctx context.Context, v MonitorInferenceLog_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["inference_log"]
	m.InferenceLog = types.ListValueMust(t, vs)
}

// GetNotifications returns the value of the Notifications field in MonitorInfo_SdkV2 as
// a MonitorNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetNotifications(ctx context.Context) (MonitorNotifications_SdkV2, bool) {
	var e MonitorNotifications_SdkV2
	if m.Notifications.IsNull() || m.Notifications.IsUnknown() {
		return e, false
	}
	var v []MonitorNotifications_SdkV2
	d := m.Notifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotifications sets the value of the Notifications field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetNotifications(ctx context.Context, v MonitorNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notifications"]
	m.Notifications = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in MonitorInfo_SdkV2 as
// a MonitorCronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetSchedule(ctx context.Context) (MonitorCronSchedule_SdkV2, bool) {
	var e MonitorCronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []MonitorCronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetSchedule(ctx context.Context, v MonitorCronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetSlicingExprs returns the value of the SlicingExprs field in MonitorInfo_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetSlicingExprs(ctx context.Context) ([]types.String, bool) {
	if m.SlicingExprs.IsNull() || m.SlicingExprs.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SlicingExprs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSlicingExprs sets the value of the SlicingExprs field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetSlicingExprs(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["slicing_exprs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SlicingExprs = types.ListValueMust(t, vs)
}

// GetSnapshot returns the value of the Snapshot field in MonitorInfo_SdkV2 as
// a MonitorSnapshot_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetSnapshot(ctx context.Context) (MonitorSnapshot_SdkV2, bool) {
	var e MonitorSnapshot_SdkV2
	if m.Snapshot.IsNull() || m.Snapshot.IsUnknown() {
		return e, false
	}
	var v []MonitorSnapshot_SdkV2
	d := m.Snapshot.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSnapshot sets the value of the Snapshot field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetSnapshot(ctx context.Context, v MonitorSnapshot_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["snapshot"]
	m.Snapshot = types.ListValueMust(t, vs)
}

// GetTimeSeries returns the value of the TimeSeries field in MonitorInfo_SdkV2 as
// a MonitorTimeSeries_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorInfo_SdkV2) GetTimeSeries(ctx context.Context) (MonitorTimeSeries_SdkV2, bool) {
	var e MonitorTimeSeries_SdkV2
	if m.TimeSeries.IsNull() || m.TimeSeries.IsUnknown() {
		return e, false
	}
	var v []MonitorTimeSeries_SdkV2
	d := m.TimeSeries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTimeSeries sets the value of the TimeSeries field in MonitorInfo_SdkV2.
func (m *MonitorInfo_SdkV2) SetTimeSeries(ctx context.Context, v MonitorTimeSeries_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["time_series"]
	m.TimeSeries = types.ListValueMust(t, vs)
}

// Custom metric definition.
type MonitorMetric_SdkV2 struct {
	// Jinja template for a SQL expression that specifies how to compute the
	// metric. See [create metric definition].
	//
	// [create metric definition]: https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition
	Definition types.String `tfsdk:"definition"`
	// A list of column names in the input table the metric should be computed
	// for. Can use ``":table"`` to indicate that the metric needs information
	// from multiple columns.
	InputColumns types.List `tfsdk:"input_columns"`
	// Name of the metric in the output tables.
	Name types.String `tfsdk:"name"`
	// The output type of the custom metric.
	OutputDataType types.String `tfsdk:"output_data_type"`
	// Can only be one of ``"CUSTOM_METRIC_TYPE_AGGREGATE"``,
	// ``"CUSTOM_METRIC_TYPE_DERIVED"``, or ``"CUSTOM_METRIC_TYPE_DRIFT"``. The
	// ``"CUSTOM_METRIC_TYPE_AGGREGATE"`` and ``"CUSTOM_METRIC_TYPE_DERIVED"``
	// metrics are computed on a single table, whereas the
	// ``"CUSTOM_METRIC_TYPE_DRIFT"`` compare metrics across baseline and input
	// table, or across the two consecutive time windows. -
	// CUSTOM_METRIC_TYPE_AGGREGATE: only depend on the existing columns in your
	// table - CUSTOM_METRIC_TYPE_DERIVED: depend on previously computed
	// aggregate metrics - CUSTOM_METRIC_TYPE_DRIFT: depend on previously
	// computed aggregate or derived metrics
	Type_ types.String `tfsdk:"type"`
}

func (to *MonitorMetric_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorMetric_SdkV2) {
}

func (to *MonitorMetric_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorMetric_SdkV2) {
}

func (m MonitorMetric_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["definition"] = attrs["definition"].SetRequired()
	attrs["input_columns"] = attrs["input_columns"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["output_data_type"] = attrs["output_data_type"].SetRequired()
	attrs["type"] = attrs["type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorMetric.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorMetric_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_columns": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorMetric_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorMetric_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"definition":       m.Definition,
			"input_columns":    m.InputColumns,
			"name":             m.Name,
			"output_data_type": m.OutputDataType,
			"type":             m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorMetric_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"definition": types.StringType,
			"input_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name":             types.StringType,
			"output_data_type": types.StringType,
			"type":             types.StringType,
		},
	}
}

// GetInputColumns returns the value of the InputColumns field in MonitorMetric_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorMetric_SdkV2) GetInputColumns(ctx context.Context) ([]types.String, bool) {
	if m.InputColumns.IsNull() || m.InputColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.InputColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInputColumns sets the value of the InputColumns field in MonitorMetric_SdkV2.
func (m *MonitorMetric_SdkV2) SetInputColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["input_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.InputColumns = types.ListValueMust(t, vs)
}

type MonitorNotifications_SdkV2 struct {
	// Destinations to send notifications on failure/timeout.
	OnFailure types.List `tfsdk:"on_failure"`
	// Destinations to send notifications on new classification tag detected.
	OnNewClassificationTagDetected types.List `tfsdk:"on_new_classification_tag_detected"`
}

func (to *MonitorNotifications_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorNotifications_SdkV2) {
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() {
		if toOnFailure, ok := to.GetOnFailure(ctx); ok {
			if fromOnFailure, ok := from.GetOnFailure(ctx); ok {
				// Recursively sync the fields of OnFailure
				toOnFailure.SyncFieldsDuringCreateOrUpdate(ctx, fromOnFailure)
				to.SetOnFailure(ctx, toOnFailure)
			}
		}
	}
	if !from.OnNewClassificationTagDetected.IsNull() && !from.OnNewClassificationTagDetected.IsUnknown() {
		if toOnNewClassificationTagDetected, ok := to.GetOnNewClassificationTagDetected(ctx); ok {
			if fromOnNewClassificationTagDetected, ok := from.GetOnNewClassificationTagDetected(ctx); ok {
				// Recursively sync the fields of OnNewClassificationTagDetected
				toOnNewClassificationTagDetected.SyncFieldsDuringCreateOrUpdate(ctx, fromOnNewClassificationTagDetected)
				to.SetOnNewClassificationTagDetected(ctx, toOnNewClassificationTagDetected)
			}
		}
	}
}

func (to *MonitorNotifications_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorNotifications_SdkV2) {
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() {
		if toOnFailure, ok := to.GetOnFailure(ctx); ok {
			if fromOnFailure, ok := from.GetOnFailure(ctx); ok {
				toOnFailure.SyncFieldsDuringRead(ctx, fromOnFailure)
				to.SetOnFailure(ctx, toOnFailure)
			}
		}
	}
	if !from.OnNewClassificationTagDetected.IsNull() && !from.OnNewClassificationTagDetected.IsUnknown() {
		if toOnNewClassificationTagDetected, ok := to.GetOnNewClassificationTagDetected(ctx); ok {
			if fromOnNewClassificationTagDetected, ok := from.GetOnNewClassificationTagDetected(ctx); ok {
				toOnNewClassificationTagDetected.SyncFieldsDuringRead(ctx, fromOnNewClassificationTagDetected)
				to.SetOnNewClassificationTagDetected(ctx, toOnNewClassificationTagDetected)
			}
		}
	}
}

func (m MonitorNotifications_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["on_new_classification_tag_detected"] = attrs["on_new_classification_tag_detected"].SetOptional()
	attrs["on_new_classification_tag_detected"] = attrs["on_new_classification_tag_detected"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorNotifications_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_failure":                         reflect.TypeOf(MonitorDestination_SdkV2{}),
		"on_new_classification_tag_detected": reflect.TypeOf(MonitorDestination_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorNotifications_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorNotifications_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"on_failure":                         m.OnFailure,
			"on_new_classification_tag_detected": m.OnNewClassificationTagDetected,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorNotifications_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"on_failure": basetypes.ListType{
				ElemType: MonitorDestination_SdkV2{}.Type(ctx),
			},
			"on_new_classification_tag_detected": basetypes.ListType{
				ElemType: MonitorDestination_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetOnFailure returns the value of the OnFailure field in MonitorNotifications_SdkV2 as
// a MonitorDestination_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorNotifications_SdkV2) GetOnFailure(ctx context.Context) (MonitorDestination_SdkV2, bool) {
	var e MonitorDestination_SdkV2
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return e, false
	}
	var v []MonitorDestination_SdkV2
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetOnFailure sets the value of the OnFailure field in MonitorNotifications_SdkV2.
func (m *MonitorNotifications_SdkV2) SetOnFailure(ctx context.Context, v MonitorDestination_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnNewClassificationTagDetected returns the value of the OnNewClassificationTagDetected field in MonitorNotifications_SdkV2 as
// a MonitorDestination_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorNotifications_SdkV2) GetOnNewClassificationTagDetected(ctx context.Context) (MonitorDestination_SdkV2, bool) {
	var e MonitorDestination_SdkV2
	if m.OnNewClassificationTagDetected.IsNull() || m.OnNewClassificationTagDetected.IsUnknown() {
		return e, false
	}
	var v []MonitorDestination_SdkV2
	d := m.OnNewClassificationTagDetected.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetOnNewClassificationTagDetected sets the value of the OnNewClassificationTagDetected field in MonitorNotifications_SdkV2.
func (m *MonitorNotifications_SdkV2) SetOnNewClassificationTagDetected(ctx context.Context, v MonitorDestination_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_new_classification_tag_detected"]
	m.OnNewClassificationTagDetected = types.ListValueMust(t, vs)
}

type MonitorRefreshInfo_SdkV2 struct {
	// Time at which refresh operation completed (milliseconds since 1/1/1970
	// UTC).
	EndTimeMs types.Int64 `tfsdk:"end_time_ms"`
	// An optional message to give insight into the current state of the job
	// (e.g. FAILURE messages).
	Message types.String `tfsdk:"message"`
	// Unique id of the refresh operation.
	RefreshId types.Int64 `tfsdk:"refresh_id"`
	// Time at which refresh operation was initiated (milliseconds since
	// 1/1/1970 UTC).
	StartTimeMs types.Int64 `tfsdk:"start_time_ms"`
	// The current state of the refresh.
	State types.String `tfsdk:"state"`
	// The method by which the refresh was triggered.
	Trigger types.String `tfsdk:"trigger"`
}

func (to *MonitorRefreshInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorRefreshInfo_SdkV2) {
}

func (to *MonitorRefreshInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorRefreshInfo_SdkV2) {
}

func (m MonitorRefreshInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["end_time_ms"] = attrs["end_time_ms"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()
	attrs["refresh_id"] = attrs["refresh_id"].SetRequired()
	attrs["start_time_ms"] = attrs["start_time_ms"].SetRequired()
	attrs["state"] = attrs["state"].SetRequired()
	attrs["trigger"] = attrs["trigger"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorRefreshInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorRefreshInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorRefreshInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorRefreshInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"end_time_ms":   m.EndTimeMs,
			"message":       m.Message,
			"refresh_id":    m.RefreshId,
			"start_time_ms": m.StartTimeMs,
			"state":         m.State,
			"trigger":       m.Trigger,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorRefreshInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"end_time_ms":   types.Int64Type,
			"message":       types.StringType,
			"refresh_id":    types.Int64Type,
			"start_time_ms": types.Int64Type,
			"state":         types.StringType,
			"trigger":       types.StringType,
		},
	}
}

type MonitorRefreshListResponse_SdkV2 struct {
	// List of refreshes.
	Refreshes types.List `tfsdk:"refreshes"`
}

func (to *MonitorRefreshListResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorRefreshListResponse_SdkV2) {
	if !from.Refreshes.IsNull() && !from.Refreshes.IsUnknown() && to.Refreshes.IsNull() && len(from.Refreshes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Refreshes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Refreshes = from.Refreshes
	}
}

func (to *MonitorRefreshListResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorRefreshListResponse_SdkV2) {
	if !from.Refreshes.IsNull() && !from.Refreshes.IsUnknown() && to.Refreshes.IsNull() && len(from.Refreshes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Refreshes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Refreshes = from.Refreshes
	}
}

func (m MonitorRefreshListResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["refreshes"] = attrs["refreshes"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorRefreshListResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorRefreshListResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"refreshes": reflect.TypeOf(MonitorRefreshInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorRefreshListResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorRefreshListResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"refreshes": m.Refreshes,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorRefreshListResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"refreshes": basetypes.ListType{
				ElemType: MonitorRefreshInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetRefreshes returns the value of the Refreshes field in MonitorRefreshListResponse_SdkV2 as
// a slice of MonitorRefreshInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorRefreshListResponse_SdkV2) GetRefreshes(ctx context.Context) ([]MonitorRefreshInfo_SdkV2, bool) {
	if m.Refreshes.IsNull() || m.Refreshes.IsUnknown() {
		return nil, false
	}
	var v []MonitorRefreshInfo_SdkV2
	d := m.Refreshes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRefreshes sets the value of the Refreshes field in MonitorRefreshListResponse_SdkV2.
func (m *MonitorRefreshListResponse_SdkV2) SetRefreshes(ctx context.Context, v []MonitorRefreshInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["refreshes"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Refreshes = types.ListValueMust(t, vs)
}

// Snapshot analysis configuration
type MonitorSnapshot_SdkV2 struct {
}

func (to *MonitorSnapshot_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorSnapshot_SdkV2) {
}

func (to *MonitorSnapshot_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorSnapshot_SdkV2) {
}

func (m MonitorSnapshot_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorSnapshot.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorSnapshot_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorSnapshot_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorSnapshot_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorSnapshot_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// Time series analysis configuration.
type MonitorTimeSeries_SdkV2 struct {
	// Granularities for aggregating data into time windows based on their
	// timestamp. Currently the following static granularities are supported:
	// {``\"5 minutes\"``, ``\"30 minutes\"``, ``\"1 hour\"``, ``\"1 day\"``,
	// ``\"\u003cn\u003e week(s)\"``, ``\"1 month\"``, ``\"1 year\"``}.
	Granularities types.List `tfsdk:"granularities"`
	// Column for the timestamp.
	TimestampCol types.String `tfsdk:"timestamp_col"`
}

func (to *MonitorTimeSeries_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MonitorTimeSeries_SdkV2) {
}

func (to *MonitorTimeSeries_SdkV2) SyncFieldsDuringRead(ctx context.Context, from MonitorTimeSeries_SdkV2) {
}

func (m MonitorTimeSeries_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["granularities"] = attrs["granularities"].SetRequired()
	attrs["timestamp_col"] = attrs["timestamp_col"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorTimeSeries.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MonitorTimeSeries_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"granularities": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorTimeSeries_SdkV2
// only implements ToObjectValue() and Type().
func (m MonitorTimeSeries_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"granularities": m.Granularities,
			"timestamp_col": m.TimestampCol,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MonitorTimeSeries_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"granularities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timestamp_col": types.StringType,
		},
	}
}

// GetGranularities returns the value of the Granularities field in MonitorTimeSeries_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *MonitorTimeSeries_SdkV2) GetGranularities(ctx context.Context) ([]types.String, bool) {
	if m.Granularities.IsNull() || m.Granularities.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Granularities.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGranularities sets the value of the Granularities field in MonitorTimeSeries_SdkV2.
func (m *MonitorTimeSeries_SdkV2) SetGranularities(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["granularities"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Granularities = types.ListValueMust(t, vs)
}

type NamedTableConstraint_SdkV2 struct {
	// The name of the constraint.
	Name types.String `tfsdk:"name"`
}

func (to *NamedTableConstraint_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from NamedTableConstraint_SdkV2) {
}

func (to *NamedTableConstraint_SdkV2) SyncFieldsDuringRead(ctx context.Context, from NamedTableConstraint_SdkV2) {
}

func (m NamedTableConstraint_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NamedTableConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m NamedTableConstraint_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NamedTableConstraint_SdkV2
// only implements ToObjectValue() and Type().
func (m NamedTableConstraint_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m NamedTableConstraint_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type NotificationDestination_SdkV2 struct {
	// The identifier for the destination. This is the email address for EMAIL
	// destinations, the URL for URL destinations, or the unique Databricks
	// notification destination ID for all other external destinations.
	DestinationId types.String `tfsdk:"destination_id"`
	// The type of the destination.
	DestinationType types.String `tfsdk:"destination_type"`
	// This field is used to denote whether the destination is the email of the
	// owner of the securable object. The special destination cannot be assigned
	// to a securable and only represents the default destination of the
	// securable. The securable types that support default special destinations
	// are: "catalog", "external_location", "connection", "credential", and
	// "metastore". The **destination_type** of a **special_destination** is
	// always EMAIL.
	SpecialDestination types.String `tfsdk:"special_destination"`
}

func (to *NotificationDestination_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from NotificationDestination_SdkV2) {
}

func (to *NotificationDestination_SdkV2) SyncFieldsDuringRead(ctx context.Context, from NotificationDestination_SdkV2) {
}

func (m NotificationDestination_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetOptional()
	attrs["destination_type"] = attrs["destination_type"].SetOptional()
	attrs["special_destination"] = attrs["special_destination"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NotificationDestination.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m NotificationDestination_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NotificationDestination_SdkV2
// only implements ToObjectValue() and Type().
func (m NotificationDestination_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id":      m.DestinationId,
			"destination_type":    m.DestinationType,
			"special_destination": m.SpecialDestination,
		})
}

// Type implements basetypes.ObjectValuable.
func (m NotificationDestination_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id":      types.StringType,
			"destination_type":    types.StringType,
			"special_destination": types.StringType,
		},
	}
}

// Online Table information.
type OnlineTable_SdkV2 struct {
	// Full three-part (catalog, schema, table) name of the table.
	Name types.String `tfsdk:"name"`
	// Specification of the online table.
	Spec types.List `tfsdk:"spec"`
	// Online Table data synchronization status
	Status types.List `tfsdk:"status"`
	// Data serving REST API URL for this table
	TableServingUrl types.String `tfsdk:"table_serving_url"`
	// The provisioning state of the online table entity in Unity Catalog. This
	// is distinct from the state of the data synchronization pipeline (i.e. the
	// table may be in "ACTIVE" but the pipeline may be in "PROVISIONING" as it
	// runs asynchronously).
	UnityCatalogProvisioningState types.String `tfsdk:"unity_catalog_provisioning_state"`
}

func (to *OnlineTable_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OnlineTable_SdkV2) {
	if !from.Spec.IsNull() && !from.Spec.IsUnknown() {
		if toSpec, ok := to.GetSpec(ctx); ok {
			if fromSpec, ok := from.GetSpec(ctx); ok {
				// Recursively sync the fields of Spec
				toSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromSpec)
				to.SetSpec(ctx, toSpec)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
}

func (to *OnlineTable_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OnlineTable_SdkV2) {
	if !from.Spec.IsNull() && !from.Spec.IsUnknown() {
		if toSpec, ok := to.GetSpec(ctx); ok {
			if fromSpec, ok := from.GetSpec(ctx); ok {
				toSpec.SyncFieldsDuringRead(ctx, fromSpec)
				to.SetSpec(ctx, toSpec)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
}

func (m OnlineTable_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()
	attrs["spec"] = attrs["spec"].SetOptional()
	attrs["spec"] = attrs["spec"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["status"] = attrs["status"].SetComputed()
	attrs["status"] = attrs["status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table_serving_url"] = attrs["table_serving_url"].SetComputed()
	attrs["unity_catalog_provisioning_state"] = attrs["unity_catalog_provisioning_state"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OnlineTable_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"spec":   reflect.TypeOf(OnlineTableSpec_SdkV2{}),
		"status": reflect.TypeOf(OnlineTableStatus_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTable_SdkV2
// only implements ToObjectValue() and Type().
func (m OnlineTable_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                             m.Name,
			"spec":                             m.Spec,
			"status":                           m.Status,
			"table_serving_url":                m.TableServingUrl,
			"unity_catalog_provisioning_state": m.UnityCatalogProvisioningState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m OnlineTable_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
			"spec": basetypes.ListType{
				ElemType: OnlineTableSpec_SdkV2{}.Type(ctx),
			},
			"status": basetypes.ListType{
				ElemType: OnlineTableStatus_SdkV2{}.Type(ctx),
			},
			"table_serving_url":                types.StringType,
			"unity_catalog_provisioning_state": types.StringType,
		},
	}
}

// GetSpec returns the value of the Spec field in OnlineTable_SdkV2 as
// a OnlineTableSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTable_SdkV2) GetSpec(ctx context.Context) (OnlineTableSpec_SdkV2, bool) {
	var e OnlineTableSpec_SdkV2
	if m.Spec.IsNull() || m.Spec.IsUnknown() {
		return e, false
	}
	var v []OnlineTableSpec_SdkV2
	d := m.Spec.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSpec sets the value of the Spec field in OnlineTable_SdkV2.
func (m *OnlineTable_SdkV2) SetSpec(ctx context.Context, v OnlineTableSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spec"]
	m.Spec = types.ListValueMust(t, vs)
}

// GetStatus returns the value of the Status field in OnlineTable_SdkV2 as
// a OnlineTableStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTable_SdkV2) GetStatus(ctx context.Context) (OnlineTableStatus_SdkV2, bool) {
	var e OnlineTableStatus_SdkV2
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v []OnlineTableStatus_SdkV2
	d := m.Status.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetStatus sets the value of the Status field in OnlineTable_SdkV2.
func (m *OnlineTable_SdkV2) SetStatus(ctx context.Context, v OnlineTableStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["status"]
	m.Status = types.ListValueMust(t, vs)
}

// Specification of an online table.
type OnlineTableSpec_SdkV2 struct {
	// Whether to create a full-copy pipeline -- a pipeline that stops after
	// creates a full copy of the source table upon initialization and does not
	// process any change data feeds (CDFs) afterwards. The pipeline can still
	// be manually triggered afterwards, but it always perform a full copy of
	// the source table and there are no incremental updates. This mode is
	// useful for syncing views or tables without CDFs to online tables. Note
	// that the full-copy pipeline only supports "triggered" scheduling policy.
	PerformFullCopy types.Bool `tfsdk:"perform_full_copy"`
	// ID of the associated pipeline. Generated by the server - cannot be set by
	// the caller.
	PipelineId types.String `tfsdk:"pipeline_id"`
	// Primary Key columns to be used for data insert/update in the destination.
	PrimaryKeyColumns types.List `tfsdk:"primary_key_columns"`
	// Pipeline runs continuously after generating the initial data.
	RunContinuously types.List `tfsdk:"run_continuously"`
	// Pipeline stops after generating the initial data and can be triggered
	// later (manually, through a cron job or through data triggers)
	RunTriggered types.List `tfsdk:"run_triggered"`
	// Three-part (catalog, schema, table) name of the source Delta table.
	SourceTableFullName types.String `tfsdk:"source_table_full_name"`
	// Time series key to deduplicate (tie-break) rows with the same primary
	// key.
	TimeseriesKey types.String `tfsdk:"timeseries_key"`
}

func (to *OnlineTableSpec_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OnlineTableSpec_SdkV2) {
	if !from.PrimaryKeyColumns.IsNull() && !from.PrimaryKeyColumns.IsUnknown() && to.PrimaryKeyColumns.IsNull() && len(from.PrimaryKeyColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrimaryKeyColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrimaryKeyColumns = from.PrimaryKeyColumns
	}
	if !from.RunContinuously.IsNull() && !from.RunContinuously.IsUnknown() {
		if toRunContinuously, ok := to.GetRunContinuously(ctx); ok {
			if fromRunContinuously, ok := from.GetRunContinuously(ctx); ok {
				// Recursively sync the fields of RunContinuously
				toRunContinuously.SyncFieldsDuringCreateOrUpdate(ctx, fromRunContinuously)
				to.SetRunContinuously(ctx, toRunContinuously)
			}
		}
	}
	if !from.RunTriggered.IsNull() && !from.RunTriggered.IsUnknown() {
		if toRunTriggered, ok := to.GetRunTriggered(ctx); ok {
			if fromRunTriggered, ok := from.GetRunTriggered(ctx); ok {
				// Recursively sync the fields of RunTriggered
				toRunTriggered.SyncFieldsDuringCreateOrUpdate(ctx, fromRunTriggered)
				to.SetRunTriggered(ctx, toRunTriggered)
			}
		}
	}
}

func (to *OnlineTableSpec_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OnlineTableSpec_SdkV2) {
	if !from.PrimaryKeyColumns.IsNull() && !from.PrimaryKeyColumns.IsUnknown() && to.PrimaryKeyColumns.IsNull() && len(from.PrimaryKeyColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrimaryKeyColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrimaryKeyColumns = from.PrimaryKeyColumns
	}
	if !from.RunContinuously.IsNull() && !from.RunContinuously.IsUnknown() {
		if toRunContinuously, ok := to.GetRunContinuously(ctx); ok {
			if fromRunContinuously, ok := from.GetRunContinuously(ctx); ok {
				toRunContinuously.SyncFieldsDuringRead(ctx, fromRunContinuously)
				to.SetRunContinuously(ctx, toRunContinuously)
			}
		}
	}
	if !from.RunTriggered.IsNull() && !from.RunTriggered.IsUnknown() {
		if toRunTriggered, ok := to.GetRunTriggered(ctx); ok {
			if fromRunTriggered, ok := from.GetRunTriggered(ctx); ok {
				toRunTriggered.SyncFieldsDuringRead(ctx, fromRunTriggered)
				to.SetRunTriggered(ctx, toRunTriggered)
			}
		}
	}
}

func (m OnlineTableSpec_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["perform_full_copy"] = attrs["perform_full_copy"].SetOptional()
	attrs["pipeline_id"] = attrs["pipeline_id"].SetComputed()
	attrs["primary_key_columns"] = attrs["primary_key_columns"].SetOptional()
	attrs["run_continuously"] = attrs["run_continuously"].SetOptional()
	attrs["run_continuously"] = attrs["run_continuously"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_triggered"] = attrs["run_triggered"].SetOptional()
	attrs["run_triggered"] = attrs["run_triggered"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["source_table_full_name"] = attrs["source_table_full_name"].SetOptional()
	attrs["timeseries_key"] = attrs["timeseries_key"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableSpec.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OnlineTableSpec_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"primary_key_columns": reflect.TypeOf(types.String{}),
		"run_continuously":    reflect.TypeOf(OnlineTableSpecContinuousSchedulingPolicy_SdkV2{}),
		"run_triggered":       reflect.TypeOf(OnlineTableSpecTriggeredSchedulingPolicy_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableSpec_SdkV2
// only implements ToObjectValue() and Type().
func (m OnlineTableSpec_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"perform_full_copy":      m.PerformFullCopy,
			"pipeline_id":            m.PipelineId,
			"primary_key_columns":    m.PrimaryKeyColumns,
			"run_continuously":       m.RunContinuously,
			"run_triggered":          m.RunTriggered,
			"source_table_full_name": m.SourceTableFullName,
			"timeseries_key":         m.TimeseriesKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m OnlineTableSpec_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"perform_full_copy": types.BoolType,
			"pipeline_id":       types.StringType,
			"primary_key_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"run_continuously": basetypes.ListType{
				ElemType: OnlineTableSpecContinuousSchedulingPolicy_SdkV2{}.Type(ctx),
			},
			"run_triggered": basetypes.ListType{
				ElemType: OnlineTableSpecTriggeredSchedulingPolicy_SdkV2{}.Type(ctx),
			},
			"source_table_full_name": types.StringType,
			"timeseries_key":         types.StringType,
		},
	}
}

// GetPrimaryKeyColumns returns the value of the PrimaryKeyColumns field in OnlineTableSpec_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableSpec_SdkV2) GetPrimaryKeyColumns(ctx context.Context) ([]types.String, bool) {
	if m.PrimaryKeyColumns.IsNull() || m.PrimaryKeyColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PrimaryKeyColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrimaryKeyColumns sets the value of the PrimaryKeyColumns field in OnlineTableSpec_SdkV2.
func (m *OnlineTableSpec_SdkV2) SetPrimaryKeyColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["primary_key_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PrimaryKeyColumns = types.ListValueMust(t, vs)
}

// GetRunContinuously returns the value of the RunContinuously field in OnlineTableSpec_SdkV2 as
// a OnlineTableSpecContinuousSchedulingPolicy_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableSpec_SdkV2) GetRunContinuously(ctx context.Context) (OnlineTableSpecContinuousSchedulingPolicy_SdkV2, bool) {
	var e OnlineTableSpecContinuousSchedulingPolicy_SdkV2
	if m.RunContinuously.IsNull() || m.RunContinuously.IsUnknown() {
		return e, false
	}
	var v []OnlineTableSpecContinuousSchedulingPolicy_SdkV2
	d := m.RunContinuously.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunContinuously sets the value of the RunContinuously field in OnlineTableSpec_SdkV2.
func (m *OnlineTableSpec_SdkV2) SetRunContinuously(ctx context.Context, v OnlineTableSpecContinuousSchedulingPolicy_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_continuously"]
	m.RunContinuously = types.ListValueMust(t, vs)
}

// GetRunTriggered returns the value of the RunTriggered field in OnlineTableSpec_SdkV2 as
// a OnlineTableSpecTriggeredSchedulingPolicy_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableSpec_SdkV2) GetRunTriggered(ctx context.Context) (OnlineTableSpecTriggeredSchedulingPolicy_SdkV2, bool) {
	var e OnlineTableSpecTriggeredSchedulingPolicy_SdkV2
	if m.RunTriggered.IsNull() || m.RunTriggered.IsUnknown() {
		return e, false
	}
	var v []OnlineTableSpecTriggeredSchedulingPolicy_SdkV2
	d := m.RunTriggered.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunTriggered sets the value of the RunTriggered field in OnlineTableSpec_SdkV2.
func (m *OnlineTableSpec_SdkV2) SetRunTriggered(ctx context.Context, v OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_triggered"]
	m.RunTriggered = types.ListValueMust(t, vs)
}

type OnlineTableSpecContinuousSchedulingPolicy_SdkV2 struct {
}

func (to *OnlineTableSpecContinuousSchedulingPolicy_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OnlineTableSpecContinuousSchedulingPolicy_SdkV2) {
}

func (to *OnlineTableSpecContinuousSchedulingPolicy_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OnlineTableSpecContinuousSchedulingPolicy_SdkV2) {
}

func (m OnlineTableSpecContinuousSchedulingPolicy_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableSpecContinuousSchedulingPolicy.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OnlineTableSpecContinuousSchedulingPolicy_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableSpecContinuousSchedulingPolicy_SdkV2
// only implements ToObjectValue() and Type().
func (m OnlineTableSpecContinuousSchedulingPolicy_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m OnlineTableSpecContinuousSchedulingPolicy_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type OnlineTableSpecTriggeredSchedulingPolicy_SdkV2 struct {
}

func (to *OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) {
}

func (to *OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) {
}

func (m OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableSpecTriggeredSchedulingPolicy.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableSpecTriggeredSchedulingPolicy_SdkV2
// only implements ToObjectValue() and Type().
func (m OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m OnlineTableSpecTriggeredSchedulingPolicy_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// Status of an online table.
type OnlineTableStatus_SdkV2 struct {
	ContinuousUpdateStatus types.List `tfsdk:"continuous_update_status"`
	// The state of the online table.
	DetailedState types.String `tfsdk:"detailed_state"`

	FailedStatus types.List `tfsdk:"failed_status"`
	// A text description of the current state of the online table.
	Message types.String `tfsdk:"message"`

	ProvisioningStatus types.List `tfsdk:"provisioning_status"`

	TriggeredUpdateStatus types.List `tfsdk:"triggered_update_status"`
}

func (to *OnlineTableStatus_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OnlineTableStatus_SdkV2) {
	if !from.ContinuousUpdateStatus.IsNull() && !from.ContinuousUpdateStatus.IsUnknown() {
		if toContinuousUpdateStatus, ok := to.GetContinuousUpdateStatus(ctx); ok {
			if fromContinuousUpdateStatus, ok := from.GetContinuousUpdateStatus(ctx); ok {
				// Recursively sync the fields of ContinuousUpdateStatus
				toContinuousUpdateStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromContinuousUpdateStatus)
				to.SetContinuousUpdateStatus(ctx, toContinuousUpdateStatus)
			}
		}
	}
	if !from.FailedStatus.IsNull() && !from.FailedStatus.IsUnknown() {
		if toFailedStatus, ok := to.GetFailedStatus(ctx); ok {
			if fromFailedStatus, ok := from.GetFailedStatus(ctx); ok {
				// Recursively sync the fields of FailedStatus
				toFailedStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromFailedStatus)
				to.SetFailedStatus(ctx, toFailedStatus)
			}
		}
	}
	if !from.ProvisioningStatus.IsNull() && !from.ProvisioningStatus.IsUnknown() {
		if toProvisioningStatus, ok := to.GetProvisioningStatus(ctx); ok {
			if fromProvisioningStatus, ok := from.GetProvisioningStatus(ctx); ok {
				// Recursively sync the fields of ProvisioningStatus
				toProvisioningStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromProvisioningStatus)
				to.SetProvisioningStatus(ctx, toProvisioningStatus)
			}
		}
	}
	if !from.TriggeredUpdateStatus.IsNull() && !from.TriggeredUpdateStatus.IsUnknown() {
		if toTriggeredUpdateStatus, ok := to.GetTriggeredUpdateStatus(ctx); ok {
			if fromTriggeredUpdateStatus, ok := from.GetTriggeredUpdateStatus(ctx); ok {
				// Recursively sync the fields of TriggeredUpdateStatus
				toTriggeredUpdateStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggeredUpdateStatus)
				to.SetTriggeredUpdateStatus(ctx, toTriggeredUpdateStatus)
			}
		}
	}
}

func (to *OnlineTableStatus_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OnlineTableStatus_SdkV2) {
	if !from.ContinuousUpdateStatus.IsNull() && !from.ContinuousUpdateStatus.IsUnknown() {
		if toContinuousUpdateStatus, ok := to.GetContinuousUpdateStatus(ctx); ok {
			if fromContinuousUpdateStatus, ok := from.GetContinuousUpdateStatus(ctx); ok {
				toContinuousUpdateStatus.SyncFieldsDuringRead(ctx, fromContinuousUpdateStatus)
				to.SetContinuousUpdateStatus(ctx, toContinuousUpdateStatus)
			}
		}
	}
	if !from.FailedStatus.IsNull() && !from.FailedStatus.IsUnknown() {
		if toFailedStatus, ok := to.GetFailedStatus(ctx); ok {
			if fromFailedStatus, ok := from.GetFailedStatus(ctx); ok {
				toFailedStatus.SyncFieldsDuringRead(ctx, fromFailedStatus)
				to.SetFailedStatus(ctx, toFailedStatus)
			}
		}
	}
	if !from.ProvisioningStatus.IsNull() && !from.ProvisioningStatus.IsUnknown() {
		if toProvisioningStatus, ok := to.GetProvisioningStatus(ctx); ok {
			if fromProvisioningStatus, ok := from.GetProvisioningStatus(ctx); ok {
				toProvisioningStatus.SyncFieldsDuringRead(ctx, fromProvisioningStatus)
				to.SetProvisioningStatus(ctx, toProvisioningStatus)
			}
		}
	}
	if !from.TriggeredUpdateStatus.IsNull() && !from.TriggeredUpdateStatus.IsUnknown() {
		if toTriggeredUpdateStatus, ok := to.GetTriggeredUpdateStatus(ctx); ok {
			if fromTriggeredUpdateStatus, ok := from.GetTriggeredUpdateStatus(ctx); ok {
				toTriggeredUpdateStatus.SyncFieldsDuringRead(ctx, fromTriggeredUpdateStatus)
				to.SetTriggeredUpdateStatus(ctx, toTriggeredUpdateStatus)
			}
		}
	}
}

func (m OnlineTableStatus_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["continuous_update_status"] = attrs["continuous_update_status"].SetOptional()
	attrs["continuous_update_status"] = attrs["continuous_update_status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["detailed_state"] = attrs["detailed_state"].SetOptional()
	attrs["failed_status"] = attrs["failed_status"].SetOptional()
	attrs["failed_status"] = attrs["failed_status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["message"] = attrs["message"].SetOptional()
	attrs["provisioning_status"] = attrs["provisioning_status"].SetOptional()
	attrs["provisioning_status"] = attrs["provisioning_status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["triggered_update_status"] = attrs["triggered_update_status"].SetOptional()
	attrs["triggered_update_status"] = attrs["triggered_update_status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OnlineTableStatus_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"continuous_update_status": reflect.TypeOf(ContinuousUpdateStatus_SdkV2{}),
		"failed_status":            reflect.TypeOf(FailedStatus_SdkV2{}),
		"provisioning_status":      reflect.TypeOf(ProvisioningStatus_SdkV2{}),
		"triggered_update_status":  reflect.TypeOf(TriggeredUpdateStatus_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableStatus_SdkV2
// only implements ToObjectValue() and Type().
func (m OnlineTableStatus_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"continuous_update_status": m.ContinuousUpdateStatus,
			"detailed_state":           m.DetailedState,
			"failed_status":            m.FailedStatus,
			"message":                  m.Message,
			"provisioning_status":      m.ProvisioningStatus,
			"triggered_update_status":  m.TriggeredUpdateStatus,
		})
}

// Type implements basetypes.ObjectValuable.
func (m OnlineTableStatus_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"continuous_update_status": basetypes.ListType{
				ElemType: ContinuousUpdateStatus_SdkV2{}.Type(ctx),
			},
			"detailed_state": types.StringType,
			"failed_status": basetypes.ListType{
				ElemType: FailedStatus_SdkV2{}.Type(ctx),
			},
			"message": types.StringType,
			"provisioning_status": basetypes.ListType{
				ElemType: ProvisioningStatus_SdkV2{}.Type(ctx),
			},
			"triggered_update_status": basetypes.ListType{
				ElemType: TriggeredUpdateStatus_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetContinuousUpdateStatus returns the value of the ContinuousUpdateStatus field in OnlineTableStatus_SdkV2 as
// a ContinuousUpdateStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableStatus_SdkV2) GetContinuousUpdateStatus(ctx context.Context) (ContinuousUpdateStatus_SdkV2, bool) {
	var e ContinuousUpdateStatus_SdkV2
	if m.ContinuousUpdateStatus.IsNull() || m.ContinuousUpdateStatus.IsUnknown() {
		return e, false
	}
	var v []ContinuousUpdateStatus_SdkV2
	d := m.ContinuousUpdateStatus.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetContinuousUpdateStatus sets the value of the ContinuousUpdateStatus field in OnlineTableStatus_SdkV2.
func (m *OnlineTableStatus_SdkV2) SetContinuousUpdateStatus(ctx context.Context, v ContinuousUpdateStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["continuous_update_status"]
	m.ContinuousUpdateStatus = types.ListValueMust(t, vs)
}

// GetFailedStatus returns the value of the FailedStatus field in OnlineTableStatus_SdkV2 as
// a FailedStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableStatus_SdkV2) GetFailedStatus(ctx context.Context) (FailedStatus_SdkV2, bool) {
	var e FailedStatus_SdkV2
	if m.FailedStatus.IsNull() || m.FailedStatus.IsUnknown() {
		return e, false
	}
	var v []FailedStatus_SdkV2
	d := m.FailedStatus.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFailedStatus sets the value of the FailedStatus field in OnlineTableStatus_SdkV2.
func (m *OnlineTableStatus_SdkV2) SetFailedStatus(ctx context.Context, v FailedStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["failed_status"]
	m.FailedStatus = types.ListValueMust(t, vs)
}

// GetProvisioningStatus returns the value of the ProvisioningStatus field in OnlineTableStatus_SdkV2 as
// a ProvisioningStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableStatus_SdkV2) GetProvisioningStatus(ctx context.Context) (ProvisioningStatus_SdkV2, bool) {
	var e ProvisioningStatus_SdkV2
	if m.ProvisioningStatus.IsNull() || m.ProvisioningStatus.IsUnknown() {
		return e, false
	}
	var v []ProvisioningStatus_SdkV2
	d := m.ProvisioningStatus.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetProvisioningStatus sets the value of the ProvisioningStatus field in OnlineTableStatus_SdkV2.
func (m *OnlineTableStatus_SdkV2) SetProvisioningStatus(ctx context.Context, v ProvisioningStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["provisioning_status"]
	m.ProvisioningStatus = types.ListValueMust(t, vs)
}

// GetTriggeredUpdateStatus returns the value of the TriggeredUpdateStatus field in OnlineTableStatus_SdkV2 as
// a TriggeredUpdateStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *OnlineTableStatus_SdkV2) GetTriggeredUpdateStatus(ctx context.Context) (TriggeredUpdateStatus_SdkV2, bool) {
	var e TriggeredUpdateStatus_SdkV2
	if m.TriggeredUpdateStatus.IsNull() || m.TriggeredUpdateStatus.IsUnknown() {
		return e, false
	}
	var v []TriggeredUpdateStatus_SdkV2
	d := m.TriggeredUpdateStatus.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTriggeredUpdateStatus sets the value of the TriggeredUpdateStatus field in OnlineTableStatus_SdkV2.
func (m *OnlineTableStatus_SdkV2) SetTriggeredUpdateStatus(ctx context.Context, v TriggeredUpdateStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["triggered_update_status"]
	m.TriggeredUpdateStatus = types.ListValueMust(t, vs)
}

// Spec of an allowed option on a securable kind and its attributes. This is
// mostly used by UI to provide user friendly hints and descriptions in order to
// facilitate the securable creation process.
type OptionSpec_SdkV2 struct {
	// For drop down / radio button selections, UI will want to know the
	// possible input values, it can also be used by other option types to limit
	// input selections.
	AllowedValues types.List `tfsdk:"allowed_values"`
	// The default value of the option, for example, value '443' for 'port'
	// option.
	DefaultValue types.String `tfsdk:"default_value"`
	// A concise user facing description of what the input value of this option
	// should look like.
	Description types.String `tfsdk:"description"`
	// The hint is used on the UI to suggest what the input value can possibly
	// be like, for example: example.com for 'host' option. Unlike default
	// value, it will not be applied automatically without user input.
	Hint types.String `tfsdk:"hint"`
	// Indicates whether an option should be displayed with copy button on the
	// UI.
	IsCopiable types.Bool `tfsdk:"is_copiable"`
	// Indicates whether an option can be provided by users in the create/update
	// path of an entity.
	IsCreatable types.Bool `tfsdk:"is_creatable"`
	// Is the option value not user settable and is thus not shown on the UI.
	IsHidden types.Bool `tfsdk:"is_hidden"`
	// Specifies whether this option is safe to log, i.e. no sensitive
	// information.
	IsLoggable types.Bool `tfsdk:"is_loggable"`
	// Is the option required.
	IsRequired types.Bool `tfsdk:"is_required"`
	// Is the option value considered secret and thus redacted on the UI.
	IsSecret types.Bool `tfsdk:"is_secret"`
	// Is the option updatable by users.
	IsUpdatable types.Bool `tfsdk:"is_updatable"`
	// The unique name of the option.
	Name types.String `tfsdk:"name"`
	// Specifies when the option value is displayed on the UI within the OAuth
	// flow.
	OauthStage types.String `tfsdk:"oauth_stage"`
	// The type of the option.
	Type_ types.String `tfsdk:"type"`
}

func (to *OptionSpec_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OptionSpec_SdkV2) {
	if !from.AllowedValues.IsNull() && !from.AllowedValues.IsUnknown() && to.AllowedValues.IsNull() && len(from.AllowedValues.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllowedValues, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllowedValues = from.AllowedValues
	}
}

func (to *OptionSpec_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OptionSpec_SdkV2) {
	if !from.AllowedValues.IsNull() && !from.AllowedValues.IsUnknown() && to.AllowedValues.IsNull() && len(from.AllowedValues.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllowedValues, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllowedValues = from.AllowedValues
	}
}

func (m OptionSpec_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["allowed_values"] = attrs["allowed_values"].SetOptional()
	attrs["default_value"] = attrs["default_value"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["hint"] = attrs["hint"].SetOptional()
	attrs["is_copiable"] = attrs["is_copiable"].SetOptional()
	attrs["is_creatable"] = attrs["is_creatable"].SetOptional()
	attrs["is_hidden"] = attrs["is_hidden"].SetOptional()
	attrs["is_loggable"] = attrs["is_loggable"].SetOptional()
	attrs["is_required"] = attrs["is_required"].SetOptional()
	attrs["is_secret"] = attrs["is_secret"].SetOptional()
	attrs["is_updatable"] = attrs["is_updatable"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["oauth_stage"] = attrs["oauth_stage"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OptionSpec.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OptionSpec_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"allowed_values": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OptionSpec_SdkV2
// only implements ToObjectValue() and Type().
func (m OptionSpec_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"allowed_values": m.AllowedValues,
			"default_value":  m.DefaultValue,
			"description":    m.Description,
			"hint":           m.Hint,
			"is_copiable":    m.IsCopiable,
			"is_creatable":   m.IsCreatable,
			"is_hidden":      m.IsHidden,
			"is_loggable":    m.IsLoggable,
			"is_required":    m.IsRequired,
			"is_secret":      m.IsSecret,
			"is_updatable":   m.IsUpdatable,
			"name":           m.Name,
			"oauth_stage":    m.OauthStage,
			"type":           m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m OptionSpec_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"allowed_values": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default_value": types.StringType,
			"description":   types.StringType,
			"hint":          types.StringType,
			"is_copiable":   types.BoolType,
			"is_creatable":  types.BoolType,
			"is_hidden":     types.BoolType,
			"is_loggable":   types.BoolType,
			"is_required":   types.BoolType,
			"is_secret":     types.BoolType,
			"is_updatable":  types.BoolType,
			"name":          types.StringType,
			"oauth_stage":   types.StringType,
			"type":          types.StringType,
		},
	}
}

// GetAllowedValues returns the value of the AllowedValues field in OptionSpec_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *OptionSpec_SdkV2) GetAllowedValues(ctx context.Context) ([]types.String, bool) {
	if m.AllowedValues.IsNull() || m.AllowedValues.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.AllowedValues.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAllowedValues sets the value of the AllowedValues field in OptionSpec_SdkV2.
func (m *OptionSpec_SdkV2) SetAllowedValues(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["allowed_values"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AllowedValues = types.ListValueMust(t, vs)
}

type PermissionsChange_SdkV2 struct {
	// The set of privileges to add.
	Add types.List `tfsdk:"add"`
	// The principal whose privileges we are changing. Only one of principal or
	// principal_id should be specified, never both at the same time.
	Principal types.String `tfsdk:"principal"`
	// The set of privileges to remove.
	Remove types.List `tfsdk:"remove"`
}

func (to *PermissionsChange_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PermissionsChange_SdkV2) {
	if !from.Add.IsNull() && !from.Add.IsUnknown() && to.Add.IsNull() && len(from.Add.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Add, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Add = from.Add
	}
	if !from.Remove.IsNull() && !from.Remove.IsUnknown() && to.Remove.IsNull() && len(from.Remove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Remove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Remove = from.Remove
	}
}

func (to *PermissionsChange_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PermissionsChange_SdkV2) {
	if !from.Add.IsNull() && !from.Add.IsUnknown() && to.Add.IsNull() && len(from.Add.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Add, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Add = from.Add
	}
	if !from.Remove.IsNull() && !from.Remove.IsUnknown() && to.Remove.IsNull() && len(from.Remove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Remove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Remove = from.Remove
	}
}

func (m PermissionsChange_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["add"] = attrs["add"].SetOptional()
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["remove"] = attrs["remove"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PermissionsChange.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PermissionsChange_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"add":    reflect.TypeOf(types.String{}),
		"remove": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PermissionsChange_SdkV2
// only implements ToObjectValue() and Type().
func (m PermissionsChange_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"add":       m.Add,
			"principal": m.Principal,
			"remove":    m.Remove,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PermissionsChange_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"principal": types.StringType,
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetAdd returns the value of the Add field in PermissionsChange_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PermissionsChange_SdkV2) GetAdd(ctx context.Context) ([]types.String, bool) {
	if m.Add.IsNull() || m.Add.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Add.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAdd sets the value of the Add field in PermissionsChange_SdkV2.
func (m *PermissionsChange_SdkV2) SetAdd(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["add"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Add = types.ListValueMust(t, vs)
}

// GetRemove returns the value of the Remove field in PermissionsChange_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PermissionsChange_SdkV2) GetRemove(ctx context.Context) ([]types.String, bool) {
	if m.Remove.IsNull() || m.Remove.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Remove.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRemove sets the value of the Remove field in PermissionsChange_SdkV2.
func (m *PermissionsChange_SdkV2) SetRemove(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["remove"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Remove = types.ListValueMust(t, vs)
}

// Progress information of the Online Table data synchronization pipeline.
type PipelineProgress_SdkV2 struct {
	// The estimated time remaining to complete this update in seconds.
	EstimatedCompletionTimeSeconds types.Float64 `tfsdk:"estimated_completion_time_seconds"`
	// The source table Delta version that was last processed by the pipeline.
	// The pipeline may not have completely processed this version yet.
	LatestVersionCurrentlyProcessing types.Int64 `tfsdk:"latest_version_currently_processing"`
	// The completion ratio of this update. This is a number between 0 and 1.
	SyncProgressCompletion types.Float64 `tfsdk:"sync_progress_completion"`
	// The number of rows that have been synced in this update.
	SyncedRowCount types.Int64 `tfsdk:"synced_row_count"`
	// The total number of rows that need to be synced in this update. This
	// number may be an estimate.
	TotalRowCount types.Int64 `tfsdk:"total_row_count"`
}

func (to *PipelineProgress_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PipelineProgress_SdkV2) {
}

func (to *PipelineProgress_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PipelineProgress_SdkV2) {
}

func (m PipelineProgress_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["estimated_completion_time_seconds"] = attrs["estimated_completion_time_seconds"].SetOptional()
	attrs["latest_version_currently_processing"] = attrs["latest_version_currently_processing"].SetOptional()
	attrs["sync_progress_completion"] = attrs["sync_progress_completion"].SetOptional()
	attrs["synced_row_count"] = attrs["synced_row_count"].SetOptional()
	attrs["total_row_count"] = attrs["total_row_count"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PipelineProgress.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PipelineProgress_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PipelineProgress_SdkV2
// only implements ToObjectValue() and Type().
func (m PipelineProgress_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"estimated_completion_time_seconds":   m.EstimatedCompletionTimeSeconds,
			"latest_version_currently_processing": m.LatestVersionCurrentlyProcessing,
			"sync_progress_completion":            m.SyncProgressCompletion,
			"synced_row_count":                    m.SyncedRowCount,
			"total_row_count":                     m.TotalRowCount,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PipelineProgress_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"estimated_completion_time_seconds":   types.Float64Type,
			"latest_version_currently_processing": types.Int64Type,
			"sync_progress_completion":            types.Float64Type,
			"synced_row_count":                    types.Int64Type,
			"total_row_count":                     types.Int64Type,
		},
	}
}

type PolicyInfo_SdkV2 struct {
	// Options for column mask policies. Valid only if `policy_type` is
	// `POLICY_TYPE_COLUMN_MASK`. Required on create and optional on update.
	// When specified on update, the new options will replace the existing
	// options as a whole.
	ColumnMask types.List `tfsdk:"column_mask"`
	// Optional description of the policy.
	Comment types.String `tfsdk:"comment"`
	// Time at which the policy was created, in epoch milliseconds. Output only.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who created the policy. Output only.
	CreatedBy types.String `tfsdk:"created_by"`
	// Optional list of user or group names that should be excluded from the
	// policy.
	ExceptPrincipals types.List `tfsdk:"except_principals"`
	// Type of securables that the policy should take effect on. Only `TABLE` is
	// supported at this moment. Required on create and optional on update.
	ForSecurableType types.String `tfsdk:"for_securable_type"`
	// Unique identifier of the policy. This field is output only and is
	// generated by the system.
	Id types.String `tfsdk:"id"`
	// Optional list of condition expressions used to match table columns. Only
	// valid when `for_securable_type` is `TABLE`. When specified, the policy
	// only applies to tables whose columns satisfy all match conditions.
	MatchColumns types.List `tfsdk:"match_columns"`
	// Name of the policy. Required on create and optional on update. To rename
	// the policy, set `name` to a different value on update.
	Name types.String `tfsdk:"name"`
	// Full name of the securable on which the policy is defined. Required on
	// create and ignored on update.
	OnSecurableFullname types.String `tfsdk:"on_securable_fullname"`
	// Type of the securable on which the policy is defined. Only `CATALOG`,
	// `SCHEMA` and `TABLE` are supported at this moment. Required on create and
	// ignored on update.
	OnSecurableType types.String `tfsdk:"on_securable_type"`
	// Type of the policy. Required on create and ignored on update.
	PolicyType types.String `tfsdk:"policy_type"`
	// Options for row filter policies. Valid only if `policy_type` is
	// `POLICY_TYPE_ROW_FILTER`. Required on create and optional on update. When
	// specified on update, the new options will replace the existing options as
	// a whole.
	RowFilter types.List `tfsdk:"row_filter"`
	// List of user or group names that the policy applies to. Required on
	// create and optional on update.
	ToPrincipals types.List `tfsdk:"to_principals"`
	// Time at which the policy was last modified, in epoch milliseconds. Output
	// only.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of the user who last modified the policy. Output only.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Optional condition when the policy should take effect.
	WhenCondition types.String `tfsdk:"when_condition"`
}

func (to *PolicyInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PolicyInfo_SdkV2) {
	if !from.ColumnMask.IsNull() && !from.ColumnMask.IsUnknown() {
		if toColumnMask, ok := to.GetColumnMask(ctx); ok {
			if fromColumnMask, ok := from.GetColumnMask(ctx); ok {
				// Recursively sync the fields of ColumnMask
				toColumnMask.SyncFieldsDuringCreateOrUpdate(ctx, fromColumnMask)
				to.SetColumnMask(ctx, toColumnMask)
			}
		}
	}
	if !from.ExceptPrincipals.IsNull() && !from.ExceptPrincipals.IsUnknown() && to.ExceptPrincipals.IsNull() && len(from.ExceptPrincipals.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExceptPrincipals, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExceptPrincipals = from.ExceptPrincipals
	}
	if !from.MatchColumns.IsNull() && !from.MatchColumns.IsUnknown() && to.MatchColumns.IsNull() && len(from.MatchColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for MatchColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.MatchColumns = from.MatchColumns
	}
	if !from.RowFilter.IsNull() && !from.RowFilter.IsUnknown() {
		if toRowFilter, ok := to.GetRowFilter(ctx); ok {
			if fromRowFilter, ok := from.GetRowFilter(ctx); ok {
				// Recursively sync the fields of RowFilter
				toRowFilter.SyncFieldsDuringCreateOrUpdate(ctx, fromRowFilter)
				to.SetRowFilter(ctx, toRowFilter)
			}
		}
	}
}

func (to *PolicyInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PolicyInfo_SdkV2) {
	if !from.ColumnMask.IsNull() && !from.ColumnMask.IsUnknown() {
		if toColumnMask, ok := to.GetColumnMask(ctx); ok {
			if fromColumnMask, ok := from.GetColumnMask(ctx); ok {
				toColumnMask.SyncFieldsDuringRead(ctx, fromColumnMask)
				to.SetColumnMask(ctx, toColumnMask)
			}
		}
	}
	if !from.ExceptPrincipals.IsNull() && !from.ExceptPrincipals.IsUnknown() && to.ExceptPrincipals.IsNull() && len(from.ExceptPrincipals.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExceptPrincipals, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExceptPrincipals = from.ExceptPrincipals
	}
	if !from.MatchColumns.IsNull() && !from.MatchColumns.IsUnknown() && to.MatchColumns.IsNull() && len(from.MatchColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for MatchColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.MatchColumns = from.MatchColumns
	}
	if !from.RowFilter.IsNull() && !from.RowFilter.IsUnknown() {
		if toRowFilter, ok := to.GetRowFilter(ctx); ok {
			if fromRowFilter, ok := from.GetRowFilter(ctx); ok {
				toRowFilter.SyncFieldsDuringRead(ctx, fromRowFilter)
				to.SetRowFilter(ctx, toRowFilter)
			}
		}
	}
}

func (m PolicyInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["column_mask"] = attrs["column_mask"].SetOptional()
	attrs["column_mask"] = attrs["column_mask"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["except_principals"] = attrs["except_principals"].SetOptional()
	attrs["for_securable_type"] = attrs["for_securable_type"].SetRequired()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["match_columns"] = attrs["match_columns"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetOptional()
	attrs["on_securable_type"] = attrs["on_securable_type"].SetOptional()
	attrs["policy_type"] = attrs["policy_type"].SetRequired()
	attrs["row_filter"] = attrs["row_filter"].SetOptional()
	attrs["row_filter"] = attrs["row_filter"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["to_principals"] = attrs["to_principals"].SetRequired()
	attrs["updated_at"] = attrs["updated_at"].SetComputed()
	attrs["updated_by"] = attrs["updated_by"].SetComputed()
	attrs["when_condition"] = attrs["when_condition"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PolicyInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PolicyInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"column_mask":       reflect.TypeOf(ColumnMaskOptions_SdkV2{}),
		"except_principals": reflect.TypeOf(types.String{}),
		"match_columns":     reflect.TypeOf(MatchColumn_SdkV2{}),
		"row_filter":        reflect.TypeOf(RowFilterOptions_SdkV2{}),
		"to_principals":     reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PolicyInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m PolicyInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"column_mask":           m.ColumnMask,
			"comment":               m.Comment,
			"created_at":            m.CreatedAt,
			"created_by":            m.CreatedBy,
			"except_principals":     m.ExceptPrincipals,
			"for_securable_type":    m.ForSecurableType,
			"id":                    m.Id,
			"match_columns":         m.MatchColumns,
			"name":                  m.Name,
			"on_securable_fullname": m.OnSecurableFullname,
			"on_securable_type":     m.OnSecurableType,
			"policy_type":           m.PolicyType,
			"row_filter":            m.RowFilter,
			"to_principals":         m.ToPrincipals,
			"updated_at":            m.UpdatedAt,
			"updated_by":            m.UpdatedBy,
			"when_condition":        m.WhenCondition,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PolicyInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"column_mask": basetypes.ListType{
				ElemType: ColumnMaskOptions_SdkV2{}.Type(ctx),
			},
			"comment":    types.StringType,
			"created_at": types.Int64Type,
			"created_by": types.StringType,
			"except_principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"for_securable_type": types.StringType,
			"id":                 types.StringType,
			"match_columns": basetypes.ListType{
				ElemType: MatchColumn_SdkV2{}.Type(ctx),
			},
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"policy_type":           types.StringType,
			"row_filter": basetypes.ListType{
				ElemType: RowFilterOptions_SdkV2{}.Type(ctx),
			},
			"to_principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"updated_at":     types.Int64Type,
			"updated_by":     types.StringType,
			"when_condition": types.StringType,
		},
	}
}

// GetColumnMask returns the value of the ColumnMask field in PolicyInfo_SdkV2 as
// a ColumnMaskOptions_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo_SdkV2) GetColumnMask(ctx context.Context) (ColumnMaskOptions_SdkV2, bool) {
	var e ColumnMaskOptions_SdkV2
	if m.ColumnMask.IsNull() || m.ColumnMask.IsUnknown() {
		return e, false
	}
	var v []ColumnMaskOptions_SdkV2
	d := m.ColumnMask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetColumnMask sets the value of the ColumnMask field in PolicyInfo_SdkV2.
func (m *PolicyInfo_SdkV2) SetColumnMask(ctx context.Context, v ColumnMaskOptions_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["column_mask"]
	m.ColumnMask = types.ListValueMust(t, vs)
}

// GetExceptPrincipals returns the value of the ExceptPrincipals field in PolicyInfo_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo_SdkV2) GetExceptPrincipals(ctx context.Context) ([]types.String, bool) {
	if m.ExceptPrincipals.IsNull() || m.ExceptPrincipals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ExceptPrincipals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExceptPrincipals sets the value of the ExceptPrincipals field in PolicyInfo_SdkV2.
func (m *PolicyInfo_SdkV2) SetExceptPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["except_principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ExceptPrincipals = types.ListValueMust(t, vs)
}

// GetMatchColumns returns the value of the MatchColumns field in PolicyInfo_SdkV2 as
// a slice of MatchColumn_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo_SdkV2) GetMatchColumns(ctx context.Context) ([]MatchColumn_SdkV2, bool) {
	if m.MatchColumns.IsNull() || m.MatchColumns.IsUnknown() {
		return nil, false
	}
	var v []MatchColumn_SdkV2
	d := m.MatchColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMatchColumns sets the value of the MatchColumns field in PolicyInfo_SdkV2.
func (m *PolicyInfo_SdkV2) SetMatchColumns(ctx context.Context, v []MatchColumn_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["match_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.MatchColumns = types.ListValueMust(t, vs)
}

// GetRowFilter returns the value of the RowFilter field in PolicyInfo_SdkV2 as
// a RowFilterOptions_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo_SdkV2) GetRowFilter(ctx context.Context) (RowFilterOptions_SdkV2, bool) {
	var e RowFilterOptions_SdkV2
	if m.RowFilter.IsNull() || m.RowFilter.IsUnknown() {
		return e, false
	}
	var v []RowFilterOptions_SdkV2
	d := m.RowFilter.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRowFilter sets the value of the RowFilter field in PolicyInfo_SdkV2.
func (m *PolicyInfo_SdkV2) SetRowFilter(ctx context.Context, v RowFilterOptions_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["row_filter"]
	m.RowFilter = types.ListValueMust(t, vs)
}

// GetToPrincipals returns the value of the ToPrincipals field in PolicyInfo_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PolicyInfo_SdkV2) GetToPrincipals(ctx context.Context) ([]types.String, bool) {
	if m.ToPrincipals.IsNull() || m.ToPrincipals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ToPrincipals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetToPrincipals sets the value of the ToPrincipals field in PolicyInfo_SdkV2.
func (m *PolicyInfo_SdkV2) SetToPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["to_principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ToPrincipals = types.ListValueMust(t, vs)
}

type PrimaryKeyConstraint_SdkV2 struct {
	// Column names for this constraint.
	ChildColumns types.List `tfsdk:"child_columns"`
	// The name of the constraint.
	Name types.String `tfsdk:"name"`
	// True if the constraint is RELY, false or unset if NORELY.
	Rely types.Bool `tfsdk:"rely"`
	// Column names that represent a timeseries.
	TimeseriesColumns types.List `tfsdk:"timeseries_columns"`
}

func (to *PrimaryKeyConstraint_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PrimaryKeyConstraint_SdkV2) {
	if !from.TimeseriesColumns.IsNull() && !from.TimeseriesColumns.IsUnknown() && to.TimeseriesColumns.IsNull() && len(from.TimeseriesColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TimeseriesColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TimeseriesColumns = from.TimeseriesColumns
	}
}

func (to *PrimaryKeyConstraint_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PrimaryKeyConstraint_SdkV2) {
	if !from.TimeseriesColumns.IsNull() && !from.TimeseriesColumns.IsUnknown() && to.TimeseriesColumns.IsNull() && len(from.TimeseriesColumns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TimeseriesColumns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TimeseriesColumns = from.TimeseriesColumns
	}
}

func (m PrimaryKeyConstraint_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["child_columns"] = attrs["child_columns"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["rely"] = attrs["rely"].SetOptional()
	attrs["timeseries_columns"] = attrs["timeseries_columns"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PrimaryKeyConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PrimaryKeyConstraint_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"child_columns":      reflect.TypeOf(types.String{}),
		"timeseries_columns": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PrimaryKeyConstraint_SdkV2
// only implements ToObjectValue() and Type().
func (m PrimaryKeyConstraint_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"child_columns":      m.ChildColumns,
			"name":               m.Name,
			"rely":               m.Rely,
			"timeseries_columns": m.TimeseriesColumns,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PrimaryKeyConstraint_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"child_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": types.StringType,
			"rely": types.BoolType,
			"timeseries_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetChildColumns returns the value of the ChildColumns field in PrimaryKeyConstraint_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PrimaryKeyConstraint_SdkV2) GetChildColumns(ctx context.Context) ([]types.String, bool) {
	if m.ChildColumns.IsNull() || m.ChildColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ChildColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetChildColumns sets the value of the ChildColumns field in PrimaryKeyConstraint_SdkV2.
func (m *PrimaryKeyConstraint_SdkV2) SetChildColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["child_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ChildColumns = types.ListValueMust(t, vs)
}

// GetTimeseriesColumns returns the value of the TimeseriesColumns field in PrimaryKeyConstraint_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PrimaryKeyConstraint_SdkV2) GetTimeseriesColumns(ctx context.Context) ([]types.String, bool) {
	if m.TimeseriesColumns.IsNull() || m.TimeseriesColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.TimeseriesColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTimeseriesColumns sets the value of the TimeseriesColumns field in PrimaryKeyConstraint_SdkV2.
func (m *PrimaryKeyConstraint_SdkV2) SetTimeseriesColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["timeseries_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TimeseriesColumns = types.ListValueMust(t, vs)
}

type Principal_SdkV2 struct {
	// Databricks user, group or service principal ID.
	Id types.String `tfsdk:"id"`

	PrincipalType types.String `tfsdk:"principal_type"`
}

func (to *Principal_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Principal_SdkV2) {
}

func (to *Principal_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Principal_SdkV2) {
}

func (m Principal_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetOptional()
	attrs["principal_type"] = attrs["principal_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Principal.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Principal_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Principal_SdkV2
// only implements ToObjectValue() and Type().
func (m Principal_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":             m.Id,
			"principal_type": m.PrincipalType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Principal_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id":             types.StringType,
			"principal_type": types.StringType,
		},
	}
}

type PrivilegeAssignment_SdkV2 struct {
	// The principal (user email address or group name). For deleted principals,
	// `principal` is empty while `principal_id` is populated.
	Principal types.String `tfsdk:"principal"`
	// The privileges assigned to the principal.
	Privileges types.List `tfsdk:"privileges"`
}

func (to *PrivilegeAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PrivilegeAssignment_SdkV2) {
	if !from.Privileges.IsNull() && !from.Privileges.IsUnknown() && to.Privileges.IsNull() && len(from.Privileges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Privileges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Privileges = from.Privileges
	}
}

func (to *PrivilegeAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PrivilegeAssignment_SdkV2) {
	if !from.Privileges.IsNull() && !from.Privileges.IsUnknown() && to.Privileges.IsNull() && len(from.Privileges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Privileges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Privileges = from.Privileges
	}
}

func (m PrivilegeAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["privileges"] = attrs["privileges"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PrivilegeAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PrivilegeAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privileges": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PrivilegeAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m PrivilegeAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"principal":  m.Principal,
			"privileges": m.Privileges,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PrivilegeAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"principal": types.StringType,
			"privileges": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetPrivileges returns the value of the Privileges field in PrivilegeAssignment_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PrivilegeAssignment_SdkV2) GetPrivileges(ctx context.Context) ([]types.String, bool) {
	if m.Privileges.IsNull() || m.Privileges.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Privileges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivileges sets the value of the Privileges field in PrivilegeAssignment_SdkV2.
func (m *PrivilegeAssignment_SdkV2) SetPrivileges(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["privileges"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Privileges = types.ListValueMust(t, vs)
}

// Status of an asynchronously provisioned resource.
type ProvisioningInfo_SdkV2 struct {
	// The provisioning state of the resource.
	State types.String `tfsdk:"state"`
}

func (to *ProvisioningInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ProvisioningInfo_SdkV2) {
}

func (to *ProvisioningInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ProvisioningInfo_SdkV2) {
}

func (m ProvisioningInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["state"] = attrs["state"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ProvisioningInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ProvisioningInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ProvisioningInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m ProvisioningInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"state": m.State,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ProvisioningInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"state": types.StringType,
		},
	}
}

// Detailed status of an online table. Shown if the online table is in the
// PROVISIONING_PIPELINE_RESOURCES or the PROVISIONING_INITIAL_SNAPSHOT state.
type ProvisioningStatus_SdkV2 struct {
	// Details about initial data synchronization. Only populated when in the
	// PROVISIONING_INITIAL_SNAPSHOT state.
	InitialPipelineSyncProgress types.List `tfsdk:"initial_pipeline_sync_progress"`
}

func (to *ProvisioningStatus_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ProvisioningStatus_SdkV2) {
	if !from.InitialPipelineSyncProgress.IsNull() && !from.InitialPipelineSyncProgress.IsUnknown() {
		if toInitialPipelineSyncProgress, ok := to.GetInitialPipelineSyncProgress(ctx); ok {
			if fromInitialPipelineSyncProgress, ok := from.GetInitialPipelineSyncProgress(ctx); ok {
				// Recursively sync the fields of InitialPipelineSyncProgress
				toInitialPipelineSyncProgress.SyncFieldsDuringCreateOrUpdate(ctx, fromInitialPipelineSyncProgress)
				to.SetInitialPipelineSyncProgress(ctx, toInitialPipelineSyncProgress)
			}
		}
	}
}

func (to *ProvisioningStatus_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ProvisioningStatus_SdkV2) {
	if !from.InitialPipelineSyncProgress.IsNull() && !from.InitialPipelineSyncProgress.IsUnknown() {
		if toInitialPipelineSyncProgress, ok := to.GetInitialPipelineSyncProgress(ctx); ok {
			if fromInitialPipelineSyncProgress, ok := from.GetInitialPipelineSyncProgress(ctx); ok {
				toInitialPipelineSyncProgress.SyncFieldsDuringRead(ctx, fromInitialPipelineSyncProgress)
				to.SetInitialPipelineSyncProgress(ctx, toInitialPipelineSyncProgress)
			}
		}
	}
}

func (m ProvisioningStatus_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["initial_pipeline_sync_progress"] = attrs["initial_pipeline_sync_progress"].SetOptional()
	attrs["initial_pipeline_sync_progress"] = attrs["initial_pipeline_sync_progress"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ProvisioningStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ProvisioningStatus_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"initial_pipeline_sync_progress": reflect.TypeOf(PipelineProgress_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ProvisioningStatus_SdkV2
// only implements ToObjectValue() and Type().
func (m ProvisioningStatus_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"initial_pipeline_sync_progress": m.InitialPipelineSyncProgress,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ProvisioningStatus_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"initial_pipeline_sync_progress": basetypes.ListType{
				ElemType: PipelineProgress_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetInitialPipelineSyncProgress returns the value of the InitialPipelineSyncProgress field in ProvisioningStatus_SdkV2 as
// a PipelineProgress_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ProvisioningStatus_SdkV2) GetInitialPipelineSyncProgress(ctx context.Context) (PipelineProgress_SdkV2, bool) {
	var e PipelineProgress_SdkV2
	if m.InitialPipelineSyncProgress.IsNull() || m.InitialPipelineSyncProgress.IsUnknown() {
		return e, false
	}
	var v []PipelineProgress_SdkV2
	d := m.InitialPipelineSyncProgress.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInitialPipelineSyncProgress sets the value of the InitialPipelineSyncProgress field in ProvisioningStatus_SdkV2.
func (m *ProvisioningStatus_SdkV2) SetInitialPipelineSyncProgress(ctx context.Context, v PipelineProgress_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["initial_pipeline_sync_progress"]
	m.InitialPipelineSyncProgress = types.ListValueMust(t, vs)
}

type QuotaInfo_SdkV2 struct {
	// The timestamp that indicates when the quota count was last updated.
	LastRefreshedAt types.Int64 `tfsdk:"last_refreshed_at"`
	// Name of the parent resource. Returns metastore ID if the parent is a
	// metastore.
	ParentFullName types.String `tfsdk:"parent_full_name"`
	// The quota parent securable type.
	ParentSecurableType types.String `tfsdk:"parent_securable_type"`
	// The current usage of the resource quota.
	QuotaCount types.Int64 `tfsdk:"quota_count"`
	// The current limit of the resource quota.
	QuotaLimit types.Int64 `tfsdk:"quota_limit"`
	// The name of the quota.
	QuotaName types.String `tfsdk:"quota_name"`
}

func (to *QuotaInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from QuotaInfo_SdkV2) {
}

func (to *QuotaInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from QuotaInfo_SdkV2) {
}

func (m QuotaInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_refreshed_at"] = attrs["last_refreshed_at"].SetOptional()
	attrs["parent_full_name"] = attrs["parent_full_name"].SetOptional()
	attrs["parent_securable_type"] = attrs["parent_securable_type"].SetOptional()
	attrs["quota_count"] = attrs["quota_count"].SetOptional()
	attrs["quota_limit"] = attrs["quota_limit"].SetOptional()
	attrs["quota_name"] = attrs["quota_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QuotaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m QuotaInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QuotaInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m QuotaInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_refreshed_at":     m.LastRefreshedAt,
			"parent_full_name":      m.ParentFullName,
			"parent_securable_type": m.ParentSecurableType,
			"quota_count":           m.QuotaCount,
			"quota_limit":           m.QuotaLimit,
			"quota_name":            m.QuotaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m QuotaInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_refreshed_at":     types.Int64Type,
			"parent_full_name":      types.StringType,
			"parent_securable_type": types.StringType,
			"quota_count":           types.Int64Type,
			"quota_limit":           types.Int64Type,
			"quota_name":            types.StringType,
		},
	}
}

// R2 temporary credentials for API authentication. Read more at
// https://developers.cloudflare.com/r2/api/s3/tokens/.
type R2Credentials_SdkV2 struct {
	// The access key ID that identifies the temporary credentials.
	AccessKeyId types.String `tfsdk:"access_key_id"`
	// The secret access key associated with the access key.
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
	// The generated JWT that users must pass to use the temporary credentials.
	SessionToken types.String `tfsdk:"session_token"`
}

func (to *R2Credentials_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from R2Credentials_SdkV2) {
}

func (to *R2Credentials_SdkV2) SyncFieldsDuringRead(ctx context.Context, from R2Credentials_SdkV2) {
}

func (m R2Credentials_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_key_id"] = attrs["access_key_id"].SetOptional()
	attrs["secret_access_key"] = attrs["secret_access_key"].SetOptional()
	attrs["session_token"] = attrs["session_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in R2Credentials.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m R2Credentials_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, R2Credentials_SdkV2
// only implements ToObjectValue() and Type().
func (m R2Credentials_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_key_id":     m.AccessKeyId,
			"secret_access_key": m.SecretAccessKey,
			"session_token":     m.SessionToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m R2Credentials_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_key_id":     types.StringType,
			"secret_access_key": types.StringType,
			"session_token":     types.StringType,
		},
	}
}

type ReadVolumeRequest_SdkV2 struct {
	// Whether to include volumes in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The three-level (fully qualified) name of the volume
	Name types.String `tfsdk:"-"`
}

func (to *ReadVolumeRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ReadVolumeRequest_SdkV2) {
}

func (to *ReadVolumeRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ReadVolumeRequest_SdkV2) {
}

func (m ReadVolumeRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ReadVolumeRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ReadVolumeRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ReadVolumeRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ReadVolumeRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": m.IncludeBrowse,
			"name":           m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ReadVolumeRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type RegenerateDashboardRequest_SdkV2 struct {
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
	// Optional argument to specify the warehouse for dashboard regeneration. If
	// not specified, the first running warehouse will be used.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *RegenerateDashboardRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RegenerateDashboardRequest_SdkV2) {
}

func (to *RegenerateDashboardRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RegenerateDashboardRequest_SdkV2) {
}

func (m RegenerateDashboardRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegenerateDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RegenerateDashboardRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegenerateDashboardRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m RegenerateDashboardRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name":   m.TableName,
			"warehouse_id": m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RegenerateDashboardRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name":   types.StringType,
			"warehouse_id": types.StringType,
		},
	}
}

type RegenerateDashboardResponse_SdkV2 struct {
	DashboardId types.String `tfsdk:"dashboard_id"`
	// Parent folder is equivalent to {assets_dir}/{tableName}
	ParentFolder types.String `tfsdk:"parent_folder"`
}

func (to *RegenerateDashboardResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RegenerateDashboardResponse_SdkV2) {
}

func (to *RegenerateDashboardResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RegenerateDashboardResponse_SdkV2) {
}

func (m RegenerateDashboardResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetOptional()
	attrs["parent_folder"] = attrs["parent_folder"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegenerateDashboardResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RegenerateDashboardResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegenerateDashboardResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m RegenerateDashboardResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id":  m.DashboardId,
			"parent_folder": m.ParentFolder,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RegenerateDashboardResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id":  types.StringType,
			"parent_folder": types.StringType,
		},
	}
}

type RegisteredModelAlias_SdkV2 struct {
	// Name of the alias, e.g. 'champion' or 'latest_stable'
	AliasName types.String `tfsdk:"alias_name"`
	// The name of the catalog containing the model version
	CatalogName types.String `tfsdk:"catalog_name"`
	// The unique identifier of the alias
	Id types.String `tfsdk:"id"`
	// The name of the parent registered model of the model version, relative to
	// parent schema
	ModelName types.String `tfsdk:"model_name"`
	// The name of the schema containing the model version, relative to parent
	// catalog
	SchemaName types.String `tfsdk:"schema_name"`
	// Integer version number of the model version to which this alias points.
	VersionNum types.Int64 `tfsdk:"version_num"`
}

func (to *RegisteredModelAlias_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RegisteredModelAlias_SdkV2) {
}

func (to *RegisteredModelAlias_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RegisteredModelAlias_SdkV2) {
}

func (m RegisteredModelAlias_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias_name"] = attrs["alias_name"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["version_num"] = attrs["version_num"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegisteredModelAlias.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RegisteredModelAlias_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegisteredModelAlias_SdkV2
// only implements ToObjectValue() and Type().
func (m RegisteredModelAlias_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias_name":   m.AliasName,
			"catalog_name": m.CatalogName,
			"id":           m.Id,
			"model_name":   m.ModelName,
			"schema_name":  m.SchemaName,
			"version_num":  m.VersionNum,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RegisteredModelAlias_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias_name":   types.StringType,
			"catalog_name": types.StringType,
			"id":           types.StringType,
			"model_name":   types.StringType,
			"schema_name":  types.StringType,
			"version_num":  types.Int64Type,
		},
	}
}

type RegisteredModelInfo_SdkV2 struct {
	// List of aliases associated with the registered model
	Aliases types.List `tfsdk:"aliases"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog where the schema and the registered model reside
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the registered model
	Comment types.String `tfsdk:"comment"`
	// Creation timestamp of the registered model in milliseconds since the Unix
	// epoch
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the registered model
	CreatedBy types.String `tfsdk:"created_by"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the metastore
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the registered model
	Name types.String `tfsdk:"name"`
	// The identifier of the user who owns the registered model
	Owner types.String `tfsdk:"owner"`
	// The name of the schema where the registered model resides
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`
	// Last-update timestamp of the registered model in milliseconds since the
	// Unix epoch
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the registered model last time
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *RegisteredModelInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RegisteredModelInfo_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
}

func (to *RegisteredModelInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RegisteredModelInfo_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
}

func (m RegisteredModelInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegisteredModelInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RegisteredModelInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases": reflect.TypeOf(RegisteredModelAlias_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegisteredModelInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m RegisteredModelInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":          m.Aliases,
			"browse_only":      m.BrowseOnly,
			"catalog_name":     m.CatalogName,
			"comment":          m.Comment,
			"created_at":       m.CreatedAt,
			"created_by":       m.CreatedBy,
			"full_name":        m.FullName,
			"metastore_id":     m.MetastoreId,
			"name":             m.Name,
			"owner":            m.Owner,
			"schema_name":      m.SchemaName,
			"storage_location": m.StorageLocation,
			"updated_at":       m.UpdatedAt,
			"updated_by":       m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RegisteredModelInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias_SdkV2{}.Type(ctx),
			},
			"browse_only":      types.BoolType,
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"created_at":       types.Int64Type,
			"created_by":       types.StringType,
			"full_name":        types.StringType,
			"metastore_id":     types.StringType,
			"name":             types.StringType,
			"owner":            types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetAliases returns the value of the Aliases field in RegisteredModelInfo_SdkV2 as
// a slice of RegisteredModelAlias_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *RegisteredModelInfo_SdkV2) GetAliases(ctx context.Context) ([]RegisteredModelAlias_SdkV2, bool) {
	if m.Aliases.IsNull() || m.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias_SdkV2
	d := m.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in RegisteredModelInfo_SdkV2.
func (m *RegisteredModelInfo_SdkV2) SetAliases(ctx context.Context, v []RegisteredModelAlias_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Aliases = types.ListValueMust(t, vs)
}

type RowFilterOptions_SdkV2 struct {
	// The fully qualified name of the row filter function. The function is
	// called on each row of the target table. It should return a boolean value
	// indicating whether the row should be visible to the user. Required on
	// create and update.
	FunctionName types.String `tfsdk:"function_name"`
	// Optional list of column aliases or constant literals to be passed as
	// arguments to the row filter function. The type of each column should
	// match the positional argument of the row filter function.
	Using types.List `tfsdk:"using"`
}

func (to *RowFilterOptions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RowFilterOptions_SdkV2) {
	if !from.Using.IsNull() && !from.Using.IsUnknown() && to.Using.IsNull() && len(from.Using.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Using, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Using = from.Using
	}
}

func (to *RowFilterOptions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RowFilterOptions_SdkV2) {
	if !from.Using.IsNull() && !from.Using.IsUnknown() && to.Using.IsNull() && len(from.Using.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Using, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Using = from.Using
	}
}

func (m RowFilterOptions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetRequired()
	attrs["using"] = attrs["using"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RowFilterOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RowFilterOptions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"using": reflect.TypeOf(FunctionArgument_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RowFilterOptions_SdkV2
// only implements ToObjectValue() and Type().
func (m RowFilterOptions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name": m.FunctionName,
			"using":         m.Using,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RowFilterOptions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"using": basetypes.ListType{
				ElemType: FunctionArgument_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetUsing returns the value of the Using field in RowFilterOptions_SdkV2 as
// a slice of FunctionArgument_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *RowFilterOptions_SdkV2) GetUsing(ctx context.Context) ([]FunctionArgument_SdkV2, bool) {
	if m.Using.IsNull() || m.Using.IsUnknown() {
		return nil, false
	}
	var v []FunctionArgument_SdkV2
	d := m.Using.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUsing sets the value of the Using field in RowFilterOptions_SdkV2.
func (m *RowFilterOptions_SdkV2) SetUsing(ctx context.Context, v []FunctionArgument_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["using"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Using = types.ListValueMust(t, vs)
}

type RunRefreshRequest_SdkV2 struct {
	// UC table name in format `catalog.schema.table_name`. table_name is case
	// insensitive and spaces are disallowed.
	TableName types.String `tfsdk:"-"`
}

func (to *RunRefreshRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunRefreshRequest_SdkV2) {
}

func (to *RunRefreshRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunRefreshRequest_SdkV2) {
}

func (m RunRefreshRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunRefreshRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunRefreshRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunRefreshRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m RunRefreshRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunRefreshRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

// Next ID: 40
type SchemaInfo_SdkV2 struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// The type of the parent catalog.
	CatalogType types.String `tfsdk:"catalog_type"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this schema was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of schema creator.
	CreatedBy types.String `tfsdk:"created_by"`

	EffectivePredictiveOptimizationFlag types.List `tfsdk:"effective_predictive_optimization_flag"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// Full name of schema, in form of __catalog_name__.__schema_name__.
	FullName types.String `tfsdk:"full_name"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of schema, relative to parent catalog.
	Name types.String `tfsdk:"name"`
	// Username of current owner of schema.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// The unique identifier of the schema.
	SchemaId types.String `tfsdk:"schema_id"`
	// Storage location for managed tables within schema.
	StorageLocation types.String `tfsdk:"storage_location"`
	// Storage root URL for managed tables within schema.
	StorageRoot types.String `tfsdk:"storage_root"`
	// Time at which this schema was created, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified schema.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *SchemaInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SchemaInfo_SdkV2) {
	if !from.EffectivePredictiveOptimizationFlag.IsNull() && !from.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toEffectivePredictiveOptimizationFlag, ok := to.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromEffectivePredictiveOptimizationFlag, ok := from.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				// Recursively sync the fields of EffectivePredictiveOptimizationFlag
				toEffectivePredictiveOptimizationFlag.SyncFieldsDuringCreateOrUpdate(ctx, fromEffectivePredictiveOptimizationFlag)
				to.SetEffectivePredictiveOptimizationFlag(ctx, toEffectivePredictiveOptimizationFlag)
			}
		}
	}
}

func (to *SchemaInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SchemaInfo_SdkV2) {
	if !from.EffectivePredictiveOptimizationFlag.IsNull() && !from.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toEffectivePredictiveOptimizationFlag, ok := to.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromEffectivePredictiveOptimizationFlag, ok := from.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toEffectivePredictiveOptimizationFlag.SyncFieldsDuringRead(ctx, fromEffectivePredictiveOptimizationFlag)
				to.SetEffectivePredictiveOptimizationFlag(ctx, toEffectivePredictiveOptimizationFlag)
			}
		}
	}
}

func (m SchemaInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["catalog_type"] = attrs["catalog_type"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["schema_id"] = attrs["schema_id"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SchemaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SchemaInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"effective_predictive_optimization_flag": reflect.TypeOf(EffectivePredictiveOptimizationFlag_SdkV2{}),
		"properties":                             reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SchemaInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m SchemaInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":                            m.BrowseOnly,
			"catalog_name":                           m.CatalogName,
			"catalog_type":                           m.CatalogType,
			"comment":                                m.Comment,
			"created_at":                             m.CreatedAt,
			"created_by":                             m.CreatedBy,
			"effective_predictive_optimization_flag": m.EffectivePredictiveOptimizationFlag,
			"enable_predictive_optimization":         m.EnablePredictiveOptimization,
			"full_name":                              m.FullName,
			"metastore_id":                           m.MetastoreId,
			"name":                                   m.Name,
			"owner":                                  m.Owner,
			"properties":                             m.Properties,
			"schema_id":                              m.SchemaId,
			"storage_location":                       m.StorageLocation,
			"storage_root":                           m.StorageRoot,
			"updated_at":                             m.UpdatedAt,
			"updated_by":                             m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SchemaInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":  types.BoolType,
			"catalog_name": types.StringType,
			"catalog_type": types.StringType,
			"comment":      types.StringType,
			"created_at":   types.Int64Type,
			"created_by":   types.StringType,
			"effective_predictive_optimization_flag": basetypes.ListType{
				ElemType: EffectivePredictiveOptimizationFlag_SdkV2{}.Type(ctx),
			},
			"enable_predictive_optimization": types.StringType,
			"full_name":                      types.StringType,
			"metastore_id":                   types.StringType,
			"name":                           types.StringType,
			"owner":                          types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"schema_id":        types.StringType,
			"storage_location": types.StringType,
			"storage_root":     types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetEffectivePredictiveOptimizationFlag returns the value of the EffectivePredictiveOptimizationFlag field in SchemaInfo_SdkV2 as
// a EffectivePredictiveOptimizationFlag_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SchemaInfo_SdkV2) GetEffectivePredictiveOptimizationFlag(ctx context.Context) (EffectivePredictiveOptimizationFlag_SdkV2, bool) {
	var e EffectivePredictiveOptimizationFlag_SdkV2
	if m.EffectivePredictiveOptimizationFlag.IsNull() || m.EffectivePredictiveOptimizationFlag.IsUnknown() {
		return e, false
	}
	var v []EffectivePredictiveOptimizationFlag_SdkV2
	d := m.EffectivePredictiveOptimizationFlag.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEffectivePredictiveOptimizationFlag sets the value of the EffectivePredictiveOptimizationFlag field in SchemaInfo_SdkV2.
func (m *SchemaInfo_SdkV2) SetEffectivePredictiveOptimizationFlag(ctx context.Context, v EffectivePredictiveOptimizationFlag_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["effective_predictive_optimization_flag"]
	m.EffectivePredictiveOptimizationFlag = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in SchemaInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SchemaInfo_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in SchemaInfo_SdkV2.
func (m *SchemaInfo_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// Generic definition of a securable, which is uniquely defined in a metastore
// by its type and full name.
type Securable_SdkV2 struct {
	// Required. The full name of the catalog/schema/table. Optional if
	// resource_name is present.
	FullName types.String `tfsdk:"full_name"`
	// Optional. The name of the Share object that contains the securable when
	// the securable is getting shared in D2D Delta Sharing.
	ProviderShare types.String `tfsdk:"provider_share"`
	// Required. The type of securable (catalog/schema/table). Optional if
	// resource_name is present.
	Type_ types.String `tfsdk:"type"`
}

func (to *Securable_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Securable_SdkV2) {
}

func (to *Securable_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Securable_SdkV2) {
}

func (m Securable_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["provider_share"] = attrs["provider_share"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Securable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Securable_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Securable_SdkV2
// only implements ToObjectValue() and Type().
func (m Securable_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      m.FullName,
			"provider_share": m.ProviderShare,
			"type":           m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Securable_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"provider_share": types.StringType,
			"type":           types.StringType,
		},
	}
}

// Manifest of a specific securable kind.
type SecurableKindManifest_SdkV2 struct {
	// Privileges that can be assigned to the securable.
	AssignablePrivileges types.List `tfsdk:"assignable_privileges"`
	// A list of capabilities in the securable kind.
	Capabilities types.List `tfsdk:"capabilities"`
	// Detailed specs of allowed options.
	Options types.List `tfsdk:"options"`
	// Securable kind to get manifest of.
	SecurableKind types.String `tfsdk:"securable_kind"`
	// Securable Type of the kind.
	SecurableType types.String `tfsdk:"securable_type"`
}

func (to *SecurableKindManifest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SecurableKindManifest_SdkV2) {
	if !from.AssignablePrivileges.IsNull() && !from.AssignablePrivileges.IsUnknown() && to.AssignablePrivileges.IsNull() && len(from.AssignablePrivileges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AssignablePrivileges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AssignablePrivileges = from.AssignablePrivileges
	}
	if !from.Capabilities.IsNull() && !from.Capabilities.IsUnknown() && to.Capabilities.IsNull() && len(from.Capabilities.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Capabilities, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Capabilities = from.Capabilities
	}
	if !from.Options.IsNull() && !from.Options.IsUnknown() && to.Options.IsNull() && len(from.Options.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Options, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Options = from.Options
	}
}

func (to *SecurableKindManifest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SecurableKindManifest_SdkV2) {
	if !from.AssignablePrivileges.IsNull() && !from.AssignablePrivileges.IsUnknown() && to.AssignablePrivileges.IsNull() && len(from.AssignablePrivileges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AssignablePrivileges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AssignablePrivileges = from.AssignablePrivileges
	}
	if !from.Capabilities.IsNull() && !from.Capabilities.IsUnknown() && to.Capabilities.IsNull() && len(from.Capabilities.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Capabilities, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Capabilities = from.Capabilities
	}
	if !from.Options.IsNull() && !from.Options.IsUnknown() && to.Options.IsNull() && len(from.Options.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Options, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Options = from.Options
	}
}

func (m SecurableKindManifest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assignable_privileges"] = attrs["assignable_privileges"].SetOptional()
	attrs["capabilities"] = attrs["capabilities"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["securable_kind"] = attrs["securable_kind"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SecurableKindManifest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SecurableKindManifest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"assignable_privileges": reflect.TypeOf(types.String{}),
		"capabilities":          reflect.TypeOf(types.String{}),
		"options":               reflect.TypeOf(OptionSpec_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SecurableKindManifest_SdkV2
// only implements ToObjectValue() and Type().
func (m SecurableKindManifest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assignable_privileges": m.AssignablePrivileges,
			"capabilities":          m.Capabilities,
			"options":               m.Options,
			"securable_kind":        m.SecurableKind,
			"securable_type":        m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SecurableKindManifest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assignable_privileges": basetypes.ListType{
				ElemType: types.StringType,
			},
			"capabilities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"options": basetypes.ListType{
				ElemType: OptionSpec_SdkV2{}.Type(ctx),
			},
			"securable_kind": types.StringType,
			"securable_type": types.StringType,
		},
	}
}

// GetAssignablePrivileges returns the value of the AssignablePrivileges field in SecurableKindManifest_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SecurableKindManifest_SdkV2) GetAssignablePrivileges(ctx context.Context) ([]types.String, bool) {
	if m.AssignablePrivileges.IsNull() || m.AssignablePrivileges.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.AssignablePrivileges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAssignablePrivileges sets the value of the AssignablePrivileges field in SecurableKindManifest_SdkV2.
func (m *SecurableKindManifest_SdkV2) SetAssignablePrivileges(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["assignable_privileges"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AssignablePrivileges = types.ListValueMust(t, vs)
}

// GetCapabilities returns the value of the Capabilities field in SecurableKindManifest_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SecurableKindManifest_SdkV2) GetCapabilities(ctx context.Context) ([]types.String, bool) {
	if m.Capabilities.IsNull() || m.Capabilities.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Capabilities.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCapabilities sets the value of the Capabilities field in SecurableKindManifest_SdkV2.
func (m *SecurableKindManifest_SdkV2) SetCapabilities(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["capabilities"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Capabilities = types.ListValueMust(t, vs)
}

// GetOptions returns the value of the Options field in SecurableKindManifest_SdkV2 as
// a slice of OptionSpec_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SecurableKindManifest_SdkV2) GetOptions(ctx context.Context) ([]OptionSpec_SdkV2, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v []OptionSpec_SdkV2
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in SecurableKindManifest_SdkV2.
func (m *SecurableKindManifest_SdkV2) SetOptions(ctx context.Context, v []OptionSpec_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.ListValueMust(t, vs)
}

type SecurablePermissions_SdkV2 struct {
	// List of requested Unity Catalog permissions.
	Permissions types.List `tfsdk:"permissions"`
	// The securable for which the access request destinations are being
	// requested.
	Securable types.List `tfsdk:"securable"`
}

func (to *SecurablePermissions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SecurablePermissions_SdkV2) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
	if !from.Securable.IsNull() && !from.Securable.IsUnknown() {
		if toSecurable, ok := to.GetSecurable(ctx); ok {
			if fromSecurable, ok := from.GetSecurable(ctx); ok {
				// Recursively sync the fields of Securable
				toSecurable.SyncFieldsDuringCreateOrUpdate(ctx, fromSecurable)
				to.SetSecurable(ctx, toSecurable)
			}
		}
	}
}

func (to *SecurablePermissions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SecurablePermissions_SdkV2) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
	if !from.Securable.IsNull() && !from.Securable.IsUnknown() {
		if toSecurable, ok := to.GetSecurable(ctx); ok {
			if fromSecurable, ok := from.GetSecurable(ctx); ok {
				toSecurable.SyncFieldsDuringRead(ctx, fromSecurable)
				to.SetSecurable(ctx, toSecurable)
			}
		}
	}
}

func (m SecurablePermissions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permissions"] = attrs["permissions"].SetOptional()
	attrs["securable"] = attrs["securable"].SetOptional()
	attrs["securable"] = attrs["securable"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SecurablePermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SecurablePermissions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permissions": reflect.TypeOf(types.String{}),
		"securable":   reflect.TypeOf(Securable_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SecurablePermissions_SdkV2
// only implements ToObjectValue() and Type().
func (m SecurablePermissions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permissions": m.Permissions,
			"securable":   m.Securable,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SecurablePermissions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permissions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"securable": basetypes.ListType{
				ElemType: Securable_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPermissions returns the value of the Permissions field in SecurablePermissions_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SecurablePermissions_SdkV2) GetPermissions(ctx context.Context) ([]types.String, bool) {
	if m.Permissions.IsNull() || m.Permissions.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Permissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissions sets the value of the Permissions field in SecurablePermissions_SdkV2.
func (m *SecurablePermissions_SdkV2) SetPermissions(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Permissions = types.ListValueMust(t, vs)
}

// GetSecurable returns the value of the Securable field in SecurablePermissions_SdkV2 as
// a Securable_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SecurablePermissions_SdkV2) GetSecurable(ctx context.Context) (Securable_SdkV2, bool) {
	var e Securable_SdkV2
	if m.Securable.IsNull() || m.Securable.IsUnknown() {
		return e, false
	}
	var v []Securable_SdkV2
	d := m.Securable.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSecurable sets the value of the Securable field in SecurablePermissions_SdkV2.
func (m *SecurablePermissions_SdkV2) SetSecurable(ctx context.Context, v Securable_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["securable"]
	m.Securable = types.ListValueMust(t, vs)
}

type SetArtifactAllowlist_SdkV2 struct {
	// A list of allowed artifact match patterns.
	ArtifactMatchers types.List `tfsdk:"artifact_matchers"`
	// The artifact type of the allowlist.
	ArtifactType types.String `tfsdk:"-"`
	// Time at which this artifact allowlist was set, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who set the artifact allowlist.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
}

func (to *SetArtifactAllowlist_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SetArtifactAllowlist_SdkV2) {
}

func (to *SetArtifactAllowlist_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SetArtifactAllowlist_SdkV2) {
}

func (m SetArtifactAllowlist_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact_matchers"] = attrs["artifact_matchers"].SetRequired()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()
	attrs["artifact_type"] = attrs["artifact_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SetArtifactAllowlist.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SetArtifactAllowlist_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"artifact_matchers": reflect.TypeOf(ArtifactMatcher_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SetArtifactAllowlist_SdkV2
// only implements ToObjectValue() and Type().
func (m SetArtifactAllowlist_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact_matchers": m.ArtifactMatchers,
			"artifact_type":     m.ArtifactType,
			"created_at":        m.CreatedAt,
			"created_by":        m.CreatedBy,
			"metastore_id":      m.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SetArtifactAllowlist_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact_matchers": basetypes.ListType{
				ElemType: ArtifactMatcher_SdkV2{}.Type(ctx),
			},
			"artifact_type": types.StringType,
			"created_at":    types.Int64Type,
			"created_by":    types.StringType,
			"metastore_id":  types.StringType,
		},
	}
}

// GetArtifactMatchers returns the value of the ArtifactMatchers field in SetArtifactAllowlist_SdkV2 as
// a slice of ArtifactMatcher_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SetArtifactAllowlist_SdkV2) GetArtifactMatchers(ctx context.Context) ([]ArtifactMatcher_SdkV2, bool) {
	if m.ArtifactMatchers.IsNull() || m.ArtifactMatchers.IsUnknown() {
		return nil, false
	}
	var v []ArtifactMatcher_SdkV2
	d := m.ArtifactMatchers.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetArtifactMatchers sets the value of the ArtifactMatchers field in SetArtifactAllowlist_SdkV2.
func (m *SetArtifactAllowlist_SdkV2) SetArtifactMatchers(ctx context.Context, v []ArtifactMatcher_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["artifact_matchers"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ArtifactMatchers = types.ListValueMust(t, vs)
}

type SetRegisteredModelAliasRequest_SdkV2 struct {
	// The name of the alias
	Alias types.String `tfsdk:"-"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// The version number of the model version to which the alias points
	VersionNum types.Int64 `tfsdk:"version_num"`
}

func (to *SetRegisteredModelAliasRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SetRegisteredModelAliasRequest_SdkV2) {
}

func (to *SetRegisteredModelAliasRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SetRegisteredModelAliasRequest_SdkV2) {
}

func (m SetRegisteredModelAliasRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["version_num"] = attrs["version_num"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["alias"] = attrs["alias"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SetRegisteredModelAliasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SetRegisteredModelAliasRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SetRegisteredModelAliasRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m SetRegisteredModelAliasRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":       m.Alias,
			"full_name":   m.FullName,
			"version_num": m.VersionNum,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SetRegisteredModelAliasRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":       types.StringType,
			"full_name":   types.StringType,
			"version_num": types.Int64Type,
		},
	}
}

// Server-Side Encryption properties for clients communicating with AWS s3.
type SseEncryptionDetails_SdkV2 struct {
	// Sets the value of the 'x-amz-server-side-encryption' header in S3
	// request.
	Algorithm types.String `tfsdk:"algorithm"`
	// Optional. The ARN of the SSE-KMS key used with the S3 location, when
	// algorithm = "SSE-KMS". Sets the value of the
	// 'x-amz-server-side-encryption-aws-kms-key-id' header.
	AwsKmsKeyArn types.String `tfsdk:"aws_kms_key_arn"`
}

func (to *SseEncryptionDetails_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SseEncryptionDetails_SdkV2) {
}

func (to *SseEncryptionDetails_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SseEncryptionDetails_SdkV2) {
}

func (m SseEncryptionDetails_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["algorithm"] = attrs["algorithm"].SetOptional()
	attrs["aws_kms_key_arn"] = attrs["aws_kms_key_arn"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SseEncryptionDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SseEncryptionDetails_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SseEncryptionDetails_SdkV2
// only implements ToObjectValue() and Type().
func (m SseEncryptionDetails_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"algorithm":       m.Algorithm,
			"aws_kms_key_arn": m.AwsKmsKeyArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SseEncryptionDetails_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"algorithm":       types.StringType,
			"aws_kms_key_arn": types.StringType,
		},
	}
}

type StorageCredentialInfo_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.List `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// Time at which this credential was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of credential creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The full name of the credential.
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the credential.
	Id types.String `tfsdk:"id"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of the parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Time at which this credential was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the credential.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Whether this credential is the current metastore's root storage
	// credential. Only applicable when purpose is **STORAGE**.
	UsedForManagedStorage types.Bool `tfsdk:"used_for_managed_storage"`
}

func (to *StorageCredentialInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from StorageCredentialInfo_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				// Recursively sync the fields of CloudflareApiToken
				toCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *StorageCredentialInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from StorageCredentialInfo_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				toCloudflareApiToken.SyncFieldsDuringRead(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m StorageCredentialInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["used_for_managed_storage"] = attrs["used_for_managed_storage"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in StorageCredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m StorageCredentialInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleResponse_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityResponse_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountResponse_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, StorageCredentialInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m StorageCredentialInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"cloudflare_api_token":           m.CloudflareApiToken,
			"comment":                        m.Comment,
			"created_at":                     m.CreatedAt,
			"created_by":                     m.CreatedBy,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"full_name":                      m.FullName,
			"id":                             m.Id,
			"isolation_mode":                 m.IsolationMode,
			"metastore_id":                   m.MetastoreId,
			"name":                           m.Name,
			"owner":                          m.Owner,
			"read_only":                      m.ReadOnly,
			"updated_at":                     m.UpdatedAt,
			"updated_by":                     m.UpdatedBy,
			"used_for_managed_storage":       m.UsedForManagedStorage,
		})
}

// Type implements basetypes.ObjectValuable.
func (m StorageCredentialInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRoleResponse_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentityResponse_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"cloudflare_api_token": basetypes.ListType{
				ElemType: CloudflareApiToken_SdkV2{}.Type(ctx),
			},
			"comment":    types.StringType,
			"created_at": types.Int64Type,
			"created_by": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccountResponse_SdkV2{}.Type(ctx),
			},
			"full_name":                types.StringType,
			"id":                       types.StringType,
			"isolation_mode":           types.StringType,
			"metastore_id":             types.StringType,
			"name":                     types.StringType,
			"owner":                    types.StringType,
			"read_only":                types.BoolType,
			"updated_at":               types.Int64Type,
			"updated_by":               types.StringType,
			"used_for_managed_storage": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in StorageCredentialInfo_SdkV2 as
// a AwsIamRoleResponse_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *StorageCredentialInfo_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRoleResponse_SdkV2, bool) {
	var e AwsIamRoleResponse_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRoleResponse_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in StorageCredentialInfo_SdkV2.
func (m *StorageCredentialInfo_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRoleResponse_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in StorageCredentialInfo_SdkV2 as
// a AzureManagedIdentityResponse_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *StorageCredentialInfo_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityResponse_SdkV2, bool) {
	var e AzureManagedIdentityResponse_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentityResponse_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in StorageCredentialInfo_SdkV2.
func (m *StorageCredentialInfo_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityResponse_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in StorageCredentialInfo_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *StorageCredentialInfo_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in StorageCredentialInfo_SdkV2.
func (m *StorageCredentialInfo_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in StorageCredentialInfo_SdkV2 as
// a CloudflareApiToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *StorageCredentialInfo_SdkV2) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken_SdkV2, bool) {
	var e CloudflareApiToken_SdkV2
	if m.CloudflareApiToken.IsNull() || m.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v []CloudflareApiToken_SdkV2
	d := m.CloudflareApiToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in StorageCredentialInfo_SdkV2.
func (m *StorageCredentialInfo_SdkV2) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cloudflare_api_token"]
	m.CloudflareApiToken = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in StorageCredentialInfo_SdkV2 as
// a DatabricksGcpServiceAccountResponse_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *StorageCredentialInfo_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountResponse_SdkV2, bool) {
	var e DatabricksGcpServiceAccountResponse_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccountResponse_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in StorageCredentialInfo_SdkV2.
func (m *StorageCredentialInfo_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountResponse_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type SummaryRequest_SdkV2 struct {
}

func (to *SummaryRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SummaryRequest_SdkV2) {
}

func (to *SummaryRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SummaryRequest_SdkV2) {
}

func (m SummaryRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SummaryRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SummaryRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SummaryRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m SummaryRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m SummaryRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type SystemSchemaInfo_SdkV2 struct {
	// Name of the system schema.
	Schema types.String `tfsdk:"schema"`
	// The current state of enablement for the system schema. An empty string
	// means the system schema is available and ready for opt-in. Possible
	// values: AVAILABLE | ENABLE_INITIALIZED | ENABLE_COMPLETED |
	// DISABLE_INITIALIZED | UNAVAILABLE | MANAGED
	State types.String `tfsdk:"state"`
}

func (to *SystemSchemaInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SystemSchemaInfo_SdkV2) {
}

func (to *SystemSchemaInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SystemSchemaInfo_SdkV2) {
}

func (m SystemSchemaInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["schema"] = attrs["schema"].SetRequired()
	attrs["state"] = attrs["state"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SystemSchemaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SystemSchemaInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SystemSchemaInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m SystemSchemaInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"schema": m.Schema,
			"state":  m.State,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SystemSchemaInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"schema": types.StringType,
			"state":  types.StringType,
		},
	}
}

// A table constraint, as defined by *one* of the following fields being set:
// __primary_key_constraint__, __foreign_key_constraint__,
// __named_table_constraint__.
type TableConstraint_SdkV2 struct {
	ForeignKeyConstraint types.List `tfsdk:"foreign_key_constraint"`

	NamedTableConstraint types.List `tfsdk:"named_table_constraint"`

	PrimaryKeyConstraint types.List `tfsdk:"primary_key_constraint"`
}

func (to *TableConstraint_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableConstraint_SdkV2) {
	if !from.ForeignKeyConstraint.IsNull() && !from.ForeignKeyConstraint.IsUnknown() {
		if toForeignKeyConstraint, ok := to.GetForeignKeyConstraint(ctx); ok {
			if fromForeignKeyConstraint, ok := from.GetForeignKeyConstraint(ctx); ok {
				// Recursively sync the fields of ForeignKeyConstraint
				toForeignKeyConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromForeignKeyConstraint)
				to.SetForeignKeyConstraint(ctx, toForeignKeyConstraint)
			}
		}
	}
	if !from.NamedTableConstraint.IsNull() && !from.NamedTableConstraint.IsUnknown() {
		if toNamedTableConstraint, ok := to.GetNamedTableConstraint(ctx); ok {
			if fromNamedTableConstraint, ok := from.GetNamedTableConstraint(ctx); ok {
				// Recursively sync the fields of NamedTableConstraint
				toNamedTableConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromNamedTableConstraint)
				to.SetNamedTableConstraint(ctx, toNamedTableConstraint)
			}
		}
	}
	if !from.PrimaryKeyConstraint.IsNull() && !from.PrimaryKeyConstraint.IsUnknown() {
		if toPrimaryKeyConstraint, ok := to.GetPrimaryKeyConstraint(ctx); ok {
			if fromPrimaryKeyConstraint, ok := from.GetPrimaryKeyConstraint(ctx); ok {
				// Recursively sync the fields of PrimaryKeyConstraint
				toPrimaryKeyConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromPrimaryKeyConstraint)
				to.SetPrimaryKeyConstraint(ctx, toPrimaryKeyConstraint)
			}
		}
	}
}

func (to *TableConstraint_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableConstraint_SdkV2) {
	if !from.ForeignKeyConstraint.IsNull() && !from.ForeignKeyConstraint.IsUnknown() {
		if toForeignKeyConstraint, ok := to.GetForeignKeyConstraint(ctx); ok {
			if fromForeignKeyConstraint, ok := from.GetForeignKeyConstraint(ctx); ok {
				toForeignKeyConstraint.SyncFieldsDuringRead(ctx, fromForeignKeyConstraint)
				to.SetForeignKeyConstraint(ctx, toForeignKeyConstraint)
			}
		}
	}
	if !from.NamedTableConstraint.IsNull() && !from.NamedTableConstraint.IsUnknown() {
		if toNamedTableConstraint, ok := to.GetNamedTableConstraint(ctx); ok {
			if fromNamedTableConstraint, ok := from.GetNamedTableConstraint(ctx); ok {
				toNamedTableConstraint.SyncFieldsDuringRead(ctx, fromNamedTableConstraint)
				to.SetNamedTableConstraint(ctx, toNamedTableConstraint)
			}
		}
	}
	if !from.PrimaryKeyConstraint.IsNull() && !from.PrimaryKeyConstraint.IsUnknown() {
		if toPrimaryKeyConstraint, ok := to.GetPrimaryKeyConstraint(ctx); ok {
			if fromPrimaryKeyConstraint, ok := from.GetPrimaryKeyConstraint(ctx); ok {
				toPrimaryKeyConstraint.SyncFieldsDuringRead(ctx, fromPrimaryKeyConstraint)
				to.SetPrimaryKeyConstraint(ctx, toPrimaryKeyConstraint)
			}
		}
	}
}

func (m TableConstraint_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["foreign_key_constraint"] = attrs["foreign_key_constraint"].SetOptional()
	attrs["foreign_key_constraint"] = attrs["foreign_key_constraint"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["named_table_constraint"] = attrs["named_table_constraint"].SetOptional()
	attrs["named_table_constraint"] = attrs["named_table_constraint"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["primary_key_constraint"] = attrs["primary_key_constraint"].SetOptional()
	attrs["primary_key_constraint"] = attrs["primary_key_constraint"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableConstraint_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"foreign_key_constraint": reflect.TypeOf(ForeignKeyConstraint_SdkV2{}),
		"named_table_constraint": reflect.TypeOf(NamedTableConstraint_SdkV2{}),
		"primary_key_constraint": reflect.TypeOf(PrimaryKeyConstraint_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableConstraint_SdkV2
// only implements ToObjectValue() and Type().
func (m TableConstraint_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"foreign_key_constraint": m.ForeignKeyConstraint,
			"named_table_constraint": m.NamedTableConstraint,
			"primary_key_constraint": m.PrimaryKeyConstraint,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableConstraint_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"foreign_key_constraint": basetypes.ListType{
				ElemType: ForeignKeyConstraint_SdkV2{}.Type(ctx),
			},
			"named_table_constraint": basetypes.ListType{
				ElemType: NamedTableConstraint_SdkV2{}.Type(ctx),
			},
			"primary_key_constraint": basetypes.ListType{
				ElemType: PrimaryKeyConstraint_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetForeignKeyConstraint returns the value of the ForeignKeyConstraint field in TableConstraint_SdkV2 as
// a ForeignKeyConstraint_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableConstraint_SdkV2) GetForeignKeyConstraint(ctx context.Context) (ForeignKeyConstraint_SdkV2, bool) {
	var e ForeignKeyConstraint_SdkV2
	if m.ForeignKeyConstraint.IsNull() || m.ForeignKeyConstraint.IsUnknown() {
		return e, false
	}
	var v []ForeignKeyConstraint_SdkV2
	d := m.ForeignKeyConstraint.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetForeignKeyConstraint sets the value of the ForeignKeyConstraint field in TableConstraint_SdkV2.
func (m *TableConstraint_SdkV2) SetForeignKeyConstraint(ctx context.Context, v ForeignKeyConstraint_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["foreign_key_constraint"]
	m.ForeignKeyConstraint = types.ListValueMust(t, vs)
}

// GetNamedTableConstraint returns the value of the NamedTableConstraint field in TableConstraint_SdkV2 as
// a NamedTableConstraint_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableConstraint_SdkV2) GetNamedTableConstraint(ctx context.Context) (NamedTableConstraint_SdkV2, bool) {
	var e NamedTableConstraint_SdkV2
	if m.NamedTableConstraint.IsNull() || m.NamedTableConstraint.IsUnknown() {
		return e, false
	}
	var v []NamedTableConstraint_SdkV2
	d := m.NamedTableConstraint.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNamedTableConstraint sets the value of the NamedTableConstraint field in TableConstraint_SdkV2.
func (m *TableConstraint_SdkV2) SetNamedTableConstraint(ctx context.Context, v NamedTableConstraint_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["named_table_constraint"]
	m.NamedTableConstraint = types.ListValueMust(t, vs)
}

// GetPrimaryKeyConstraint returns the value of the PrimaryKeyConstraint field in TableConstraint_SdkV2 as
// a PrimaryKeyConstraint_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableConstraint_SdkV2) GetPrimaryKeyConstraint(ctx context.Context) (PrimaryKeyConstraint_SdkV2, bool) {
	var e PrimaryKeyConstraint_SdkV2
	if m.PrimaryKeyConstraint.IsNull() || m.PrimaryKeyConstraint.IsUnknown() {
		return e, false
	}
	var v []PrimaryKeyConstraint_SdkV2
	d := m.PrimaryKeyConstraint.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPrimaryKeyConstraint sets the value of the PrimaryKeyConstraint field in TableConstraint_SdkV2.
func (m *TableConstraint_SdkV2) SetPrimaryKeyConstraint(ctx context.Context, v PrimaryKeyConstraint_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["primary_key_constraint"]
	m.PrimaryKeyConstraint = types.ListValueMust(t, vs)
}

// A table that is dependent on a SQL object.
type TableDependency_SdkV2 struct {
	// Full name of the dependent table, in the form of
	// __catalog_name__.__schema_name__.__table_name__.
	TableFullName types.String `tfsdk:"table_full_name"`
}

func (to *TableDependency_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableDependency_SdkV2) {
}

func (to *TableDependency_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableDependency_SdkV2) {
}

func (m TableDependency_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_full_name"] = attrs["table_full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableDependency_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableDependency_SdkV2
// only implements ToObjectValue() and Type().
func (m TableDependency_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_full_name": m.TableFullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableDependency_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_full_name": types.StringType,
		},
	}
}

type TableExistsResponse_SdkV2 struct {
	// Whether the table exists or not.
	TableExists types.Bool `tfsdk:"table_exists"`
}

func (to *TableExistsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableExistsResponse_SdkV2) {
}

func (to *TableExistsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableExistsResponse_SdkV2) {
}

func (m TableExistsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_exists"] = attrs["table_exists"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableExistsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableExistsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableExistsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m TableExistsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_exists": m.TableExists,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableExistsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_exists": types.BoolType,
		},
	}
}

type TableInfo_SdkV2 struct {
	// The AWS access point to use when accesing s3 for this external location.
	AccessPoint types.String `tfsdk:"access_point"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// The array of __ColumnInfo__ definitions of the table's columns.
	Columns types.List `tfsdk:"columns"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this table was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of table creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique ID of the Data Access Configuration to use with the table data.
	DataAccessConfigurationId types.String `tfsdk:"data_access_configuration_id"`

	DataSourceFormat types.String `tfsdk:"data_source_format"`
	// Time at which this table was deleted, in epoch milliseconds. Field is
	// omitted if table is not deleted.
	DeletedAt types.Int64 `tfsdk:"deleted_at"`
	// Information pertaining to current state of the delta table.
	DeltaRuntimePropertiesKvpairs types.List `tfsdk:"delta_runtime_properties_kvpairs"`

	EffectivePredictiveOptimizationFlag types.List `tfsdk:"effective_predictive_optimization_flag"`

	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`

	EncryptionDetails types.List `tfsdk:"encryption_details"`
	// Full name of table, in form of
	// __catalog_name__.__schema_name__.__table_name__
	FullName types.String `tfsdk:"full_name"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of table, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// Username of current owner of table.
	Owner types.String `tfsdk:"owner"`
	// The pipeline ID of the table. Applicable for tables created by pipelines
	// (Materialized View, Streaming Table, etc.).
	PipelineId types.String `tfsdk:"pipeline_id"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`

	RowFilter types.List `tfsdk:"row_filter"`
	// Name of parent schema relative to its parent catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// SecurableKindManifest of table, including capabilities the table has.
	SecurableKindManifest types.List `tfsdk:"securable_kind_manifest"`
	// List of schemes whose objects can be referenced without qualification.
	SqlPath types.String `tfsdk:"sql_path"`
	// Name of the storage credential, when a storage credential is configured
	// for use with this table.
	StorageCredentialName types.String `tfsdk:"storage_credential_name"`
	// Storage root URL for table (for **MANAGED**, **EXTERNAL** tables).
	StorageLocation types.String `tfsdk:"storage_location"`
	// List of table constraints. Note: this field is not set in the output of
	// the __listTables__ API.
	TableConstraints types.List `tfsdk:"table_constraints"`
	// The unique identifier of the table.
	TableId types.String `tfsdk:"table_id"`

	TableType types.String `tfsdk:"table_type"`
	// Time at which this table was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the table.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// View definition SQL (when __table_type__ is **VIEW**,
	// **MATERIALIZED_VIEW**, or **STREAMING_TABLE**)
	ViewDefinition types.String `tfsdk:"view_definition"`
	// View dependencies (when table_type == **VIEW** or **MATERIALIZED_VIEW**,
	// **STREAMING_TABLE**) - when DependencyList is None, the dependency is not
	// provided; - when DependencyList is an empty list, the dependency is
	// provided but is empty; - when DependencyList is not an empty list,
	// dependencies are provided and recorded.
	ViewDependencies types.List `tfsdk:"view_dependencies"`
}

func (to *TableInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableInfo_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.DeltaRuntimePropertiesKvpairs.IsNull() && !from.DeltaRuntimePropertiesKvpairs.IsUnknown() {
		if toDeltaRuntimePropertiesKvpairs, ok := to.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
			if fromDeltaRuntimePropertiesKvpairs, ok := from.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
				// Recursively sync the fields of DeltaRuntimePropertiesKvpairs
				toDeltaRuntimePropertiesKvpairs.SyncFieldsDuringCreateOrUpdate(ctx, fromDeltaRuntimePropertiesKvpairs)
				to.SetDeltaRuntimePropertiesKvpairs(ctx, toDeltaRuntimePropertiesKvpairs)
			}
		}
	}
	if !from.EffectivePredictiveOptimizationFlag.IsNull() && !from.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toEffectivePredictiveOptimizationFlag, ok := to.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromEffectivePredictiveOptimizationFlag, ok := from.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				// Recursively sync the fields of EffectivePredictiveOptimizationFlag
				toEffectivePredictiveOptimizationFlag.SyncFieldsDuringCreateOrUpdate(ctx, fromEffectivePredictiveOptimizationFlag)
				to.SetEffectivePredictiveOptimizationFlag(ctx, toEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				// Recursively sync the fields of EncryptionDetails
				toEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.RowFilter.IsNull() && !from.RowFilter.IsUnknown() {
		if toRowFilter, ok := to.GetRowFilter(ctx); ok {
			if fromRowFilter, ok := from.GetRowFilter(ctx); ok {
				// Recursively sync the fields of RowFilter
				toRowFilter.SyncFieldsDuringCreateOrUpdate(ctx, fromRowFilter)
				to.SetRowFilter(ctx, toRowFilter)
			}
		}
	}
	if !from.SecurableKindManifest.IsNull() && !from.SecurableKindManifest.IsUnknown() {
		if toSecurableKindManifest, ok := to.GetSecurableKindManifest(ctx); ok {
			if fromSecurableKindManifest, ok := from.GetSecurableKindManifest(ctx); ok {
				// Recursively sync the fields of SecurableKindManifest
				toSecurableKindManifest.SyncFieldsDuringCreateOrUpdate(ctx, fromSecurableKindManifest)
				to.SetSecurableKindManifest(ctx, toSecurableKindManifest)
			}
		}
	}
	if !from.TableConstraints.IsNull() && !from.TableConstraints.IsUnknown() && to.TableConstraints.IsNull() && len(from.TableConstraints.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TableConstraints, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TableConstraints = from.TableConstraints
	}
	if !from.ViewDependencies.IsNull() && !from.ViewDependencies.IsUnknown() {
		if toViewDependencies, ok := to.GetViewDependencies(ctx); ok {
			if fromViewDependencies, ok := from.GetViewDependencies(ctx); ok {
				// Recursively sync the fields of ViewDependencies
				toViewDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromViewDependencies)
				to.SetViewDependencies(ctx, toViewDependencies)
			}
		}
	}
}

func (to *TableInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableInfo_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.DeltaRuntimePropertiesKvpairs.IsNull() && !from.DeltaRuntimePropertiesKvpairs.IsUnknown() {
		if toDeltaRuntimePropertiesKvpairs, ok := to.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
			if fromDeltaRuntimePropertiesKvpairs, ok := from.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
				toDeltaRuntimePropertiesKvpairs.SyncFieldsDuringRead(ctx, fromDeltaRuntimePropertiesKvpairs)
				to.SetDeltaRuntimePropertiesKvpairs(ctx, toDeltaRuntimePropertiesKvpairs)
			}
		}
	}
	if !from.EffectivePredictiveOptimizationFlag.IsNull() && !from.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toEffectivePredictiveOptimizationFlag, ok := to.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromEffectivePredictiveOptimizationFlag, ok := from.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toEffectivePredictiveOptimizationFlag.SyncFieldsDuringRead(ctx, fromEffectivePredictiveOptimizationFlag)
				to.SetEffectivePredictiveOptimizationFlag(ctx, toEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				toEncryptionDetails.SyncFieldsDuringRead(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.RowFilter.IsNull() && !from.RowFilter.IsUnknown() {
		if toRowFilter, ok := to.GetRowFilter(ctx); ok {
			if fromRowFilter, ok := from.GetRowFilter(ctx); ok {
				toRowFilter.SyncFieldsDuringRead(ctx, fromRowFilter)
				to.SetRowFilter(ctx, toRowFilter)
			}
		}
	}
	if !from.SecurableKindManifest.IsNull() && !from.SecurableKindManifest.IsUnknown() {
		if toSecurableKindManifest, ok := to.GetSecurableKindManifest(ctx); ok {
			if fromSecurableKindManifest, ok := from.GetSecurableKindManifest(ctx); ok {
				toSecurableKindManifest.SyncFieldsDuringRead(ctx, fromSecurableKindManifest)
				to.SetSecurableKindManifest(ctx, toSecurableKindManifest)
			}
		}
	}
	if !from.TableConstraints.IsNull() && !from.TableConstraints.IsUnknown() && to.TableConstraints.IsNull() && len(from.TableConstraints.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TableConstraints, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TableConstraints = from.TableConstraints
	}
	if !from.ViewDependencies.IsNull() && !from.ViewDependencies.IsUnknown() {
		if toViewDependencies, ok := to.GetViewDependencies(ctx); ok {
			if fromViewDependencies, ok := from.GetViewDependencies(ctx); ok {
				toViewDependencies.SyncFieldsDuringRead(ctx, fromViewDependencies)
				to.SetViewDependencies(ctx, toViewDependencies)
			}
		}
	}
}

func (m TableInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_point"] = attrs["access_point"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["data_access_configuration_id"] = attrs["data_access_configuration_id"].SetOptional()
	attrs["data_source_format"] = attrs["data_source_format"].SetOptional()
	attrs["deleted_at"] = attrs["deleted_at"].SetOptional()
	attrs["delta_runtime_properties_kvpairs"] = attrs["delta_runtime_properties_kvpairs"].SetOptional()
	attrs["delta_runtime_properties_kvpairs"] = attrs["delta_runtime_properties_kvpairs"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["pipeline_id"] = attrs["pipeline_id"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["row_filter"] = attrs["row_filter"].SetOptional()
	attrs["row_filter"] = attrs["row_filter"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["securable_kind_manifest"] = attrs["securable_kind_manifest"].SetOptional()
	attrs["securable_kind_manifest"] = attrs["securable_kind_manifest"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["sql_path"] = attrs["sql_path"].SetOptional()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["table_constraints"] = attrs["table_constraints"].SetOptional()
	attrs["table_id"] = attrs["table_id"].SetOptional()
	attrs["table_type"] = attrs["table_type"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["view_definition"] = attrs["view_definition"].SetOptional()
	attrs["view_dependencies"] = attrs["view_dependencies"].SetOptional()
	attrs["view_dependencies"] = attrs["view_dependencies"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":                                reflect.TypeOf(ColumnInfo_SdkV2{}),
		"delta_runtime_properties_kvpairs":       reflect.TypeOf(DeltaRuntimePropertiesKvPairs_SdkV2{}),
		"effective_predictive_optimization_flag": reflect.TypeOf(EffectivePredictiveOptimizationFlag_SdkV2{}),
		"encryption_details":                     reflect.TypeOf(EncryptionDetails_SdkV2{}),
		"properties":                             reflect.TypeOf(types.String{}),
		"row_filter":                             reflect.TypeOf(TableRowFilter_SdkV2{}),
		"securable_kind_manifest":                reflect.TypeOf(SecurableKindManifest_SdkV2{}),
		"table_constraints":                      reflect.TypeOf(TableConstraint_SdkV2{}),
		"view_dependencies":                      reflect.TypeOf(DependencyList_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m TableInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_point":                           m.AccessPoint,
			"browse_only":                            m.BrowseOnly,
			"catalog_name":                           m.CatalogName,
			"columns":                                m.Columns,
			"comment":                                m.Comment,
			"created_at":                             m.CreatedAt,
			"created_by":                             m.CreatedBy,
			"data_access_configuration_id":           m.DataAccessConfigurationId,
			"data_source_format":                     m.DataSourceFormat,
			"deleted_at":                             m.DeletedAt,
			"delta_runtime_properties_kvpairs":       m.DeltaRuntimePropertiesKvpairs,
			"effective_predictive_optimization_flag": m.EffectivePredictiveOptimizationFlag,
			"enable_predictive_optimization":         m.EnablePredictiveOptimization,
			"encryption_details":                     m.EncryptionDetails,
			"full_name":                              m.FullName,
			"metastore_id":                           m.MetastoreId,
			"name":                                   m.Name,
			"owner":                                  m.Owner,
			"pipeline_id":                            m.PipelineId,
			"properties":                             m.Properties,
			"row_filter":                             m.RowFilter,
			"schema_name":                            m.SchemaName,
			"securable_kind_manifest":                m.SecurableKindManifest,
			"sql_path":                               m.SqlPath,
			"storage_credential_name":                m.StorageCredentialName,
			"storage_location":                       m.StorageLocation,
			"table_constraints":                      m.TableConstraints,
			"table_id":                               m.TableId,
			"table_type":                             m.TableType,
			"updated_at":                             m.UpdatedAt,
			"updated_by":                             m.UpdatedBy,
			"view_definition":                        m.ViewDefinition,
			"view_dependencies":                      m.ViewDependencies,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_point": types.StringType,
			"browse_only":  types.BoolType,
			"catalog_name": types.StringType,
			"columns": basetypes.ListType{
				ElemType: ColumnInfo_SdkV2{}.Type(ctx),
			},
			"comment":                      types.StringType,
			"created_at":                   types.Int64Type,
			"created_by":                   types.StringType,
			"data_access_configuration_id": types.StringType,
			"data_source_format":           types.StringType,
			"deleted_at":                   types.Int64Type,
			"delta_runtime_properties_kvpairs": basetypes.ListType{
				ElemType: DeltaRuntimePropertiesKvPairs_SdkV2{}.Type(ctx),
			},
			"effective_predictive_optimization_flag": basetypes.ListType{
				ElemType: EffectivePredictiveOptimizationFlag_SdkV2{}.Type(ctx),
			},
			"enable_predictive_optimization": types.StringType,
			"encryption_details": basetypes.ListType{
				ElemType: EncryptionDetails_SdkV2{}.Type(ctx),
			},
			"full_name":    types.StringType,
			"metastore_id": types.StringType,
			"name":         types.StringType,
			"owner":        types.StringType,
			"pipeline_id":  types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"row_filter": basetypes.ListType{
				ElemType: TableRowFilter_SdkV2{}.Type(ctx),
			},
			"schema_name": types.StringType,
			"securable_kind_manifest": basetypes.ListType{
				ElemType: SecurableKindManifest_SdkV2{}.Type(ctx),
			},
			"sql_path":                types.StringType,
			"storage_credential_name": types.StringType,
			"storage_location":        types.StringType,
			"table_constraints": basetypes.ListType{
				ElemType: TableConstraint_SdkV2{}.Type(ctx),
			},
			"table_id":        types.StringType,
			"table_type":      types.StringType,
			"updated_at":      types.Int64Type,
			"updated_by":      types.StringType,
			"view_definition": types.StringType,
			"view_dependencies": basetypes.ListType{
				ElemType: DependencyList_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetColumns returns the value of the Columns field in TableInfo_SdkV2 as
// a slice of ColumnInfo_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetColumns(ctx context.Context) ([]ColumnInfo_SdkV2, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnInfo_SdkV2
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetColumns(ctx context.Context, v []ColumnInfo_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetDeltaRuntimePropertiesKvpairs returns the value of the DeltaRuntimePropertiesKvpairs field in TableInfo_SdkV2 as
// a DeltaRuntimePropertiesKvPairs_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetDeltaRuntimePropertiesKvpairs(ctx context.Context) (DeltaRuntimePropertiesKvPairs_SdkV2, bool) {
	var e DeltaRuntimePropertiesKvPairs_SdkV2
	if m.DeltaRuntimePropertiesKvpairs.IsNull() || m.DeltaRuntimePropertiesKvpairs.IsUnknown() {
		return e, false
	}
	var v []DeltaRuntimePropertiesKvPairs_SdkV2
	d := m.DeltaRuntimePropertiesKvpairs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDeltaRuntimePropertiesKvpairs sets the value of the DeltaRuntimePropertiesKvpairs field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetDeltaRuntimePropertiesKvpairs(ctx context.Context, v DeltaRuntimePropertiesKvPairs_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["delta_runtime_properties_kvpairs"]
	m.DeltaRuntimePropertiesKvpairs = types.ListValueMust(t, vs)
}

// GetEffectivePredictiveOptimizationFlag returns the value of the EffectivePredictiveOptimizationFlag field in TableInfo_SdkV2 as
// a EffectivePredictiveOptimizationFlag_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetEffectivePredictiveOptimizationFlag(ctx context.Context) (EffectivePredictiveOptimizationFlag_SdkV2, bool) {
	var e EffectivePredictiveOptimizationFlag_SdkV2
	if m.EffectivePredictiveOptimizationFlag.IsNull() || m.EffectivePredictiveOptimizationFlag.IsUnknown() {
		return e, false
	}
	var v []EffectivePredictiveOptimizationFlag_SdkV2
	d := m.EffectivePredictiveOptimizationFlag.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEffectivePredictiveOptimizationFlag sets the value of the EffectivePredictiveOptimizationFlag field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetEffectivePredictiveOptimizationFlag(ctx context.Context, v EffectivePredictiveOptimizationFlag_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["effective_predictive_optimization_flag"]
	m.EffectivePredictiveOptimizationFlag = types.ListValueMust(t, vs)
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in TableInfo_SdkV2 as
// a EncryptionDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetEncryptionDetails(ctx context.Context) (EncryptionDetails_SdkV2, bool) {
	var e EncryptionDetails_SdkV2
	if m.EncryptionDetails.IsNull() || m.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v []EncryptionDetails_SdkV2
	d := m.EncryptionDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetEncryptionDetails(ctx context.Context, v EncryptionDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["encryption_details"]
	m.EncryptionDetails = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in TableInfo_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetRowFilter returns the value of the RowFilter field in TableInfo_SdkV2 as
// a TableRowFilter_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetRowFilter(ctx context.Context) (TableRowFilter_SdkV2, bool) {
	var e TableRowFilter_SdkV2
	if m.RowFilter.IsNull() || m.RowFilter.IsUnknown() {
		return e, false
	}
	var v []TableRowFilter_SdkV2
	d := m.RowFilter.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRowFilter sets the value of the RowFilter field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetRowFilter(ctx context.Context, v TableRowFilter_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["row_filter"]
	m.RowFilter = types.ListValueMust(t, vs)
}

// GetSecurableKindManifest returns the value of the SecurableKindManifest field in TableInfo_SdkV2 as
// a SecurableKindManifest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetSecurableKindManifest(ctx context.Context) (SecurableKindManifest_SdkV2, bool) {
	var e SecurableKindManifest_SdkV2
	if m.SecurableKindManifest.IsNull() || m.SecurableKindManifest.IsUnknown() {
		return e, false
	}
	var v []SecurableKindManifest_SdkV2
	d := m.SecurableKindManifest.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSecurableKindManifest sets the value of the SecurableKindManifest field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetSecurableKindManifest(ctx context.Context, v SecurableKindManifest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["securable_kind_manifest"]
	m.SecurableKindManifest = types.ListValueMust(t, vs)
}

// GetTableConstraints returns the value of the TableConstraints field in TableInfo_SdkV2 as
// a slice of TableConstraint_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetTableConstraints(ctx context.Context) ([]TableConstraint_SdkV2, bool) {
	if m.TableConstraints.IsNull() || m.TableConstraints.IsUnknown() {
		return nil, false
	}
	var v []TableConstraint_SdkV2
	d := m.TableConstraints.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTableConstraints sets the value of the TableConstraints field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetTableConstraints(ctx context.Context, v []TableConstraint_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table_constraints"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TableConstraints = types.ListValueMust(t, vs)
}

// GetViewDependencies returns the value of the ViewDependencies field in TableInfo_SdkV2 as
// a DependencyList_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableInfo_SdkV2) GetViewDependencies(ctx context.Context) (DependencyList_SdkV2, bool) {
	var e DependencyList_SdkV2
	if m.ViewDependencies.IsNull() || m.ViewDependencies.IsUnknown() {
		return e, false
	}
	var v []DependencyList_SdkV2
	d := m.ViewDependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetViewDependencies sets the value of the ViewDependencies field in TableInfo_SdkV2.
func (m *TableInfo_SdkV2) SetViewDependencies(ctx context.Context, v DependencyList_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["view_dependencies"]
	m.ViewDependencies = types.ListValueMust(t, vs)
}

type TableRowFilter_SdkV2 struct {
	// The full name of the row filter SQL UDF.
	FunctionName types.String `tfsdk:"function_name"`
	// The list of table columns to be passed as input to the row filter
	// function. The column types should match the types of the filter function
	// arguments.
	InputColumnNames types.List `tfsdk:"input_column_names"`
}

func (to *TableRowFilter_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableRowFilter_SdkV2) {
}

func (to *TableRowFilter_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableRowFilter_SdkV2) {
}

func (m TableRowFilter_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetRequired()
	attrs["input_column_names"] = attrs["input_column_names"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableRowFilter.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableRowFilter_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableRowFilter_SdkV2
// only implements ToObjectValue() and Type().
func (m TableRowFilter_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name":      m.FunctionName,
			"input_column_names": m.InputColumnNames,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableRowFilter_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"input_column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetInputColumnNames returns the value of the InputColumnNames field in TableRowFilter_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableRowFilter_SdkV2) GetInputColumnNames(ctx context.Context) ([]types.String, bool) {
	if m.InputColumnNames.IsNull() || m.InputColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.InputColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInputColumnNames sets the value of the InputColumnNames field in TableRowFilter_SdkV2.
func (m *TableRowFilter_SdkV2) SetInputColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["input_column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.InputColumnNames = types.ListValueMust(t, vs)
}

type TableSummary_SdkV2 struct {
	// The full name of the table.
	FullName types.String `tfsdk:"full_name"`
	// SecurableKindManifest of table, including capabilities the table has.
	SecurableKindManifest types.List `tfsdk:"securable_kind_manifest"`

	TableType types.String `tfsdk:"table_type"`
}

func (to *TableSummary_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableSummary_SdkV2) {
	if !from.SecurableKindManifest.IsNull() && !from.SecurableKindManifest.IsUnknown() {
		if toSecurableKindManifest, ok := to.GetSecurableKindManifest(ctx); ok {
			if fromSecurableKindManifest, ok := from.GetSecurableKindManifest(ctx); ok {
				// Recursively sync the fields of SecurableKindManifest
				toSecurableKindManifest.SyncFieldsDuringCreateOrUpdate(ctx, fromSecurableKindManifest)
				to.SetSecurableKindManifest(ctx, toSecurableKindManifest)
			}
		}
	}
}

func (to *TableSummary_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableSummary_SdkV2) {
	if !from.SecurableKindManifest.IsNull() && !from.SecurableKindManifest.IsUnknown() {
		if toSecurableKindManifest, ok := to.GetSecurableKindManifest(ctx); ok {
			if fromSecurableKindManifest, ok := from.GetSecurableKindManifest(ctx); ok {
				toSecurableKindManifest.SyncFieldsDuringRead(ctx, fromSecurableKindManifest)
				to.SetSecurableKindManifest(ctx, toSecurableKindManifest)
			}
		}
	}
}

func (m TableSummary_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["securable_kind_manifest"] = attrs["securable_kind_manifest"].SetOptional()
	attrs["securable_kind_manifest"] = attrs["securable_kind_manifest"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table_type"] = attrs["table_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableSummary.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableSummary_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"securable_kind_manifest": reflect.TypeOf(SecurableKindManifest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableSummary_SdkV2
// only implements ToObjectValue() and Type().
func (m TableSummary_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":               m.FullName,
			"securable_kind_manifest": m.SecurableKindManifest,
			"table_type":              m.TableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableSummary_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
			"securable_kind_manifest": basetypes.ListType{
				ElemType: SecurableKindManifest_SdkV2{}.Type(ctx),
			},
			"table_type": types.StringType,
		},
	}
}

// GetSecurableKindManifest returns the value of the SecurableKindManifest field in TableSummary_SdkV2 as
// a SecurableKindManifest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TableSummary_SdkV2) GetSecurableKindManifest(ctx context.Context) (SecurableKindManifest_SdkV2, bool) {
	var e SecurableKindManifest_SdkV2
	if m.SecurableKindManifest.IsNull() || m.SecurableKindManifest.IsUnknown() {
		return e, false
	}
	var v []SecurableKindManifest_SdkV2
	d := m.SecurableKindManifest.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSecurableKindManifest sets the value of the SecurableKindManifest field in TableSummary_SdkV2.
func (m *TableSummary_SdkV2) SetSecurableKindManifest(ctx context.Context, v SecurableKindManifest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["securable_kind_manifest"]
	m.SecurableKindManifest = types.ListValueMust(t, vs)
}

type TagKeyValue_SdkV2 struct {
	// name of the tag
	Key types.String `tfsdk:"key"`
	// value of the tag associated with the key, could be optional
	Value types.String `tfsdk:"value"`
}

func (to *TagKeyValue_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TagKeyValue_SdkV2) {
}

func (to *TagKeyValue_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TagKeyValue_SdkV2) {
}

func (m TagKeyValue_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["key"] = attrs["key"].SetOptional()
	attrs["value"] = attrs["value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TagKeyValue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TagKeyValue_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TagKeyValue_SdkV2
// only implements ToObjectValue() and Type().
func (m TagKeyValue_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"key":   m.Key,
			"value": m.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TagKeyValue_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"key":   types.StringType,
			"value": types.StringType,
		},
	}
}

type TemporaryCredentials_SdkV2 struct {
	AwsTempCredentials types.List `tfsdk:"aws_temp_credentials"`

	AzureAad types.List `tfsdk:"azure_aad"`
	// Server time when the credential will expire, in epoch milliseconds. The
	// API client is advised to cache the credential given this expiration time.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	GcpOauthToken types.List `tfsdk:"gcp_oauth_token"`
}

func (to *TemporaryCredentials_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TemporaryCredentials_SdkV2) {
	if !from.AwsTempCredentials.IsNull() && !from.AwsTempCredentials.IsUnknown() {
		if toAwsTempCredentials, ok := to.GetAwsTempCredentials(ctx); ok {
			if fromAwsTempCredentials, ok := from.GetAwsTempCredentials(ctx); ok {
				// Recursively sync the fields of AwsTempCredentials
				toAwsTempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsTempCredentials)
				to.SetAwsTempCredentials(ctx, toAwsTempCredentials)
			}
		}
	}
	if !from.AzureAad.IsNull() && !from.AzureAad.IsUnknown() {
		if toAzureAad, ok := to.GetAzureAad(ctx); ok {
			if fromAzureAad, ok := from.GetAzureAad(ctx); ok {
				// Recursively sync the fields of AzureAad
				toAzureAad.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureAad)
				to.SetAzureAad(ctx, toAzureAad)
			}
		}
	}
	if !from.GcpOauthToken.IsNull() && !from.GcpOauthToken.IsUnknown() {
		if toGcpOauthToken, ok := to.GetGcpOauthToken(ctx); ok {
			if fromGcpOauthToken, ok := from.GetGcpOauthToken(ctx); ok {
				// Recursively sync the fields of GcpOauthToken
				toGcpOauthToken.SyncFieldsDuringCreateOrUpdate(ctx, fromGcpOauthToken)
				to.SetGcpOauthToken(ctx, toGcpOauthToken)
			}
		}
	}
}

func (to *TemporaryCredentials_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TemporaryCredentials_SdkV2) {
	if !from.AwsTempCredentials.IsNull() && !from.AwsTempCredentials.IsUnknown() {
		if toAwsTempCredentials, ok := to.GetAwsTempCredentials(ctx); ok {
			if fromAwsTempCredentials, ok := from.GetAwsTempCredentials(ctx); ok {
				toAwsTempCredentials.SyncFieldsDuringRead(ctx, fromAwsTempCredentials)
				to.SetAwsTempCredentials(ctx, toAwsTempCredentials)
			}
		}
	}
	if !from.AzureAad.IsNull() && !from.AzureAad.IsUnknown() {
		if toAzureAad, ok := to.GetAzureAad(ctx); ok {
			if fromAzureAad, ok := from.GetAzureAad(ctx); ok {
				toAzureAad.SyncFieldsDuringRead(ctx, fromAzureAad)
				to.SetAzureAad(ctx, toAzureAad)
			}
		}
	}
	if !from.GcpOauthToken.IsNull() && !from.GcpOauthToken.IsUnknown() {
		if toGcpOauthToken, ok := to.GetGcpOauthToken(ctx); ok {
			if fromGcpOauthToken, ok := from.GetGcpOauthToken(ctx); ok {
				toGcpOauthToken.SyncFieldsDuringRead(ctx, fromGcpOauthToken)
				to.SetGcpOauthToken(ctx, toGcpOauthToken)
			}
		}
	}
}

func (m TemporaryCredentials_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].SetOptional()
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_aad"] = attrs["azure_aad"].SetOptional()
	attrs["azure_aad"] = attrs["azure_aad"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TemporaryCredentials.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TemporaryCredentials_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_temp_credentials": reflect.TypeOf(AwsCredentials_SdkV2{}),
		"azure_aad":            reflect.TypeOf(AzureActiveDirectoryToken_SdkV2{}),
		"gcp_oauth_token":      reflect.TypeOf(GcpOauthToken_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TemporaryCredentials_SdkV2
// only implements ToObjectValue() and Type().
func (m TemporaryCredentials_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_temp_credentials": m.AwsTempCredentials,
			"azure_aad":            m.AzureAad,
			"expiration_time":      m.ExpirationTime,
			"gcp_oauth_token":      m.GcpOauthToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TemporaryCredentials_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_temp_credentials": basetypes.ListType{
				ElemType: AwsCredentials_SdkV2{}.Type(ctx),
			},
			"azure_aad": basetypes.ListType{
				ElemType: AzureActiveDirectoryToken_SdkV2{}.Type(ctx),
			},
			"expiration_time": types.Int64Type,
			"gcp_oauth_token": basetypes.ListType{
				ElemType: GcpOauthToken_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetAwsTempCredentials returns the value of the AwsTempCredentials field in TemporaryCredentials_SdkV2 as
// a AwsCredentials_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TemporaryCredentials_SdkV2) GetAwsTempCredentials(ctx context.Context) (AwsCredentials_SdkV2, bool) {
	var e AwsCredentials_SdkV2
	if m.AwsTempCredentials.IsNull() || m.AwsTempCredentials.IsUnknown() {
		return e, false
	}
	var v []AwsCredentials_SdkV2
	d := m.AwsTempCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsTempCredentials sets the value of the AwsTempCredentials field in TemporaryCredentials_SdkV2.
func (m *TemporaryCredentials_SdkV2) SetAwsTempCredentials(ctx context.Context, v AwsCredentials_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_temp_credentials"]
	m.AwsTempCredentials = types.ListValueMust(t, vs)
}

// GetAzureAad returns the value of the AzureAad field in TemporaryCredentials_SdkV2 as
// a AzureActiveDirectoryToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TemporaryCredentials_SdkV2) GetAzureAad(ctx context.Context) (AzureActiveDirectoryToken_SdkV2, bool) {
	var e AzureActiveDirectoryToken_SdkV2
	if m.AzureAad.IsNull() || m.AzureAad.IsUnknown() {
		return e, false
	}
	var v []AzureActiveDirectoryToken_SdkV2
	d := m.AzureAad.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureAad sets the value of the AzureAad field in TemporaryCredentials_SdkV2.
func (m *TemporaryCredentials_SdkV2) SetAzureAad(ctx context.Context, v AzureActiveDirectoryToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_aad"]
	m.AzureAad = types.ListValueMust(t, vs)
}

// GetGcpOauthToken returns the value of the GcpOauthToken field in TemporaryCredentials_SdkV2 as
// a GcpOauthToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TemporaryCredentials_SdkV2) GetGcpOauthToken(ctx context.Context) (GcpOauthToken_SdkV2, bool) {
	var e GcpOauthToken_SdkV2
	if m.GcpOauthToken.IsNull() || m.GcpOauthToken.IsUnknown() {
		return e, false
	}
	var v []GcpOauthToken_SdkV2
	d := m.GcpOauthToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGcpOauthToken sets the value of the GcpOauthToken field in TemporaryCredentials_SdkV2.
func (m *TemporaryCredentials_SdkV2) SetGcpOauthToken(ctx context.Context, v GcpOauthToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gcp_oauth_token"]
	m.GcpOauthToken = types.ListValueMust(t, vs)
}

// Detailed status of an online table. Shown if the online table is in the
// ONLINE_TRIGGERED_UPDATE or the ONLINE_NO_PENDING_UPDATE state.
type TriggeredUpdateStatus_SdkV2 struct {
	// The last source table Delta version that was synced to the online table.
	// Note that this Delta version may not be completely synced to the online
	// table yet.
	LastProcessedCommitVersion types.Int64 `tfsdk:"last_processed_commit_version"`
	// The timestamp of the last time any data was synchronized from the source
	// table to the online table.
	Timestamp types.String `tfsdk:"timestamp"`
	// Progress of the active data synchronization pipeline.
	TriggeredUpdateProgress types.List `tfsdk:"triggered_update_progress"`
}

func (to *TriggeredUpdateStatus_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggeredUpdateStatus_SdkV2) {
	if !from.TriggeredUpdateProgress.IsNull() && !from.TriggeredUpdateProgress.IsUnknown() {
		if toTriggeredUpdateProgress, ok := to.GetTriggeredUpdateProgress(ctx); ok {
			if fromTriggeredUpdateProgress, ok := from.GetTriggeredUpdateProgress(ctx); ok {
				// Recursively sync the fields of TriggeredUpdateProgress
				toTriggeredUpdateProgress.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggeredUpdateProgress)
				to.SetTriggeredUpdateProgress(ctx, toTriggeredUpdateProgress)
			}
		}
	}
}

func (to *TriggeredUpdateStatus_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TriggeredUpdateStatus_SdkV2) {
	if !from.TriggeredUpdateProgress.IsNull() && !from.TriggeredUpdateProgress.IsUnknown() {
		if toTriggeredUpdateProgress, ok := to.GetTriggeredUpdateProgress(ctx); ok {
			if fromTriggeredUpdateProgress, ok := from.GetTriggeredUpdateProgress(ctx); ok {
				toTriggeredUpdateProgress.SyncFieldsDuringRead(ctx, fromTriggeredUpdateProgress)
				to.SetTriggeredUpdateProgress(ctx, toTriggeredUpdateProgress)
			}
		}
	}
}

func (m TriggeredUpdateStatus_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_processed_commit_version"] = attrs["last_processed_commit_version"].SetOptional()
	attrs["timestamp"] = attrs["timestamp"].SetOptional()
	attrs["triggered_update_progress"] = attrs["triggered_update_progress"].SetOptional()
	attrs["triggered_update_progress"] = attrs["triggered_update_progress"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggeredUpdateStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggeredUpdateStatus_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"triggered_update_progress": reflect.TypeOf(PipelineProgress_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggeredUpdateStatus_SdkV2
// only implements ToObjectValue() and Type().
func (m TriggeredUpdateStatus_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_processed_commit_version": m.LastProcessedCommitVersion,
			"timestamp":                     m.Timestamp,
			"triggered_update_progress":     m.TriggeredUpdateProgress,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggeredUpdateStatus_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_processed_commit_version": types.Int64Type,
			"timestamp":                     types.StringType,
			"triggered_update_progress": basetypes.ListType{
				ElemType: PipelineProgress_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTriggeredUpdateProgress returns the value of the TriggeredUpdateProgress field in TriggeredUpdateStatus_SdkV2 as
// a PipelineProgress_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggeredUpdateStatus_SdkV2) GetTriggeredUpdateProgress(ctx context.Context) (PipelineProgress_SdkV2, bool) {
	var e PipelineProgress_SdkV2
	if m.TriggeredUpdateProgress.IsNull() || m.TriggeredUpdateProgress.IsUnknown() {
		return e, false
	}
	var v []PipelineProgress_SdkV2
	d := m.TriggeredUpdateProgress.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTriggeredUpdateProgress sets the value of the TriggeredUpdateProgress field in TriggeredUpdateStatus_SdkV2.
func (m *TriggeredUpdateStatus_SdkV2) SetTriggeredUpdateProgress(ctx context.Context, v PipelineProgress_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["triggered_update_progress"]
	m.TriggeredUpdateProgress = types.ListValueMust(t, vs)
}

type UnassignRequest_SdkV2 struct {
	// Query for the ID of the metastore to delete.
	MetastoreId types.String `tfsdk:"-"`
	// A workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *UnassignRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UnassignRequest_SdkV2) {
}

func (to *UnassignRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UnassignRequest_SdkV2) {
}

func (m UnassignRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UnassignRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UnassignRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UnassignRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UnassignRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": m.MetastoreId,
			"workspace_id": m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UnassignRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}

type UnassignResponse_SdkV2 struct {
}

func (to *UnassignResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UnassignResponse_SdkV2) {
}

func (to *UnassignResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UnassignResponse_SdkV2) {
}

func (m UnassignResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UnassignResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UnassignResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UnassignResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m UnassignResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m UnassignResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateAccessRequestDestinationsRequest_SdkV2 struct {
	// The access request destinations to assign to the securable. For each
	// destination, a **destination_id** and **destination_type** must be
	// defined.
	AccessRequestDestinations types.List `tfsdk:"access_request_destinations"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (to *UpdateAccessRequestDestinationsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAccessRequestDestinationsRequest_SdkV2) {
	if !from.AccessRequestDestinations.IsNull() && !from.AccessRequestDestinations.IsUnknown() {
		if toAccessRequestDestinations, ok := to.GetAccessRequestDestinations(ctx); ok {
			if fromAccessRequestDestinations, ok := from.GetAccessRequestDestinations(ctx); ok {
				// Recursively sync the fields of AccessRequestDestinations
				toAccessRequestDestinations.SyncFieldsDuringCreateOrUpdate(ctx, fromAccessRequestDestinations)
				to.SetAccessRequestDestinations(ctx, toAccessRequestDestinations)
			}
		}
	}
}

func (to *UpdateAccessRequestDestinationsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateAccessRequestDestinationsRequest_SdkV2) {
	if !from.AccessRequestDestinations.IsNull() && !from.AccessRequestDestinations.IsUnknown() {
		if toAccessRequestDestinations, ok := to.GetAccessRequestDestinations(ctx); ok {
			if fromAccessRequestDestinations, ok := from.GetAccessRequestDestinations(ctx); ok {
				toAccessRequestDestinations.SyncFieldsDuringRead(ctx, fromAccessRequestDestinations)
				to.SetAccessRequestDestinations(ctx, toAccessRequestDestinations)
			}
		}
	}
}

func (m UpdateAccessRequestDestinationsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_request_destinations"] = attrs["access_request_destinations"].SetRequired()
	attrs["access_request_destinations"] = attrs["access_request_destinations"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccessRequestDestinationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateAccessRequestDestinationsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_request_destinations": reflect.TypeOf(AccessRequestDestinations_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccessRequestDestinationsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateAccessRequestDestinationsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_request_destinations": m.AccessRequestDestinations,
			"update_mask":                 m.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateAccessRequestDestinationsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_request_destinations": basetypes.ListType{
				ElemType: AccessRequestDestinations_SdkV2{}.Type(ctx),
			},
			"update_mask": types.StringType,
		},
	}
}

// GetAccessRequestDestinations returns the value of the AccessRequestDestinations field in UpdateAccessRequestDestinationsRequest_SdkV2 as
// a AccessRequestDestinations_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateAccessRequestDestinationsRequest_SdkV2) GetAccessRequestDestinations(ctx context.Context) (AccessRequestDestinations_SdkV2, bool) {
	var e AccessRequestDestinations_SdkV2
	if m.AccessRequestDestinations.IsNull() || m.AccessRequestDestinations.IsUnknown() {
		return e, false
	}
	var v []AccessRequestDestinations_SdkV2
	d := m.AccessRequestDestinations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAccessRequestDestinations sets the value of the AccessRequestDestinations field in UpdateAccessRequestDestinationsRequest_SdkV2.
func (m *UpdateAccessRequestDestinationsRequest_SdkV2) SetAccessRequestDestinations(ctx context.Context, v AccessRequestDestinations_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_request_destinations"]
	m.AccessRequestDestinations = types.ListValueMust(t, vs)
}

type UpdateAccountsMetastore_SdkV2 struct {
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
}

func (to *UpdateAccountsMetastore_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAccountsMetastore_SdkV2) {
}

func (to *UpdateAccountsMetastore_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateAccountsMetastore_SdkV2) {
}

func (m UpdateAccountsMetastore_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccountsMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateAccountsMetastore_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccountsMetastore_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateAccountsMetastore_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"delta_sharing_organization_name":                   m.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": m.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               m.DeltaSharingScope,
			"owner":                                             m.Owner,
			"privilege_model_version":                           m.PrivilegeModelVersion,
			"storage_root_credential_id":                        m.StorageRootCredentialId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateAccountsMetastore_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"delta_sharing_organization_name":                   types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"storage_root_credential_id":                        types.StringType,
		},
	}
}

type UpdateAccountsStorageCredential_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.List `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
}

func (to *UpdateAccountsStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAccountsStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				// Recursively sync the fields of CloudflareApiToken
				toCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *UpdateAccountsStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateAccountsStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				toCloudflareApiToken.SyncFieldsDuringRead(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m UpdateAccountsStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccountsStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateAccountsStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityResponse_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccountsStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateAccountsStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"cloudflare_api_token":           m.CloudflareApiToken,
			"comment":                        m.Comment,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"isolation_mode":                 m.IsolationMode,
			"owner":                          m.Owner,
			"read_only":                      m.ReadOnly,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateAccountsStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRoleRequest_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentityResponse_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"cloudflare_api_token": basetypes.ListType{
				ElemType: CloudflareApiToken_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccountRequest_SdkV2{}.Type(ctx),
			},
			"isolation_mode": types.StringType,
			"owner":          types.StringType,
			"read_only":      types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in UpdateAccountsStorageCredential_SdkV2 as
// a AwsIamRoleRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateAccountsStorageCredential_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest_SdkV2, bool) {
	var e AwsIamRoleRequest_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRoleRequest_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in UpdateAccountsStorageCredential_SdkV2.
func (m *UpdateAccountsStorageCredential_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in UpdateAccountsStorageCredential_SdkV2 as
// a AzureManagedIdentityResponse_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateAccountsStorageCredential_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityResponse_SdkV2, bool) {
	var e AzureManagedIdentityResponse_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentityResponse_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in UpdateAccountsStorageCredential_SdkV2.
func (m *UpdateAccountsStorageCredential_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityResponse_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in UpdateAccountsStorageCredential_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateAccountsStorageCredential_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in UpdateAccountsStorageCredential_SdkV2.
func (m *UpdateAccountsStorageCredential_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in UpdateAccountsStorageCredential_SdkV2 as
// a CloudflareApiToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateAccountsStorageCredential_SdkV2) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken_SdkV2, bool) {
	var e CloudflareApiToken_SdkV2
	if m.CloudflareApiToken.IsNull() || m.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v []CloudflareApiToken_SdkV2
	d := m.CloudflareApiToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in UpdateAccountsStorageCredential_SdkV2.
func (m *UpdateAccountsStorageCredential_SdkV2) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cloudflare_api_token"]
	m.CloudflareApiToken = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in UpdateAccountsStorageCredential_SdkV2 as
// a DatabricksGcpServiceAccountRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateAccountsStorageCredential_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest_SdkV2, bool) {
	var e DatabricksGcpServiceAccountRequest_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccountRequest_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in UpdateAccountsStorageCredential_SdkV2.
func (m *UpdateAccountsStorageCredential_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type UpdateAssignmentResponse_SdkV2 struct {
}

func (to *UpdateAssignmentResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAssignmentResponse_SdkV2) {
}

func (to *UpdateAssignmentResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateAssignmentResponse_SdkV2) {
}

func (m UpdateAssignmentResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAssignmentResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateAssignmentResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAssignmentResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateAssignmentResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateAssignmentResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateCatalog_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
	// New name for the catalog.
	NewName types.String `tfsdk:"new_name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of catalog.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
}

func (to *UpdateCatalog_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateCatalog_SdkV2) {
}

func (to *UpdateCatalog_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateCatalog_SdkV2) {
}

func (m UpdateCatalog_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCatalog.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateCatalog_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCatalog_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateCatalog_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":                        m.Comment,
			"enable_predictive_optimization": m.EnablePredictiveOptimization,
			"isolation_mode":                 m.IsolationMode,
			"name":                           m.Name,
			"new_name":                       m.NewName,
			"options":                        m.Options,
			"owner":                          m.Owner,
			"properties":                     m.Properties,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateCatalog_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":                        types.StringType,
			"enable_predictive_optimization": types.StringType,
			"isolation_mode":                 types.StringType,
			"name":                           types.StringType,
			"new_name":                       types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOptions returns the value of the Options field in UpdateCatalog_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCatalog_SdkV2) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in UpdateCatalog_SdkV2.
func (m *UpdateCatalog_SdkV2) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in UpdateCatalog_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCatalog_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in UpdateCatalog_SdkV2.
func (m *UpdateCatalog_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

type UpdateCatalogWorkspaceBindingsResponse_SdkV2 struct {
	// A list of workspace IDs
	Workspaces types.List `tfsdk:"workspaces"`
}

func (to *UpdateCatalogWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateCatalogWorkspaceBindingsResponse_SdkV2) {
	if !from.Workspaces.IsNull() && !from.Workspaces.IsUnknown() && to.Workspaces.IsNull() && len(from.Workspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Workspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Workspaces = from.Workspaces
	}
}

func (to *UpdateCatalogWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateCatalogWorkspaceBindingsResponse_SdkV2) {
	if !from.Workspaces.IsNull() && !from.Workspaces.IsUnknown() && to.Workspaces.IsNull() && len(from.Workspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Workspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Workspaces = from.Workspaces
	}
}

func (m UpdateCatalogWorkspaceBindingsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspaces"] = attrs["workspaces"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCatalogWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateCatalogWorkspaceBindingsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"workspaces": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCatalogWorkspaceBindingsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateCatalogWorkspaceBindingsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspaces": m.Workspaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateCatalogWorkspaceBindingsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetWorkspaces returns the value of the Workspaces field in UpdateCatalogWorkspaceBindingsResponse_SdkV2 as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCatalogWorkspaceBindingsResponse_SdkV2) GetWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if m.Workspaces.IsNull() || m.Workspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.Workspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWorkspaces sets the value of the Workspaces field in UpdateCatalogWorkspaceBindingsResponse_SdkV2.
func (m *UpdateCatalogWorkspaceBindingsResponse_SdkV2) SetWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Workspaces = types.ListValueMust(t, vs)
}

type UpdateConnection_SdkV2 struct {
	// Name of the connection.
	Name types.String `tfsdk:"-"`
	// New name for the connection.
	NewName types.String `tfsdk:"new_name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of the connection.
	Owner types.String `tfsdk:"owner"`
}

func (to *UpdateConnection_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateConnection_SdkV2) {
}

func (to *UpdateConnection_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateConnection_SdkV2) {
}

func (m UpdateConnection_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["options"] = attrs["options"].SetRequired()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateConnection.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateConnection_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateConnection_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateConnection_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":     m.Name,
			"new_name": m.NewName,
			"options":  m.Options,
			"owner":    m.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateConnection_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":     types.StringType,
			"new_name": types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
		},
	}
}

// GetOptions returns the value of the Options field in UpdateConnection_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateConnection_SdkV2) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if m.Options.IsNull() || m.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in UpdateConnection_SdkV2.
func (m *UpdateConnection_SdkV2) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Options = types.MapValueMust(t, vs)
}

type UpdateCredentialRequest_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// Force an update even if there are dependent services (when purpose is
	// **SERVICE**) or dependent external locations and external tables (when
	// purpose is **STORAGE**).
	Force types.Bool `tfsdk:"force"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Name of the credential.
	NameArg types.String `tfsdk:"-"`
	// New name of credential.
	NewName types.String `tfsdk:"new_name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Supply true to this argument to skip validation of the updated
	// credential.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (to *UpdateCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateCredentialRequest_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *UpdateCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateCredentialRequest_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m UpdateCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["force"] = attrs["force"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["name_arg"] = attrs["name_arg"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"comment":                        m.Comment,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"force":                          m.Force,
			"isolation_mode":                 m.IsolationMode,
			"name_arg":                       m.NameArg,
			"new_name":                       m.NewName,
			"owner":                          m.Owner,
			"read_only":                      m.ReadOnly,
			"skip_validation":                m.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRole_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentity_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccount_SdkV2{}.Type(ctx),
			},
			"force":           types.BoolType,
			"isolation_mode":  types.StringType,
			"name_arg":        types.StringType,
			"new_name":        types.StringType,
			"owner":           types.StringType,
			"read_only":       types.BoolType,
			"skip_validation": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in UpdateCredentialRequest_SdkV2 as
// a AwsIamRole_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCredentialRequest_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRole_SdkV2, bool) {
	var e AwsIamRole_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRole_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in UpdateCredentialRequest_SdkV2.
func (m *UpdateCredentialRequest_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRole_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in UpdateCredentialRequest_SdkV2 as
// a AzureManagedIdentity_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCredentialRequest_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity_SdkV2, bool) {
	var e AzureManagedIdentity_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentity_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in UpdateCredentialRequest_SdkV2.
func (m *UpdateCredentialRequest_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in UpdateCredentialRequest_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCredentialRequest_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in UpdateCredentialRequest_SdkV2.
func (m *UpdateCredentialRequest_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in UpdateCredentialRequest_SdkV2 as
// a DatabricksGcpServiceAccount_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCredentialRequest_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount_SdkV2, bool) {
	var e DatabricksGcpServiceAccount_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccount_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in UpdateCredentialRequest_SdkV2.
func (m *UpdateCredentialRequest_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type UpdateEntityTagAssignmentRequest_SdkV2 struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`

	TagAssignment types.List `tfsdk:"tag_assignment"`
	// The key of the tag
	TagKey types.String `tfsdk:"-"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (to *UpdateEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateEntityTagAssignmentRequest_SdkV2) {
	if !from.TagAssignment.IsNull() && !from.TagAssignment.IsUnknown() {
		if toTagAssignment, ok := to.GetTagAssignment(ctx); ok {
			if fromTagAssignment, ok := from.GetTagAssignment(ctx); ok {
				// Recursively sync the fields of TagAssignment
				toTagAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromTagAssignment)
				to.SetTagAssignment(ctx, toTagAssignment)
			}
		}
	}
}

func (to *UpdateEntityTagAssignmentRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateEntityTagAssignmentRequest_SdkV2) {
	if !from.TagAssignment.IsNull() && !from.TagAssignment.IsUnknown() {
		if toTagAssignment, ok := to.GetTagAssignment(ctx); ok {
			if fromTagAssignment, ok := from.GetTagAssignment(ctx); ok {
				toTagAssignment.SyncFieldsDuringRead(ctx, fromTagAssignment)
				to.SetTagAssignment(ctx, toTagAssignment)
			}
		}
	}
}

func (m UpdateEntityTagAssignmentRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["tag_assignment"] = attrs["tag_assignment"].SetRequired()
	attrs["tag_assignment"] = attrs["tag_assignment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_type"] = attrs["entity_type"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["tag_key"] = attrs["tag_key"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateEntityTagAssignmentRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tag_assignment": reflect.TypeOf(EntityTagAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateEntityTagAssignmentRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateEntityTagAssignmentRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name":    m.EntityName,
			"entity_type":    m.EntityType,
			"tag_assignment": m.TagAssignment,
			"tag_key":        m.TagKey,
			"update_mask":    m.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateEntityTagAssignmentRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_assignment": basetypes.ListType{
				ElemType: EntityTagAssignment_SdkV2{}.Type(ctx),
			},
			"tag_key":     types.StringType,
			"update_mask": types.StringType,
		},
	}
}

// GetTagAssignment returns the value of the TagAssignment field in UpdateEntityTagAssignmentRequest_SdkV2 as
// a EntityTagAssignment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateEntityTagAssignmentRequest_SdkV2) GetTagAssignment(ctx context.Context) (EntityTagAssignment_SdkV2, bool) {
	var e EntityTagAssignment_SdkV2
	if m.TagAssignment.IsNull() || m.TagAssignment.IsUnknown() {
		return e, false
	}
	var v []EntityTagAssignment_SdkV2
	d := m.TagAssignment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTagAssignment sets the value of the TagAssignment field in UpdateEntityTagAssignmentRequest_SdkV2.
func (m *UpdateEntityTagAssignmentRequest_SdkV2) SetTagAssignment(ctx context.Context, v EntityTagAssignment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tag_assignment"]
	m.TagAssignment = types.ListValueMust(t, vs)
}

type UpdateExternalLineageRelationshipRequest_SdkV2 struct {
	ExternalLineageRelationship types.List `tfsdk:"external_lineage_relationship"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (to *UpdateExternalLineageRelationshipRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateExternalLineageRelationshipRequest_SdkV2) {
	if !from.ExternalLineageRelationship.IsNull() && !from.ExternalLineageRelationship.IsUnknown() {
		if toExternalLineageRelationship, ok := to.GetExternalLineageRelationship(ctx); ok {
			if fromExternalLineageRelationship, ok := from.GetExternalLineageRelationship(ctx); ok {
				// Recursively sync the fields of ExternalLineageRelationship
				toExternalLineageRelationship.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalLineageRelationship)
				to.SetExternalLineageRelationship(ctx, toExternalLineageRelationship)
			}
		}
	}
}

func (to *UpdateExternalLineageRelationshipRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateExternalLineageRelationshipRequest_SdkV2) {
	if !from.ExternalLineageRelationship.IsNull() && !from.ExternalLineageRelationship.IsUnknown() {
		if toExternalLineageRelationship, ok := to.GetExternalLineageRelationship(ctx); ok {
			if fromExternalLineageRelationship, ok := from.GetExternalLineageRelationship(ctx); ok {
				toExternalLineageRelationship.SyncFieldsDuringRead(ctx, fromExternalLineageRelationship)
				to.SetExternalLineageRelationship(ctx, toExternalLineageRelationship)
			}
		}
	}
}

func (m UpdateExternalLineageRelationshipRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].SetRequired()
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateExternalLineageRelationshipRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateExternalLineageRelationshipRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationship": reflect.TypeOf(UpdateRequestExternalLineage_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateExternalLineageRelationshipRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateExternalLineageRelationshipRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationship": m.ExternalLineageRelationship,
			"update_mask":                   m.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateExternalLineageRelationshipRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationship": basetypes.ListType{
				ElemType: UpdateRequestExternalLineage_SdkV2{}.Type(ctx),
			},
			"update_mask": types.StringType,
		},
	}
}

// GetExternalLineageRelationship returns the value of the ExternalLineageRelationship field in UpdateExternalLineageRelationshipRequest_SdkV2 as
// a UpdateRequestExternalLineage_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateExternalLineageRelationshipRequest_SdkV2) GetExternalLineageRelationship(ctx context.Context) (UpdateRequestExternalLineage_SdkV2, bool) {
	var e UpdateRequestExternalLineage_SdkV2
	if m.ExternalLineageRelationship.IsNull() || m.ExternalLineageRelationship.IsUnknown() {
		return e, false
	}
	var v []UpdateRequestExternalLineage_SdkV2
	d := m.ExternalLineageRelationship.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalLineageRelationship sets the value of the ExternalLineageRelationship field in UpdateExternalLineageRelationshipRequest_SdkV2.
func (m *UpdateExternalLineageRelationshipRequest_SdkV2) SetExternalLineageRelationship(ctx context.Context, v UpdateRequestExternalLineage_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_lineage_relationship"]
	m.ExternalLineageRelationship = types.ListValueMust(t, vs)
}

type UpdateExternalLocation_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of the storage credential used with this location.
	CredentialName types.String `tfsdk:"credential_name"`
	// Whether to enable file events on this external location.
	EnableFileEvents types.Bool `tfsdk:"enable_file_events"`

	EncryptionDetails types.List `tfsdk:"encryption_details"`
	// Indicates whether fallback mode is enabled for this external location.
	// When fallback mode is enabled, the access to the location falls back to
	// cluster credentials if UC credentials are not sufficient.
	Fallback types.Bool `tfsdk:"fallback"`
	// File event queue settings. If `enable_file_events` is `true`, must be
	// defined and have exactly one of the documented properties.
	FileEventQueue types.List `tfsdk:"file_event_queue"`
	// Force update even if changing url invalidates dependent external tables
	// or mounts.
	Force types.Bool `tfsdk:"force"`

	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Name of the external location.
	Name types.String `tfsdk:"-"`
	// New name for the external location.
	NewName types.String `tfsdk:"new_name"`
	// The owner of the external location.
	Owner types.String `tfsdk:"owner"`
	// Indicates whether the external location is read-only.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Skips validation of the storage credential associated with the external
	// location.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
	// Path URL of the external location.
	Url types.String `tfsdk:"url"`
}

func (to *UpdateExternalLocation_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateExternalLocation_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				// Recursively sync the fields of EncryptionDetails
				toEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.FileEventQueue.IsNull() && !from.FileEventQueue.IsUnknown() {
		if toFileEventQueue, ok := to.GetFileEventQueue(ctx); ok {
			if fromFileEventQueue, ok := from.GetFileEventQueue(ctx); ok {
				// Recursively sync the fields of FileEventQueue
				toFileEventQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromFileEventQueue)
				to.SetFileEventQueue(ctx, toFileEventQueue)
			}
		}
	}
}

func (to *UpdateExternalLocation_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateExternalLocation_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				toEncryptionDetails.SyncFieldsDuringRead(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
	if !from.FileEventQueue.IsNull() && !from.FileEventQueue.IsUnknown() {
		if toFileEventQueue, ok := to.GetFileEventQueue(ctx); ok {
			if fromFileEventQueue, ok := from.GetFileEventQueue(ctx); ok {
				toFileEventQueue.SyncFieldsDuringRead(ctx, fromFileEventQueue)
				to.SetFileEventQueue(ctx, toFileEventQueue)
			}
		}
	}
}

func (m UpdateExternalLocation_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetOptional()
	attrs["enable_file_events"] = attrs["enable_file_events"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["fallback"] = attrs["fallback"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["force"] = attrs["force"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateExternalLocation.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateExternalLocation_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails_SdkV2{}),
		"file_event_queue":   reflect.TypeOf(FileEventQueue_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateExternalLocation_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateExternalLocation_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            m.Comment,
			"credential_name":    m.CredentialName,
			"enable_file_events": m.EnableFileEvents,
			"encryption_details": m.EncryptionDetails,
			"fallback":           m.Fallback,
			"file_event_queue":   m.FileEventQueue,
			"force":              m.Force,
			"isolation_mode":     m.IsolationMode,
			"name":               m.Name,
			"new_name":           m.NewName,
			"owner":              m.Owner,
			"read_only":          m.ReadOnly,
			"skip_validation":    m.SkipValidation,
			"url":                m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateExternalLocation_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"credential_name":    types.StringType,
			"enable_file_events": types.BoolType,
			"encryption_details": basetypes.ListType{
				ElemType: EncryptionDetails_SdkV2{}.Type(ctx),
			},
			"fallback": types.BoolType,
			"file_event_queue": basetypes.ListType{
				ElemType: FileEventQueue_SdkV2{}.Type(ctx),
			},
			"force":           types.BoolType,
			"isolation_mode":  types.StringType,
			"name":            types.StringType,
			"new_name":        types.StringType,
			"owner":           types.StringType,
			"read_only":       types.BoolType,
			"skip_validation": types.BoolType,
			"url":             types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in UpdateExternalLocation_SdkV2 as
// a EncryptionDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateExternalLocation_SdkV2) GetEncryptionDetails(ctx context.Context) (EncryptionDetails_SdkV2, bool) {
	var e EncryptionDetails_SdkV2
	if m.EncryptionDetails.IsNull() || m.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v []EncryptionDetails_SdkV2
	d := m.EncryptionDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in UpdateExternalLocation_SdkV2.
func (m *UpdateExternalLocation_SdkV2) SetEncryptionDetails(ctx context.Context, v EncryptionDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["encryption_details"]
	m.EncryptionDetails = types.ListValueMust(t, vs)
}

// GetFileEventQueue returns the value of the FileEventQueue field in UpdateExternalLocation_SdkV2 as
// a FileEventQueue_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateExternalLocation_SdkV2) GetFileEventQueue(ctx context.Context) (FileEventQueue_SdkV2, bool) {
	var e FileEventQueue_SdkV2
	if m.FileEventQueue.IsNull() || m.FileEventQueue.IsUnknown() {
		return e, false
	}
	var v []FileEventQueue_SdkV2
	d := m.FileEventQueue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFileEventQueue sets the value of the FileEventQueue field in UpdateExternalLocation_SdkV2.
func (m *UpdateExternalLocation_SdkV2) SetFileEventQueue(ctx context.Context, v FileEventQueue_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file_event_queue"]
	m.FileEventQueue = types.ListValueMust(t, vs)
}

type UpdateExternalMetadataRequest_SdkV2 struct {
	ExternalMetadata types.List `tfsdk:"external_metadata"`
	// Name of the external metadata object.
	Name types.String `tfsdk:"-"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (to *UpdateExternalMetadataRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateExternalMetadataRequest_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() {
		if toExternalMetadata, ok := to.GetExternalMetadata(ctx); ok {
			if fromExternalMetadata, ok := from.GetExternalMetadata(ctx); ok {
				// Recursively sync the fields of ExternalMetadata
				toExternalMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromExternalMetadata)
				to.SetExternalMetadata(ctx, toExternalMetadata)
			}
		}
	}
}

func (to *UpdateExternalMetadataRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateExternalMetadataRequest_SdkV2) {
	if !from.ExternalMetadata.IsNull() && !from.ExternalMetadata.IsUnknown() {
		if toExternalMetadata, ok := to.GetExternalMetadata(ctx); ok {
			if fromExternalMetadata, ok := from.GetExternalMetadata(ctx); ok {
				toExternalMetadata.SyncFieldsDuringRead(ctx, fromExternalMetadata)
				to.SetExternalMetadata(ctx, toExternalMetadata)
			}
		}
	}
}

func (m UpdateExternalMetadataRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetRequired()
	attrs["external_metadata"] = attrs["external_metadata"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["name"] = attrs["name"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateExternalMetadataRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalMetadata_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateExternalMetadataRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateExternalMetadataRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": m.ExternalMetadata,
			"name":              m.Name,
			"update_mask":       m.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateExternalMetadataRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": basetypes.ListType{
				ElemType: ExternalMetadata_SdkV2{}.Type(ctx),
			},
			"name":        types.StringType,
			"update_mask": types.StringType,
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in UpdateExternalMetadataRequest_SdkV2 as
// a ExternalMetadata_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateExternalMetadataRequest_SdkV2) GetExternalMetadata(ctx context.Context) (ExternalMetadata_SdkV2, bool) {
	var e ExternalMetadata_SdkV2
	if m.ExternalMetadata.IsNull() || m.ExternalMetadata.IsUnknown() {
		return e, false
	}
	var v []ExternalMetadata_SdkV2
	d := m.ExternalMetadata.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in UpdateExternalMetadataRequest_SdkV2.
func (m *UpdateExternalMetadataRequest_SdkV2) SetExternalMetadata(ctx context.Context, v ExternalMetadata_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["external_metadata"]
	m.ExternalMetadata = types.ListValueMust(t, vs)
}

type UpdateFunction_SdkV2 struct {
	// The fully-qualified name of the function (of the form
	// __catalog_name__.__schema_name__.__function__name__).
	Name types.String `tfsdk:"-"`
	// Username of current owner of the function.
	Owner types.String `tfsdk:"owner"`
}

func (to *UpdateFunction_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateFunction_SdkV2) {
}

func (to *UpdateFunction_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateFunction_SdkV2) {
}

func (m UpdateFunction_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateFunction.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateFunction_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateFunction_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateFunction_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":  m.Name,
			"owner": m.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateFunction_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":  types.StringType,
			"owner": types.StringType,
		},
	}
}

type UpdateMetastore_SdkV2 struct {
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// Unique ID of the metastore.
	Id types.String `tfsdk:"-"`
	// New name for the metastore.
	NewName types.String `tfsdk:"new_name"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
}

func (to *UpdateMetastore_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateMetastore_SdkV2) {
}

func (to *UpdateMetastore_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateMetastore_SdkV2) {
}

func (m UpdateMetastore_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateMetastore_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateMetastore_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateMetastore_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"delta_sharing_organization_name":                   m.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": m.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               m.DeltaSharingScope,
			"id":                                                m.Id,
			"new_name":                                          m.NewName,
			"owner":                                             m.Owner,
			"privilege_model_version":                           m.PrivilegeModelVersion,
			"storage_root_credential_id":                        m.StorageRootCredentialId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateMetastore_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"delta_sharing_organization_name":                   types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"id":                                                types.StringType,
			"new_name":                                          types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"storage_root_credential_id":                        types.StringType,
		},
	}
}

type UpdateMetastoreAssignment_SdkV2 struct {
	// The name of the default catalog in the metastore. This field is
	// deprecated. Please use "Default Namespace API" to configure the default
	// catalog for a Databricks workspace.
	DefaultCatalogName types.String `tfsdk:"default_catalog_name"`
	// The unique ID of the metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// A workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *UpdateMetastoreAssignment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateMetastoreAssignment_SdkV2) {
}

func (to *UpdateMetastoreAssignment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateMetastoreAssignment_SdkV2) {
}

func (m UpdateMetastoreAssignment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default_catalog_name"] = attrs["default_catalog_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateMetastoreAssignment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateMetastoreAssignment_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateMetastoreAssignment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default_catalog_name": m.DefaultCatalogName,
			"metastore_id":         m.MetastoreId,
			"workspace_id":         m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateMetastoreAssignment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default_catalog_name": types.StringType,
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

type UpdateModelVersionRequest_SdkV2 struct {
	// List of aliases associated with the model version
	Aliases types.List `tfsdk:"aliases"`
	// The name of the catalog containing the model version
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the model version
	Comment types.String `tfsdk:"comment"`

	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the model version
	CreatedBy types.String `tfsdk:"created_by"`
	// The three-level (fully qualified) name of the model version
	FullName types.String `tfsdk:"-"`
	// The unique identifier of the model version
	Id types.String `tfsdk:"id"`
	// The unique identifier of the metastore containing the model version
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the parent registered model of the model version, relative to
	// parent schema
	ModelName types.String `tfsdk:"model_name"`
	// Model version dependencies, for feature-store packaged models
	ModelVersionDependencies types.List `tfsdk:"model_version_dependencies"`
	// MLflow run ID used when creating the model version, if ``source`` was
	// generated by an experiment run stored in an MLflow tracking server
	RunId types.String `tfsdk:"run_id"`
	// ID of the Databricks workspace containing the MLflow run that generated
	// this model version, if applicable
	RunWorkspaceId types.Int64 `tfsdk:"run_workspace_id"`
	// The name of the schema containing the model version, relative to parent
	// catalog
	SchemaName types.String `tfsdk:"schema_name"`
	// URI indicating the location of the source artifacts (files) for the model
	// version
	Source types.String `tfsdk:"source"`
	// Current status of the model version. Newly created model versions start
	// in PENDING_REGISTRATION status, then move to READY status once the model
	// version files are uploaded and the model version is finalized. Only model
	// versions in READY status can be loaded for inference or served.
	Status types.String `tfsdk:"status"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`

	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the model version last time
	UpdatedBy types.String `tfsdk:"updated_by"`
	// The integer version number of the model version
	Version types.Int64 `tfsdk:"-"`
}

func (to *UpdateModelVersionRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateModelVersionRequest_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
	if !from.ModelVersionDependencies.IsNull() && !from.ModelVersionDependencies.IsUnknown() {
		if toModelVersionDependencies, ok := to.GetModelVersionDependencies(ctx); ok {
			if fromModelVersionDependencies, ok := from.GetModelVersionDependencies(ctx); ok {
				// Recursively sync the fields of ModelVersionDependencies
				toModelVersionDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromModelVersionDependencies)
				to.SetModelVersionDependencies(ctx, toModelVersionDependencies)
			}
		}
	}
}

func (to *UpdateModelVersionRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateModelVersionRequest_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
	if !from.ModelVersionDependencies.IsNull() && !from.ModelVersionDependencies.IsUnknown() {
		if toModelVersionDependencies, ok := to.GetModelVersionDependencies(ctx); ok {
			if fromModelVersionDependencies, ok := from.GetModelVersionDependencies(ctx); ok {
				toModelVersionDependencies.SyncFieldsDuringRead(ctx, fromModelVersionDependencies)
				to.SetModelVersionDependencies(ctx, toModelVersionDependencies)
			}
		}
	}
}

func (m UpdateModelVersionRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["model_version_dependencies"] = attrs["model_version_dependencies"].SetOptional()
	attrs["model_version_dependencies"] = attrs["model_version_dependencies"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_workspace_id"] = attrs["run_workspace_id"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version"] = attrs["version"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateModelVersionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateModelVersionRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases":                    reflect.TypeOf(RegisteredModelAlias_SdkV2{}),
		"model_version_dependencies": reflect.TypeOf(DependencyList_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateModelVersionRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateModelVersionRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":                    m.Aliases,
			"catalog_name":               m.CatalogName,
			"comment":                    m.Comment,
			"created_at":                 m.CreatedAt,
			"created_by":                 m.CreatedBy,
			"full_name":                  m.FullName,
			"id":                         m.Id,
			"metastore_id":               m.MetastoreId,
			"model_name":                 m.ModelName,
			"model_version_dependencies": m.ModelVersionDependencies,
			"run_id":                     m.RunId,
			"run_workspace_id":           m.RunWorkspaceId,
			"schema_name":                m.SchemaName,
			"source":                     m.Source,
			"status":                     m.Status,
			"storage_location":           m.StorageLocation,
			"updated_at":                 m.UpdatedAt,
			"updated_by":                 m.UpdatedBy,
			"version":                    m.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateModelVersionRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias_SdkV2{}.Type(ctx),
			},
			"catalog_name": types.StringType,
			"comment":      types.StringType,
			"created_at":   types.Int64Type,
			"created_by":   types.StringType,
			"full_name":    types.StringType,
			"id":           types.StringType,
			"metastore_id": types.StringType,
			"model_name":   types.StringType,
			"model_version_dependencies": basetypes.ListType{
				ElemType: DependencyList_SdkV2{}.Type(ctx),
			},
			"run_id":           types.StringType,
			"run_workspace_id": types.Int64Type,
			"schema_name":      types.StringType,
			"source":           types.StringType,
			"status":           types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
			"version":          types.Int64Type,
		},
	}
}

// GetAliases returns the value of the Aliases field in UpdateModelVersionRequest_SdkV2 as
// a slice of RegisteredModelAlias_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateModelVersionRequest_SdkV2) GetAliases(ctx context.Context) ([]RegisteredModelAlias_SdkV2, bool) {
	if m.Aliases.IsNull() || m.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias_SdkV2
	d := m.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in UpdateModelVersionRequest_SdkV2.
func (m *UpdateModelVersionRequest_SdkV2) SetAliases(ctx context.Context, v []RegisteredModelAlias_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Aliases = types.ListValueMust(t, vs)
}

// GetModelVersionDependencies returns the value of the ModelVersionDependencies field in UpdateModelVersionRequest_SdkV2 as
// a DependencyList_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateModelVersionRequest_SdkV2) GetModelVersionDependencies(ctx context.Context) (DependencyList_SdkV2, bool) {
	var e DependencyList_SdkV2
	if m.ModelVersionDependencies.IsNull() || m.ModelVersionDependencies.IsUnknown() {
		return e, false
	}
	var v []DependencyList_SdkV2
	d := m.ModelVersionDependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetModelVersionDependencies sets the value of the ModelVersionDependencies field in UpdateModelVersionRequest_SdkV2.
func (m *UpdateModelVersionRequest_SdkV2) SetModelVersionDependencies(ctx context.Context, v DependencyList_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["model_version_dependencies"]
	m.ModelVersionDependencies = types.ListValueMust(t, vs)
}

type UpdateMonitor_SdkV2 struct {
	// [Create:OPT Update:OPT] Baseline table name. Baseline data is used to
	// compute drift from the data in the monitored `table_name`. The baseline
	// table and the monitored table shall have the same schema.
	BaselineTableName types.String `tfsdk:"baseline_table_name"`
	// [Create:OPT Update:OPT] Custom metrics.
	CustomMetrics types.List `tfsdk:"custom_metrics"`
	// [Create:ERR Update:OPT] Id of dashboard that visualizes the computed
	// metrics. This can be empty if the monitor is in PENDING state.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// [Create:OPT Update:OPT] Data classification related config.
	DataClassificationConfig types.List `tfsdk:"data_classification_config"`

	InferenceLog types.List `tfsdk:"inference_log"`
	// [Create:ERR Update:IGN] The latest error message for a monitor failure.
	LatestMonitorFailureMsg types.String `tfsdk:"latest_monitor_failure_msg"`
	// [Create:OPT Update:OPT] Field for specifying notification settings.
	Notifications types.List `tfsdk:"notifications"`
	// [Create:REQ Update:REQ] Schema where output tables are created. Needs to
	// be in 2-level format {catalog}.{schema}
	OutputSchemaName types.String `tfsdk:"output_schema_name"`
	// [Create:OPT Update:OPT] The monitor schedule.
	Schedule types.List `tfsdk:"schedule"`
	// [Create:OPT Update:OPT] List of column expressions to slice data with for
	// targeted analysis. The data is grouped by each expression independently,
	// resulting in a separate slice for each predicate and its complements. For
	// example `slicing_exprs=[col_1, col_2 > 10]` will generate the
	// following slices: two slices for `col_2 > 10` (True and False), and one
	// slice per unique value in `col1`. For high-cardinality columns, only the
	// top 100 unique values by frequency will generate slices.
	SlicingExprs types.List `tfsdk:"slicing_exprs"`
	// Configuration for monitoring snapshot tables.
	Snapshot types.List `tfsdk:"snapshot"`
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
	// Configuration for monitoring time series tables.
	TimeSeries types.List `tfsdk:"time_series"`
}

func (to *UpdateMonitor_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateMonitor_SdkV2) {
	if !from.CustomMetrics.IsNull() && !from.CustomMetrics.IsUnknown() && to.CustomMetrics.IsNull() && len(from.CustomMetrics.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for CustomMetrics, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.CustomMetrics = from.CustomMetrics
	}
	if !from.DataClassificationConfig.IsNull() && !from.DataClassificationConfig.IsUnknown() {
		if toDataClassificationConfig, ok := to.GetDataClassificationConfig(ctx); ok {
			if fromDataClassificationConfig, ok := from.GetDataClassificationConfig(ctx); ok {
				// Recursively sync the fields of DataClassificationConfig
				toDataClassificationConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromDataClassificationConfig)
				to.SetDataClassificationConfig(ctx, toDataClassificationConfig)
			}
		}
	}
	if !from.InferenceLog.IsNull() && !from.InferenceLog.IsUnknown() {
		if toInferenceLog, ok := to.GetInferenceLog(ctx); ok {
			if fromInferenceLog, ok := from.GetInferenceLog(ctx); ok {
				// Recursively sync the fields of InferenceLog
				toInferenceLog.SyncFieldsDuringCreateOrUpdate(ctx, fromInferenceLog)
				to.SetInferenceLog(ctx, toInferenceLog)
			}
		}
	}
	if !from.Notifications.IsNull() && !from.Notifications.IsUnknown() {
		if toNotifications, ok := to.GetNotifications(ctx); ok {
			if fromNotifications, ok := from.GetNotifications(ctx); ok {
				// Recursively sync the fields of Notifications
				toNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromNotifications)
				to.SetNotifications(ctx, toNotifications)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.SlicingExprs.IsNull() && !from.SlicingExprs.IsUnknown() && to.SlicingExprs.IsNull() && len(from.SlicingExprs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SlicingExprs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SlicingExprs = from.SlicingExprs
	}
	if !from.Snapshot.IsNull() && !from.Snapshot.IsUnknown() {
		if toSnapshot, ok := to.GetSnapshot(ctx); ok {
			if fromSnapshot, ok := from.GetSnapshot(ctx); ok {
				// Recursively sync the fields of Snapshot
				toSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromSnapshot)
				to.SetSnapshot(ctx, toSnapshot)
			}
		}
	}
	if !from.TimeSeries.IsNull() && !from.TimeSeries.IsUnknown() {
		if toTimeSeries, ok := to.GetTimeSeries(ctx); ok {
			if fromTimeSeries, ok := from.GetTimeSeries(ctx); ok {
				// Recursively sync the fields of TimeSeries
				toTimeSeries.SyncFieldsDuringCreateOrUpdate(ctx, fromTimeSeries)
				to.SetTimeSeries(ctx, toTimeSeries)
			}
		}
	}
}

func (to *UpdateMonitor_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateMonitor_SdkV2) {
	if !from.CustomMetrics.IsNull() && !from.CustomMetrics.IsUnknown() && to.CustomMetrics.IsNull() && len(from.CustomMetrics.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for CustomMetrics, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.CustomMetrics = from.CustomMetrics
	}
	if !from.DataClassificationConfig.IsNull() && !from.DataClassificationConfig.IsUnknown() {
		if toDataClassificationConfig, ok := to.GetDataClassificationConfig(ctx); ok {
			if fromDataClassificationConfig, ok := from.GetDataClassificationConfig(ctx); ok {
				toDataClassificationConfig.SyncFieldsDuringRead(ctx, fromDataClassificationConfig)
				to.SetDataClassificationConfig(ctx, toDataClassificationConfig)
			}
		}
	}
	if !from.InferenceLog.IsNull() && !from.InferenceLog.IsUnknown() {
		if toInferenceLog, ok := to.GetInferenceLog(ctx); ok {
			if fromInferenceLog, ok := from.GetInferenceLog(ctx); ok {
				toInferenceLog.SyncFieldsDuringRead(ctx, fromInferenceLog)
				to.SetInferenceLog(ctx, toInferenceLog)
			}
		}
	}
	if !from.Notifications.IsNull() && !from.Notifications.IsUnknown() {
		if toNotifications, ok := to.GetNotifications(ctx); ok {
			if fromNotifications, ok := from.GetNotifications(ctx); ok {
				toNotifications.SyncFieldsDuringRead(ctx, fromNotifications)
				to.SetNotifications(ctx, toNotifications)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.SlicingExprs.IsNull() && !from.SlicingExprs.IsUnknown() && to.SlicingExprs.IsNull() && len(from.SlicingExprs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SlicingExprs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SlicingExprs = from.SlicingExprs
	}
	if !from.Snapshot.IsNull() && !from.Snapshot.IsUnknown() {
		if toSnapshot, ok := to.GetSnapshot(ctx); ok {
			if fromSnapshot, ok := from.GetSnapshot(ctx); ok {
				toSnapshot.SyncFieldsDuringRead(ctx, fromSnapshot)
				to.SetSnapshot(ctx, toSnapshot)
			}
		}
	}
	if !from.TimeSeries.IsNull() && !from.TimeSeries.IsUnknown() {
		if toTimeSeries, ok := to.GetTimeSeries(ctx); ok {
			if fromTimeSeries, ok := from.GetTimeSeries(ctx); ok {
				toTimeSeries.SyncFieldsDuringRead(ctx, fromTimeSeries)
				to.SetTimeSeries(ctx, toTimeSeries)
			}
		}
	}
}

func (m UpdateMonitor_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["baseline_table_name"] = attrs["baseline_table_name"].SetOptional()
	attrs["custom_metrics"] = attrs["custom_metrics"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["inference_log"] = attrs["inference_log"].SetOptional()
	attrs["inference_log"] = attrs["inference_log"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["latest_monitor_failure_msg"] = attrs["latest_monitor_failure_msg"].SetOptional()
	attrs["notifications"] = attrs["notifications"].SetOptional()
	attrs["notifications"] = attrs["notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["output_schema_name"] = attrs["output_schema_name"].SetRequired()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["slicing_exprs"] = attrs["slicing_exprs"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["time_series"] = attrs["time_series"].SetOptional()
	attrs["time_series"] = attrs["time_series"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateMonitor.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateMonitor_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_metrics":             reflect.TypeOf(MonitorMetric_SdkV2{}),
		"data_classification_config": reflect.TypeOf(MonitorDataClassificationConfig_SdkV2{}),
		"inference_log":              reflect.TypeOf(MonitorInferenceLog_SdkV2{}),
		"notifications":              reflect.TypeOf(MonitorNotifications_SdkV2{}),
		"schedule":                   reflect.TypeOf(MonitorCronSchedule_SdkV2{}),
		"slicing_exprs":              reflect.TypeOf(types.String{}),
		"snapshot":                   reflect.TypeOf(MonitorSnapshot_SdkV2{}),
		"time_series":                reflect.TypeOf(MonitorTimeSeries_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateMonitor_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateMonitor_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"baseline_table_name":        m.BaselineTableName,
			"custom_metrics":             m.CustomMetrics,
			"dashboard_id":               m.DashboardId,
			"data_classification_config": m.DataClassificationConfig,
			"inference_log":              m.InferenceLog,
			"latest_monitor_failure_msg": m.LatestMonitorFailureMsg,
			"notifications":              m.Notifications,
			"output_schema_name":         m.OutputSchemaName,
			"schedule":                   m.Schedule,
			"slicing_exprs":              m.SlicingExprs,
			"snapshot":                   m.Snapshot,
			"table_name":                 m.TableName,
			"time_series":                m.TimeSeries,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateMonitor_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"baseline_table_name": types.StringType,
			"custom_metrics": basetypes.ListType{
				ElemType: MonitorMetric_SdkV2{}.Type(ctx),
			},
			"dashboard_id": types.StringType,
			"data_classification_config": basetypes.ListType{
				ElemType: MonitorDataClassificationConfig_SdkV2{}.Type(ctx),
			},
			"inference_log": basetypes.ListType{
				ElemType: MonitorInferenceLog_SdkV2{}.Type(ctx),
			},
			"latest_monitor_failure_msg": types.StringType,
			"notifications": basetypes.ListType{
				ElemType: MonitorNotifications_SdkV2{}.Type(ctx),
			},
			"output_schema_name": types.StringType,
			"schedule": basetypes.ListType{
				ElemType: MonitorCronSchedule_SdkV2{}.Type(ctx),
			},
			"slicing_exprs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"snapshot": basetypes.ListType{
				ElemType: MonitorSnapshot_SdkV2{}.Type(ctx),
			},
			"table_name": types.StringType,
			"time_series": basetypes.ListType{
				ElemType: MonitorTimeSeries_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCustomMetrics returns the value of the CustomMetrics field in UpdateMonitor_SdkV2 as
// a slice of MonitorMetric_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetCustomMetrics(ctx context.Context) ([]MonitorMetric_SdkV2, bool) {
	if m.CustomMetrics.IsNull() || m.CustomMetrics.IsUnknown() {
		return nil, false
	}
	var v []MonitorMetric_SdkV2
	d := m.CustomMetrics.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomMetrics sets the value of the CustomMetrics field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetCustomMetrics(ctx context.Context, v []MonitorMetric_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["custom_metrics"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.CustomMetrics = types.ListValueMust(t, vs)
}

// GetDataClassificationConfig returns the value of the DataClassificationConfig field in UpdateMonitor_SdkV2 as
// a MonitorDataClassificationConfig_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetDataClassificationConfig(ctx context.Context) (MonitorDataClassificationConfig_SdkV2, bool) {
	var e MonitorDataClassificationConfig_SdkV2
	if m.DataClassificationConfig.IsNull() || m.DataClassificationConfig.IsUnknown() {
		return e, false
	}
	var v []MonitorDataClassificationConfig_SdkV2
	d := m.DataClassificationConfig.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDataClassificationConfig sets the value of the DataClassificationConfig field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetDataClassificationConfig(ctx context.Context, v MonitorDataClassificationConfig_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["data_classification_config"]
	m.DataClassificationConfig = types.ListValueMust(t, vs)
}

// GetInferenceLog returns the value of the InferenceLog field in UpdateMonitor_SdkV2 as
// a MonitorInferenceLog_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetInferenceLog(ctx context.Context) (MonitorInferenceLog_SdkV2, bool) {
	var e MonitorInferenceLog_SdkV2
	if m.InferenceLog.IsNull() || m.InferenceLog.IsUnknown() {
		return e, false
	}
	var v []MonitorInferenceLog_SdkV2
	d := m.InferenceLog.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetInferenceLog sets the value of the InferenceLog field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetInferenceLog(ctx context.Context, v MonitorInferenceLog_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["inference_log"]
	m.InferenceLog = types.ListValueMust(t, vs)
}

// GetNotifications returns the value of the Notifications field in UpdateMonitor_SdkV2 as
// a MonitorNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetNotifications(ctx context.Context) (MonitorNotifications_SdkV2, bool) {
	var e MonitorNotifications_SdkV2
	if m.Notifications.IsNull() || m.Notifications.IsUnknown() {
		return e, false
	}
	var v []MonitorNotifications_SdkV2
	d := m.Notifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotifications sets the value of the Notifications field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetNotifications(ctx context.Context, v MonitorNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notifications"]
	m.Notifications = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in UpdateMonitor_SdkV2 as
// a MonitorCronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetSchedule(ctx context.Context) (MonitorCronSchedule_SdkV2, bool) {
	var e MonitorCronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []MonitorCronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetSchedule(ctx context.Context, v MonitorCronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetSlicingExprs returns the value of the SlicingExprs field in UpdateMonitor_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetSlicingExprs(ctx context.Context) ([]types.String, bool) {
	if m.SlicingExprs.IsNull() || m.SlicingExprs.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SlicingExprs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSlicingExprs sets the value of the SlicingExprs field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetSlicingExprs(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["slicing_exprs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SlicingExprs = types.ListValueMust(t, vs)
}

// GetSnapshot returns the value of the Snapshot field in UpdateMonitor_SdkV2 as
// a MonitorSnapshot_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetSnapshot(ctx context.Context) (MonitorSnapshot_SdkV2, bool) {
	var e MonitorSnapshot_SdkV2
	if m.Snapshot.IsNull() || m.Snapshot.IsUnknown() {
		return e, false
	}
	var v []MonitorSnapshot_SdkV2
	d := m.Snapshot.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSnapshot sets the value of the Snapshot field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetSnapshot(ctx context.Context, v MonitorSnapshot_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["snapshot"]
	m.Snapshot = types.ListValueMust(t, vs)
}

// GetTimeSeries returns the value of the TimeSeries field in UpdateMonitor_SdkV2 as
// a MonitorTimeSeries_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateMonitor_SdkV2) GetTimeSeries(ctx context.Context) (MonitorTimeSeries_SdkV2, bool) {
	var e MonitorTimeSeries_SdkV2
	if m.TimeSeries.IsNull() || m.TimeSeries.IsUnknown() {
		return e, false
	}
	var v []MonitorTimeSeries_SdkV2
	d := m.TimeSeries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTimeSeries sets the value of the TimeSeries field in UpdateMonitor_SdkV2.
func (m *UpdateMonitor_SdkV2) SetTimeSeries(ctx context.Context, v MonitorTimeSeries_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["time_series"]
	m.TimeSeries = types.ListValueMust(t, vs)
}

type UpdatePermissions_SdkV2 struct {
	// Array of permissions change objects.
	Changes types.List `tfsdk:"changes"`
	// Full name of securable.
	FullName types.String `tfsdk:"-"`
	// Type of securable.
	SecurableType types.String `tfsdk:"-"`
}

func (to *UpdatePermissions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdatePermissions_SdkV2) {
	if !from.Changes.IsNull() && !from.Changes.IsUnknown() && to.Changes.IsNull() && len(from.Changes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Changes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Changes = from.Changes
	}
}

func (to *UpdatePermissions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdatePermissions_SdkV2) {
	if !from.Changes.IsNull() && !from.Changes.IsUnknown() && to.Changes.IsNull() && len(from.Changes.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Changes, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Changes = from.Changes
	}
}

func (m UpdatePermissions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["changes"] = attrs["changes"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdatePermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdatePermissions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"changes": reflect.TypeOf(PermissionsChange_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdatePermissions_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdatePermissions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"changes":        m.Changes,
			"full_name":      m.FullName,
			"securable_type": m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdatePermissions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"changes": basetypes.ListType{
				ElemType: PermissionsChange_SdkV2{}.Type(ctx),
			},
			"full_name":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

// GetChanges returns the value of the Changes field in UpdatePermissions_SdkV2 as
// a slice of PermissionsChange_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdatePermissions_SdkV2) GetChanges(ctx context.Context) ([]PermissionsChange_SdkV2, bool) {
	if m.Changes.IsNull() || m.Changes.IsUnknown() {
		return nil, false
	}
	var v []PermissionsChange_SdkV2
	d := m.Changes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetChanges sets the value of the Changes field in UpdatePermissions_SdkV2.
func (m *UpdatePermissions_SdkV2) SetChanges(ctx context.Context, v []PermissionsChange_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["changes"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Changes = types.ListValueMust(t, vs)
}

type UpdatePermissionsResponse_SdkV2 struct {
	// The privileges assigned to each principal
	PrivilegeAssignments types.List `tfsdk:"privilege_assignments"`
}

func (to *UpdatePermissionsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdatePermissionsResponse_SdkV2) {
	if !from.PrivilegeAssignments.IsNull() && !from.PrivilegeAssignments.IsUnknown() && to.PrivilegeAssignments.IsNull() && len(from.PrivilegeAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrivilegeAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrivilegeAssignments = from.PrivilegeAssignments
	}
}

func (to *UpdatePermissionsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdatePermissionsResponse_SdkV2) {
	if !from.PrivilegeAssignments.IsNull() && !from.PrivilegeAssignments.IsUnknown() && to.PrivilegeAssignments.IsNull() && len(from.PrivilegeAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PrivilegeAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PrivilegeAssignments = from.PrivilegeAssignments
	}
}

func (m UpdatePermissionsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["privilege_assignments"] = attrs["privilege_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdatePermissionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdatePermissionsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privilege_assignments": reflect.TypeOf(PrivilegeAssignment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdatePermissionsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdatePermissionsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"privilege_assignments": m.PrivilegeAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdatePermissionsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"privilege_assignments": basetypes.ListType{
				ElemType: PrivilegeAssignment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPrivilegeAssignments returns the value of the PrivilegeAssignments field in UpdatePermissionsResponse_SdkV2 as
// a slice of PrivilegeAssignment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdatePermissionsResponse_SdkV2) GetPrivilegeAssignments(ctx context.Context) ([]PrivilegeAssignment_SdkV2, bool) {
	if m.PrivilegeAssignments.IsNull() || m.PrivilegeAssignments.IsUnknown() {
		return nil, false
	}
	var v []PrivilegeAssignment_SdkV2
	d := m.PrivilegeAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivilegeAssignments sets the value of the PrivilegeAssignments field in UpdatePermissionsResponse_SdkV2.
func (m *UpdatePermissionsResponse_SdkV2) SetPrivilegeAssignments(ctx context.Context, v []PrivilegeAssignment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["privilege_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PrivilegeAssignments = types.ListValueMust(t, vs)
}

type UpdatePolicyRequest_SdkV2 struct {
	// Required. The name of the policy to update.
	Name types.String `tfsdk:"-"`
	// Required. The fully qualified name of the securable to update the policy
	// for.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to update the policy for.
	OnSecurableType types.String `tfsdk:"-"`
	// Optional fields to update. This is the request body for updating a
	// policy. Use `update_mask` field to specify which fields in the request is
	// to be updated. - If `update_mask` is empty or "*", all specified fields
	// will be updated. - If `update_mask` is specified, only the fields
	// specified in the `update_mask` will be updated. If a field is specified
	// in `update_mask` and not set in the request, the field will be cleared.
	// Users can use the update mask to explicitly unset optional fields such as
	// `exception_principals` and `when_condition`.
	PolicyInfo types.List `tfsdk:"policy_info"`
	// Optional. The update mask field for specifying user intentions on which
	// fields to update in the request.
	UpdateMask types.String `tfsdk:"-"`
}

func (to *UpdatePolicyRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdatePolicyRequest_SdkV2) {
	if !from.PolicyInfo.IsNull() && !from.PolicyInfo.IsUnknown() {
		if toPolicyInfo, ok := to.GetPolicyInfo(ctx); ok {
			if fromPolicyInfo, ok := from.GetPolicyInfo(ctx); ok {
				// Recursively sync the fields of PolicyInfo
				toPolicyInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPolicyInfo)
				to.SetPolicyInfo(ctx, toPolicyInfo)
			}
		}
	}
}

func (to *UpdatePolicyRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdatePolicyRequest_SdkV2) {
	if !from.PolicyInfo.IsNull() && !from.PolicyInfo.IsUnknown() {
		if toPolicyInfo, ok := to.GetPolicyInfo(ctx); ok {
			if fromPolicyInfo, ok := from.GetPolicyInfo(ctx); ok {
				toPolicyInfo.SyncFieldsDuringRead(ctx, fromPolicyInfo)
				to.SetPolicyInfo(ctx, toPolicyInfo)
			}
		}
	}
}

func (m UpdatePolicyRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["policy_info"] = attrs["policy_info"].SetRequired()
	attrs["policy_info"] = attrs["policy_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdatePolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdatePolicyRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"policy_info": reflect.TypeOf(PolicyInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdatePolicyRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdatePolicyRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                  m.Name,
			"on_securable_fullname": m.OnSecurableFullname,
			"on_securable_type":     m.OnSecurableType,
			"policy_info":           m.PolicyInfo,
			"update_mask":           m.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdatePolicyRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"policy_info": basetypes.ListType{
				ElemType: PolicyInfo_SdkV2{}.Type(ctx),
			},
			"update_mask": types.StringType,
		},
	}
}

// GetPolicyInfo returns the value of the PolicyInfo field in UpdatePolicyRequest_SdkV2 as
// a PolicyInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdatePolicyRequest_SdkV2) GetPolicyInfo(ctx context.Context) (PolicyInfo_SdkV2, bool) {
	var e PolicyInfo_SdkV2
	if m.PolicyInfo.IsNull() || m.PolicyInfo.IsUnknown() {
		return e, false
	}
	var v []PolicyInfo_SdkV2
	d := m.PolicyInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPolicyInfo sets the value of the PolicyInfo field in UpdatePolicyRequest_SdkV2.
func (m *UpdatePolicyRequest_SdkV2) SetPolicyInfo(ctx context.Context, v PolicyInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["policy_info"]
	m.PolicyInfo = types.ListValueMust(t, vs)
}

type UpdateRegisteredModelRequest_SdkV2 struct {
	// List of aliases associated with the registered model
	Aliases types.List `tfsdk:"aliases"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog where the schema and the registered model reside
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the registered model
	Comment types.String `tfsdk:"comment"`
	// Creation timestamp of the registered model in milliseconds since the Unix
	// epoch
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the registered model
	CreatedBy types.String `tfsdk:"created_by"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// The unique identifier of the metastore
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the registered model
	Name types.String `tfsdk:"name"`
	// New name for the registered model.
	NewName types.String `tfsdk:"new_name"`
	// The identifier of the user who owns the registered model
	Owner types.String `tfsdk:"owner"`
	// The name of the schema where the registered model resides
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`
	// Last-update timestamp of the registered model in milliseconds since the
	// Unix epoch
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the registered model last time
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (to *UpdateRegisteredModelRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateRegisteredModelRequest_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
}

func (to *UpdateRegisteredModelRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateRegisteredModelRequest_SdkV2) {
	if !from.Aliases.IsNull() && !from.Aliases.IsUnknown() && to.Aliases.IsNull() && len(from.Aliases.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Aliases, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Aliases = from.Aliases
	}
}

func (m UpdateRegisteredModelRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateRegisteredModelRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases": reflect.TypeOf(RegisteredModelAlias_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateRegisteredModelRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateRegisteredModelRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":          m.Aliases,
			"browse_only":      m.BrowseOnly,
			"catalog_name":     m.CatalogName,
			"comment":          m.Comment,
			"created_at":       m.CreatedAt,
			"created_by":       m.CreatedBy,
			"full_name":        m.FullName,
			"metastore_id":     m.MetastoreId,
			"name":             m.Name,
			"new_name":         m.NewName,
			"owner":            m.Owner,
			"schema_name":      m.SchemaName,
			"storage_location": m.StorageLocation,
			"updated_at":       m.UpdatedAt,
			"updated_by":       m.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateRegisteredModelRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias_SdkV2{}.Type(ctx),
			},
			"browse_only":      types.BoolType,
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"created_at":       types.Int64Type,
			"created_by":       types.StringType,
			"full_name":        types.StringType,
			"metastore_id":     types.StringType,
			"name":             types.StringType,
			"new_name":         types.StringType,
			"owner":            types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetAliases returns the value of the Aliases field in UpdateRegisteredModelRequest_SdkV2 as
// a slice of RegisteredModelAlias_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateRegisteredModelRequest_SdkV2) GetAliases(ctx context.Context) ([]RegisteredModelAlias_SdkV2, bool) {
	if m.Aliases.IsNull() || m.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias_SdkV2
	d := m.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in UpdateRegisteredModelRequest_SdkV2.
func (m *UpdateRegisteredModelRequest_SdkV2) SetAliases(ctx context.Context, v []RegisteredModelAlias_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Aliases = types.ListValueMust(t, vs)
}

type UpdateRequestExternalLineage_SdkV2 struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.List `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.List `tfsdk:"target"`
}

func (to *UpdateRequestExternalLineage_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateRequestExternalLineage_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				// Recursively sync the fields of Source
				toSource.SyncFieldsDuringCreateOrUpdate(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				// Recursively sync the fields of Target
				toTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (to *UpdateRequestExternalLineage_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateRequestExternalLineage_SdkV2) {
	if !from.Columns.IsNull() && !from.Columns.IsUnknown() && to.Columns.IsNull() && len(from.Columns.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Columns, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Columns = from.Columns
	}
	if !from.Source.IsNull() && !from.Source.IsUnknown() {
		if toSource, ok := to.GetSource(ctx); ok {
			if fromSource, ok := from.GetSource(ctx); ok {
				toSource.SyncFieldsDuringRead(ctx, fromSource)
				to.SetSource(ctx, toSource)
			}
		}
	}
	if !from.Target.IsNull() && !from.Target.IsUnknown() {
		if toTarget, ok := to.GetTarget(ctx); ok {
			if fromTarget, ok := from.GetTarget(ctx); ok {
				toTarget.SyncFieldsDuringRead(ctx, fromTarget)
				to.SetTarget(ctx, toTarget)
			}
		}
	}
}

func (m UpdateRequestExternalLineage_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["source"] = attrs["source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["target"] = attrs["target"].SetRequired()
	attrs["target"] = attrs["target"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateRequestExternalLineage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateRequestExternalLineage_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship_SdkV2{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
		"target":     reflect.TypeOf(ExternalLineageObject_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateRequestExternalLineage_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateRequestExternalLineage_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    m.Columns,
			"id":         m.Id,
			"properties": m.Properties,
			"source":     m.Source,
			"target":     m.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateRequestExternalLineage_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship_SdkV2{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
			"target": basetypes.ListType{
				ElemType: ExternalLineageObject_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetColumns returns the value of the Columns field in UpdateRequestExternalLineage_SdkV2 as
// a slice of ColumnRelationship_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateRequestExternalLineage_SdkV2) GetColumns(ctx context.Context) ([]ColumnRelationship_SdkV2, bool) {
	if m.Columns.IsNull() || m.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship_SdkV2
	d := m.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in UpdateRequestExternalLineage_SdkV2.
func (m *UpdateRequestExternalLineage_SdkV2) SetColumns(ctx context.Context, v []ColumnRelationship_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in UpdateRequestExternalLineage_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateRequestExternalLineage_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in UpdateRequestExternalLineage_SdkV2.
func (m *UpdateRequestExternalLineage_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in UpdateRequestExternalLineage_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateRequestExternalLineage_SdkV2) GetSource(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Source.IsNull() || m.Source.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Source.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSource sets the value of the Source field in UpdateRequestExternalLineage_SdkV2.
func (m *UpdateRequestExternalLineage_SdkV2) SetSource(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["source"]
	m.Source = types.ListValueMust(t, vs)
}

// GetTarget returns the value of the Target field in UpdateRequestExternalLineage_SdkV2 as
// a ExternalLineageObject_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateRequestExternalLineage_SdkV2) GetTarget(ctx context.Context) (ExternalLineageObject_SdkV2, bool) {
	var e ExternalLineageObject_SdkV2
	if m.Target.IsNull() || m.Target.IsUnknown() {
		return e, false
	}
	var v []ExternalLineageObject_SdkV2
	d := m.Target.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTarget sets the value of the Target field in UpdateRequestExternalLineage_SdkV2.
func (m *UpdateRequestExternalLineage_SdkV2) SetTarget(ctx context.Context, v ExternalLineageObject_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["target"]
	m.Target = types.ListValueMust(t, vs)
}

type UpdateResponse_SdkV2 struct {
}

func (to *UpdateResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateResponse_SdkV2) {
}

func (to *UpdateResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateResponse_SdkV2) {
}

func (m UpdateResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateSchema_SdkV2 struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// Full name of the schema.
	FullName types.String `tfsdk:"-"`
	// New name for the schema.
	NewName types.String `tfsdk:"new_name"`
	// Username of current owner of schema.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
}

func (to *UpdateSchema_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateSchema_SdkV2) {
}

func (to *UpdateSchema_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateSchema_SdkV2) {
}

func (m UpdateSchema_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateSchema.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateSchema_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateSchema_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateSchema_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":                        m.Comment,
			"enable_predictive_optimization": m.EnablePredictiveOptimization,
			"full_name":                      m.FullName,
			"new_name":                       m.NewName,
			"owner":                          m.Owner,
			"properties":                     m.Properties,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateSchema_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":                        types.StringType,
			"enable_predictive_optimization": types.StringType,
			"full_name":                      types.StringType,
			"new_name":                       types.StringType,
			"owner":                          types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetProperties returns the value of the Properties field in UpdateSchema_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateSchema_SdkV2) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if m.Properties.IsNull() || m.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in UpdateSchema_SdkV2.
func (m *UpdateSchema_SdkV2) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Properties = types.MapValueMust(t, vs)
}

type UpdateStorageCredential_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.List `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// Force update even if there are dependent external locations or external
	// tables.
	Force types.Bool `tfsdk:"force"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Name of the storage credential.
	Name types.String `tfsdk:"-"`
	// New name for the storage credential.
	NewName types.String `tfsdk:"new_name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Supplying true to this argument skips validation of the updated
	// credential.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (to *UpdateStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				// Recursively sync the fields of CloudflareApiToken
				toCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *UpdateStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				toCloudflareApiToken.SyncFieldsDuringRead(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m UpdateStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["force"] = attrs["force"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityResponse_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"cloudflare_api_token":           m.CloudflareApiToken,
			"comment":                        m.Comment,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"force":                          m.Force,
			"isolation_mode":                 m.IsolationMode,
			"name":                           m.Name,
			"new_name":                       m.NewName,
			"owner":                          m.Owner,
			"read_only":                      m.ReadOnly,
			"skip_validation":                m.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRoleRequest_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentityResponse_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"cloudflare_api_token": basetypes.ListType{
				ElemType: CloudflareApiToken_SdkV2{}.Type(ctx),
			},
			"comment": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccountRequest_SdkV2{}.Type(ctx),
			},
			"force":           types.BoolType,
			"isolation_mode":  types.StringType,
			"name":            types.StringType,
			"new_name":        types.StringType,
			"owner":           types.StringType,
			"read_only":       types.BoolType,
			"skip_validation": types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in UpdateStorageCredential_SdkV2 as
// a AwsIamRoleRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateStorageCredential_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest_SdkV2, bool) {
	var e AwsIamRoleRequest_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRoleRequest_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in UpdateStorageCredential_SdkV2.
func (m *UpdateStorageCredential_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in UpdateStorageCredential_SdkV2 as
// a AzureManagedIdentityResponse_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateStorageCredential_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityResponse_SdkV2, bool) {
	var e AzureManagedIdentityResponse_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentityResponse_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in UpdateStorageCredential_SdkV2.
func (m *UpdateStorageCredential_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityResponse_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in UpdateStorageCredential_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateStorageCredential_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in UpdateStorageCredential_SdkV2.
func (m *UpdateStorageCredential_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in UpdateStorageCredential_SdkV2 as
// a CloudflareApiToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateStorageCredential_SdkV2) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken_SdkV2, bool) {
	var e CloudflareApiToken_SdkV2
	if m.CloudflareApiToken.IsNull() || m.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v []CloudflareApiToken_SdkV2
	d := m.CloudflareApiToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in UpdateStorageCredential_SdkV2.
func (m *UpdateStorageCredential_SdkV2) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cloudflare_api_token"]
	m.CloudflareApiToken = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in UpdateStorageCredential_SdkV2 as
// a DatabricksGcpServiceAccountRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateStorageCredential_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest_SdkV2, bool) {
	var e DatabricksGcpServiceAccountRequest_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccountRequest_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in UpdateStorageCredential_SdkV2.
func (m *UpdateStorageCredential_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type UpdateTableRequest_SdkV2 struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
	// Username of current owner of table.
	Owner types.String `tfsdk:"owner"`
}

func (to *UpdateTableRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateTableRequest_SdkV2) {
}

func (to *UpdateTableRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateTableRequest_SdkV2) {
}

func (m UpdateTableRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateTableRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateTableRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateTableRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": m.FullName,
			"owner":     m.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateTableRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
			"owner":     types.StringType,
		},
	}
}

type UpdateVolumeRequestContent_SdkV2 struct {
	// The comment attached to the volume
	Comment types.String `tfsdk:"comment"`
	// The three-level (fully qualified) name of the volume
	Name types.String `tfsdk:"-"`
	// New name for the volume.
	NewName types.String `tfsdk:"new_name"`
	// The identifier of the user who owns the volume
	Owner types.String `tfsdk:"owner"`
}

func (to *UpdateVolumeRequestContent_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateVolumeRequestContent_SdkV2) {
}

func (to *UpdateVolumeRequestContent_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateVolumeRequestContent_SdkV2) {
}

func (m UpdateVolumeRequestContent_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateVolumeRequestContent.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateVolumeRequestContent_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateVolumeRequestContent_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateVolumeRequestContent_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":  m.Comment,
			"name":     m.Name,
			"new_name": m.NewName,
			"owner":    m.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateVolumeRequestContent_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":  types.StringType,
			"name":     types.StringType,
			"new_name": types.StringType,
			"owner":    types.StringType,
		},
	}
}

type UpdateWorkspaceBindings_SdkV2 struct {
	// A list of workspace IDs.
	AssignWorkspaces types.List `tfsdk:"assign_workspaces"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
	// A list of workspace IDs.
	UnassignWorkspaces types.List `tfsdk:"unassign_workspaces"`
}

func (to *UpdateWorkspaceBindings_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateWorkspaceBindings_SdkV2) {
	if !from.AssignWorkspaces.IsNull() && !from.AssignWorkspaces.IsUnknown() && to.AssignWorkspaces.IsNull() && len(from.AssignWorkspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AssignWorkspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AssignWorkspaces = from.AssignWorkspaces
	}
	if !from.UnassignWorkspaces.IsNull() && !from.UnassignWorkspaces.IsUnknown() && to.UnassignWorkspaces.IsNull() && len(from.UnassignWorkspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for UnassignWorkspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.UnassignWorkspaces = from.UnassignWorkspaces
	}
}

func (to *UpdateWorkspaceBindings_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateWorkspaceBindings_SdkV2) {
	if !from.AssignWorkspaces.IsNull() && !from.AssignWorkspaces.IsUnknown() && to.AssignWorkspaces.IsNull() && len(from.AssignWorkspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AssignWorkspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AssignWorkspaces = from.AssignWorkspaces
	}
	if !from.UnassignWorkspaces.IsNull() && !from.UnassignWorkspaces.IsUnknown() && to.UnassignWorkspaces.IsNull() && len(from.UnassignWorkspaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for UnassignWorkspaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.UnassignWorkspaces = from.UnassignWorkspaces
	}
}

func (m UpdateWorkspaceBindings_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assign_workspaces"] = attrs["assign_workspaces"].SetOptional()
	attrs["unassign_workspaces"] = attrs["unassign_workspaces"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceBindings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateWorkspaceBindings_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"assign_workspaces":   reflect.TypeOf(types.Int64{}),
		"unassign_workspaces": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceBindings_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateWorkspaceBindings_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assign_workspaces":   m.AssignWorkspaces,
			"name":                m.Name,
			"unassign_workspaces": m.UnassignWorkspaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateWorkspaceBindings_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assign_workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"name": types.StringType,
			"unassign_workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetAssignWorkspaces returns the value of the AssignWorkspaces field in UpdateWorkspaceBindings_SdkV2 as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateWorkspaceBindings_SdkV2) GetAssignWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if m.AssignWorkspaces.IsNull() || m.AssignWorkspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.AssignWorkspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAssignWorkspaces sets the value of the AssignWorkspaces field in UpdateWorkspaceBindings_SdkV2.
func (m *UpdateWorkspaceBindings_SdkV2) SetAssignWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["assign_workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AssignWorkspaces = types.ListValueMust(t, vs)
}

// GetUnassignWorkspaces returns the value of the UnassignWorkspaces field in UpdateWorkspaceBindings_SdkV2 as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateWorkspaceBindings_SdkV2) GetUnassignWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if m.UnassignWorkspaces.IsNull() || m.UnassignWorkspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.UnassignWorkspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUnassignWorkspaces sets the value of the UnassignWorkspaces field in UpdateWorkspaceBindings_SdkV2.
func (m *UpdateWorkspaceBindings_SdkV2) SetUnassignWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["unassign_workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.UnassignWorkspaces = types.ListValueMust(t, vs)
}

type UpdateWorkspaceBindingsParameters_SdkV2 struct {
	// List of workspace bindings to add. If a binding for the workspace already
	// exists with a different binding_type, adding it again with a new
	// binding_type will update the existing binding (e.g., from READ_WRITE to
	// READ_ONLY).
	Add types.List `tfsdk:"add"`
	// List of workspace bindings to remove.
	Remove types.List `tfsdk:"remove"`
	// The name of the securable.
	SecurableName types.String `tfsdk:"-"`
	// The type of the securable to bind to a workspace (catalog,
	// storage_credential, credential, or external_location).
	SecurableType types.String `tfsdk:"-"`
}

func (to *UpdateWorkspaceBindingsParameters_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateWorkspaceBindingsParameters_SdkV2) {
	if !from.Add.IsNull() && !from.Add.IsUnknown() && to.Add.IsNull() && len(from.Add.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Add, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Add = from.Add
	}
	if !from.Remove.IsNull() && !from.Remove.IsUnknown() && to.Remove.IsNull() && len(from.Remove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Remove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Remove = from.Remove
	}
}

func (to *UpdateWorkspaceBindingsParameters_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateWorkspaceBindingsParameters_SdkV2) {
	if !from.Add.IsNull() && !from.Add.IsUnknown() && to.Add.IsNull() && len(from.Add.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Add, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Add = from.Add
	}
	if !from.Remove.IsNull() && !from.Remove.IsUnknown() && to.Remove.IsNull() && len(from.Remove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Remove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Remove = from.Remove
	}
}

func (m UpdateWorkspaceBindingsParameters_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["add"] = attrs["add"].SetOptional()
	attrs["remove"] = attrs["remove"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["securable_name"] = attrs["securable_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceBindingsParameters.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateWorkspaceBindingsParameters_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"add":    reflect.TypeOf(WorkspaceBinding_SdkV2{}),
		"remove": reflect.TypeOf(WorkspaceBinding_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceBindingsParameters_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateWorkspaceBindingsParameters_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"add":            m.Add,
			"remove":         m.Remove,
			"securable_name": m.SecurableName,
			"securable_type": m.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateWorkspaceBindingsParameters_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: WorkspaceBinding_SdkV2{}.Type(ctx),
			},
			"remove": basetypes.ListType{
				ElemType: WorkspaceBinding_SdkV2{}.Type(ctx),
			},
			"securable_name": types.StringType,
			"securable_type": types.StringType,
		},
	}
}

// GetAdd returns the value of the Add field in UpdateWorkspaceBindingsParameters_SdkV2 as
// a slice of WorkspaceBinding_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateWorkspaceBindingsParameters_SdkV2) GetAdd(ctx context.Context) ([]WorkspaceBinding_SdkV2, bool) {
	if m.Add.IsNull() || m.Add.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding_SdkV2
	d := m.Add.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAdd sets the value of the Add field in UpdateWorkspaceBindingsParameters_SdkV2.
func (m *UpdateWorkspaceBindingsParameters_SdkV2) SetAdd(ctx context.Context, v []WorkspaceBinding_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["add"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Add = types.ListValueMust(t, vs)
}

// GetRemove returns the value of the Remove field in UpdateWorkspaceBindingsParameters_SdkV2 as
// a slice of WorkspaceBinding_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateWorkspaceBindingsParameters_SdkV2) GetRemove(ctx context.Context) ([]WorkspaceBinding_SdkV2, bool) {
	if m.Remove.IsNull() || m.Remove.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding_SdkV2
	d := m.Remove.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRemove sets the value of the Remove field in UpdateWorkspaceBindingsParameters_SdkV2.
func (m *UpdateWorkspaceBindingsParameters_SdkV2) SetRemove(ctx context.Context, v []WorkspaceBinding_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["remove"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Remove = types.ListValueMust(t, vs)
}

// A list of workspace IDs that are bound to the securable
type UpdateWorkspaceBindingsResponse_SdkV2 struct {
	// List of workspace bindings.
	Bindings types.List `tfsdk:"bindings"`
}

func (to *UpdateWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateWorkspaceBindingsResponse_SdkV2) {
	if !from.Bindings.IsNull() && !from.Bindings.IsUnknown() && to.Bindings.IsNull() && len(from.Bindings.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Bindings, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Bindings = from.Bindings
	}
}

func (to *UpdateWorkspaceBindingsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateWorkspaceBindingsResponse_SdkV2) {
	if !from.Bindings.IsNull() && !from.Bindings.IsUnknown() && to.Bindings.IsNull() && len(from.Bindings.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Bindings, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Bindings = from.Bindings
	}
}

func (m UpdateWorkspaceBindingsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["bindings"] = attrs["bindings"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateWorkspaceBindingsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"bindings": reflect.TypeOf(WorkspaceBinding_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceBindingsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateWorkspaceBindingsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"bindings": m.Bindings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateWorkspaceBindingsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"bindings": basetypes.ListType{
				ElemType: WorkspaceBinding_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetBindings returns the value of the Bindings field in UpdateWorkspaceBindingsResponse_SdkV2 as
// a slice of WorkspaceBinding_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateWorkspaceBindingsResponse_SdkV2) GetBindings(ctx context.Context) ([]WorkspaceBinding_SdkV2, bool) {
	if m.Bindings.IsNull() || m.Bindings.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding_SdkV2
	d := m.Bindings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBindings sets the value of the Bindings field in UpdateWorkspaceBindingsResponse_SdkV2.
func (m *UpdateWorkspaceBindingsResponse_SdkV2) SetBindings(ctx context.Context, v []WorkspaceBinding_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["bindings"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Bindings = types.ListValueMust(t, vs)
}

// Next ID: 17
type ValidateCredentialRequest_SdkV2 struct {
	AwsIamRole types.List `tfsdk:"aws_iam_role"`

	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// Required. The name of an existing credential or long-lived cloud
	// credential to validate.
	CredentialName types.String `tfsdk:"credential_name"`

	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The name of an existing external location to validate. Only applicable
	// for storage credentials (purpose is **STORAGE**.)
	ExternalLocationName types.String `tfsdk:"external_location_name"`
	// The purpose of the credential. This should only be used when the
	// credential is specified.
	Purpose types.String `tfsdk:"purpose"`
	// Whether the credential is only usable for read operations. Only
	// applicable for storage credentials (purpose is **STORAGE**.)
	ReadOnly types.Bool `tfsdk:"read_only"`
	// The external location url to validate. Only applicable when purpose is
	// **STORAGE**.
	Url types.String `tfsdk:"url"`
}

func (to *ValidateCredentialRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ValidateCredentialRequest_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *ValidateCredentialRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ValidateCredentialRequest_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m ValidateCredentialRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["credential_name"] = attrs["credential_name"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["external_location_name"] = attrs["external_location_name"].SetOptional()
	attrs["purpose"] = attrs["purpose"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ValidateCredentialRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateCredentialRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ValidateCredentialRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"credential_name":                m.CredentialName,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"external_location_name":         m.ExternalLocationName,
			"purpose":                        m.Purpose,
			"read_only":                      m.ReadOnly,
			"url":                            m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ValidateCredentialRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRole_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentity_SdkV2{}.Type(ctx),
			},
			"credential_name": types.StringType,
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccount_SdkV2{}.Type(ctx),
			},
			"external_location_name": types.StringType,
			"purpose":                types.StringType,
			"read_only":              types.BoolType,
			"url":                    types.StringType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in ValidateCredentialRequest_SdkV2 as
// a AwsIamRole_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateCredentialRequest_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRole_SdkV2, bool) {
	var e AwsIamRole_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRole_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in ValidateCredentialRequest_SdkV2.
func (m *ValidateCredentialRequest_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRole_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in ValidateCredentialRequest_SdkV2 as
// a AzureManagedIdentity_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateCredentialRequest_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity_SdkV2, bool) {
	var e AzureManagedIdentity_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentity_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in ValidateCredentialRequest_SdkV2.
func (m *ValidateCredentialRequest_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in ValidateCredentialRequest_SdkV2 as
// a DatabricksGcpServiceAccount_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateCredentialRequest_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount_SdkV2, bool) {
	var e DatabricksGcpServiceAccount_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccount_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in ValidateCredentialRequest_SdkV2.
func (m *ValidateCredentialRequest_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type ValidateCredentialResponse_SdkV2 struct {
	// Whether the tested location is a directory in cloud storage. Only
	// applicable for when purpose is **STORAGE**.
	IsDir types.Bool `tfsdk:"is_dir"`
	// The results of the validation check.
	Results types.List `tfsdk:"results"`
}

func (to *ValidateCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ValidateCredentialResponse_SdkV2) {
	if !from.Results.IsNull() && !from.Results.IsUnknown() && to.Results.IsNull() && len(from.Results.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Results, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Results = from.Results
	}
}

func (to *ValidateCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ValidateCredentialResponse_SdkV2) {
	if !from.Results.IsNull() && !from.Results.IsUnknown() && to.Results.IsNull() && len(from.Results.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Results, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Results = from.Results
	}
}

func (m ValidateCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_dir"] = attrs["is_dir"].SetOptional()
	attrs["results"] = attrs["results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ValidateCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"results": reflect.TypeOf(CredentialValidationResult_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ValidateCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_dir":  m.IsDir,
			"results": m.Results,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ValidateCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_dir": types.BoolType,
			"results": basetypes.ListType{
				ElemType: CredentialValidationResult_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetResults returns the value of the Results field in ValidateCredentialResponse_SdkV2 as
// a slice of CredentialValidationResult_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateCredentialResponse_SdkV2) GetResults(ctx context.Context) ([]CredentialValidationResult_SdkV2, bool) {
	if m.Results.IsNull() || m.Results.IsUnknown() {
		return nil, false
	}
	var v []CredentialValidationResult_SdkV2
	d := m.Results.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResults sets the value of the Results field in ValidateCredentialResponse_SdkV2.
func (m *ValidateCredentialResponse_SdkV2) SetResults(ctx context.Context, v []CredentialValidationResult_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["results"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Results = types.ListValueMust(t, vs)
}

type ValidateStorageCredential_SdkV2 struct {
	// The AWS IAM role configuration.
	AwsIamRole types.List `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.List `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.List `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.List `tfsdk:"cloudflare_api_token"`
	// The Databricks created GCP service account configuration.
	DatabricksGcpServiceAccount types.List `tfsdk:"databricks_gcp_service_account"`
	// The name of an existing external location to validate.
	ExternalLocationName types.String `tfsdk:"external_location_name"`
	// Whether the storage credential is only usable for read operations.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Required. The name of an existing credential or long-lived cloud
	// credential to validate.
	StorageCredentialName types.String `tfsdk:"storage_credential_name"`
	// The external location url to validate.
	Url types.String `tfsdk:"url"`
}

func (to *ValidateStorageCredential_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ValidateStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				// Recursively sync the fields of AwsIamRole
				toAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				// Recursively sync the fields of AzureManagedIdentity
				toAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				// Recursively sync the fields of AzureServicePrincipal
				toAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				// Recursively sync the fields of CloudflareApiToken
				toCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				// Recursively sync the fields of DatabricksGcpServiceAccount
				toDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (to *ValidateStorageCredential_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ValidateStorageCredential_SdkV2) {
	if !from.AwsIamRole.IsNull() && !from.AwsIamRole.IsUnknown() {
		if toAwsIamRole, ok := to.GetAwsIamRole(ctx); ok {
			if fromAwsIamRole, ok := from.GetAwsIamRole(ctx); ok {
				toAwsIamRole.SyncFieldsDuringRead(ctx, fromAwsIamRole)
				to.SetAwsIamRole(ctx, toAwsIamRole)
			}
		}
	}
	if !from.AzureManagedIdentity.IsNull() && !from.AzureManagedIdentity.IsUnknown() {
		if toAzureManagedIdentity, ok := to.GetAzureManagedIdentity(ctx); ok {
			if fromAzureManagedIdentity, ok := from.GetAzureManagedIdentity(ctx); ok {
				toAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromAzureManagedIdentity)
				to.SetAzureManagedIdentity(ctx, toAzureManagedIdentity)
			}
		}
	}
	if !from.AzureServicePrincipal.IsNull() && !from.AzureServicePrincipal.IsUnknown() {
		if toAzureServicePrincipal, ok := to.GetAzureServicePrincipal(ctx); ok {
			if fromAzureServicePrincipal, ok := from.GetAzureServicePrincipal(ctx); ok {
				toAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromAzureServicePrincipal)
				to.SetAzureServicePrincipal(ctx, toAzureServicePrincipal)
			}
		}
	}
	if !from.CloudflareApiToken.IsNull() && !from.CloudflareApiToken.IsUnknown() {
		if toCloudflareApiToken, ok := to.GetCloudflareApiToken(ctx); ok {
			if fromCloudflareApiToken, ok := from.GetCloudflareApiToken(ctx); ok {
				toCloudflareApiToken.SyncFieldsDuringRead(ctx, fromCloudflareApiToken)
				to.SetCloudflareApiToken(ctx, toCloudflareApiToken)
			}
		}
	}
	if !from.DatabricksGcpServiceAccount.IsNull() && !from.DatabricksGcpServiceAccount.IsUnknown() {
		if toDatabricksGcpServiceAccount, ok := to.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromDatabricksGcpServiceAccount, ok := from.GetDatabricksGcpServiceAccount(ctx); ok {
				toDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromDatabricksGcpServiceAccount)
				to.SetDatabricksGcpServiceAccount(ctx, toDatabricksGcpServiceAccount)
			}
		}
	}
}

func (m ValidateStorageCredential_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["aws_iam_role"] = attrs["aws_iam_role"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["external_location_name"] = attrs["external_location_name"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ValidateStorageCredential_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest_SdkV2{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityRequest_SdkV2{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal_SdkV2{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken_SdkV2{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateStorageCredential_SdkV2
// only implements ToObjectValue() and Type().
func (m ValidateStorageCredential_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   m.AwsIamRole,
			"azure_managed_identity":         m.AzureManagedIdentity,
			"azure_service_principal":        m.AzureServicePrincipal,
			"cloudflare_api_token":           m.CloudflareApiToken,
			"databricks_gcp_service_account": m.DatabricksGcpServiceAccount,
			"external_location_name":         m.ExternalLocationName,
			"read_only":                      m.ReadOnly,
			"storage_credential_name":        m.StorageCredentialName,
			"url":                            m.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ValidateStorageCredential_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role": basetypes.ListType{
				ElemType: AwsIamRoleRequest_SdkV2{}.Type(ctx),
			},
			"azure_managed_identity": basetypes.ListType{
				ElemType: AzureManagedIdentityRequest_SdkV2{}.Type(ctx),
			},
			"azure_service_principal": basetypes.ListType{
				ElemType: AzureServicePrincipal_SdkV2{}.Type(ctx),
			},
			"cloudflare_api_token": basetypes.ListType{
				ElemType: CloudflareApiToken_SdkV2{}.Type(ctx),
			},
			"databricks_gcp_service_account": basetypes.ListType{
				ElemType: DatabricksGcpServiceAccountRequest_SdkV2{}.Type(ctx),
			},
			"external_location_name":  types.StringType,
			"read_only":               types.BoolType,
			"storage_credential_name": types.StringType,
			"url":                     types.StringType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in ValidateStorageCredential_SdkV2 as
// a AwsIamRoleRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateStorageCredential_SdkV2) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest_SdkV2, bool) {
	var e AwsIamRoleRequest_SdkV2
	if m.AwsIamRole.IsNull() || m.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v []AwsIamRoleRequest_SdkV2
	d := m.AwsIamRole.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAwsIamRole sets the value of the AwsIamRole field in ValidateStorageCredential_SdkV2.
func (m *ValidateStorageCredential_SdkV2) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["aws_iam_role"]
	m.AwsIamRole = types.ListValueMust(t, vs)
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in ValidateStorageCredential_SdkV2 as
// a AzureManagedIdentityRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateStorageCredential_SdkV2) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityRequest_SdkV2, bool) {
	var e AzureManagedIdentityRequest_SdkV2
	if m.AzureManagedIdentity.IsNull() || m.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v []AzureManagedIdentityRequest_SdkV2
	d := m.AzureManagedIdentity.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in ValidateStorageCredential_SdkV2.
func (m *ValidateStorageCredential_SdkV2) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_managed_identity"]
	m.AzureManagedIdentity = types.ListValueMust(t, vs)
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in ValidateStorageCredential_SdkV2 as
// a AzureServicePrincipal_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateStorageCredential_SdkV2) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal_SdkV2, bool) {
	var e AzureServicePrincipal_SdkV2
	if m.AzureServicePrincipal.IsNull() || m.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v []AzureServicePrincipal_SdkV2
	d := m.AzureServicePrincipal.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in ValidateStorageCredential_SdkV2.
func (m *ValidateStorageCredential_SdkV2) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["azure_service_principal"]
	m.AzureServicePrincipal = types.ListValueMust(t, vs)
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in ValidateStorageCredential_SdkV2 as
// a CloudflareApiToken_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateStorageCredential_SdkV2) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken_SdkV2, bool) {
	var e CloudflareApiToken_SdkV2
	if m.CloudflareApiToken.IsNull() || m.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v []CloudflareApiToken_SdkV2
	d := m.CloudflareApiToken.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in ValidateStorageCredential_SdkV2.
func (m *ValidateStorageCredential_SdkV2) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cloudflare_api_token"]
	m.CloudflareApiToken = types.ListValueMust(t, vs)
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in ValidateStorageCredential_SdkV2 as
// a DatabricksGcpServiceAccountRequest_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateStorageCredential_SdkV2) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest_SdkV2, bool) {
	var e DatabricksGcpServiceAccountRequest_SdkV2
	if m.DatabricksGcpServiceAccount.IsNull() || m.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v []DatabricksGcpServiceAccountRequest_SdkV2
	d := m.DatabricksGcpServiceAccount.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in ValidateStorageCredential_SdkV2.
func (m *ValidateStorageCredential_SdkV2) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["databricks_gcp_service_account"]
	m.DatabricksGcpServiceAccount = types.ListValueMust(t, vs)
}

type ValidateStorageCredentialResponse_SdkV2 struct {
	// Whether the tested location is a directory in cloud storage.
	IsDir types.Bool `tfsdk:"is_dir"`
	// The results of the validation check.
	Results types.List `tfsdk:"results"`
}

func (to *ValidateStorageCredentialResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ValidateStorageCredentialResponse_SdkV2) {
	if !from.Results.IsNull() && !from.Results.IsUnknown() && to.Results.IsNull() && len(from.Results.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Results, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Results = from.Results
	}
}

func (to *ValidateStorageCredentialResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ValidateStorageCredentialResponse_SdkV2) {
	if !from.Results.IsNull() && !from.Results.IsUnknown() && to.Results.IsNull() && len(from.Results.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Results, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Results = from.Results
	}
}

func (m ValidateStorageCredentialResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_dir"] = attrs["is_dir"].SetOptional()
	attrs["results"] = attrs["results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateStorageCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ValidateStorageCredentialResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"results": reflect.TypeOf(ValidationResult_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateStorageCredentialResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ValidateStorageCredentialResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_dir":  m.IsDir,
			"results": m.Results,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ValidateStorageCredentialResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_dir": types.BoolType,
			"results": basetypes.ListType{
				ElemType: ValidationResult_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetResults returns the value of the Results field in ValidateStorageCredentialResponse_SdkV2 as
// a slice of ValidationResult_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidateStorageCredentialResponse_SdkV2) GetResults(ctx context.Context) ([]ValidationResult_SdkV2, bool) {
	if m.Results.IsNull() || m.Results.IsUnknown() {
		return nil, false
	}
	var v []ValidationResult_SdkV2
	d := m.Results.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResults sets the value of the Results field in ValidateStorageCredentialResponse_SdkV2.
func (m *ValidateStorageCredentialResponse_SdkV2) SetResults(ctx context.Context, v []ValidationResult_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["results"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Results = types.ListValueMust(t, vs)
}

type ValidationResult_SdkV2 struct {
	// Error message would exist when the result does not equal to **PASS**.
	Message types.String `tfsdk:"message"`
	// The operation tested.
	Operation types.String `tfsdk:"operation"`
	// The results of the tested operation.
	Result types.String `tfsdk:"result"`
}

func (to *ValidationResult_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ValidationResult_SdkV2) {
}

func (to *ValidationResult_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ValidationResult_SdkV2) {
}

func (m ValidationResult_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetOptional()
	attrs["operation"] = attrs["operation"].SetOptional()
	attrs["result"] = attrs["result"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidationResult.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ValidationResult_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidationResult_SdkV2
// only implements ToObjectValue() and Type().
func (m ValidationResult_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message":   m.Message,
			"operation": m.Operation,
			"result":    m.Result,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ValidationResult_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message":   types.StringType,
			"operation": types.StringType,
			"result":    types.StringType,
		},
	}
}

type VolumeInfo_SdkV2 struct {
	// The AWS access point to use when accesing s3 for this external location.
	AccessPoint types.String `tfsdk:"access_point"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog where the schema and the volume are
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the volume
	Comment types.String `tfsdk:"comment"`

	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the volume
	CreatedBy types.String `tfsdk:"created_by"`

	EncryptionDetails types.List `tfsdk:"encryption_details"`
	// The three-level (fully qualified) name of the volume
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the metastore
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the volume
	Name types.String `tfsdk:"name"`
	// The identifier of the user who owns the volume
	Owner types.String `tfsdk:"owner"`
	// The name of the schema where the volume is
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud
	StorageLocation types.String `tfsdk:"storage_location"`

	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the volume last time
	UpdatedBy types.String `tfsdk:"updated_by"`
	// The unique identifier of the volume
	VolumeId types.String `tfsdk:"volume_id"`
	// The type of the volume. An external volume is located in the specified
	// external location. A managed volume is located in the default location
	// which is specified by the parent schema, or the parent catalog, or the
	// Metastore. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/aws/en/volumes/managed-vs-external
	VolumeType types.String `tfsdk:"volume_type"`
}

func (to *VolumeInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from VolumeInfo_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				// Recursively sync the fields of EncryptionDetails
				toEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
}

func (to *VolumeInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from VolumeInfo_SdkV2) {
	if !from.EncryptionDetails.IsNull() && !from.EncryptionDetails.IsUnknown() {
		if toEncryptionDetails, ok := to.GetEncryptionDetails(ctx); ok {
			if fromEncryptionDetails, ok := from.GetEncryptionDetails(ctx); ok {
				toEncryptionDetails.SyncFieldsDuringRead(ctx, fromEncryptionDetails)
				to.SetEncryptionDetails(ctx, toEncryptionDetails)
			}
		}
	}
}

func (m VolumeInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_point"] = attrs["access_point"].SetComputed()
	attrs["browse_only"] = attrs["browse_only"].SetComputed()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetComputed()
	attrs["encryption_details"] = attrs["encryption_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["full_name"] = attrs["full_name"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetComputed()
	attrs["updated_by"] = attrs["updated_by"].SetComputed()
	attrs["volume_id"] = attrs["volume_id"].SetComputed()
	attrs["volume_type"] = attrs["volume_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in VolumeInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m VolumeInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, VolumeInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m VolumeInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_point":       m.AccessPoint,
			"browse_only":        m.BrowseOnly,
			"catalog_name":       m.CatalogName,
			"comment":            m.Comment,
			"created_at":         m.CreatedAt,
			"created_by":         m.CreatedBy,
			"encryption_details": m.EncryptionDetails,
			"full_name":          m.FullName,
			"metastore_id":       m.MetastoreId,
			"name":               m.Name,
			"owner":              m.Owner,
			"schema_name":        m.SchemaName,
			"storage_location":   m.StorageLocation,
			"updated_at":         m.UpdatedAt,
			"updated_by":         m.UpdatedBy,
			"volume_id":          m.VolumeId,
			"volume_type":        m.VolumeType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m VolumeInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_point": types.StringType,
			"browse_only":  types.BoolType,
			"catalog_name": types.StringType,
			"comment":      types.StringType,
			"created_at":   types.Int64Type,
			"created_by":   types.StringType,
			"encryption_details": basetypes.ListType{
				ElemType: EncryptionDetails_SdkV2{}.Type(ctx),
			},
			"full_name":        types.StringType,
			"metastore_id":     types.StringType,
			"name":             types.StringType,
			"owner":            types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
			"volume_id":        types.StringType,
			"volume_type":      types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in VolumeInfo_SdkV2 as
// a EncryptionDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *VolumeInfo_SdkV2) GetEncryptionDetails(ctx context.Context) (EncryptionDetails_SdkV2, bool) {
	var e EncryptionDetails_SdkV2
	if m.EncryptionDetails.IsNull() || m.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v []EncryptionDetails_SdkV2
	d := m.EncryptionDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in VolumeInfo_SdkV2.
func (m *VolumeInfo_SdkV2) SetEncryptionDetails(ctx context.Context, v EncryptionDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["encryption_details"]
	m.EncryptionDetails = types.ListValueMust(t, vs)
}

type WorkspaceBinding_SdkV2 struct {
	// One of READ_WRITE/READ_ONLY. Default is READ_WRITE.
	BindingType types.String `tfsdk:"binding_type"`
	// Required
	WorkspaceId types.Int64 `tfsdk:"workspace_id"`
}

func (to *WorkspaceBinding_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from WorkspaceBinding_SdkV2) {
}

func (to *WorkspaceBinding_SdkV2) SyncFieldsDuringRead(ctx context.Context, from WorkspaceBinding_SdkV2) {
}

func (m WorkspaceBinding_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["binding_type"] = attrs["binding_type"].SetOptional()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WorkspaceBinding.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m WorkspaceBinding_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WorkspaceBinding_SdkV2
// only implements ToObjectValue() and Type().
func (m WorkspaceBinding_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"binding_type": m.BindingType,
			"workspace_id": m.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m WorkspaceBinding_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"binding_type": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}
