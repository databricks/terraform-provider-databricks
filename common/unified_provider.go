package common

import (
	"context"
	"fmt"
	"regexp"

	"github.com/databricks/databricks-sdk-go"
	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/config"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// workspaceIDSchemaKey is the key for the workspace ID in schema
const workspaceIDSchemaKey = "provider_config.0.workspace_id"

// Namespace stores the provider configurations for unified terraform provider
// This should be kept in sync with Namespace for plugin framework resources and data sources
// defined in internal/providers/pluginfw/tfschema/unified_provider.go
// and for autogenerated resources.
type Namespace struct {
	ProviderConfig *ProviderConfig `json:"provider_config,omitempty"`
}

// ProviderConfig is used to store the provider configurations for unified terraform provider
// across resources onboarded to SDKv2.
type ProviderConfig struct {
	WorkspaceID string `json:"workspace_id"`
}

// workspaceIDValidateFunc is used to validate the workspace ID for the provider configuration
func workspaceIDValidateFunc() func(interface{}, string) ([]string, []error) {
	return validation.All(
		validation.StringIsNotEmpty,
		validation.StringMatch(regexp.MustCompile(`^[1-9]\d*$`), "workspace_id must be a positive integer without leading zeros"),
	)
}

// AddNamespaceInSchema adds the provider_config schema to the given schema map.
// This is used by resources and data sources that are developed over SDKv2 and not using Go SDK
// that manually defines the schema without Structs
func AddNamespaceInSchema(m map[string]*schema.Schema) map[string]*schema.Schema {
	// panic if provider_config already exists in the schema map
	if _, ok := m["provider_config"]; ok {
		panic("provider_config already exists in schema map")
	}
	m["provider_config"] = &schema.Schema{
		Type:     schema.TypeList,
		Optional: true,
		MaxItems: 1,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"workspace_id": {
					Type:     schema.TypeString,
					Required: true,
				},
			},
		},
	}
	return m
}

// NamespaceCustomizeSchema is used to customize the schema for the provider configuration
// for a single schema.
func NamespaceCustomizeSchema(s *CustomizableSchema) {
	s.SchemaPath("provider_config", "workspace_id").SetValidateFunc(workspaceIDValidateFunc())
}

// NamespaceCustomizeSchemaMap is used to customize the schema for the provider configuration
// in a map of schemas.
func NamespaceCustomizeSchemaMap(m map[string]*schema.Schema) map[string]*schema.Schema {
	providerConfig, ok := m["provider_config"]
	if !ok {
		panic("provider_config not found in schema")
	}
	elem, ok := providerConfig.Elem.(*schema.Resource)
	if !ok {
		panic("provider_config.Elem is not a *schema.Resource")
	}
	if workspaceID, ok := elem.Schema["workspace_id"]; ok {
		workspaceID.ValidateFunc = workspaceIDValidateFunc()
	}
	return m
}

// namespaceForceNew marks the workspace_id field as ForceNew if it changed.
func namespaceForceNew(d *schema.ResourceDiff) error {
	workspaceIDKey := workspaceIDSchemaKey
	oldWorkspaceID, newWorkspaceID := d.GetChange(workspaceIDKey)
	if oldWorkspaceID != "" && newWorkspaceID != "" && oldWorkspaceID != newWorkspaceID {
		if err := d.ForceNew(workspaceIDKey); err != nil {
			return err
		}
	}
	return nil
}

// namespaceValidateWorkspaceID validates that the workspace_id in provider_config
// is reachable during the plan phase.
// For workspace-level providers, it checks that the workspace_id matches the provider's workspace.
// For account-level providers, it checks that the workspace is accessible from the account.
// This is a no-op when provider_config is not set.
func namespaceValidateWorkspaceID(ctx context.Context, d *schema.ResourceDiff, c *DatabricksClient) error {
	_, newWorkspaceID := d.GetChange(workspaceIDSchemaKey)
	newWSID, ok := newWorkspaceID.(string)
	if !ok || newWSID == "" {
		return nil
	}
	workspaceIDInt, err := parseWorkspaceID(newWSID)
	if err != nil {
		return err
	}
	if c.Config.HostType() != config.WorkspaceHost {
		_, err := c.WorkspaceClientForWorkspace(ctx, workspaceIDInt)
		if err != nil {
			return fmt.Errorf("failed to get workspace client with workspace_id %d: %w", workspaceIDInt, err)
		}
		return nil
	}
	w, err := c.WorkspaceClient()
	if err != nil {
		return err
	}
	err = c.validateWorkspaceIDFromProvider(ctx, workspaceIDInt, w)
	if err != nil {
		return fmt.Errorf("failed to validate workspace_id: %w", err)
	}
	return nil
}

// NamespaceCustomizeDiff is used to customize the diff for the provider configuration
// in a resource diff.
func NamespaceCustomizeDiff(ctx context.Context, d *schema.ResourceDiff, c *DatabricksClient) error {
	if err := namespaceForceNew(d); err != nil {
		return err
	}
	return namespaceValidateWorkspaceID(ctx, d, c)
}

// WorkspaceClientUnifiedProvider returns the WorkspaceClient for the workspace ID from the resource data
// This is used by resources and data sources that are developed over SDKv2.
func (c *DatabricksClient) WorkspaceClientUnifiedProvider(ctx context.Context, d *schema.ResourceData) (*databricks.WorkspaceClient, error) {
	workspaceIDFromSchema := d.Get(workspaceIDSchemaKey)
	// workspace_id does not exist in the resource data
	if workspaceIDFromSchema == nil {
		return c.GetWorkspaceClientForUnifiedProvider(ctx, "")
	}
	var workspaceID string
	workspaceID, ok := workspaceIDFromSchema.(string)
	if !ok {
		return nil, fmt.Errorf("workspace_id must be a string")
	}
	return c.GetWorkspaceClientForUnifiedProvider(ctx, workspaceID)
}

// DatabricksClientForUnifiedProvider returns a new Databricks Client for the workspace ID from the resource data
// This is used by resources and data sources that are developed
// over SDKv2 and are not using Go SDK.
func (c *DatabricksClient) DatabricksClientForUnifiedProvider(ctx context.Context, d *schema.ResourceData) (*DatabricksClient, error) {
	workspaceIDFromResourceData := d.Get(workspaceIDSchemaKey)
	// workspace_id does not exist in the resource data
	// so we don't need to create a new client
	// and can return the current client.
	if workspaceIDFromResourceData == nil {
		return c, nil
	}
	var workspaceID string
	workspaceID, ok := workspaceIDFromResourceData.(string)
	if !ok {
		return nil, fmt.Errorf("workspace_id must be a string")
	}
	// If the workspace_id is not passed in the resource configuration, we don't need to create a new client
	// and can return the current client.
	if workspaceID == "" {
		return c, nil
	}
	return c.getDatabricksClientForUnifiedProvider(ctx, workspaceID)
}

// getDatabricksClientForUnifiedProvider returns the Databricks Client for the workspace ID from the resource data
// This is used by resources and data sources that are developed
// over SDKv2 and are not using Go SDK.
func (c *DatabricksClient) getDatabricksClientForUnifiedProvider(ctx context.Context, workspaceID string) (*DatabricksClient, error) {
	workspaceIDInt, err := parseWorkspaceID(workspaceID)
	if err != nil {
		return nil, err
	}

	// If the Databricks Client is cached, we use it
	if c.cachedDatabricksClients != nil {
		if client, ok := c.cachedDatabricksClients[workspaceIDInt]; ok && client != nil {
			return &DatabricksClient{
				DatabricksClient: client,
			}, nil
		}
	}

	// If the Databricks Client is not cached, we create a client
	// and cache it.
	err = c.setCachedDatabricksClient(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	// Return the Databricks Client.
	return &DatabricksClient{
		DatabricksClient: c.cachedDatabricksClients[workspaceIDInt],
	}, nil
}

// setCachedDatabricksClient sets the cached Databricks Client.
func (c *DatabricksClient) setCachedDatabricksClient(ctx context.Context, workspaceID string) error {
	// Acquire the lock to avoid race conditions.
	c.muLegacy.Lock()
	defer c.muLegacy.Unlock()

	// Initialize the map if it's nil
	if c.cachedDatabricksClients == nil {
		c.cachedDatabricksClients = make(map[int64]*client.DatabricksClient)
	}

	workspaceIDInt, err := parseWorkspaceID(workspaceID)
	if err != nil {
		return err
	}

	// Double checked locking
	if existingClient, ok := c.cachedDatabricksClients[workspaceIDInt]; ok && existingClient != nil {
		return nil
	}

	// Get the workspace client for the workspace ID
	workspaceClient, err := c.GetWorkspaceClientForUnifiedProvider(ctx, workspaceID)
	if err != nil {
		return err
	}

	// Create a new Databricks Client with the same configuration
	// as the workspace client
	newClient, err := client.New(workspaceClient.Config)
	if err != nil {
		return err
	}
	c.cachedDatabricksClients[workspaceIDInt] = newClient
	return nil
}
