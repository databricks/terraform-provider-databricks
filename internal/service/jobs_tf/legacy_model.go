// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package jobs_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/databricks/terraform-provider-databricks/internal/service/compute_tf" // .tmpl
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type BaseJob_SdkV2 struct {
	// The time at which this job was created in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC).
	CreatedTime types.Int64 `tfsdk:"created_time"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// The id of the budget policy used by this job for cost attribution
	// purposes. This may be set through (in order of precedence): 1. Budget
	// admins through the account or workspace console 2. Jobs UI in the job
	// details page and Jobs API using `budget_policy_id` 3. Inferred default
	// based on accessible budget policies of the run_as identity on job
	// creation or modification.
	EffectiveBudgetPolicyId types.String `tfsdk:"effective_budget_policy_id"`
	// The id of the usage policy used by this job for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// Indicates if the job has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/get endpoint.
	// It is only relevant for API 2.2 :method:jobs/list requests with
	// `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// The canonical identifier for this job.
	JobId types.Int64 `tfsdk:"job_id"`
	// Settings for this job and all of its runs. These settings can be updated
	// using the `resetJob` method.
	Settings types.List `tfsdk:"settings"`
	// State of the trigger associated with the job.
	TriggerState types.List `tfsdk:"trigger_state"`
}

func (to *BaseJob_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from BaseJob_SdkV2) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				// Recursively sync the fields of Settings
				toSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				// Recursively sync the fields of TriggerState
				toTriggerState.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (to *BaseJob_SdkV2) SyncFieldsDuringRead(ctx context.Context, from BaseJob_SdkV2) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				toSettings.SyncFieldsDuringRead(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				toTriggerState.SyncFieldsDuringRead(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (m BaseJob_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["created_time"] = attrs["created_time"].SetOptional()
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["effective_budget_policy_id"] = attrs["effective_budget_policy_id"].SetComputed()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["settings"] = attrs["settings"].SetOptional()
	attrs["settings"] = attrs["settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["trigger_state"] = attrs["trigger_state"].SetComputed()
	attrs["trigger_state"] = attrs["trigger_state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BaseJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m BaseJob_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"settings":      reflect.TypeOf(JobSettings_SdkV2{}),
		"trigger_state": reflect.TypeOf(TriggerStateProto_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BaseJob_SdkV2
// only implements ToObjectValue() and Type().
func (m BaseJob_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"created_time":               m.CreatedTime,
			"creator_user_name":          m.CreatorUserName,
			"effective_budget_policy_id": m.EffectiveBudgetPolicyId,
			"effective_usage_policy_id":  m.EffectiveUsagePolicyId,
			"has_more":                   m.HasMore,
			"job_id":                     m.JobId,
			"settings":                   m.Settings,
			"trigger_state":              m.TriggerState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m BaseJob_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"created_time":               types.Int64Type,
			"creator_user_name":          types.StringType,
			"effective_budget_policy_id": types.StringType,
			"effective_usage_policy_id":  types.StringType,
			"has_more":                   types.BoolType,
			"job_id":                     types.Int64Type,
			"settings": basetypes.ListType{
				ElemType: JobSettings_SdkV2{}.Type(ctx),
			},
			"trigger_state": basetypes.ListType{
				ElemType: TriggerStateProto_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSettings returns the value of the Settings field in BaseJob_SdkV2 as
// a JobSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseJob_SdkV2) GetSettings(ctx context.Context) (JobSettings_SdkV2, bool) {
	var e JobSettings_SdkV2
	if m.Settings.IsNull() || m.Settings.IsUnknown() {
		return e, false
	}
	var v []JobSettings_SdkV2
	d := m.Settings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSettings sets the value of the Settings field in BaseJob_SdkV2.
func (m *BaseJob_SdkV2) SetSettings(ctx context.Context, v JobSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["settings"]
	m.Settings = types.ListValueMust(t, vs)
}

// GetTriggerState returns the value of the TriggerState field in BaseJob_SdkV2 as
// a TriggerStateProto_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseJob_SdkV2) GetTriggerState(ctx context.Context) (TriggerStateProto_SdkV2, bool) {
	var e TriggerStateProto_SdkV2
	if m.TriggerState.IsNull() || m.TriggerState.IsUnknown() {
		return e, false
	}
	var v []TriggerStateProto_SdkV2
	d := m.TriggerState.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTriggerState sets the value of the TriggerState field in BaseJob_SdkV2.
func (m *BaseJob_SdkV2) SetTriggerState(ctx context.Context, v TriggerStateProto_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["trigger_state"]
	m.TriggerState = types.ListValueMust(t, vs)
}

type BaseRun_SdkV2 struct {
	// The sequence number of this run attempt for a triggered job run. The
	// initial attempt of a run has an attempt_number of 0. If the initial run
	// attempt fails, and the job has a retry policy (`max_retries` > 0),
	// subsequent runs are created with an `original_attempt_run_id` of the
	// original attempt’s ID and an incrementing `attempt_number`. Runs are
	// retried only until they succeed, and the maximum `attempt_number` is the
	// same as the `max_retries` value for the job.
	AttemptNumber types.Int64 `tfsdk:"attempt_number"`
	// The time in milliseconds it took to terminate the cluster and clean up
	// any associated artifacts. The duration of a task run is the sum of the
	// `setup_duration`, `execution_duration`, and the `cleanup_duration`. The
	// `cleanup_duration` field is set to 0 for multitask job runs. The total
	// duration of a multitask job run is the value of the `run_duration` field.
	CleanupDuration types.Int64 `tfsdk:"cleanup_duration"`
	// The cluster used for this run. If the run is specified to use a new
	// cluster, this field is set once the Jobs service has requested a cluster
	// for the run.
	ClusterInstance types.List `tfsdk:"cluster_instance"`
	// A snapshot of the job’s cluster specification when this run was
	// created.
	ClusterSpec types.List `tfsdk:"cluster_spec"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// Description of the run
	Description types.String `tfsdk:"description"`
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// The id of the usage policy used by this run for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// The time at which this run ended in epoch milliseconds (milliseconds
	// since 1/1/1970 UTC). This field is set to 0 if the job is still running.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The time in milliseconds it took to execute the commands in the JAR or
	// notebook until they completed, failed, timed out, were cancelled, or
	// encountered an unexpected error. The duration of a task run is the sum of
	// the `setup_duration`, `execution_duration`, and the `cleanup_duration`.
	// The `execution_duration` field is set to 0 for multitask job runs. The
	// total duration of a multitask job run is the value of the `run_duration`
	// field.
	ExecutionDuration types.Int64 `tfsdk:"execution_duration"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.List `tfsdk:"git_source"`
	// Indicates if the run has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/getrun
	// endpoint. It is only relevant for API 2.2 :method:jobs/listruns requests
	// with `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings. If more than 100
	// job clusters are available, you can paginate through them using
	// :method:jobs/getrun.
	JobClusters types.List `tfsdk:"job_clusters"`
	// The canonical identifier of the job that contains this run.
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used in the run
	JobParameters types.List `tfsdk:"job_parameters"`
	// ID of the job run that this run belongs to. For legacy and single-task
	// job runs the field is populated with the job run ID. For task runs, the
	// field is populated with the ID of the job run that the task run belongs
	// to.
	JobRunId types.Int64 `tfsdk:"job_run_id"`
	// A unique identifier for this job run. This is set to the same value as
	// `run_id`.
	NumberInJob types.Int64 `tfsdk:"number_in_job"`
	// If this run is a retry of a prior run attempt, this field contains the
	// run_id of the original attempt; otherwise, it is the same as the run_id.
	OriginalAttemptRunId types.Int64 `tfsdk:"original_attempt_run_id"`
	// The parameters used for this run.
	OverridingParameters types.List `tfsdk:"overriding_parameters"`
	// The time in milliseconds that the run has spent in the queue.
	QueueDuration types.Int64 `tfsdk:"queue_duration"`
	// The repair history of the run.
	RepairHistory types.List `tfsdk:"repair_history"`
	// The time in milliseconds it took the job run and all of its repairs to
	// finish.
	RunDuration types.Int64 `tfsdk:"run_duration"`
	// The canonical identifier of the run. This ID is unique across all runs of
	// all jobs.
	RunId types.Int64 `tfsdk:"run_id"`
	// An optional name for the run. The maximum length is 4096 bytes in UTF-8
	// encoding.
	RunName types.String `tfsdk:"run_name"`
	// The URL to the detail page of the run.
	RunPageUrl types.String `tfsdk:"run_page_url"`

	RunType types.String `tfsdk:"run_type"`
	// The cron schedule that triggered this run if it was triggered by the
	// periodic scheduler.
	Schedule types.List `tfsdk:"schedule"`
	// The time in milliseconds it took to set up the cluster. For runs that run
	// on new clusters this is the cluster creation time, for runs that run on
	// existing clusters this time should be very short. The duration of a task
	// run is the sum of the `setup_duration`, `execution_duration`, and the
	// `cleanup_duration`. The `setup_duration` field is set to 0 for multitask
	// job runs. The total duration of a multitask job run is the value of the
	// `run_duration` field.
	SetupDuration types.Int64 `tfsdk:"setup_duration"`
	// The time at which this run was started in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC). This may not be the time when the job
	// task starts executing, for example, if the job is scheduled to run on a
	// new cluster, this is the time the cluster creation call is issued.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.List `tfsdk:"state"`

	Status types.List `tfsdk:"status"`
	// The list of tasks performed by the run. Each task has its own `run_id`
	// which you can use to call `JobsGetOutput` to retrieve the run resutls. If
	// more than 100 tasks are available, you can paginate through them using
	// :method:jobs/getrun. Use the `next_page_token` field at the object root
	// to determine if more results are available.
	Tasks types.List `tfsdk:"tasks"`

	Trigger types.String `tfsdk:"trigger"`

	TriggerInfo types.List `tfsdk:"trigger_info"`
}

func (to *BaseRun_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from BaseRun_SdkV2) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				// Recursively sync the fields of ClusterInstance
				toClusterInstance.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				// Recursively sync the fields of ClusterSpec
				toClusterSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				// Recursively sync the fields of OverridingParameters
				toOverridingParameters.SyncFieldsDuringCreateOrUpdate(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				// Recursively sync the fields of TriggerInfo
				toTriggerInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (to *BaseRun_SdkV2) SyncFieldsDuringRead(ctx context.Context, from BaseRun_SdkV2) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				toClusterInstance.SyncFieldsDuringRead(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				toClusterSpec.SyncFieldsDuringRead(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				toOverridingParameters.SyncFieldsDuringRead(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				toTriggerInfo.SyncFieldsDuringRead(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (m BaseRun_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attempt_number"] = attrs["attempt_number"].SetOptional()
	attrs["cleanup_duration"] = attrs["cleanup_duration"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cluster_spec"] = attrs["cluster_spec"].SetOptional()
	attrs["cluster_spec"] = attrs["cluster_spec"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetOptional()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["execution_duration"] = attrs["execution_duration"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["git_source"] = attrs["git_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["job_clusters"] = attrs["job_clusters"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["job_run_id"] = attrs["job_run_id"].SetOptional()
	attrs["number_in_job"] = attrs["number_in_job"].SetOptional()
	attrs["original_attempt_run_id"] = attrs["original_attempt_run_id"].SetOptional()
	attrs["overriding_parameters"] = attrs["overriding_parameters"].SetOptional()
	attrs["overriding_parameters"] = attrs["overriding_parameters"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["queue_duration"] = attrs["queue_duration"].SetOptional()
	attrs["repair_history"] = attrs["repair_history"].SetOptional()
	attrs["run_duration"] = attrs["run_duration"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_name"] = attrs["run_name"].SetOptional()
	attrs["run_page_url"] = attrs["run_page_url"].SetOptional()
	attrs["run_type"] = attrs["run_type"].SetOptional()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["setup_duration"] = attrs["setup_duration"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["state"] = attrs["state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["status"] = attrs["status"].SetOptional()
	attrs["status"] = attrs["status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["tasks"] = attrs["tasks"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["trigger_info"] = attrs["trigger_info"].SetOptional()
	attrs["trigger_info"] = attrs["trigger_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BaseRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m BaseRun_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"cluster_instance":      reflect.TypeOf(ClusterInstance_SdkV2{}),
		"cluster_spec":          reflect.TypeOf(ClusterSpec_SdkV2{}),
		"git_source":            reflect.TypeOf(GitSource_SdkV2{}),
		"job_clusters":          reflect.TypeOf(JobCluster_SdkV2{}),
		"job_parameters":        reflect.TypeOf(JobParameter_SdkV2{}),
		"overriding_parameters": reflect.TypeOf(RunParameters_SdkV2{}),
		"repair_history":        reflect.TypeOf(RepairHistoryItem_SdkV2{}),
		"schedule":              reflect.TypeOf(CronSchedule_SdkV2{}),
		"state":                 reflect.TypeOf(RunState_SdkV2{}),
		"status":                reflect.TypeOf(RunStatus_SdkV2{}),
		"tasks":                 reflect.TypeOf(RunTask_SdkV2{}),
		"trigger_info":          reflect.TypeOf(TriggerInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BaseRun_SdkV2
// only implements ToObjectValue() and Type().
func (m BaseRun_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attempt_number":               m.AttemptNumber,
			"cleanup_duration":             m.CleanupDuration,
			"cluster_instance":             m.ClusterInstance,
			"cluster_spec":                 m.ClusterSpec,
			"creator_user_name":            m.CreatorUserName,
			"description":                  m.Description,
			"effective_performance_target": m.EffectivePerformanceTarget,
			"effective_usage_policy_id":    m.EffectiveUsagePolicyId,
			"end_time":                     m.EndTime,
			"execution_duration":           m.ExecutionDuration,
			"git_source":                   m.GitSource,
			"has_more":                     m.HasMore,
			"job_clusters":                 m.JobClusters,
			"job_id":                       m.JobId,
			"job_parameters":               m.JobParameters,
			"job_run_id":                   m.JobRunId,
			"number_in_job":                m.NumberInJob,
			"original_attempt_run_id":      m.OriginalAttemptRunId,
			"overriding_parameters":        m.OverridingParameters,
			"queue_duration":               m.QueueDuration,
			"repair_history":               m.RepairHistory,
			"run_duration":                 m.RunDuration,
			"run_id":                       m.RunId,
			"run_name":                     m.RunName,
			"run_page_url":                 m.RunPageUrl,
			"run_type":                     m.RunType,
			"schedule":                     m.Schedule,
			"setup_duration":               m.SetupDuration,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"tasks":                        m.Tasks,
			"trigger":                      m.Trigger,
			"trigger_info":                 m.TriggerInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m BaseRun_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attempt_number":   types.Int64Type,
			"cleanup_duration": types.Int64Type,
			"cluster_instance": basetypes.ListType{
				ElemType: ClusterInstance_SdkV2{}.Type(ctx),
			},
			"cluster_spec": basetypes.ListType{
				ElemType: ClusterSpec_SdkV2{}.Type(ctx),
			},
			"creator_user_name":            types.StringType,
			"description":                  types.StringType,
			"effective_performance_target": types.StringType,
			"effective_usage_policy_id":    types.StringType,
			"end_time":                     types.Int64Type,
			"execution_duration":           types.Int64Type,
			"git_source": basetypes.ListType{
				ElemType: GitSource_SdkV2{}.Type(ctx),
			},
			"has_more": types.BoolType,
			"job_clusters": basetypes.ListType{
				ElemType: JobCluster_SdkV2{}.Type(ctx),
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.ListType{
				ElemType: JobParameter_SdkV2{}.Type(ctx),
			},
			"job_run_id":              types.Int64Type,
			"number_in_job":           types.Int64Type,
			"original_attempt_run_id": types.Int64Type,
			"overriding_parameters": basetypes.ListType{
				ElemType: RunParameters_SdkV2{}.Type(ctx),
			},
			"queue_duration": types.Int64Type,
			"repair_history": basetypes.ListType{
				ElemType: RepairHistoryItem_SdkV2{}.Type(ctx),
			},
			"run_duration": types.Int64Type,
			"run_id":       types.Int64Type,
			"run_name":     types.StringType,
			"run_page_url": types.StringType,
			"run_type":     types.StringType,
			"schedule": basetypes.ListType{
				ElemType: CronSchedule_SdkV2{}.Type(ctx),
			},
			"setup_duration": types.Int64Type,
			"start_time":     types.Int64Type,
			"state": basetypes.ListType{
				ElemType: RunState_SdkV2{}.Type(ctx),
			},
			"status": basetypes.ListType{
				ElemType: RunStatus_SdkV2{}.Type(ctx),
			},
			"tasks": basetypes.ListType{
				ElemType: RunTask_SdkV2{}.Type(ctx),
			},
			"trigger": types.StringType,
			"trigger_info": basetypes.ListType{
				ElemType: TriggerInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetClusterInstance returns the value of the ClusterInstance field in BaseRun_SdkV2 as
// a ClusterInstance_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetClusterInstance(ctx context.Context) (ClusterInstance_SdkV2, bool) {
	var e ClusterInstance_SdkV2
	if m.ClusterInstance.IsNull() || m.ClusterInstance.IsUnknown() {
		return e, false
	}
	var v []ClusterInstance_SdkV2
	d := m.ClusterInstance.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetClusterInstance sets the value of the ClusterInstance field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetClusterInstance(ctx context.Context, v ClusterInstance_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cluster_instance"]
	m.ClusterInstance = types.ListValueMust(t, vs)
}

// GetClusterSpec returns the value of the ClusterSpec field in BaseRun_SdkV2 as
// a ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetClusterSpec(ctx context.Context) (ClusterSpec_SdkV2, bool) {
	var e ClusterSpec_SdkV2
	if m.ClusterSpec.IsNull() || m.ClusterSpec.IsUnknown() {
		return e, false
	}
	var v []ClusterSpec_SdkV2
	d := m.ClusterSpec.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetClusterSpec sets the value of the ClusterSpec field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetClusterSpec(ctx context.Context, v ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cluster_spec"]
	m.ClusterSpec = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in BaseRun_SdkV2 as
// a GitSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetGitSource(ctx context.Context) (GitSource_SdkV2, bool) {
	var e GitSource_SdkV2
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v []GitSource_SdkV2
	d := m.GitSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSource sets the value of the GitSource field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetGitSource(ctx context.Context, v GitSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_source"]
	m.GitSource = types.ListValueMust(t, vs)
}

// GetJobClusters returns the value of the JobClusters field in BaseRun_SdkV2 as
// a slice of JobCluster_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetJobClusters(ctx context.Context) ([]JobCluster_SdkV2, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster_SdkV2
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetJobClusters(ctx context.Context, v []JobCluster_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_clusters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in BaseRun_SdkV2 as
// a slice of JobParameter_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetJobParameters(ctx context.Context) ([]JobParameter_SdkV2, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameter_SdkV2
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetJobParameters(ctx context.Context, v []JobParameter_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.ListValueMust(t, vs)
}

// GetOverridingParameters returns the value of the OverridingParameters field in BaseRun_SdkV2 as
// a RunParameters_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetOverridingParameters(ctx context.Context) (RunParameters_SdkV2, bool) {
	var e RunParameters_SdkV2
	if m.OverridingParameters.IsNull() || m.OverridingParameters.IsUnknown() {
		return e, false
	}
	var v []RunParameters_SdkV2
	d := m.OverridingParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetOverridingParameters sets the value of the OverridingParameters field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetOverridingParameters(ctx context.Context, v RunParameters_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["overriding_parameters"]
	m.OverridingParameters = types.ListValueMust(t, vs)
}

// GetRepairHistory returns the value of the RepairHistory field in BaseRun_SdkV2 as
// a slice of RepairHistoryItem_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetRepairHistory(ctx context.Context) ([]RepairHistoryItem_SdkV2, bool) {
	if m.RepairHistory.IsNull() || m.RepairHistory.IsUnknown() {
		return nil, false
	}
	var v []RepairHistoryItem_SdkV2
	d := m.RepairHistory.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRepairHistory sets the value of the RepairHistory field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetRepairHistory(ctx context.Context, v []RepairHistoryItem_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["repair_history"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RepairHistory = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in BaseRun_SdkV2 as
// a CronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetSchedule(ctx context.Context) (CronSchedule_SdkV2, bool) {
	var e CronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []CronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetSchedule(ctx context.Context, v CronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetState returns the value of the State field in BaseRun_SdkV2 as
// a RunState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetState(ctx context.Context) (RunState_SdkV2, bool) {
	var e RunState_SdkV2
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v []RunState_SdkV2
	d := m.State.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetState sets the value of the State field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetState(ctx context.Context, v RunState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["state"]
	m.State = types.ListValueMust(t, vs)
}

// GetStatus returns the value of the Status field in BaseRun_SdkV2 as
// a RunStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetStatus(ctx context.Context) (RunStatus_SdkV2, bool) {
	var e RunStatus_SdkV2
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v []RunStatus_SdkV2
	d := m.Status.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetStatus sets the value of the Status field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetStatus(ctx context.Context, v RunStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["status"]
	m.Status = types.ListValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in BaseRun_SdkV2 as
// a slice of RunTask_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetTasks(ctx context.Context) ([]RunTask_SdkV2, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []RunTask_SdkV2
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetTasks(ctx context.Context, v []RunTask_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTriggerInfo returns the value of the TriggerInfo field in BaseRun_SdkV2 as
// a TriggerInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun_SdkV2) GetTriggerInfo(ctx context.Context) (TriggerInfo_SdkV2, bool) {
	var e TriggerInfo_SdkV2
	if m.TriggerInfo.IsNull() || m.TriggerInfo.IsUnknown() {
		return e, false
	}
	var v []TriggerInfo_SdkV2
	d := m.TriggerInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTriggerInfo sets the value of the TriggerInfo field in BaseRun_SdkV2.
func (m *BaseRun_SdkV2) SetTriggerInfo(ctx context.Context, v TriggerInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["trigger_info"]
	m.TriggerInfo = types.ListValueMust(t, vs)
}

type CancelAllRuns_SdkV2 struct {
	// Optional boolean parameter to cancel all queued runs. If no job_id is
	// provided, all queued runs in the workspace are canceled.
	AllQueuedRuns types.Bool `tfsdk:"all_queued_runs"`
	// The canonical identifier of the job to cancel all runs of.
	JobId types.Int64 `tfsdk:"job_id"`
}

func (to *CancelAllRuns_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelAllRuns_SdkV2) {
}

func (to *CancelAllRuns_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CancelAllRuns_SdkV2) {
}

func (m CancelAllRuns_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["all_queued_runs"] = attrs["all_queued_runs"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelAllRuns.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelAllRuns_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelAllRuns_SdkV2
// only implements ToObjectValue() and Type().
func (m CancelAllRuns_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"all_queued_runs": m.AllQueuedRuns,
			"job_id":          m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CancelAllRuns_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"all_queued_runs": types.BoolType,
			"job_id":          types.Int64Type,
		},
	}
}

type CancelRun_SdkV2 struct {
	// This field is required.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *CancelRun_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelRun_SdkV2) {
}

func (to *CancelRun_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CancelRun_SdkV2) {
}

func (m CancelRun_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelRun_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelRun_SdkV2
// only implements ToObjectValue() and Type().
func (m CancelRun_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CancelRun_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

// Stores the run state of the clean rooms notebook task.
type CleanRoomTaskRunState_SdkV2 struct {
	// A value indicating the run's current lifecycle state. This field is
	// always available in the response. Note: Additional states might be
	// introduced in future releases.
	LifeCycleState types.String `tfsdk:"life_cycle_state"`
	// A value indicating the run's result. This field is only available for
	// terminal lifecycle states. Note: Additional states might be introduced in
	// future releases.
	ResultState types.String `tfsdk:"result_state"`
}

func (to *CleanRoomTaskRunState_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CleanRoomTaskRunState_SdkV2) {
}

func (to *CleanRoomTaskRunState_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CleanRoomTaskRunState_SdkV2) {
}

func (m CleanRoomTaskRunState_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["life_cycle_state"] = attrs["life_cycle_state"].SetOptional()
	attrs["result_state"] = attrs["result_state"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CleanRoomTaskRunState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CleanRoomTaskRunState_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CleanRoomTaskRunState_SdkV2
// only implements ToObjectValue() and Type().
func (m CleanRoomTaskRunState_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"life_cycle_state": m.LifeCycleState,
			"result_state":     m.ResultState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CleanRoomTaskRunState_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"life_cycle_state": types.StringType,
			"result_state":     types.StringType,
		},
	}
}

type CleanRoomsNotebookTask_SdkV2 struct {
	// The clean room that the notebook belongs to.
	CleanRoomName types.String `tfsdk:"clean_room_name"`
	// Checksum to validate the freshness of the notebook resource (i.e. the
	// notebook being run is the latest version). It can be fetched by calling
	// the :method:cleanroomassets/get API.
	Etag types.String `tfsdk:"etag"`
	// Base parameters to be used for the clean room notebook job.
	NotebookBaseParameters types.Map `tfsdk:"notebook_base_parameters"`
	// Name of the notebook being run.
	NotebookName types.String `tfsdk:"notebook_name"`
}

func (to *CleanRoomsNotebookTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CleanRoomsNotebookTask_SdkV2) {
}

func (to *CleanRoomsNotebookTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CleanRoomsNotebookTask_SdkV2) {
}

func (m CleanRoomsNotebookTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_room_name"] = attrs["clean_room_name"].SetRequired()
	attrs["etag"] = attrs["etag"].SetOptional()
	attrs["notebook_base_parameters"] = attrs["notebook_base_parameters"].SetOptional()
	attrs["notebook_name"] = attrs["notebook_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CleanRoomsNotebookTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CleanRoomsNotebookTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"notebook_base_parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CleanRoomsNotebookTask_SdkV2
// only implements ToObjectValue() and Type().
func (m CleanRoomsNotebookTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_room_name":          m.CleanRoomName,
			"etag":                     m.Etag,
			"notebook_base_parameters": m.NotebookBaseParameters,
			"notebook_name":            m.NotebookName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CleanRoomsNotebookTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_room_name": types.StringType,
			"etag":            types.StringType,
			"notebook_base_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_name": types.StringType,
		},
	}
}

// GetNotebookBaseParameters returns the value of the NotebookBaseParameters field in CleanRoomsNotebookTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTask_SdkV2) GetNotebookBaseParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookBaseParameters.IsNull() || m.NotebookBaseParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookBaseParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookBaseParameters sets the value of the NotebookBaseParameters field in CleanRoomsNotebookTask_SdkV2.
func (m *CleanRoomsNotebookTask_SdkV2) SetNotebookBaseParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_base_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookBaseParameters = types.MapValueMust(t, vs)
}

type CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2 struct {
	// The run state of the clean rooms notebook task.
	CleanRoomJobRunState types.List `tfsdk:"clean_room_job_run_state"`
	// The notebook output for the clean room run
	NotebookOutput types.List `tfsdk:"notebook_output"`
	// Information on how to access the output schema for the clean room run
	OutputSchemaInfo types.List `tfsdk:"output_schema_info"`
}

func (to *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) {
	if !from.CleanRoomJobRunState.IsNull() && !from.CleanRoomJobRunState.IsUnknown() {
		if toCleanRoomJobRunState, ok := to.GetCleanRoomJobRunState(ctx); ok {
			if fromCleanRoomJobRunState, ok := from.GetCleanRoomJobRunState(ctx); ok {
				// Recursively sync the fields of CleanRoomJobRunState
				toCleanRoomJobRunState.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomJobRunState)
				to.SetCleanRoomJobRunState(ctx, toCleanRoomJobRunState)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				// Recursively sync the fields of NotebookOutput
				toNotebookOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.OutputSchemaInfo.IsNull() && !from.OutputSchemaInfo.IsUnknown() {
		if toOutputSchemaInfo, ok := to.GetOutputSchemaInfo(ctx); ok {
			if fromOutputSchemaInfo, ok := from.GetOutputSchemaInfo(ctx); ok {
				// Recursively sync the fields of OutputSchemaInfo
				toOutputSchemaInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromOutputSchemaInfo)
				to.SetOutputSchemaInfo(ctx, toOutputSchemaInfo)
			}
		}
	}
}

func (to *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) {
	if !from.CleanRoomJobRunState.IsNull() && !from.CleanRoomJobRunState.IsUnknown() {
		if toCleanRoomJobRunState, ok := to.GetCleanRoomJobRunState(ctx); ok {
			if fromCleanRoomJobRunState, ok := from.GetCleanRoomJobRunState(ctx); ok {
				toCleanRoomJobRunState.SyncFieldsDuringRead(ctx, fromCleanRoomJobRunState)
				to.SetCleanRoomJobRunState(ctx, toCleanRoomJobRunState)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				toNotebookOutput.SyncFieldsDuringRead(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.OutputSchemaInfo.IsNull() && !from.OutputSchemaInfo.IsUnknown() {
		if toOutputSchemaInfo, ok := to.GetOutputSchemaInfo(ctx); ok {
			if fromOutputSchemaInfo, ok := from.GetOutputSchemaInfo(ctx); ok {
				toOutputSchemaInfo.SyncFieldsDuringRead(ctx, fromOutputSchemaInfo)
				to.SetOutputSchemaInfo(ctx, toOutputSchemaInfo)
			}
		}
	}
}

func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_room_job_run_state"] = attrs["clean_room_job_run_state"].SetOptional()
	attrs["clean_room_job_run_state"] = attrs["clean_room_job_run_state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notebook_output"] = attrs["notebook_output"].SetOptional()
	attrs["notebook_output"] = attrs["notebook_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["output_schema_info"] = attrs["output_schema_info"].SetOptional()
	attrs["output_schema_info"] = attrs["output_schema_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_room_job_run_state": reflect.TypeOf(CleanRoomTaskRunState_SdkV2{}),
		"notebook_output":          reflect.TypeOf(NotebookOutput_SdkV2{}),
		"output_schema_info":       reflect.TypeOf(OutputSchemaInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_room_job_run_state": m.CleanRoomJobRunState,
			"notebook_output":          m.NotebookOutput,
			"output_schema_info":       m.OutputSchemaInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_room_job_run_state": basetypes.ListType{
				ElemType: CleanRoomTaskRunState_SdkV2{}.Type(ctx),
			},
			"notebook_output": basetypes.ListType{
				ElemType: NotebookOutput_SdkV2{}.Type(ctx),
			},
			"output_schema_info": basetypes.ListType{
				ElemType: OutputSchemaInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCleanRoomJobRunState returns the value of the CleanRoomJobRunState field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2 as
// a CleanRoomTaskRunState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) GetCleanRoomJobRunState(ctx context.Context) (CleanRoomTaskRunState_SdkV2, bool) {
	var e CleanRoomTaskRunState_SdkV2
	if m.CleanRoomJobRunState.IsNull() || m.CleanRoomJobRunState.IsUnknown() {
		return e, false
	}
	var v []CleanRoomTaskRunState_SdkV2
	d := m.CleanRoomJobRunState.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCleanRoomJobRunState sets the value of the CleanRoomJobRunState field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) SetCleanRoomJobRunState(ctx context.Context, v CleanRoomTaskRunState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["clean_room_job_run_state"]
	m.CleanRoomJobRunState = types.ListValueMust(t, vs)
}

// GetNotebookOutput returns the value of the NotebookOutput field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2 as
// a NotebookOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) GetNotebookOutput(ctx context.Context) (NotebookOutput_SdkV2, bool) {
	var e NotebookOutput_SdkV2
	if m.NotebookOutput.IsNull() || m.NotebookOutput.IsUnknown() {
		return e, false
	}
	var v []NotebookOutput_SdkV2
	d := m.NotebookOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotebookOutput sets the value of the NotebookOutput field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) SetNotebookOutput(ctx context.Context, v NotebookOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_output"]
	m.NotebookOutput = types.ListValueMust(t, vs)
}

// GetOutputSchemaInfo returns the value of the OutputSchemaInfo field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2 as
// a OutputSchemaInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) GetOutputSchemaInfo(ctx context.Context) (OutputSchemaInfo_SdkV2, bool) {
	var e OutputSchemaInfo_SdkV2
	if m.OutputSchemaInfo.IsNull() || m.OutputSchemaInfo.IsUnknown() {
		return e, false
	}
	var v []OutputSchemaInfo_SdkV2
	d := m.OutputSchemaInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetOutputSchemaInfo sets the value of the OutputSchemaInfo field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) SetOutputSchemaInfo(ctx context.Context, v OutputSchemaInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["output_schema_info"]
	m.OutputSchemaInfo = types.ListValueMust(t, vs)
}

type ClusterInstance_SdkV2 struct {
	// The canonical identifier for the cluster used by a run. This field is
	// always available for runs on existing clusters. For runs on new clusters,
	// it becomes available once the cluster is created. This value can be used
	// to view logs by browsing to `/#setting/sparkui/$cluster_id/driver-logs`.
	// The logs continue to be available after the run completes.
	//
	// The response won’t include this field if the identifier is not
	// available yet.
	ClusterId types.String `tfsdk:"cluster_id"`
	// The canonical identifier for the Spark context used by a run. This field
	// is filled in once the run begins execution. This value can be used to
	// view the Spark UI by browsing to
	// `/#setting/sparkui/$cluster_id/$spark_context_id`. The Spark UI continues
	// to be available after the run has completed.
	//
	// The response won’t include this field if the identifier is not
	// available yet.
	SparkContextId types.String `tfsdk:"spark_context_id"`
}

func (to *ClusterInstance_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ClusterInstance_SdkV2) {
}

func (to *ClusterInstance_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ClusterInstance_SdkV2) {
}

func (m ClusterInstance_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["cluster_id"] = attrs["cluster_id"].SetOptional()
	attrs["spark_context_id"] = attrs["spark_context_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ClusterInstance.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ClusterInstance_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ClusterInstance_SdkV2
// only implements ToObjectValue() and Type().
func (m ClusterInstance_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cluster_id":       m.ClusterId,
			"spark_context_id": m.SparkContextId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ClusterInstance_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cluster_id":       types.StringType,
			"spark_context_id": types.StringType,
		},
	}
}

type ClusterSpec_SdkV2 struct {
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// If job_cluster_key, this task is executed reusing the cluster specified
	// in `job.settings.job_clusters`.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.List `tfsdk:"new_cluster"`
}

func (to *ClusterSpec_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ClusterSpec_SdkV2) {
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (to *ClusterSpec_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ClusterSpec_SdkV2) {
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (m ClusterSpec_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ClusterSpec.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ClusterSpec_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"library":     reflect.TypeOf(compute_tf.Library_SdkV2{}),
		"new_cluster": reflect.TypeOf(compute_tf.ClusterSpec_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ClusterSpec_SdkV2
// only implements ToObjectValue() and Type().
func (m ClusterSpec_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"existing_cluster_id": m.ExistingClusterId,
			"job_cluster_key":     m.JobClusterKey,
			"library":             m.Libraries,
			"new_cluster":         m.NewCluster,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ClusterSpec_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"existing_cluster_id": types.StringType,
			"job_cluster_key":     types.StringType,
			"library": basetypes.ListType{
				ElemType: compute_tf.Library_SdkV2{}.Type(ctx),
			},
			"new_cluster": basetypes.ListType{
				ElemType: compute_tf.ClusterSpec_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetLibraries returns the value of the Libraries field in ClusterSpec_SdkV2 as
// a slice of compute_tf.Library_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ClusterSpec_SdkV2) GetLibraries(ctx context.Context) ([]compute_tf.Library_SdkV2, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library_SdkV2
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in ClusterSpec_SdkV2.
func (m *ClusterSpec_SdkV2) SetLibraries(ctx context.Context, v []compute_tf.Library_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in ClusterSpec_SdkV2 as
// a compute_tf.ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ClusterSpec_SdkV2) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec_SdkV2, bool) {
	var e compute_tf.ClusterSpec_SdkV2
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v []compute_tf.ClusterSpec_SdkV2
	d := m.NewCluster.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewCluster sets the value of the NewCluster field in ClusterSpec_SdkV2.
func (m *ClusterSpec_SdkV2) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_cluster"]
	m.NewCluster = types.ListValueMust(t, vs)
}

type ComputeConfig_SdkV2 struct {
	// IDof the GPU pool to use.
	GpuNodePoolId types.String `tfsdk:"gpu_node_pool_id"`
	// GPU type.
	GpuType types.String `tfsdk:"gpu_type"`
	// Number of GPUs.
	NumGpus types.Int64 `tfsdk:"num_gpus"`
}

func (to *ComputeConfig_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ComputeConfig_SdkV2) {
}

func (to *ComputeConfig_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ComputeConfig_SdkV2) {
}

func (m ComputeConfig_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["gpu_node_pool_id"] = attrs["gpu_node_pool_id"].SetOptional()
	attrs["gpu_type"] = attrs["gpu_type"].SetOptional()
	attrs["num_gpus"] = attrs["num_gpus"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ComputeConfig.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ComputeConfig_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ComputeConfig_SdkV2
// only implements ToObjectValue() and Type().
func (m ComputeConfig_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"gpu_node_pool_id": m.GpuNodePoolId,
			"gpu_type":         m.GpuType,
			"num_gpus":         m.NumGpus,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ComputeConfig_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"gpu_node_pool_id": types.StringType,
			"gpu_type":         types.StringType,
			"num_gpus":         types.Int64Type,
		},
	}
}

type ConditionTask_SdkV2 struct {
	// The left operand of the condition task. Can be either a string value or a
	// job state or parameter reference.
	Left types.String `tfsdk:"left"`
	// * `EQUAL_TO`, `NOT_EQUAL` operators perform string comparison of their
	// operands. This means that `“12.0” == “12”` will evaluate to
	// `false`. * `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`,
	// `LESS_THAN_OR_EQUAL` operators perform numeric comparison of their
	// operands. `“12.0” >= “12”` will evaluate to `true`, `“10.0”
	// >= “12”` will evaluate to `false`.
	//
	// The boolean comparison to task values can be implemented with operators
	// `EQUAL_TO`, `NOT_EQUAL`. If a task value was set to a boolean value, it
	// will be serialized to `“true”` or `“false”` for the comparison.
	Op types.String `tfsdk:"op"`
	// The right operand of the condition task. Can be either a string value or
	// a job state or parameter reference.
	Right types.String `tfsdk:"right"`
}

func (to *ConditionTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ConditionTask_SdkV2) {
}

func (to *ConditionTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ConditionTask_SdkV2) {
}

func (m ConditionTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["left"] = attrs["left"].SetRequired()
	attrs["op"] = attrs["op"].SetRequired()
	attrs["right"] = attrs["right"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConditionTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ConditionTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConditionTask_SdkV2
// only implements ToObjectValue() and Type().
func (m ConditionTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"left":  m.Left,
			"op":    m.Op,
			"right": m.Right,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ConditionTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"left":  types.StringType,
			"op":    types.StringType,
			"right": types.StringType,
		},
	}
}

type Continuous_SdkV2 struct {
	// Indicate whether the continuous execution of the job is paused or not.
	// Defaults to UNPAUSED.
	PauseStatus types.String `tfsdk:"pause_status"`
	// Indicate whether the continuous job is applying task level retries or
	// not. Defaults to NEVER.
	TaskRetryMode types.String `tfsdk:"task_retry_mode"`
}

func (to *Continuous_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Continuous_SdkV2) {
}

func (to *Continuous_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Continuous_SdkV2) {
}

func (m Continuous_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["task_retry_mode"] = attrs["task_retry_mode"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Continuous.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Continuous_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Continuous_SdkV2
// only implements ToObjectValue() and Type().
func (m Continuous_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"pause_status":    m.PauseStatus,
			"task_retry_mode": m.TaskRetryMode,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Continuous_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"pause_status":    types.StringType,
			"task_retry_mode": types.StringType,
		},
	}
}

type CreateJob_SdkV2 struct {
	// List of permissions to set on the job.
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The id of the user specified budget policy to use for this job. If not
	// specified, a default budget policy may be applied when creating or
	// modifying the job. See `effective_budget_policy_id` for the budget policy
	// used by this workload.
	BudgetPolicyId types.String `tfsdk:"budget_policy_id"`
	// An optional continuous property for this job. The continuous property
	// will ensure that there is always one run executing. Only one of
	// `schedule` and `continuous` can be used.
	Continuous types.List `tfsdk:"continuous"`
	// Deployment information for jobs managed by external sources.
	Deployment types.List `tfsdk:"deployment"`
	// An optional description for the job. The maximum length is 27700
	// characters in UTF-8 encoding.
	Description types.String `tfsdk:"description"`
	// Edit mode of the job.
	//
	// * `UI_LOCKED`: The job is in a locked UI state and cannot be modified. *
	// `EDITABLE`: The job is in an editable state and can be modified.
	EditMode types.String `tfsdk:"edit_mode"`
	// An optional set of email addresses that is notified when runs of this job
	// begin or complete as well as when this job is deleted.
	EmailNotifications types.List `tfsdk:"email_notifications"`
	// A list of task execution environment specifications that can be
	// referenced by serverless tasks of this job. An environment is required to
	// be present for serverless tasks. For serverless notebook tasks, the
	// environment is accessible in the notebook environment panel. For other
	// serverless tasks, the task environment is required to be specified using
	// environment_key in the task settings.
	Environments types.List `tfsdk:"environment"`
	// Used to tell what is the format of the job. This field is ignored in
	// Create/Update/Reset calls. When using the Jobs API 2.1 this value is
	// always set to `"MULTI_TASK"`.
	Format types.String `tfsdk:"format"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.List `tfsdk:"git_source"`

	Health types.List `tfsdk:"health"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings.
	JobClusters types.List `tfsdk:"job_cluster"`
	// An optional maximum allowed number of concurrent runs of the job. Set
	// this value if you want to be able to execute multiple runs of the same
	// job concurrently. This is useful for example if you trigger your job on a
	// frequent schedule and want to allow consecutive runs to overlap with each
	// other, or if you want to trigger multiple runs which differ by their
	// input parameters. This setting affects only new runs. For example,
	// suppose the job’s concurrency is 4 and there are 4 concurrent active
	// runs. Then setting the concurrency to 3 won’t kill any of the active
	// runs. However, from then on, new runs are skipped unless there are fewer
	// than 3 active runs. This value cannot exceed 1000. Setting this value to
	// `0` causes all new runs to be skipped.
	MaxConcurrentRuns types.Int64 `tfsdk:"max_concurrent_runs"`
	// An optional name for the job. The maximum length is 4096 bytes in UTF-8
	// encoding.
	Name types.String `tfsdk:"name"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// job.
	NotificationSettings types.List `tfsdk:"notification_settings"`
	// Job-level parameter definitions
	Parameters types.List `tfsdk:"parameter"`
	// The performance mode on a serverless job. This field determines the level
	// of compute performance or cost-efficiency for the run.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// The queue settings of the job.
	Queue types.List `tfsdk:"queue"`
	// The user or service principal that the job runs as, if specified in the
	// request. This field indicates the explicit configuration of `run_as` for
	// the job. To find the value in all cases, explicit or implicit, use
	// `run_as_user_name`.
	RunAs types.List `tfsdk:"run_as"`
	// An optional periodic schedule for this job. The default behavior is that
	// the job only runs when triggered by clicking “Run Now” in the Jobs UI
	// or sending an API request to `runNow`.
	Schedule types.List `tfsdk:"schedule"`
	// A map of tags associated with the job. These are forwarded to the cluster
	// as cluster tags for jobs clusters, and are subject to the same
	// limitations as cluster tags. A maximum of 25 tags can be added to the
	// job.
	Tags types.Map `tfsdk:"tags"`
	// A list of task specifications to be executed by this job. It supports up
	// to 1000 elements in write endpoints (:method:jobs/create,
	// :method:jobs/reset, :method:jobs/update, :method:jobs/submit). Read
	// endpoints return only 100 tasks. If more than 100 tasks are available,
	// you can paginate through them using :method:jobs/get. Use the
	// `next_page_token` field at the object root to determine if more results
	// are available.
	Tasks types.List `tfsdk:"task"`
	// An optional timeout applied to each run of this job. A value of `0` means
	// no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A configuration to trigger a run when certain conditions are met. The
	// default behavior is that the job runs only when triggered by clicking
	// “Run Now” in the Jobs UI or sending an API request to `runNow`.
	Trigger types.List `tfsdk:"trigger"`
	// The id of the user specified usage policy to use for this job. If not
	// specified, a default usage policy may be applied when creating or
	// modifying the job. See `effective_usage_policy_id` for the usage policy
	// used by this workload.
	UsagePolicyId types.String `tfsdk:"usage_policy_id"`
	// A collection of system notification IDs to notify when runs of this job
	// begin or complete.
	WebhookNotifications types.List `tfsdk:"webhook_notifications"`
}

func (to *CreateJob_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateJob_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				// Recursively sync the fields of Continuous
				toContinuous.SyncFieldsDuringCreateOrUpdate(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				// Recursively sync the fields of Deployment
				toDeployment.SyncFieldsDuringCreateOrUpdate(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				// Recursively sync the fields of RunAs
				toRunAs.SyncFieldsDuringCreateOrUpdate(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				// Recursively sync the fields of Trigger
				toTrigger.SyncFieldsDuringCreateOrUpdate(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *CreateJob_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateJob_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				toContinuous.SyncFieldsDuringRead(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				toDeployment.SyncFieldsDuringRead(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				toRunAs.SyncFieldsDuringRead(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				toTrigger.SyncFieldsDuringRead(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m CreateJob_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetOptional()
	attrs["continuous"] = attrs["continuous"].SetOptional()
	attrs["continuous"] = attrs["continuous"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["deployment"] = attrs["deployment"].SetOptional()
	attrs["deployment"] = attrs["deployment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["description"] = attrs["description"].SetOptional()
	attrs["edit_mode"] = attrs["edit_mode"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["environment"] = attrs["environment"].SetOptional()
	attrs["format"] = attrs["format"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["git_source"] = attrs["git_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["health"] = attrs["health"].SetOptional()
	attrs["health"] = attrs["health"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["job_cluster"] = attrs["job_cluster"].SetOptional()
	attrs["max_concurrent_runs"] = attrs["max_concurrent_runs"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["parameter"] = attrs["parameter"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["queue"] = attrs["queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_as"] = attrs["run_as"].SetOptional()
	attrs["run_as"] = attrs["run_as"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["tags"] = attrs["tags"].SetOptional()
	attrs["task"] = attrs["task"].SetOptional()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["trigger"] = attrs["trigger"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateJob_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list":   reflect.TypeOf(JobAccessControlRequest_SdkV2{}),
		"continuous":            reflect.TypeOf(Continuous_SdkV2{}),
		"deployment":            reflect.TypeOf(JobDeployment_SdkV2{}),
		"email_notifications":   reflect.TypeOf(JobEmailNotifications_SdkV2{}),
		"environment":           reflect.TypeOf(JobEnvironment_SdkV2{}),
		"git_source":            reflect.TypeOf(GitSource_SdkV2{}),
		"health":                reflect.TypeOf(JobsHealthRules_SdkV2{}),
		"job_cluster":           reflect.TypeOf(JobCluster_SdkV2{}),
		"notification_settings": reflect.TypeOf(JobNotificationSettings_SdkV2{}),
		"parameter":             reflect.TypeOf(JobParameterDefinition_SdkV2{}),
		"queue":                 reflect.TypeOf(QueueSettings_SdkV2{}),
		"run_as":                reflect.TypeOf(JobRunAs_SdkV2{}),
		"schedule":              reflect.TypeOf(CronSchedule_SdkV2{}),
		"tags":                  reflect.TypeOf(types.String{}),
		"task":                  reflect.TypeOf(Task_SdkV2{}),
		"trigger":               reflect.TypeOf(TriggerSettings_SdkV2{}),
		"webhook_notifications": reflect.TypeOf(WebhookNotifications_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateJob_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateJob_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list":   m.AccessControlList,
			"budget_policy_id":      m.BudgetPolicyId,
			"continuous":            m.Continuous,
			"deployment":            m.Deployment,
			"description":           m.Description,
			"edit_mode":             m.EditMode,
			"email_notifications":   m.EmailNotifications,
			"environment":           m.Environments,
			"format":                m.Format,
			"git_source":            m.GitSource,
			"health":                m.Health,
			"job_cluster":           m.JobClusters,
			"max_concurrent_runs":   m.MaxConcurrentRuns,
			"name":                  m.Name,
			"notification_settings": m.NotificationSettings,
			"parameter":             m.Parameters,
			"performance_target":    m.PerformanceTarget,
			"queue":                 m.Queue,
			"run_as":                m.RunAs,
			"schedule":              m.Schedule,
			"tags":                  m.Tags,
			"task":                  m.Tasks,
			"timeout_seconds":       m.TimeoutSeconds,
			"trigger":               m.Trigger,
			"usage_policy_id":       m.UsagePolicyId,
			"webhook_notifications": m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateJob_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlRequest_SdkV2{}.Type(ctx),
			},
			"budget_policy_id": types.StringType,
			"continuous": basetypes.ListType{
				ElemType: Continuous_SdkV2{}.Type(ctx),
			},
			"deployment": basetypes.ListType{
				ElemType: JobDeployment_SdkV2{}.Type(ctx),
			},
			"description": types.StringType,
			"edit_mode":   types.StringType,
			"email_notifications": basetypes.ListType{
				ElemType: JobEmailNotifications_SdkV2{}.Type(ctx),
			},
			"environment": basetypes.ListType{
				ElemType: JobEnvironment_SdkV2{}.Type(ctx),
			},
			"format": types.StringType,
			"git_source": basetypes.ListType{
				ElemType: GitSource_SdkV2{}.Type(ctx),
			},
			"health": basetypes.ListType{
				ElemType: JobsHealthRules_SdkV2{}.Type(ctx),
			},
			"job_cluster": basetypes.ListType{
				ElemType: JobCluster_SdkV2{}.Type(ctx),
			},
			"max_concurrent_runs": types.Int64Type,
			"name":                types.StringType,
			"notification_settings": basetypes.ListType{
				ElemType: JobNotificationSettings_SdkV2{}.Type(ctx),
			},
			"parameter": basetypes.ListType{
				ElemType: JobParameterDefinition_SdkV2{}.Type(ctx),
			},
			"performance_target": types.StringType,
			"queue": basetypes.ListType{
				ElemType: QueueSettings_SdkV2{}.Type(ctx),
			},
			"run_as": basetypes.ListType{
				ElemType: JobRunAs_SdkV2{}.Type(ctx),
			},
			"schedule": basetypes.ListType{
				ElemType: CronSchedule_SdkV2{}.Type(ctx),
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"task": basetypes.ListType{
				ElemType: Task_SdkV2{}.Type(ctx),
			},
			"timeout_seconds": types.Int64Type,
			"trigger": basetypes.ListType{
				ElemType: TriggerSettings_SdkV2{}.Type(ctx),
			},
			"usage_policy_id": types.StringType,
			"webhook_notifications": basetypes.ListType{
				ElemType: WebhookNotifications_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in CreateJob_SdkV2 as
// a slice of JobAccessControlRequest_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetAccessControlList(ctx context.Context) ([]JobAccessControlRequest_SdkV2, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlRequest_SdkV2
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetAccessControlList(ctx context.Context, v []JobAccessControlRequest_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

// GetContinuous returns the value of the Continuous field in CreateJob_SdkV2 as
// a Continuous_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetContinuous(ctx context.Context) (Continuous_SdkV2, bool) {
	var e Continuous_SdkV2
	if m.Continuous.IsNull() || m.Continuous.IsUnknown() {
		return e, false
	}
	var v []Continuous_SdkV2
	d := m.Continuous.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetContinuous sets the value of the Continuous field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetContinuous(ctx context.Context, v Continuous_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["continuous"]
	m.Continuous = types.ListValueMust(t, vs)
}

// GetDeployment returns the value of the Deployment field in CreateJob_SdkV2 as
// a JobDeployment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetDeployment(ctx context.Context) (JobDeployment_SdkV2, bool) {
	var e JobDeployment_SdkV2
	if m.Deployment.IsNull() || m.Deployment.IsUnknown() {
		return e, false
	}
	var v []JobDeployment_SdkV2
	d := m.Deployment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDeployment sets the value of the Deployment field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetDeployment(ctx context.Context, v JobDeployment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["deployment"]
	m.Deployment = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in CreateJob_SdkV2 as
// a JobEmailNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetEmailNotifications(ctx context.Context) (JobEmailNotifications_SdkV2, bool) {
	var e JobEmailNotifications_SdkV2
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v []JobEmailNotifications_SdkV2
	d := m.EmailNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEmailNotifications sets the value of the EmailNotifications field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetEmailNotifications(ctx context.Context, v JobEmailNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_notifications"]
	m.EmailNotifications = types.ListValueMust(t, vs)
}

// GetEnvironments returns the value of the Environments field in CreateJob_SdkV2 as
// a slice of JobEnvironment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetEnvironments(ctx context.Context) ([]JobEnvironment_SdkV2, bool) {
	if m.Environments.IsNull() || m.Environments.IsUnknown() {
		return nil, false
	}
	var v []JobEnvironment_SdkV2
	d := m.Environments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEnvironments sets the value of the Environments field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetEnvironments(ctx context.Context, v []JobEnvironment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["environment"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Environments = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in CreateJob_SdkV2 as
// a GitSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetGitSource(ctx context.Context) (GitSource_SdkV2, bool) {
	var e GitSource_SdkV2
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v []GitSource_SdkV2
	d := m.GitSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSource sets the value of the GitSource field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetGitSource(ctx context.Context, v GitSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_source"]
	m.GitSource = types.ListValueMust(t, vs)
}

// GetHealth returns the value of the Health field in CreateJob_SdkV2 as
// a JobsHealthRules_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetHealth(ctx context.Context) (JobsHealthRules_SdkV2, bool) {
	var e JobsHealthRules_SdkV2
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v []JobsHealthRules_SdkV2
	d := m.Health.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetHealth sets the value of the Health field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetHealth(ctx context.Context, v JobsHealthRules_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["health"]
	m.Health = types.ListValueMust(t, vs)
}

// GetJobClusters returns the value of the JobClusters field in CreateJob_SdkV2 as
// a slice of JobCluster_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetJobClusters(ctx context.Context) ([]JobCluster_SdkV2, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster_SdkV2
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetJobClusters(ctx context.Context, v []JobCluster_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_cluster"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in CreateJob_SdkV2 as
// a JobNotificationSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetNotificationSettings(ctx context.Context) (JobNotificationSettings_SdkV2, bool) {
	var e JobNotificationSettings_SdkV2
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v []JobNotificationSettings_SdkV2
	d := m.NotificationSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotificationSettings sets the value of the NotificationSettings field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetNotificationSettings(ctx context.Context, v JobNotificationSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notification_settings"]
	m.NotificationSettings = types.ListValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in CreateJob_SdkV2 as
// a slice of JobParameterDefinition_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetParameters(ctx context.Context) ([]JobParameterDefinition_SdkV2, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameterDefinition_SdkV2
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetParameters(ctx context.Context, v []JobParameterDefinition_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameter"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in CreateJob_SdkV2 as
// a QueueSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetQueue(ctx context.Context) (QueueSettings_SdkV2, bool) {
	var e QueueSettings_SdkV2
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v []QueueSettings_SdkV2
	d := m.Queue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQueue sets the value of the Queue field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetQueue(ctx context.Context, v QueueSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["queue"]
	m.Queue = types.ListValueMust(t, vs)
}

// GetRunAs returns the value of the RunAs field in CreateJob_SdkV2 as
// a JobRunAs_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetRunAs(ctx context.Context) (JobRunAs_SdkV2, bool) {
	var e JobRunAs_SdkV2
	if m.RunAs.IsNull() || m.RunAs.IsUnknown() {
		return e, false
	}
	var v []JobRunAs_SdkV2
	d := m.RunAs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunAs sets the value of the RunAs field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetRunAs(ctx context.Context, v JobRunAs_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_as"]
	m.RunAs = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in CreateJob_SdkV2 as
// a CronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetSchedule(ctx context.Context) (CronSchedule_SdkV2, bool) {
	var e CronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []CronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetSchedule(ctx context.Context, v CronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetTags returns the value of the Tags field in CreateJob_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetTags(ctx context.Context) (map[string]types.String, bool) {
	if m.Tags.IsNull() || m.Tags.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Tags.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTags sets the value of the Tags field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetTags(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tags"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tags = types.MapValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in CreateJob_SdkV2 as
// a slice of Task_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetTasks(ctx context.Context) ([]Task_SdkV2, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []Task_SdkV2
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetTasks(ctx context.Context, v []Task_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTrigger returns the value of the Trigger field in CreateJob_SdkV2 as
// a TriggerSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetTrigger(ctx context.Context) (TriggerSettings_SdkV2, bool) {
	var e TriggerSettings_SdkV2
	if m.Trigger.IsNull() || m.Trigger.IsUnknown() {
		return e, false
	}
	var v []TriggerSettings_SdkV2
	d := m.Trigger.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTrigger sets the value of the Trigger field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetTrigger(ctx context.Context, v TriggerSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["trigger"]
	m.Trigger = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in CreateJob_SdkV2 as
// a WebhookNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob_SdkV2) GetWebhookNotifications(ctx context.Context) (WebhookNotifications_SdkV2, bool) {
	var e WebhookNotifications_SdkV2
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v []WebhookNotifications_SdkV2
	d := m.WebhookNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in CreateJob_SdkV2.
func (m *CreateJob_SdkV2) SetWebhookNotifications(ctx context.Context, v WebhookNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["webhook_notifications"]
	m.WebhookNotifications = types.ListValueMust(t, vs)
}

// Job was created successfully
type CreateResponse_SdkV2 struct {
	// The canonical identifier for the newly created job.
	JobId types.Int64 `tfsdk:"job_id"`
}

func (to *CreateResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateResponse_SdkV2) {
}

func (to *CreateResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateResponse_SdkV2) {
}

func (m CreateResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
		},
	}
}

type CronSchedule_SdkV2 struct {
	// Indicate whether this schedule is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// A Cron expression using Quartz syntax that describes the schedule for a
	// job. See [Cron Trigger] for details. This field is required.
	//
	// [Cron Trigger]: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html
	QuartzCronExpression types.String `tfsdk:"quartz_cron_expression"`
	// A Java timezone ID. The schedule for a job is resolved with respect to
	// this timezone. See [Java TimeZone] for details. This field is required.
	//
	// [Java TimeZone]: https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html
	TimezoneId types.String `tfsdk:"timezone_id"`
}

func (to *CronSchedule_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CronSchedule_SdkV2) {
}

func (to *CronSchedule_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CronSchedule_SdkV2) {
}

func (m CronSchedule_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["quartz_cron_expression"] = attrs["quartz_cron_expression"].SetRequired()
	attrs["timezone_id"] = attrs["timezone_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CronSchedule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CronSchedule_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CronSchedule_SdkV2
// only implements ToObjectValue() and Type().
func (m CronSchedule_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"pause_status":           m.PauseStatus,
			"quartz_cron_expression": m.QuartzCronExpression,
			"timezone_id":            m.TimezoneId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CronSchedule_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"pause_status":           types.StringType,
			"quartz_cron_expression": types.StringType,
			"timezone_id":            types.StringType,
		},
	}
}

type DashboardPageSnapshot_SdkV2 struct {
	PageDisplayName types.String `tfsdk:"page_display_name"`

	WidgetErrorDetails types.List `tfsdk:"widget_error_details"`
}

func (to *DashboardPageSnapshot_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DashboardPageSnapshot_SdkV2) {
	if !from.WidgetErrorDetails.IsNull() && !from.WidgetErrorDetails.IsUnknown() && to.WidgetErrorDetails.IsNull() && len(from.WidgetErrorDetails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for WidgetErrorDetails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.WidgetErrorDetails = from.WidgetErrorDetails
	}
}

func (to *DashboardPageSnapshot_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DashboardPageSnapshot_SdkV2) {
	if !from.WidgetErrorDetails.IsNull() && !from.WidgetErrorDetails.IsUnknown() && to.WidgetErrorDetails.IsNull() && len(from.WidgetErrorDetails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for WidgetErrorDetails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.WidgetErrorDetails = from.WidgetErrorDetails
	}
}

func (m DashboardPageSnapshot_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_display_name"] = attrs["page_display_name"].SetOptional()
	attrs["widget_error_details"] = attrs["widget_error_details"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DashboardPageSnapshot.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DashboardPageSnapshot_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"widget_error_details": reflect.TypeOf(WidgetErrorDetail_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DashboardPageSnapshot_SdkV2
// only implements ToObjectValue() and Type().
func (m DashboardPageSnapshot_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_display_name":    m.PageDisplayName,
			"widget_error_details": m.WidgetErrorDetails,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DashboardPageSnapshot_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_display_name": types.StringType,
			"widget_error_details": basetypes.ListType{
				ElemType: WidgetErrorDetail_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetWidgetErrorDetails returns the value of the WidgetErrorDetails field in DashboardPageSnapshot_SdkV2 as
// a slice of WidgetErrorDetail_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *DashboardPageSnapshot_SdkV2) GetWidgetErrorDetails(ctx context.Context) ([]WidgetErrorDetail_SdkV2, bool) {
	if m.WidgetErrorDetails.IsNull() || m.WidgetErrorDetails.IsUnknown() {
		return nil, false
	}
	var v []WidgetErrorDetail_SdkV2
	d := m.WidgetErrorDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWidgetErrorDetails sets the value of the WidgetErrorDetails field in DashboardPageSnapshot_SdkV2.
func (m *DashboardPageSnapshot_SdkV2) SetWidgetErrorDetails(ctx context.Context, v []WidgetErrorDetail_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["widget_error_details"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.WidgetErrorDetails = types.ListValueMust(t, vs)
}

// Configures the Lakeview Dashboard job task type.
type DashboardTask_SdkV2 struct {
	// The identifier of the dashboard to refresh.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// Optional: subscription configuration for sending the dashboard snapshot.
	Subscription types.List `tfsdk:"subscription"`
	// Optional: The warehouse id to execute the dashboard with for the
	// schedule. If not specified, the default warehouse of the dashboard will
	// be used.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *DashboardTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DashboardTask_SdkV2) {
	if !from.Subscription.IsNull() && !from.Subscription.IsUnknown() {
		if toSubscription, ok := to.GetSubscription(ctx); ok {
			if fromSubscription, ok := from.GetSubscription(ctx); ok {
				// Recursively sync the fields of Subscription
				toSubscription.SyncFieldsDuringCreateOrUpdate(ctx, fromSubscription)
				to.SetSubscription(ctx, toSubscription)
			}
		}
	}
}

func (to *DashboardTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DashboardTask_SdkV2) {
	if !from.Subscription.IsNull() && !from.Subscription.IsUnknown() {
		if toSubscription, ok := to.GetSubscription(ctx); ok {
			if fromSubscription, ok := from.GetSubscription(ctx); ok {
				toSubscription.SyncFieldsDuringRead(ctx, fromSubscription)
				to.SetSubscription(ctx, toSubscription)
			}
		}
	}
}

func (m DashboardTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["subscription"] = attrs["subscription"].SetOptional()
	attrs["subscription"] = attrs["subscription"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["warehouse_id"] = attrs["warehouse_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DashboardTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DashboardTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscription": reflect.TypeOf(Subscription_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DashboardTask_SdkV2
// only implements ToObjectValue() and Type().
func (m DashboardTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"subscription": m.Subscription,
			"warehouse_id": m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DashboardTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"subscription": basetypes.ListType{
				ElemType: Subscription_SdkV2{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetSubscription returns the value of the Subscription field in DashboardTask_SdkV2 as
// a Subscription_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *DashboardTask_SdkV2) GetSubscription(ctx context.Context) (Subscription_SdkV2, bool) {
	var e Subscription_SdkV2
	if m.Subscription.IsNull() || m.Subscription.IsUnknown() {
		return e, false
	}
	var v []Subscription_SdkV2
	d := m.Subscription.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSubscription sets the value of the Subscription field in DashboardTask_SdkV2.
func (m *DashboardTask_SdkV2) SetSubscription(ctx context.Context, v Subscription_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscription"]
	m.Subscription = types.ListValueMust(t, vs)
}

type DashboardTaskOutput_SdkV2 struct {
	// Should only be populated for manual PDF download jobs.
	PageSnapshots types.List `tfsdk:"page_snapshots"`
}

func (to *DashboardTaskOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DashboardTaskOutput_SdkV2) {
	if !from.PageSnapshots.IsNull() && !from.PageSnapshots.IsUnknown() && to.PageSnapshots.IsNull() && len(from.PageSnapshots.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PageSnapshots, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PageSnapshots = from.PageSnapshots
	}
}

func (to *DashboardTaskOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DashboardTaskOutput_SdkV2) {
	if !from.PageSnapshots.IsNull() && !from.PageSnapshots.IsUnknown() && to.PageSnapshots.IsNull() && len(from.PageSnapshots.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PageSnapshots, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PageSnapshots = from.PageSnapshots
	}
}

func (m DashboardTaskOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_snapshots"] = attrs["page_snapshots"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DashboardTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DashboardTaskOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"page_snapshots": reflect.TypeOf(DashboardPageSnapshot_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DashboardTaskOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m DashboardTaskOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_snapshots": m.PageSnapshots,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DashboardTaskOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_snapshots": basetypes.ListType{
				ElemType: DashboardPageSnapshot_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPageSnapshots returns the value of the PageSnapshots field in DashboardTaskOutput_SdkV2 as
// a slice of DashboardPageSnapshot_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *DashboardTaskOutput_SdkV2) GetPageSnapshots(ctx context.Context) ([]DashboardPageSnapshot_SdkV2, bool) {
	if m.PageSnapshots.IsNull() || m.PageSnapshots.IsUnknown() {
		return nil, false
	}
	var v []DashboardPageSnapshot_SdkV2
	d := m.PageSnapshots.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPageSnapshots sets the value of the PageSnapshots field in DashboardTaskOutput_SdkV2.
func (m *DashboardTaskOutput_SdkV2) SetPageSnapshots(ctx context.Context, v []DashboardPageSnapshot_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["page_snapshots"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PageSnapshots = types.ListValueMust(t, vs)
}

// Format of response retrieved from dbt Cloud, for inclusion in output
// Deprecated in favor of DbtPlatformJobRunStep
type DbtCloudJobRunStep_SdkV2 struct {
	// Orders the steps in the job
	Index types.Int64 `tfsdk:"index"`
	// Output of the step
	Logs types.String `tfsdk:"logs"`
	// Name of the step in the job
	Name types.String `tfsdk:"name"`
	// State of the step
	Status types.String `tfsdk:"status"`
}

func (to *DbtCloudJobRunStep_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtCloudJobRunStep_SdkV2) {
}

func (to *DbtCloudJobRunStep_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtCloudJobRunStep_SdkV2) {
}

func (m DbtCloudJobRunStep_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["index"] = attrs["index"].SetOptional()
	attrs["logs"] = attrs["logs"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtCloudJobRunStep.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtCloudJobRunStep_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtCloudJobRunStep_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtCloudJobRunStep_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"index":  m.Index,
			"logs":   m.Logs,
			"name":   m.Name,
			"status": m.Status,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtCloudJobRunStep_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"index":  types.Int64Type,
			"logs":   types.StringType,
			"name":   types.StringType,
			"status": types.StringType,
		},
	}
}

// Deprecated in favor of DbtPlatformTask
type DbtCloudTask_SdkV2 struct {
	// The resource name of the UC connection that authenticates the dbt Cloud
	// for this task
	ConnectionResourceName types.String `tfsdk:"connection_resource_name"`
	// Id of the dbt Cloud job to be triggered
	DbtCloudJobId types.Int64 `tfsdk:"dbt_cloud_job_id"`
}

func (to *DbtCloudTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtCloudTask_SdkV2) {
}

func (to *DbtCloudTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtCloudTask_SdkV2) {
}

func (m DbtCloudTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_resource_name"] = attrs["connection_resource_name"].SetOptional()
	attrs["dbt_cloud_job_id"] = attrs["dbt_cloud_job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtCloudTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtCloudTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtCloudTask_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtCloudTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_resource_name": m.ConnectionResourceName,
			"dbt_cloud_job_id":         m.DbtCloudJobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtCloudTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_resource_name": types.StringType,
			"dbt_cloud_job_id":         types.Int64Type,
		},
	}
}

// Deprecated in favor of DbtPlatformTaskOutput
type DbtCloudTaskOutput_SdkV2 struct {
	// Id of the job run in dbt Cloud
	DbtCloudJobRunId types.Int64 `tfsdk:"dbt_cloud_job_run_id"`
	// Steps of the job run as received from dbt Cloud
	DbtCloudJobRunOutput types.List `tfsdk:"dbt_cloud_job_run_output"`
	// Url where full run details can be viewed
	DbtCloudJobRunUrl types.String `tfsdk:"dbt_cloud_job_run_url"`
}

func (to *DbtCloudTaskOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtCloudTaskOutput_SdkV2) {
	if !from.DbtCloudJobRunOutput.IsNull() && !from.DbtCloudJobRunOutput.IsUnknown() && to.DbtCloudJobRunOutput.IsNull() && len(from.DbtCloudJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCloudJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCloudJobRunOutput = from.DbtCloudJobRunOutput
	}
}

func (to *DbtCloudTaskOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtCloudTaskOutput_SdkV2) {
	if !from.DbtCloudJobRunOutput.IsNull() && !from.DbtCloudJobRunOutput.IsUnknown() && to.DbtCloudJobRunOutput.IsNull() && len(from.DbtCloudJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCloudJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCloudJobRunOutput = from.DbtCloudJobRunOutput
	}
}

func (m DbtCloudTaskOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_cloud_job_run_id"] = attrs["dbt_cloud_job_run_id"].SetOptional()
	attrs["dbt_cloud_job_run_output"] = attrs["dbt_cloud_job_run_output"].SetOptional()
	attrs["dbt_cloud_job_run_url"] = attrs["dbt_cloud_job_run_url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtCloudTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtCloudTaskOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_cloud_job_run_output": reflect.TypeOf(DbtCloudJobRunStep_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtCloudTaskOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtCloudTaskOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_cloud_job_run_id":     m.DbtCloudJobRunId,
			"dbt_cloud_job_run_output": m.DbtCloudJobRunOutput,
			"dbt_cloud_job_run_url":    m.DbtCloudJobRunUrl,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtCloudTaskOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_cloud_job_run_id": types.Int64Type,
			"dbt_cloud_job_run_output": basetypes.ListType{
				ElemType: DbtCloudJobRunStep_SdkV2{}.Type(ctx),
			},
			"dbt_cloud_job_run_url": types.StringType,
		},
	}
}

// GetDbtCloudJobRunOutput returns the value of the DbtCloudJobRunOutput field in DbtCloudTaskOutput_SdkV2 as
// a slice of DbtCloudJobRunStep_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtCloudTaskOutput_SdkV2) GetDbtCloudJobRunOutput(ctx context.Context) ([]DbtCloudJobRunStep_SdkV2, bool) {
	if m.DbtCloudJobRunOutput.IsNull() || m.DbtCloudJobRunOutput.IsUnknown() {
		return nil, false
	}
	var v []DbtCloudJobRunStep_SdkV2
	d := m.DbtCloudJobRunOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCloudJobRunOutput sets the value of the DbtCloudJobRunOutput field in DbtCloudTaskOutput_SdkV2.
func (m *DbtCloudTaskOutput_SdkV2) SetDbtCloudJobRunOutput(ctx context.Context, v []DbtCloudJobRunStep_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_cloud_job_run_output"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCloudJobRunOutput = types.ListValueMust(t, vs)
}

type DbtOutput_SdkV2 struct {
	// An optional map of headers to send when retrieving the artifact from the
	// `artifacts_link`.
	ArtifactsHeaders types.Map `tfsdk:"artifacts_headers"`
	// A pre-signed URL to download the (compressed) dbt artifacts. This link is
	// valid for a limited time (30 minutes). This information is only available
	// after the run has finished.
	ArtifactsLink types.String `tfsdk:"artifacts_link"`
}

func (to *DbtOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtOutput_SdkV2) {
}

func (to *DbtOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtOutput_SdkV2) {
}

func (m DbtOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifacts_headers"] = attrs["artifacts_headers"].SetOptional()
	attrs["artifacts_link"] = attrs["artifacts_link"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"artifacts_headers": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifacts_headers": m.ArtifactsHeaders,
			"artifacts_link":    m.ArtifactsLink,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifacts_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"artifacts_link": types.StringType,
		},
	}
}

// GetArtifactsHeaders returns the value of the ArtifactsHeaders field in DbtOutput_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtOutput_SdkV2) GetArtifactsHeaders(ctx context.Context) (map[string]types.String, bool) {
	if m.ArtifactsHeaders.IsNull() || m.ArtifactsHeaders.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.ArtifactsHeaders.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetArtifactsHeaders sets the value of the ArtifactsHeaders field in DbtOutput_SdkV2.
func (m *DbtOutput_SdkV2) SetArtifactsHeaders(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["artifacts_headers"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ArtifactsHeaders = types.MapValueMust(t, vs)
}

// Format of response retrieved from dbt platform, for inclusion in output
type DbtPlatformJobRunStep_SdkV2 struct {
	// Orders the steps in the job
	Index types.Int64 `tfsdk:"index"`
	// Output of the step
	Logs types.String `tfsdk:"logs"`
	// Whether the logs of this step have been truncated. If true, the logs has
	// been truncated to 10000 characters.
	LogsTruncated types.Bool `tfsdk:"logs_truncated"`
	// Name of the step in the job
	Name types.String `tfsdk:"name"`
	// Whether the name of the job has been truncated. If true, the name has
	// been truncated to 100 characters.
	NameTruncated types.Bool `tfsdk:"name_truncated"`
	// State of the step
	Status types.String `tfsdk:"status"`
}

func (to *DbtPlatformJobRunStep_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtPlatformJobRunStep_SdkV2) {
}

func (to *DbtPlatformJobRunStep_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtPlatformJobRunStep_SdkV2) {
}

func (m DbtPlatformJobRunStep_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["index"] = attrs["index"].SetOptional()
	attrs["logs"] = attrs["logs"].SetOptional()
	attrs["logs_truncated"] = attrs["logs_truncated"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["name_truncated"] = attrs["name_truncated"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtPlatformJobRunStep.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtPlatformJobRunStep_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtPlatformJobRunStep_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtPlatformJobRunStep_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"index":          m.Index,
			"logs":           m.Logs,
			"logs_truncated": m.LogsTruncated,
			"name":           m.Name,
			"name_truncated": m.NameTruncated,
			"status":         m.Status,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtPlatformJobRunStep_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"index":          types.Int64Type,
			"logs":           types.StringType,
			"logs_truncated": types.BoolType,
			"name":           types.StringType,
			"name_truncated": types.BoolType,
			"status":         types.StringType,
		},
	}
}

type DbtPlatformTask_SdkV2 struct {
	// The resource name of the UC connection that authenticates the dbt
	// platform for this task
	ConnectionResourceName types.String `tfsdk:"connection_resource_name"`
	// Id of the dbt platform job to be triggered. Specified as a string for
	// maximum compatibility with clients.
	DbtPlatformJobId types.String `tfsdk:"dbt_platform_job_id"`
}

func (to *DbtPlatformTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtPlatformTask_SdkV2) {
}

func (to *DbtPlatformTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtPlatformTask_SdkV2) {
}

func (m DbtPlatformTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_resource_name"] = attrs["connection_resource_name"].SetOptional()
	attrs["dbt_platform_job_id"] = attrs["dbt_platform_job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtPlatformTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtPlatformTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtPlatformTask_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtPlatformTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_resource_name": m.ConnectionResourceName,
			"dbt_platform_job_id":      m.DbtPlatformJobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtPlatformTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_resource_name": types.StringType,
			"dbt_platform_job_id":      types.StringType,
		},
	}
}

type DbtPlatformTaskOutput_SdkV2 struct {
	// Id of the job run in dbt platform. Specified as a string for maximum
	// compatibility with clients.
	DbtPlatformJobRunId types.String `tfsdk:"dbt_platform_job_run_id"`
	// Steps of the job run as received from dbt platform
	DbtPlatformJobRunOutput types.List `tfsdk:"dbt_platform_job_run_output"`
	// Url where full run details can be viewed
	DbtPlatformJobRunUrl types.String `tfsdk:"dbt_platform_job_run_url"`
	// Whether the number of steps in the output has been truncated. If true,
	// the output will contain the first 20 steps of the output.
	StepsTruncated types.Bool `tfsdk:"steps_truncated"`
}

func (to *DbtPlatformTaskOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtPlatformTaskOutput_SdkV2) {
	if !from.DbtPlatformJobRunOutput.IsNull() && !from.DbtPlatformJobRunOutput.IsUnknown() && to.DbtPlatformJobRunOutput.IsNull() && len(from.DbtPlatformJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtPlatformJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtPlatformJobRunOutput = from.DbtPlatformJobRunOutput
	}
}

func (to *DbtPlatformTaskOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtPlatformTaskOutput_SdkV2) {
	if !from.DbtPlatformJobRunOutput.IsNull() && !from.DbtPlatformJobRunOutput.IsUnknown() && to.DbtPlatformJobRunOutput.IsNull() && len(from.DbtPlatformJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtPlatformJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtPlatformJobRunOutput = from.DbtPlatformJobRunOutput
	}
}

func (m DbtPlatformTaskOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_platform_job_run_id"] = attrs["dbt_platform_job_run_id"].SetOptional()
	attrs["dbt_platform_job_run_output"] = attrs["dbt_platform_job_run_output"].SetOptional()
	attrs["dbt_platform_job_run_url"] = attrs["dbt_platform_job_run_url"].SetOptional()
	attrs["steps_truncated"] = attrs["steps_truncated"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtPlatformTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtPlatformTaskOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_platform_job_run_output": reflect.TypeOf(DbtPlatformJobRunStep_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtPlatformTaskOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtPlatformTaskOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_platform_job_run_id":     m.DbtPlatformJobRunId,
			"dbt_platform_job_run_output": m.DbtPlatformJobRunOutput,
			"dbt_platform_job_run_url":    m.DbtPlatformJobRunUrl,
			"steps_truncated":             m.StepsTruncated,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtPlatformTaskOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_platform_job_run_id": types.StringType,
			"dbt_platform_job_run_output": basetypes.ListType{
				ElemType: DbtPlatformJobRunStep_SdkV2{}.Type(ctx),
			},
			"dbt_platform_job_run_url": types.StringType,
			"steps_truncated":          types.BoolType,
		},
	}
}

// GetDbtPlatformJobRunOutput returns the value of the DbtPlatformJobRunOutput field in DbtPlatformTaskOutput_SdkV2 as
// a slice of DbtPlatformJobRunStep_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtPlatformTaskOutput_SdkV2) GetDbtPlatformJobRunOutput(ctx context.Context) ([]DbtPlatformJobRunStep_SdkV2, bool) {
	if m.DbtPlatformJobRunOutput.IsNull() || m.DbtPlatformJobRunOutput.IsUnknown() {
		return nil, false
	}
	var v []DbtPlatformJobRunStep_SdkV2
	d := m.DbtPlatformJobRunOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtPlatformJobRunOutput sets the value of the DbtPlatformJobRunOutput field in DbtPlatformTaskOutput_SdkV2.
func (m *DbtPlatformTaskOutput_SdkV2) SetDbtPlatformJobRunOutput(ctx context.Context, v []DbtPlatformJobRunStep_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_platform_job_run_output"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtPlatformJobRunOutput = types.ListValueMust(t, vs)
}

type DbtTask_SdkV2 struct {
	// Optional name of the catalog to use. The value is the top level in the
	// 3-level namespace of Unity Catalog (catalog / schema / relation). The
	// catalog value can only be specified if a warehouse_id is specified.
	// Requires dbt-databricks >= 1.1.1.
	Catalog types.String `tfsdk:"catalog"`
	// A list of dbt commands to execute. All commands must start with `dbt`.
	// This parameter must not be empty. A maximum of up to 10 commands can be
	// provided.
	Commands types.List `tfsdk:"commands"`
	// Optional (relative) path to the profiles directory. Can only be specified
	// if no warehouse_id is specified. If no warehouse_id is specified and this
	// folder is unset, the root directory is used.
	ProfilesDirectory types.String `tfsdk:"profiles_directory"`
	// Path to the project directory. Optional for Git sourced tasks, in which
	// case if no value is provided, the root of the Git repository is used.
	ProjectDirectory types.String `tfsdk:"project_directory"`
	// Optional schema to write to. This parameter is only used when a
	// warehouse_id is also provided. If not provided, the `default` schema is
	// used.
	Schema types.String `tfsdk:"schema"`
	// Optional location type of the project directory. When set to `WORKSPACE`,
	// the project will be retrieved from the local Databricks workspace. When
	// set to `GIT`, the project will be retrieved from a Git repository defined
	// in `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise.
	//
	// * `WORKSPACE`: Project is located in Databricks workspace. * `GIT`:
	// Project is located in cloud Git provider.
	Source types.String `tfsdk:"source"`
	// ID of the SQL warehouse to connect to. If provided, we automatically
	// generate and provide the profile and connection details to dbt. It can be
	// overridden on a per-command basis by using the `--profiles-dir` command
	// line argument.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *DbtTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtTask_SdkV2) {
}

func (to *DbtTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DbtTask_SdkV2) {
}

func (m DbtTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog"] = attrs["catalog"].SetOptional()
	attrs["commands"] = attrs["commands"].SetRequired()
	attrs["profiles_directory"] = attrs["profiles_directory"].SetOptional()
	attrs["project_directory"] = attrs["project_directory"].SetOptional()
	attrs["schema"] = attrs["schema"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"commands": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtTask_SdkV2
// only implements ToObjectValue() and Type().
func (m DbtTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog":            m.Catalog,
			"commands":           m.Commands,
			"profiles_directory": m.ProfilesDirectory,
			"project_directory":  m.ProjectDirectory,
			"schema":             m.Schema,
			"source":             m.Source,
			"warehouse_id":       m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog": types.StringType,
			"commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"profiles_directory": types.StringType,
			"project_directory":  types.StringType,
			"schema":             types.StringType,
			"source":             types.StringType,
			"warehouse_id":       types.StringType,
		},
	}
}

// GetCommands returns the value of the Commands field in DbtTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtTask_SdkV2) GetCommands(ctx context.Context) ([]types.String, bool) {
	if m.Commands.IsNull() || m.Commands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Commands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCommands sets the value of the Commands field in DbtTask_SdkV2.
func (m *DbtTask_SdkV2) SetCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Commands = types.ListValueMust(t, vs)
}

type DeleteJob_SdkV2 struct {
	// The canonical identifier of the job to delete. This field is required.
	JobId types.Int64 `tfsdk:"job_id"`
}

func (to *DeleteJob_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteJob_SdkV2) {
}

func (to *DeleteJob_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteJob_SdkV2) {
}

func (m DeleteJob_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteJob_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteJob_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteJob_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteJob_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
		},
	}
}

type DeleteRun_SdkV2 struct {
	// ID of the run to delete.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *DeleteRun_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteRun_SdkV2) {
}

func (to *DeleteRun_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteRun_SdkV2) {
}

func (m DeleteRun_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteRun_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteRun_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteRun_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteRun_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

// Represents a change to the job cluster's settings that would be required for
// the job clusters to become compliant with their policies.
type EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2 struct {
	// The field where this change would be made, prepended with the job cluster
	// key.
	Field types.String `tfsdk:"field"`
	// The new value of this field after enforcing policy compliance (either a
	// number, a boolean, or a string) converted to a string. This is intended
	// to be read by a human. The typed new value of this field can be retrieved
	// by reading the settings field in the API response.
	NewValue types.String `tfsdk:"new_value"`
	// The previous value of this field before enforcing policy compliance
	// (either a number, a boolean, or a string) converted to a string. This is
	// intended to be read by a human. The type of the field can be retrieved by
	// reading the settings field in the API response.
	PreviousValue types.String `tfsdk:"previous_value"`
}

func (to *EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) {
}

func (to *EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) {
}

func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["field"] = attrs["field"].SetOptional()
	attrs["new_value"] = attrs["new_value"].SetOptional()
	attrs["previous_value"] = attrs["previous_value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnforcePolicyComplianceForJobResponseJobClusterSettingsChange.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2
// only implements ToObjectValue() and Type().
func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"field":          m.Field,
			"new_value":      m.NewValue,
			"previous_value": m.PreviousValue,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"field":          types.StringType,
			"new_value":      types.StringType,
			"previous_value": types.StringType,
		},
	}
}

type EnforcePolicyComplianceRequest_SdkV2 struct {
	// The ID of the job you want to enforce policy compliance on.
	JobId types.Int64 `tfsdk:"job_id"`
	// If set, previews changes made to the job to comply with its policy, but
	// does not update the job.
	ValidateOnly types.Bool `tfsdk:"validate_only"`
}

func (to *EnforcePolicyComplianceRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnforcePolicyComplianceRequest_SdkV2) {
}

func (to *EnforcePolicyComplianceRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EnforcePolicyComplianceRequest_SdkV2) {
}

func (m EnforcePolicyComplianceRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["validate_only"] = attrs["validate_only"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnforcePolicyComplianceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnforcePolicyComplianceRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnforcePolicyComplianceRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m EnforcePolicyComplianceRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id":        m.JobId,
			"validate_only": m.ValidateOnly,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnforcePolicyComplianceRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id":        types.Int64Type,
			"validate_only": types.BoolType,
		},
	}
}

type EnforcePolicyComplianceResponse_SdkV2 struct {
	// Whether any changes have been made to the job cluster settings for the
	// job to become compliant with its policies.
	HasChanges types.Bool `tfsdk:"has_changes"`
	// A list of job cluster changes that have been made to the job’s cluster
	// settings in order for all job clusters to become compliant with their
	// policies.
	JobClusterChanges types.List `tfsdk:"job_cluster_changes"`
	// Updated job settings after policy enforcement. Policy enforcement only
	// applies to job clusters that are created when running the job (which are
	// specified in new_cluster) and does not apply to existing all-purpose
	// clusters. Updated job settings are derived by applying policy default
	// values to the existing job clusters in order to satisfy policy
	// requirements.
	Settings types.List `tfsdk:"settings"`
}

func (to *EnforcePolicyComplianceResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnforcePolicyComplianceResponse_SdkV2) {
	if !from.JobClusterChanges.IsNull() && !from.JobClusterChanges.IsUnknown() && to.JobClusterChanges.IsNull() && len(from.JobClusterChanges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusterChanges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusterChanges = from.JobClusterChanges
	}
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				// Recursively sync the fields of Settings
				toSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
}

func (to *EnforcePolicyComplianceResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from EnforcePolicyComplianceResponse_SdkV2) {
	if !from.JobClusterChanges.IsNull() && !from.JobClusterChanges.IsUnknown() && to.JobClusterChanges.IsNull() && len(from.JobClusterChanges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusterChanges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusterChanges = from.JobClusterChanges
	}
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				toSettings.SyncFieldsDuringRead(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
}

func (m EnforcePolicyComplianceResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_changes"] = attrs["has_changes"].SetOptional()
	attrs["job_cluster_changes"] = attrs["job_cluster_changes"].SetOptional()
	attrs["settings"] = attrs["settings"].SetOptional()
	attrs["settings"] = attrs["settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnforcePolicyComplianceResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnforcePolicyComplianceResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"job_cluster_changes": reflect.TypeOf(EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2{}),
		"settings":            reflect.TypeOf(JobSettings_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnforcePolicyComplianceResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m EnforcePolicyComplianceResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_changes":         m.HasChanges,
			"job_cluster_changes": m.JobClusterChanges,
			"settings":            m.Settings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnforcePolicyComplianceResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_changes": types.BoolType,
			"job_cluster_changes": basetypes.ListType{
				ElemType: EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2{}.Type(ctx),
			},
			"settings": basetypes.ListType{
				ElemType: JobSettings_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetJobClusterChanges returns the value of the JobClusterChanges field in EnforcePolicyComplianceResponse_SdkV2 as
// a slice of EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *EnforcePolicyComplianceResponse_SdkV2) GetJobClusterChanges(ctx context.Context) ([]EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2, bool) {
	if m.JobClusterChanges.IsNull() || m.JobClusterChanges.IsUnknown() {
		return nil, false
	}
	var v []EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2
	d := m.JobClusterChanges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusterChanges sets the value of the JobClusterChanges field in EnforcePolicyComplianceResponse_SdkV2.
func (m *EnforcePolicyComplianceResponse_SdkV2) SetJobClusterChanges(ctx context.Context, v []EnforcePolicyComplianceForJobResponseJobClusterSettingsChange_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_cluster_changes"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusterChanges = types.ListValueMust(t, vs)
}

// GetSettings returns the value of the Settings field in EnforcePolicyComplianceResponse_SdkV2 as
// a JobSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *EnforcePolicyComplianceResponse_SdkV2) GetSettings(ctx context.Context) (JobSettings_SdkV2, bool) {
	var e JobSettings_SdkV2
	if m.Settings.IsNull() || m.Settings.IsUnknown() {
		return e, false
	}
	var v []JobSettings_SdkV2
	d := m.Settings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSettings sets the value of the Settings field in EnforcePolicyComplianceResponse_SdkV2.
func (m *EnforcePolicyComplianceResponse_SdkV2) SetSettings(ctx context.Context, v JobSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["settings"]
	m.Settings = types.ListValueMust(t, vs)
}

// Run was exported successfully.
type ExportRunOutput_SdkV2 struct {
	// The exported content in HTML format (one for every view item). To extract
	// the HTML notebook from the JSON response, download and run this [Python
	// script](/_static/examples/extract.py).
	Views types.List `tfsdk:"views"`
}

func (to *ExportRunOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExportRunOutput_SdkV2) {
	if !from.Views.IsNull() && !from.Views.IsUnknown() && to.Views.IsNull() && len(from.Views.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Views, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Views = from.Views
	}
}

func (to *ExportRunOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExportRunOutput_SdkV2) {
	if !from.Views.IsNull() && !from.Views.IsUnknown() && to.Views.IsNull() && len(from.Views.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Views, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Views = from.Views
	}
}

func (m ExportRunOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["views"] = attrs["views"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExportRunOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExportRunOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"views": reflect.TypeOf(ViewItem_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExportRunOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m ExportRunOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"views": m.Views,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExportRunOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"views": basetypes.ListType{
				ElemType: ViewItem_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetViews returns the value of the Views field in ExportRunOutput_SdkV2 as
// a slice of ViewItem_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExportRunOutput_SdkV2) GetViews(ctx context.Context) ([]ViewItem_SdkV2, bool) {
	if m.Views.IsNull() || m.Views.IsUnknown() {
		return nil, false
	}
	var v []ViewItem_SdkV2
	d := m.Views.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViews sets the value of the Views field in ExportRunOutput_SdkV2.
func (m *ExportRunOutput_SdkV2) SetViews(ctx context.Context, v []ViewItem_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["views"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Views = types.ListValueMust(t, vs)
}

type ExportRunRequest_SdkV2 struct {
	// The canonical identifier for the run. This field is required.
	RunId types.Int64 `tfsdk:"-"`
	// Which views to export (CODE, DASHBOARDS, or ALL). Defaults to CODE.
	ViewsToExport types.String `tfsdk:"-"`
}

func (to *ExportRunRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExportRunRequest_SdkV2) {
}

func (to *ExportRunRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ExportRunRequest_SdkV2) {
}

func (m ExportRunRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()
	attrs["views_to_export"] = attrs["views_to_export"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExportRunRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExportRunRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExportRunRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ExportRunRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id":          m.RunId,
			"views_to_export": m.ViewsToExport,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExportRunRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id":          types.Int64Type,
			"views_to_export": types.StringType,
		},
	}
}

type FileArrivalTriggerConfiguration_SdkV2 struct {
	// If set, the trigger starts a run only after the specified amount of time
	// passed since the last time the trigger fired. The minimum allowed value
	// is 60 seconds
	MinTimeBetweenTriggersSeconds types.Int64 `tfsdk:"min_time_between_triggers_seconds"`
	// URL to be monitored for file arrivals. The path must point to the root or
	// a subpath of the external location.
	Url types.String `tfsdk:"url"`
	// If set, the trigger starts a run only after no file activity has occurred
	// for the specified amount of time. This makes it possible to wait for a
	// batch of incoming files to arrive before triggering a run. The minimum
	// allowed value is 60 seconds.
	WaitAfterLastChangeSeconds types.Int64 `tfsdk:"wait_after_last_change_seconds"`
}

func (to *FileArrivalTriggerConfiguration_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FileArrivalTriggerConfiguration_SdkV2) {
}

func (to *FileArrivalTriggerConfiguration_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FileArrivalTriggerConfiguration_SdkV2) {
}

func (m FileArrivalTriggerConfiguration_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["min_time_between_triggers_seconds"] = attrs["min_time_between_triggers_seconds"].SetOptional()
	attrs["url"] = attrs["url"].SetRequired()
	attrs["wait_after_last_change_seconds"] = attrs["wait_after_last_change_seconds"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FileArrivalTriggerConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FileArrivalTriggerConfiguration_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FileArrivalTriggerConfiguration_SdkV2
// only implements ToObjectValue() and Type().
func (m FileArrivalTriggerConfiguration_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"min_time_between_triggers_seconds": m.MinTimeBetweenTriggersSeconds,
			"url":                               m.Url,
			"wait_after_last_change_seconds":    m.WaitAfterLastChangeSeconds,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FileArrivalTriggerConfiguration_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"min_time_between_triggers_seconds": types.Int64Type,
			"url":                               types.StringType,
			"wait_after_last_change_seconds":    types.Int64Type,
		},
	}
}

type FileArrivalTriggerState_SdkV2 struct {
	// Indicates whether the trigger leverages file events to detect file
	// arrivals.
	UsingFileEvents types.Bool `tfsdk:"using_file_events"`
}

func (to *FileArrivalTriggerState_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FileArrivalTriggerState_SdkV2) {
}

func (to *FileArrivalTriggerState_SdkV2) SyncFieldsDuringRead(ctx context.Context, from FileArrivalTriggerState_SdkV2) {
}

func (m FileArrivalTriggerState_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["using_file_events"] = attrs["using_file_events"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FileArrivalTriggerState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FileArrivalTriggerState_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FileArrivalTriggerState_SdkV2
// only implements ToObjectValue() and Type().
func (m FileArrivalTriggerState_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"using_file_events": m.UsingFileEvents,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FileArrivalTriggerState_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"using_file_events": types.BoolType,
		},
	}
}

type ForEachStats_SdkV2 struct {
	// Sample of 3 most common error messages occurred during the iteration.
	ErrorMessageStats types.List `tfsdk:"error_message_stats"`
	// Describes stats of the iteration. Only latest retries are considered.
	TaskRunStats types.List `tfsdk:"task_run_stats"`
}

func (to *ForEachStats_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachStats_SdkV2) {
	if !from.ErrorMessageStats.IsNull() && !from.ErrorMessageStats.IsUnknown() && to.ErrorMessageStats.IsNull() && len(from.ErrorMessageStats.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ErrorMessageStats, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ErrorMessageStats = from.ErrorMessageStats
	}
	if !from.TaskRunStats.IsNull() && !from.TaskRunStats.IsUnknown() {
		if toTaskRunStats, ok := to.GetTaskRunStats(ctx); ok {
			if fromTaskRunStats, ok := from.GetTaskRunStats(ctx); ok {
				// Recursively sync the fields of TaskRunStats
				toTaskRunStats.SyncFieldsDuringCreateOrUpdate(ctx, fromTaskRunStats)
				to.SetTaskRunStats(ctx, toTaskRunStats)
			}
		}
	}
}

func (to *ForEachStats_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ForEachStats_SdkV2) {
	if !from.ErrorMessageStats.IsNull() && !from.ErrorMessageStats.IsUnknown() && to.ErrorMessageStats.IsNull() && len(from.ErrorMessageStats.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ErrorMessageStats, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ErrorMessageStats = from.ErrorMessageStats
	}
	if !from.TaskRunStats.IsNull() && !from.TaskRunStats.IsUnknown() {
		if toTaskRunStats, ok := to.GetTaskRunStats(ctx); ok {
			if fromTaskRunStats, ok := from.GetTaskRunStats(ctx); ok {
				toTaskRunStats.SyncFieldsDuringRead(ctx, fromTaskRunStats)
				to.SetTaskRunStats(ctx, toTaskRunStats)
			}
		}
	}
}

func (m ForEachStats_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["error_message_stats"] = attrs["error_message_stats"].SetOptional()
	attrs["task_run_stats"] = attrs["task_run_stats"].SetOptional()
	attrs["task_run_stats"] = attrs["task_run_stats"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachStats.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachStats_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"error_message_stats": reflect.TypeOf(ForEachTaskErrorMessageStats_SdkV2{}),
		"task_run_stats":      reflect.TypeOf(ForEachTaskTaskRunStats_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachStats_SdkV2
// only implements ToObjectValue() and Type().
func (m ForEachStats_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"error_message_stats": m.ErrorMessageStats,
			"task_run_stats":      m.TaskRunStats,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachStats_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"error_message_stats": basetypes.ListType{
				ElemType: ForEachTaskErrorMessageStats_SdkV2{}.Type(ctx),
			},
			"task_run_stats": basetypes.ListType{
				ElemType: ForEachTaskTaskRunStats_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetErrorMessageStats returns the value of the ErrorMessageStats field in ForEachStats_SdkV2 as
// a slice of ForEachTaskErrorMessageStats_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ForEachStats_SdkV2) GetErrorMessageStats(ctx context.Context) ([]ForEachTaskErrorMessageStats_SdkV2, bool) {
	if m.ErrorMessageStats.IsNull() || m.ErrorMessageStats.IsUnknown() {
		return nil, false
	}
	var v []ForEachTaskErrorMessageStats_SdkV2
	d := m.ErrorMessageStats.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetErrorMessageStats sets the value of the ErrorMessageStats field in ForEachStats_SdkV2.
func (m *ForEachStats_SdkV2) SetErrorMessageStats(ctx context.Context, v []ForEachTaskErrorMessageStats_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["error_message_stats"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ErrorMessageStats = types.ListValueMust(t, vs)
}

// GetTaskRunStats returns the value of the TaskRunStats field in ForEachStats_SdkV2 as
// a ForEachTaskTaskRunStats_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ForEachStats_SdkV2) GetTaskRunStats(ctx context.Context) (ForEachTaskTaskRunStats_SdkV2, bool) {
	var e ForEachTaskTaskRunStats_SdkV2
	if m.TaskRunStats.IsNull() || m.TaskRunStats.IsUnknown() {
		return e, false
	}
	var v []ForEachTaskTaskRunStats_SdkV2
	d := m.TaskRunStats.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTaskRunStats sets the value of the TaskRunStats field in ForEachStats_SdkV2.
func (m *ForEachStats_SdkV2) SetTaskRunStats(ctx context.Context, v ForEachTaskTaskRunStats_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task_run_stats"]
	m.TaskRunStats = types.ListValueMust(t, vs)
}

type ForEachTask_SdkV2 struct {
	// An optional maximum allowed number of concurrent runs of the task. Set
	// this value if you want to be able to execute multiple runs of the task
	// concurrently.
	Concurrency types.Int64 `tfsdk:"concurrency"`
	// Array for task to iterate on. This can be a JSON string or a reference to
	// an array parameter.
	Inputs types.String `tfsdk:"inputs"`
	// Configuration for the task that will be run for each element in the array
	Task types.List `tfsdk:"task"`
}

func (to *ForEachTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachTask_SdkV2) {
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				// Recursively sync the fields of Task
				toTask.SyncFieldsDuringCreateOrUpdate(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (to *ForEachTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ForEachTask_SdkV2) {
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				toTask.SyncFieldsDuringRead(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (m ForEachTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["concurrency"] = attrs["concurrency"].SetOptional()
	attrs["inputs"] = attrs["inputs"].SetRequired()
	attrs["task"] = attrs["task"].SetRequired()
	attrs["task"] = attrs["task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"task": reflect.TypeOf(Task_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachTask_SdkV2
// only implements ToObjectValue() and Type().
func (m ForEachTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"concurrency": m.Concurrency,
			"inputs":      m.Inputs,
			"task":        m.Task,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"concurrency": types.Int64Type,
			"inputs":      types.StringType,
			"task": basetypes.ListType{
				ElemType: Task_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetTask returns the value of the Task field in ForEachTask_SdkV2 as
// a Task_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ForEachTask_SdkV2) GetTask(ctx context.Context) (Task_SdkV2, bool) {
	var e Task_SdkV2
	if m.Task.IsNull() || m.Task.IsUnknown() {
		return e, false
	}
	var v []Task_SdkV2
	d := m.Task.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTask sets the value of the Task field in ForEachTask_SdkV2.
func (m *ForEachTask_SdkV2) SetTask(ctx context.Context, v Task_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task"]
	m.Task = types.ListValueMust(t, vs)
}

type ForEachTaskErrorMessageStats_SdkV2 struct {
	// Describes the count of such error message encountered during the
	// iterations.
	Count types.Int64 `tfsdk:"count"`
	// Describes the error message occured during the iterations.
	ErrorMessage types.String `tfsdk:"error_message"`
	// Describes the termination reason for the error message.
	TerminationCategory types.String `tfsdk:"termination_category"`
}

func (to *ForEachTaskErrorMessageStats_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachTaskErrorMessageStats_SdkV2) {
}

func (to *ForEachTaskErrorMessageStats_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ForEachTaskErrorMessageStats_SdkV2) {
}

func (m ForEachTaskErrorMessageStats_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["count"] = attrs["count"].SetOptional()
	attrs["error_message"] = attrs["error_message"].SetOptional()
	attrs["termination_category"] = attrs["termination_category"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachTaskErrorMessageStats.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachTaskErrorMessageStats_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachTaskErrorMessageStats_SdkV2
// only implements ToObjectValue() and Type().
func (m ForEachTaskErrorMessageStats_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"count":                m.Count,
			"error_message":        m.ErrorMessage,
			"termination_category": m.TerminationCategory,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachTaskErrorMessageStats_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"count":                types.Int64Type,
			"error_message":        types.StringType,
			"termination_category": types.StringType,
		},
	}
}

type ForEachTaskTaskRunStats_SdkV2 struct {
	// Describes the iteration runs having an active lifecycle state or an
	// active run sub state.
	ActiveIterations types.Int64 `tfsdk:"active_iterations"`
	// Describes the number of failed and succeeded iteration runs.
	CompletedIterations types.Int64 `tfsdk:"completed_iterations"`
	// Describes the number of failed iteration runs.
	FailedIterations types.Int64 `tfsdk:"failed_iterations"`
	// Describes the number of iteration runs that have been scheduled.
	ScheduledIterations types.Int64 `tfsdk:"scheduled_iterations"`
	// Describes the number of succeeded iteration runs.
	SucceededIterations types.Int64 `tfsdk:"succeeded_iterations"`
	// Describes the length of the list of items to iterate over.
	TotalIterations types.Int64 `tfsdk:"total_iterations"`
}

func (to *ForEachTaskTaskRunStats_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachTaskTaskRunStats_SdkV2) {
}

func (to *ForEachTaskTaskRunStats_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ForEachTaskTaskRunStats_SdkV2) {
}

func (m ForEachTaskTaskRunStats_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active_iterations"] = attrs["active_iterations"].SetOptional()
	attrs["completed_iterations"] = attrs["completed_iterations"].SetOptional()
	attrs["failed_iterations"] = attrs["failed_iterations"].SetOptional()
	attrs["scheduled_iterations"] = attrs["scheduled_iterations"].SetOptional()
	attrs["succeeded_iterations"] = attrs["succeeded_iterations"].SetOptional()
	attrs["total_iterations"] = attrs["total_iterations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachTaskTaskRunStats.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachTaskTaskRunStats_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachTaskTaskRunStats_SdkV2
// only implements ToObjectValue() and Type().
func (m ForEachTaskTaskRunStats_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active_iterations":    m.ActiveIterations,
			"completed_iterations": m.CompletedIterations,
			"failed_iterations":    m.FailedIterations,
			"scheduled_iterations": m.ScheduledIterations,
			"succeeded_iterations": m.SucceededIterations,
			"total_iterations":     m.TotalIterations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachTaskTaskRunStats_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active_iterations":    types.Int64Type,
			"completed_iterations": types.Int64Type,
			"failed_iterations":    types.Int64Type,
			"scheduled_iterations": types.Int64Type,
			"succeeded_iterations": types.Int64Type,
			"total_iterations":     types.Int64Type,
		},
	}
}

type GenAiComputeTask_SdkV2 struct {
	// Command launcher to run the actual script, e.g. bash, python etc.
	Command types.String `tfsdk:"command"`

	Compute types.List `tfsdk:"compute"`
	// Runtime image
	DlRuntimeImage types.String `tfsdk:"dl_runtime_image"`
	// Optional string containing the name of the MLflow experiment to log the
	// run to. If name is not found, backend will create the mlflow experiment
	// using the name.
	MlflowExperimentName types.String `tfsdk:"mlflow_experiment_name"`
	// Optional location type of the training script. When set to `WORKSPACE`,
	// the script will be retrieved from the local Databricks workspace. When
	// set to `GIT`, the script will be retrieved from a Git repository defined
	// in `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise. * `WORKSPACE`: Script
	// is located in Databricks workspace. * `GIT`: Script is located in cloud
	// Git provider.
	Source types.String `tfsdk:"source"`
	// The training script file path to be executed. Cloud file URIs (such as
	// dbfs:/, s3:/, adls:/, gcs:/) and workspace paths are supported. For
	// python files stored in the Databricks workspace, the path must be
	// absolute and begin with `/`. For files stored in a remote repository, the
	// path must be relative. This field is required.
	TrainingScriptPath types.String `tfsdk:"training_script_path"`
	// Optional string containing model parameters passed to the training script
	// in yaml format. If present, then the content in yaml_parameters_file_path
	// will be ignored.
	YamlParameters types.String `tfsdk:"yaml_parameters"`
	// Optional path to a YAML file containing model parameters passed to the
	// training script.
	YamlParametersFilePath types.String `tfsdk:"yaml_parameters_file_path"`
}

func (to *GenAiComputeTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenAiComputeTask_SdkV2) {
	if !from.Compute.IsNull() && !from.Compute.IsUnknown() {
		if toCompute, ok := to.GetCompute(ctx); ok {
			if fromCompute, ok := from.GetCompute(ctx); ok {
				// Recursively sync the fields of Compute
				toCompute.SyncFieldsDuringCreateOrUpdate(ctx, fromCompute)
				to.SetCompute(ctx, toCompute)
			}
		}
	}
}

func (to *GenAiComputeTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GenAiComputeTask_SdkV2) {
	if !from.Compute.IsNull() && !from.Compute.IsUnknown() {
		if toCompute, ok := to.GetCompute(ctx); ok {
			if fromCompute, ok := from.GetCompute(ctx); ok {
				toCompute.SyncFieldsDuringRead(ctx, fromCompute)
				to.SetCompute(ctx, toCompute)
			}
		}
	}
}

func (m GenAiComputeTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["command"] = attrs["command"].SetOptional()
	attrs["compute"] = attrs["compute"].SetOptional()
	attrs["compute"] = attrs["compute"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dl_runtime_image"] = attrs["dl_runtime_image"].SetRequired()
	attrs["mlflow_experiment_name"] = attrs["mlflow_experiment_name"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["training_script_path"] = attrs["training_script_path"].SetOptional()
	attrs["yaml_parameters"] = attrs["yaml_parameters"].SetOptional()
	attrs["yaml_parameters_file_path"] = attrs["yaml_parameters_file_path"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenAiComputeTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenAiComputeTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"compute": reflect.TypeOf(ComputeConfig_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenAiComputeTask_SdkV2
// only implements ToObjectValue() and Type().
func (m GenAiComputeTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"command":                   m.Command,
			"compute":                   m.Compute,
			"dl_runtime_image":          m.DlRuntimeImage,
			"mlflow_experiment_name":    m.MlflowExperimentName,
			"source":                    m.Source,
			"training_script_path":      m.TrainingScriptPath,
			"yaml_parameters":           m.YamlParameters,
			"yaml_parameters_file_path": m.YamlParametersFilePath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenAiComputeTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"command": types.StringType,
			"compute": basetypes.ListType{
				ElemType: ComputeConfig_SdkV2{}.Type(ctx),
			},
			"dl_runtime_image":          types.StringType,
			"mlflow_experiment_name":    types.StringType,
			"source":                    types.StringType,
			"training_script_path":      types.StringType,
			"yaml_parameters":           types.StringType,
			"yaml_parameters_file_path": types.StringType,
		},
	}
}

// GetCompute returns the value of the Compute field in GenAiComputeTask_SdkV2 as
// a ComputeConfig_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenAiComputeTask_SdkV2) GetCompute(ctx context.Context) (ComputeConfig_SdkV2, bool) {
	var e ComputeConfig_SdkV2
	if m.Compute.IsNull() || m.Compute.IsUnknown() {
		return e, false
	}
	var v []ComputeConfig_SdkV2
	d := m.Compute.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCompute sets the value of the Compute field in GenAiComputeTask_SdkV2.
func (m *GenAiComputeTask_SdkV2) SetCompute(ctx context.Context, v ComputeConfig_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["compute"]
	m.Compute = types.ListValueMust(t, vs)
}

type GetJobPermissionLevelsRequest_SdkV2 struct {
	// The job for which to get or manage permissions.
	JobId types.String `tfsdk:"-"`
}

func (to *GetJobPermissionLevelsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobPermissionLevelsRequest_SdkV2) {
}

func (to *GetJobPermissionLevelsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetJobPermissionLevelsRequest_SdkV2) {
}

func (m GetJobPermissionLevelsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobPermissionLevelsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobPermissionLevelsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobPermissionLevelsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetJobPermissionLevelsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobPermissionLevelsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.StringType,
		},
	}
}

type GetJobPermissionLevelsResponse_SdkV2 struct {
	// Specific permission levels
	PermissionLevels types.List `tfsdk:"permission_levels"`
}

func (to *GetJobPermissionLevelsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobPermissionLevelsResponse_SdkV2) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (to *GetJobPermissionLevelsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetJobPermissionLevelsResponse_SdkV2) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (m GetJobPermissionLevelsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permission_levels"] = attrs["permission_levels"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobPermissionLevelsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobPermissionLevelsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permission_levels": reflect.TypeOf(JobPermissionsDescription_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobPermissionLevelsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetJobPermissionLevelsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permission_levels": m.PermissionLevels,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobPermissionLevelsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permission_levels": basetypes.ListType{
				ElemType: JobPermissionsDescription_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPermissionLevels returns the value of the PermissionLevels field in GetJobPermissionLevelsResponse_SdkV2 as
// a slice of JobPermissionsDescription_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetJobPermissionLevelsResponse_SdkV2) GetPermissionLevels(ctx context.Context) ([]JobPermissionsDescription_SdkV2, bool) {
	if m.PermissionLevels.IsNull() || m.PermissionLevels.IsUnknown() {
		return nil, false
	}
	var v []JobPermissionsDescription_SdkV2
	d := m.PermissionLevels.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissionLevels sets the value of the PermissionLevels field in GetJobPermissionLevelsResponse_SdkV2.
func (m *GetJobPermissionLevelsResponse_SdkV2) SetPermissionLevels(ctx context.Context, v []JobPermissionsDescription_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["permission_levels"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PermissionLevels = types.ListValueMust(t, vs)
}

type GetJobPermissionsRequest_SdkV2 struct {
	// The job for which to get or manage permissions.
	JobId types.String `tfsdk:"-"`
}

func (to *GetJobPermissionsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobPermissionsRequest_SdkV2) {
}

func (to *GetJobPermissionsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetJobPermissionsRequest_SdkV2) {
}

func (m GetJobPermissionsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobPermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobPermissionsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobPermissionsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetJobPermissionsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobPermissionsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.StringType,
		},
	}
}

type GetJobRequest_SdkV2 struct {
	// The canonical identifier of the job to retrieve information about. This
	// field is required.
	JobId types.Int64 `tfsdk:"-"`
	// Use `next_page_token` returned from the previous GetJob response to
	// request the next page of the job's array properties.
	PageToken types.String `tfsdk:"-"`
}

func (to *GetJobRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobRequest_SdkV2) {
}

func (to *GetJobRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetJobRequest_SdkV2) {
}

func (m GetJobRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetJobRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id":     m.JobId,
			"page_token": m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id":     types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

type GetPolicyComplianceRequest_SdkV2 struct {
	// The ID of the job whose compliance status you are requesting.
	JobId types.Int64 `tfsdk:"-"`
}

func (to *GetPolicyComplianceRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPolicyComplianceRequest_SdkV2) {
}

func (to *GetPolicyComplianceRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetPolicyComplianceRequest_SdkV2) {
}

func (m GetPolicyComplianceRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPolicyComplianceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPolicyComplianceRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPolicyComplianceRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetPolicyComplianceRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPolicyComplianceRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
		},
	}
}

type GetPolicyComplianceResponse_SdkV2 struct {
	// Whether the job is compliant with its policies or not. Jobs could be out
	// of compliance if a policy they are using was updated after the job was
	// last edited and some of its job clusters no longer comply with their
	// updated policies.
	IsCompliant types.Bool `tfsdk:"is_compliant"`
	// An object containing key-value mappings representing the first 200 policy
	// validation errors. The keys indicate the path where the policy validation
	// error is occurring. An identifier for the job cluster is prepended to the
	// path. The values indicate an error message describing the policy
	// validation error.
	Violations types.Map `tfsdk:"violations"`
}

func (to *GetPolicyComplianceResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPolicyComplianceResponse_SdkV2) {
}

func (to *GetPolicyComplianceResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetPolicyComplianceResponse_SdkV2) {
}

func (m GetPolicyComplianceResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_compliant"] = attrs["is_compliant"].SetOptional()
	attrs["violations"] = attrs["violations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPolicyComplianceResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPolicyComplianceResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"violations": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPolicyComplianceResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m GetPolicyComplianceResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_compliant": m.IsCompliant,
			"violations":   m.Violations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPolicyComplianceResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_compliant": types.BoolType,
			"violations": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetViolations returns the value of the Violations field in GetPolicyComplianceResponse_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetPolicyComplianceResponse_SdkV2) GetViolations(ctx context.Context) (map[string]types.String, bool) {
	if m.Violations.IsNull() || m.Violations.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Violations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViolations sets the value of the Violations field in GetPolicyComplianceResponse_SdkV2.
func (m *GetPolicyComplianceResponse_SdkV2) SetViolations(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["violations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Violations = types.MapValueMust(t, vs)
}

type GetRunOutputRequest_SdkV2 struct {
	// The canonical identifier for the run.
	RunId types.Int64 `tfsdk:"-"`
}

func (to *GetRunOutputRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRunOutputRequest_SdkV2) {
}

func (to *GetRunOutputRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetRunOutputRequest_SdkV2) {
}

func (m GetRunOutputRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRunOutputRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetRunOutputRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRunOutputRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetRunOutputRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetRunOutputRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type GetRunRequest_SdkV2 struct {
	// Whether to include the repair history in the response.
	IncludeHistory types.Bool `tfsdk:"-"`
	// Whether to include resolved parameter values in the response.
	IncludeResolvedValues types.Bool `tfsdk:"-"`
	// Use `next_page_token` returned from the previous GetRun response to
	// request the next page of the run's array properties.
	PageToken types.String `tfsdk:"-"`
	// The canonical identifier of the run for which to retrieve the metadata.
	// This field is required.
	RunId types.Int64 `tfsdk:"-"`
}

func (to *GetRunRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRunRequest_SdkV2) {
}

func (to *GetRunRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetRunRequest_SdkV2) {
}

func (m GetRunRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()
	attrs["include_history"] = attrs["include_history"].SetOptional()
	attrs["include_resolved_values"] = attrs["include_resolved_values"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRunRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetRunRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRunRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetRunRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_history":         m.IncludeHistory,
			"include_resolved_values": m.IncludeResolvedValues,
			"page_token":              m.PageToken,
			"run_id":                  m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetRunRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_history":         types.BoolType,
			"include_resolved_values": types.BoolType,
			"page_token":              types.StringType,
			"run_id":                  types.Int64Type,
		},
	}
}

// Read-only state of the remote repository at the time the job was run. This
// field is only included on job runs.
type GitSnapshot_SdkV2 struct {
	// Commit that was used to execute the run. If git_branch was specified,
	// this points to the HEAD of the branch at the time of the run; if git_tag
	// was specified, this points to the commit the tag points to.
	UsedCommit types.String `tfsdk:"used_commit"`
}

func (to *GitSnapshot_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GitSnapshot_SdkV2) {
}

func (to *GitSnapshot_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GitSnapshot_SdkV2) {
}

func (m GitSnapshot_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["used_commit"] = attrs["used_commit"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GitSnapshot.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GitSnapshot_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GitSnapshot_SdkV2
// only implements ToObjectValue() and Type().
func (m GitSnapshot_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"used_commit": m.UsedCommit,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GitSnapshot_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"used_commit": types.StringType,
		},
	}
}

// An optional specification for a remote Git repository containing the source
// code used by tasks. Version-controlled source code is supported by notebook,
// dbt, Python script, and SQL File tasks.
//
// If `git_source` is set, these tasks retrieve the file from the remote
// repository by default. However, this behavior can be overridden by setting
// `source` to `WORKSPACE` on the task.
//
// Note: dbt and SQL File tasks support only version-controlled sources. If dbt
// or SQL File tasks are used, `git_source` must be defined on the job.
type GitSource_SdkV2 struct {
	// Name of the branch to be checked out and used by this job. This field
	// cannot be specified in conjunction with git_tag or git_commit.
	GitBranch types.String `tfsdk:"branch"`
	// Commit to be checked out and used by this job. This field cannot be
	// specified in conjunction with git_branch or git_tag.
	GitCommit types.String `tfsdk:"commit"`
	// Unique identifier of the service used to host the Git repository. The
	// value is case insensitive.
	GitProvider types.String `tfsdk:"provider"`

	GitSnapshot types.List `tfsdk:"git_snapshot"`
	// Name of the tag to be checked out and used by this job. This field cannot
	// be specified in conjunction with git_branch or git_commit.
	GitTag types.String `tfsdk:"tag"`
	// URL of the repository to be cloned by this job.
	GitUrl types.String `tfsdk:"url"`
	// The source of the job specification in the remote repository when the job
	// is source controlled.
	JobSource types.List `tfsdk:"job_source"`
}

func (to *GitSource_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GitSource_SdkV2) {
	if !from.GitSnapshot.IsNull() && !from.GitSnapshot.IsUnknown() {
		if toGitSnapshot, ok := to.GetGitSnapshot(ctx); ok {
			if fromGitSnapshot, ok := from.GetGitSnapshot(ctx); ok {
				// Recursively sync the fields of GitSnapshot
				toGitSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSnapshot)
				to.SetGitSnapshot(ctx, toGitSnapshot)
			}
		}
	}
	if !from.JobSource.IsNull() && !from.JobSource.IsUnknown() {
		if toJobSource, ok := to.GetJobSource(ctx); ok {
			if fromJobSource, ok := from.GetJobSource(ctx); ok {
				// Recursively sync the fields of JobSource
				toJobSource.SyncFieldsDuringCreateOrUpdate(ctx, fromJobSource)
				to.SetJobSource(ctx, toJobSource)
			}
		}
	}
}

func (to *GitSource_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GitSource_SdkV2) {
	if !from.GitSnapshot.IsNull() && !from.GitSnapshot.IsUnknown() {
		if toGitSnapshot, ok := to.GetGitSnapshot(ctx); ok {
			if fromGitSnapshot, ok := from.GetGitSnapshot(ctx); ok {
				toGitSnapshot.SyncFieldsDuringRead(ctx, fromGitSnapshot)
				to.SetGitSnapshot(ctx, toGitSnapshot)
			}
		}
	}
	if !from.JobSource.IsNull() && !from.JobSource.IsUnknown() {
		if toJobSource, ok := to.GetJobSource(ctx); ok {
			if fromJobSource, ok := from.GetJobSource(ctx); ok {
				toJobSource.SyncFieldsDuringRead(ctx, fromJobSource)
				to.SetJobSource(ctx, toJobSource)
			}
		}
	}
}

func (m GitSource_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["branch"] = attrs["branch"].SetOptional()
	attrs["commit"] = attrs["commit"].SetOptional()
	attrs["provider"] = attrs["provider"].SetRequired()
	attrs["git_snapshot"] = attrs["git_snapshot"].SetOptional()
	attrs["git_snapshot"] = attrs["git_snapshot"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["tag"] = attrs["tag"].SetOptional()
	attrs["url"] = attrs["url"].SetRequired()
	attrs["job_source"] = attrs["job_source"].SetOptional()
	attrs["job_source"] = attrs["job_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GitSource.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GitSource_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"git_snapshot": reflect.TypeOf(GitSnapshot_SdkV2{}),
		"job_source":   reflect.TypeOf(JobSource_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GitSource_SdkV2
// only implements ToObjectValue() and Type().
func (m GitSource_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"branch":       m.GitBranch,
			"commit":       m.GitCommit,
			"provider":     m.GitProvider,
			"git_snapshot": m.GitSnapshot,
			"tag":          m.GitTag,
			"url":          m.GitUrl,
			"job_source":   m.JobSource,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GitSource_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"branch":   types.StringType,
			"commit":   types.StringType,
			"provider": types.StringType,
			"git_snapshot": basetypes.ListType{
				ElemType: GitSnapshot_SdkV2{}.Type(ctx),
			},
			"tag": types.StringType,
			"url": types.StringType,
			"job_source": basetypes.ListType{
				ElemType: JobSource_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetGitSnapshot returns the value of the GitSnapshot field in GitSource_SdkV2 as
// a GitSnapshot_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GitSource_SdkV2) GetGitSnapshot(ctx context.Context) (GitSnapshot_SdkV2, bool) {
	var e GitSnapshot_SdkV2
	if m.GitSnapshot.IsNull() || m.GitSnapshot.IsUnknown() {
		return e, false
	}
	var v []GitSnapshot_SdkV2
	d := m.GitSnapshot.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSnapshot sets the value of the GitSnapshot field in GitSource_SdkV2.
func (m *GitSource_SdkV2) SetGitSnapshot(ctx context.Context, v GitSnapshot_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_snapshot"]
	m.GitSnapshot = types.ListValueMust(t, vs)
}

// GetJobSource returns the value of the JobSource field in GitSource_SdkV2 as
// a JobSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *GitSource_SdkV2) GetJobSource(ctx context.Context) (JobSource_SdkV2, bool) {
	var e JobSource_SdkV2
	if m.JobSource.IsNull() || m.JobSource.IsUnknown() {
		return e, false
	}
	var v []JobSource_SdkV2
	d := m.JobSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetJobSource sets the value of the JobSource field in GitSource_SdkV2.
func (m *GitSource_SdkV2) SetJobSource(ctx context.Context, v JobSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_source"]
	m.JobSource = types.ListValueMust(t, vs)
}

// Job was retrieved successfully.
type Job_SdkV2 struct {
	// The time at which this job was created in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC).
	CreatedTime types.Int64 `tfsdk:"created_time"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// The id of the budget policy used by this job for cost attribution
	// purposes. This may be set through (in order of precedence): 1. Budget
	// admins through the account or workspace console 2. Jobs UI in the job
	// details page and Jobs API using `budget_policy_id` 3. Inferred default
	// based on accessible budget policies of the run_as identity on job
	// creation or modification.
	EffectiveBudgetPolicyId types.String `tfsdk:"effective_budget_policy_id"`
	// The id of the usage policy used by this job for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// Indicates if the job has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/get endpoint.
	// It is only relevant for API 2.2 :method:jobs/list requests with
	// `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// The canonical identifier for this job.
	JobId types.Int64 `tfsdk:"job_id"`
	// A token that can be used to list the next page of array properties.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The email of an active workspace user or the application ID of a service
	// principal that the job runs as. This value can be changed by setting the
	// `run_as` field when creating or updating a job.
	//
	// By default, `run_as_user_name` is based on the current job settings and
	// is set to the creator of the job if job access control is disabled or to
	// the user with the `is_owner` permission if job access control is enabled.
	RunAsUserName types.String `tfsdk:"run_as_user_name"`
	// Settings for this job and all of its runs. These settings can be updated
	// using the `resetJob` method.
	Settings types.List `tfsdk:"settings"`
	// State of the trigger associated with the job.
	TriggerState types.List `tfsdk:"trigger_state"`
}

func (to *Job_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Job_SdkV2) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				// Recursively sync the fields of Settings
				toSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				// Recursively sync the fields of TriggerState
				toTriggerState.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (to *Job_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Job_SdkV2) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				toSettings.SyncFieldsDuringRead(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				toTriggerState.SyncFieldsDuringRead(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (m Job_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["created_time"] = attrs["created_time"].SetOptional()
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["effective_budget_policy_id"] = attrs["effective_budget_policy_id"].SetComputed()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["run_as_user_name"] = attrs["run_as_user_name"].SetOptional()
	attrs["settings"] = attrs["settings"].SetOptional()
	attrs["settings"] = attrs["settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["trigger_state"] = attrs["trigger_state"].SetComputed()
	attrs["trigger_state"] = attrs["trigger_state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Job.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Job_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"settings":      reflect.TypeOf(JobSettings_SdkV2{}),
		"trigger_state": reflect.TypeOf(TriggerStateProto_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Job_SdkV2
// only implements ToObjectValue() and Type().
func (m Job_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"created_time":               m.CreatedTime,
			"creator_user_name":          m.CreatorUserName,
			"effective_budget_policy_id": m.EffectiveBudgetPolicyId,
			"effective_usage_policy_id":  m.EffectiveUsagePolicyId,
			"has_more":                   m.HasMore,
			"job_id":                     m.JobId,
			"next_page_token":            m.NextPageToken,
			"run_as_user_name":           m.RunAsUserName,
			"settings":                   m.Settings,
			"trigger_state":              m.TriggerState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Job_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"created_time":               types.Int64Type,
			"creator_user_name":          types.StringType,
			"effective_budget_policy_id": types.StringType,
			"effective_usage_policy_id":  types.StringType,
			"has_more":                   types.BoolType,
			"job_id":                     types.Int64Type,
			"next_page_token":            types.StringType,
			"run_as_user_name":           types.StringType,
			"settings": basetypes.ListType{
				ElemType: JobSettings_SdkV2{}.Type(ctx),
			},
			"trigger_state": basetypes.ListType{
				ElemType: TriggerStateProto_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSettings returns the value of the Settings field in Job_SdkV2 as
// a JobSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Job_SdkV2) GetSettings(ctx context.Context) (JobSettings_SdkV2, bool) {
	var e JobSettings_SdkV2
	if m.Settings.IsNull() || m.Settings.IsUnknown() {
		return e, false
	}
	var v []JobSettings_SdkV2
	d := m.Settings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSettings sets the value of the Settings field in Job_SdkV2.
func (m *Job_SdkV2) SetSettings(ctx context.Context, v JobSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["settings"]
	m.Settings = types.ListValueMust(t, vs)
}

// GetTriggerState returns the value of the TriggerState field in Job_SdkV2 as
// a TriggerStateProto_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Job_SdkV2) GetTriggerState(ctx context.Context) (TriggerStateProto_SdkV2, bool) {
	var e TriggerStateProto_SdkV2
	if m.TriggerState.IsNull() || m.TriggerState.IsUnknown() {
		return e, false
	}
	var v []TriggerStateProto_SdkV2
	d := m.TriggerState.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTriggerState sets the value of the TriggerState field in Job_SdkV2.
func (m *Job_SdkV2) SetTriggerState(ctx context.Context, v TriggerStateProto_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["trigger_state"]
	m.TriggerState = types.ListValueMust(t, vs)
}

type JobAccessControlRequest_SdkV2 struct {
	// name of the group
	GroupName types.String `tfsdk:"group_name"`

	PermissionLevel types.String `tfsdk:"permission_level"`
	// application ID of a service principal
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *JobAccessControlRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobAccessControlRequest_SdkV2) {
}

func (to *JobAccessControlRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobAccessControlRequest_SdkV2) {
}

func (m JobAccessControlRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobAccessControlRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobAccessControlRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobAccessControlRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m JobAccessControlRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"group_name":             m.GroupName,
			"permission_level":       m.PermissionLevel,
			"service_principal_name": m.ServicePrincipalName,
			"user_name":              m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobAccessControlRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"group_name":             types.StringType,
			"permission_level":       types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type JobAccessControlResponse_SdkV2 struct {
	// All permissions.
	AllPermissions types.List `tfsdk:"all_permissions"`
	// Display name of the user or service principal.
	DisplayName types.String `tfsdk:"display_name"`
	// name of the group
	GroupName types.String `tfsdk:"group_name"`
	// Name of the service principal.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *JobAccessControlResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobAccessControlResponse_SdkV2) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (to *JobAccessControlResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobAccessControlResponse_SdkV2) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (m JobAccessControlResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["all_permissions"] = attrs["all_permissions"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobAccessControlResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobAccessControlResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"all_permissions": reflect.TypeOf(JobPermission_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobAccessControlResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m JobAccessControlResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"all_permissions":        m.AllPermissions,
			"display_name":           m.DisplayName,
			"group_name":             m.GroupName,
			"service_principal_name": m.ServicePrincipalName,
			"user_name":              m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobAccessControlResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"all_permissions": basetypes.ListType{
				ElemType: JobPermission_SdkV2{}.Type(ctx),
			},
			"display_name":           types.StringType,
			"group_name":             types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

// GetAllPermissions returns the value of the AllPermissions field in JobAccessControlResponse_SdkV2 as
// a slice of JobPermission_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobAccessControlResponse_SdkV2) GetAllPermissions(ctx context.Context) ([]JobPermission_SdkV2, bool) {
	if m.AllPermissions.IsNull() || m.AllPermissions.IsUnknown() {
		return nil, false
	}
	var v []JobPermission_SdkV2
	d := m.AllPermissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAllPermissions sets the value of the AllPermissions field in JobAccessControlResponse_SdkV2.
func (m *JobAccessControlResponse_SdkV2) SetAllPermissions(ctx context.Context, v []JobPermission_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["all_permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AllPermissions = types.ListValueMust(t, vs)
}

type JobCluster_SdkV2 struct {
	// A unique name for the job cluster. This field is required and must be
	// unique within the job. `JobTaskSettings` may refer to this field to
	// determine which cluster to launch for the task execution.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// If new_cluster, a description of a cluster that is created for each task.
	NewCluster types.List `tfsdk:"new_cluster"`
}

func (to *JobCluster_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobCluster_SdkV2) {
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (to *JobCluster_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobCluster_SdkV2) {
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (m JobCluster_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetRequired()
	attrs["new_cluster"] = attrs["new_cluster"].SetRequired()
	attrs["new_cluster"] = attrs["new_cluster"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobCluster.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobCluster_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"new_cluster": reflect.TypeOf(compute_tf.ClusterSpec_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobCluster_SdkV2
// only implements ToObjectValue() and Type().
func (m JobCluster_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_cluster_key": m.JobClusterKey,
			"new_cluster":     m.NewCluster,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobCluster_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_cluster_key": types.StringType,
			"new_cluster": basetypes.ListType{
				ElemType: compute_tf.ClusterSpec_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetNewCluster returns the value of the NewCluster field in JobCluster_SdkV2 as
// a compute_tf.ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobCluster_SdkV2) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec_SdkV2, bool) {
	var e compute_tf.ClusterSpec_SdkV2
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v []compute_tf.ClusterSpec_SdkV2
	d := m.NewCluster.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewCluster sets the value of the NewCluster field in JobCluster_SdkV2.
func (m *JobCluster_SdkV2) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_cluster"]
	m.NewCluster = types.ListValueMust(t, vs)
}

type JobCompliance_SdkV2 struct {
	// Whether this job is in compliance with the latest version of its policy.
	IsCompliant types.Bool `tfsdk:"is_compliant"`
	// Canonical unique identifier for a job.
	JobId types.Int64 `tfsdk:"job_id"`
	// An object containing key-value mappings representing the first 200 policy
	// validation errors. The keys indicate the path where the policy validation
	// error is occurring. An identifier for the job cluster is prepended to the
	// path. The values indicate an error message describing the policy
	// validation error.
	Violations types.Map `tfsdk:"violations"`
}

func (to *JobCompliance_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobCompliance_SdkV2) {
}

func (to *JobCompliance_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobCompliance_SdkV2) {
}

func (m JobCompliance_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_compliant"] = attrs["is_compliant"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["violations"] = attrs["violations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobCompliance.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobCompliance_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"violations": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobCompliance_SdkV2
// only implements ToObjectValue() and Type().
func (m JobCompliance_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_compliant": m.IsCompliant,
			"job_id":       m.JobId,
			"violations":   m.Violations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobCompliance_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_compliant": types.BoolType,
			"job_id":       types.Int64Type,
			"violations": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetViolations returns the value of the Violations field in JobCompliance_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobCompliance_SdkV2) GetViolations(ctx context.Context) (map[string]types.String, bool) {
	if m.Violations.IsNull() || m.Violations.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Violations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViolations sets the value of the Violations field in JobCompliance_SdkV2.
func (m *JobCompliance_SdkV2) SetViolations(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["violations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Violations = types.MapValueMust(t, vs)
}

type JobDeployment_SdkV2 struct {
	// The kind of deployment that manages the job.
	//
	// * `BUNDLE`: The job is managed by Databricks Asset Bundle.
	Kind types.String `tfsdk:"kind"`
	// Path of the file that contains deployment metadata.
	MetadataFilePath types.String `tfsdk:"metadata_file_path"`
}

func (to *JobDeployment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobDeployment_SdkV2) {
}

func (to *JobDeployment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobDeployment_SdkV2) {
}

func (m JobDeployment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["kind"] = attrs["kind"].SetRequired()
	attrs["metadata_file_path"] = attrs["metadata_file_path"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobDeployment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobDeployment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobDeployment_SdkV2
// only implements ToObjectValue() and Type().
func (m JobDeployment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"kind":               m.Kind,
			"metadata_file_path": m.MetadataFilePath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobDeployment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"kind":               types.StringType,
			"metadata_file_path": types.StringType,
		},
	}
}

type JobEmailNotifications_SdkV2 struct {
	// If true, do not send email to recipients specified in `on_failure` if the
	// run is skipped. This field is `deprecated`. Please use the
	// `notification_settings.no_alert_for_skipped_runs` field.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
	// A list of email addresses to be notified when the duration of a run
	// exceeds the threshold specified for the `RUN_DURATION_SECONDS` metric in
	// the `health` field. If no rule for the `RUN_DURATION_SECONDS` metric is
	// specified in the `health` field for the job, notifications are not sent.
	OnDurationWarningThresholdExceeded types.List `tfsdk:"on_duration_warning_threshold_exceeded"`
	// A list of email addresses to be notified when a run unsuccessfully
	// completes. A run is considered to have completed unsuccessfully if it
	// ends with an `INTERNAL_ERROR` `life_cycle_state` or a `FAILED`, or
	// `TIMED_OUT` result_state. If this is not specified on job creation,
	// reset, or update the list is empty, and notifications are not sent.
	OnFailure types.List `tfsdk:"on_failure"`
	// A list of email addresses to be notified when a run begins. If not
	// specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnStart types.List `tfsdk:"on_start"`
	// A list of email addresses to notify when any streaming backlog thresholds
	// are exceeded for any stream. Streaming backlog thresholds can be set in
	// the `health` field using the following metrics:
	// `STREAMING_BACKLOG_BYTES`, `STREAMING_BACKLOG_RECORDS`,
	// `STREAMING_BACKLOG_SECONDS`, or `STREAMING_BACKLOG_FILES`. Alerting is
	// based on the 10-minute average of these metrics. If the issue persists,
	// notifications are resent every 30 minutes.
	OnStreamingBacklogExceeded types.List `tfsdk:"on_streaming_backlog_exceeded"`
	// A list of email addresses to be notified when a run successfully
	// completes. A run is considered to have completed successfully if it ends
	// with a `TERMINATED` `life_cycle_state` and a `SUCCESS` result_state. If
	// not specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnSuccess types.List `tfsdk:"on_success"`
}

func (to *JobEmailNotifications_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobEmailNotifications_SdkV2) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (to *JobEmailNotifications_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobEmailNotifications_SdkV2) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (m JobEmailNotifications_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()
	attrs["on_duration_warning_threshold_exceeded"] = attrs["on_duration_warning_threshold_exceeded"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_start"] = attrs["on_start"].SetOptional()
	attrs["on_streaming_backlog_exceeded"] = attrs["on_streaming_backlog_exceeded"].SetOptional()
	attrs["on_success"] = attrs["on_success"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobEmailNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobEmailNotifications_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_duration_warning_threshold_exceeded": reflect.TypeOf(types.String{}),
		"on_failure":                             reflect.TypeOf(types.String{}),
		"on_start":                               reflect.TypeOf(types.String{}),
		"on_streaming_backlog_exceeded":          reflect.TypeOf(types.String{}),
		"on_success":                             reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobEmailNotifications_SdkV2
// only implements ToObjectValue() and Type().
func (m JobEmailNotifications_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"no_alert_for_skipped_runs":              m.NoAlertForSkippedRuns,
			"on_duration_warning_threshold_exceeded": m.OnDurationWarningThresholdExceeded,
			"on_failure":                             m.OnFailure,
			"on_start":                               m.OnStart,
			"on_streaming_backlog_exceeded":          m.OnStreamingBacklogExceeded,
			"on_success":                             m.OnSuccess,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobEmailNotifications_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"no_alert_for_skipped_runs": types.BoolType,
			"on_duration_warning_threshold_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_failure": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_start": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_streaming_backlog_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_success": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOnDurationWarningThresholdExceeded returns the value of the OnDurationWarningThresholdExceeded field in JobEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications_SdkV2) GetOnDurationWarningThresholdExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnDurationWarningThresholdExceeded.IsNull() || m.OnDurationWarningThresholdExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnDurationWarningThresholdExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnDurationWarningThresholdExceeded sets the value of the OnDurationWarningThresholdExceeded field in JobEmailNotifications_SdkV2.
func (m *JobEmailNotifications_SdkV2) SetOnDurationWarningThresholdExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_duration_warning_threshold_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnDurationWarningThresholdExceeded = types.ListValueMust(t, vs)
}

// GetOnFailure returns the value of the OnFailure field in JobEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications_SdkV2) GetOnFailure(ctx context.Context) ([]types.String, bool) {
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in JobEmailNotifications_SdkV2.
func (m *JobEmailNotifications_SdkV2) SetOnFailure(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnStart returns the value of the OnStart field in JobEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications_SdkV2) GetOnStart(ctx context.Context) ([]types.String, bool) {
	if m.OnStart.IsNull() || m.OnStart.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStart.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStart sets the value of the OnStart field in JobEmailNotifications_SdkV2.
func (m *JobEmailNotifications_SdkV2) SetOnStart(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_start"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStart = types.ListValueMust(t, vs)
}

// GetOnStreamingBacklogExceeded returns the value of the OnStreamingBacklogExceeded field in JobEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications_SdkV2) GetOnStreamingBacklogExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnStreamingBacklogExceeded.IsNull() || m.OnStreamingBacklogExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStreamingBacklogExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStreamingBacklogExceeded sets the value of the OnStreamingBacklogExceeded field in JobEmailNotifications_SdkV2.
func (m *JobEmailNotifications_SdkV2) SetOnStreamingBacklogExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_streaming_backlog_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStreamingBacklogExceeded = types.ListValueMust(t, vs)
}

// GetOnSuccess returns the value of the OnSuccess field in JobEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications_SdkV2) GetOnSuccess(ctx context.Context) ([]types.String, bool) {
	if m.OnSuccess.IsNull() || m.OnSuccess.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnSuccess.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnSuccess sets the value of the OnSuccess field in JobEmailNotifications_SdkV2.
func (m *JobEmailNotifications_SdkV2) SetOnSuccess(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_success"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnSuccess = types.ListValueMust(t, vs)
}

type JobEnvironment_SdkV2 struct {
	// The key of an environment. It has to be unique within a job.
	EnvironmentKey types.String `tfsdk:"environment_key"`

	Spec types.List `tfsdk:"spec"`
}

func (to *JobEnvironment_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobEnvironment_SdkV2) {
	if !from.Spec.IsNull() && !from.Spec.IsUnknown() {
		if toSpec, ok := to.GetSpec(ctx); ok {
			if fromSpec, ok := from.GetSpec(ctx); ok {
				// Recursively sync the fields of Spec
				toSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromSpec)
				to.SetSpec(ctx, toSpec)
			}
		}
	}
}

func (to *JobEnvironment_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobEnvironment_SdkV2) {
	if !from.Spec.IsNull() && !from.Spec.IsUnknown() {
		if toSpec, ok := to.GetSpec(ctx); ok {
			if fromSpec, ok := from.GetSpec(ctx); ok {
				toSpec.SyncFieldsDuringRead(ctx, fromSpec)
				to.SetSpec(ctx, toSpec)
			}
		}
	}
}

func (m JobEnvironment_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["environment_key"] = attrs["environment_key"].SetRequired()
	attrs["spec"] = attrs["spec"].SetOptional()
	attrs["spec"] = attrs["spec"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobEnvironment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobEnvironment_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"spec": reflect.TypeOf(compute_tf.Environment_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobEnvironment_SdkV2
// only implements ToObjectValue() and Type().
func (m JobEnvironment_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"environment_key": m.EnvironmentKey,
			"spec":            m.Spec,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobEnvironment_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"environment_key": types.StringType,
			"spec": basetypes.ListType{
				ElemType: compute_tf.Environment_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSpec returns the value of the Spec field in JobEnvironment_SdkV2 as
// a compute_tf.Environment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEnvironment_SdkV2) GetSpec(ctx context.Context) (compute_tf.Environment_SdkV2, bool) {
	var e compute_tf.Environment_SdkV2
	if m.Spec.IsNull() || m.Spec.IsUnknown() {
		return e, false
	}
	var v []compute_tf.Environment_SdkV2
	d := m.Spec.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSpec sets the value of the Spec field in JobEnvironment_SdkV2.
func (m *JobEnvironment_SdkV2) SetSpec(ctx context.Context, v compute_tf.Environment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spec"]
	m.Spec = types.ListValueMust(t, vs)
}

type JobNotificationSettings_SdkV2 struct {
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is canceled.
	NoAlertForCanceledRuns types.Bool `tfsdk:"no_alert_for_canceled_runs"`
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is skipped.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
}

func (to *JobNotificationSettings_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobNotificationSettings_SdkV2) {
}

func (to *JobNotificationSettings_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobNotificationSettings_SdkV2) {
}

func (m JobNotificationSettings_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["no_alert_for_canceled_runs"] = attrs["no_alert_for_canceled_runs"].SetOptional()
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobNotificationSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobNotificationSettings_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobNotificationSettings_SdkV2
// only implements ToObjectValue() and Type().
func (m JobNotificationSettings_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"no_alert_for_canceled_runs": m.NoAlertForCanceledRuns,
			"no_alert_for_skipped_runs":  m.NoAlertForSkippedRuns,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobNotificationSettings_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"no_alert_for_canceled_runs": types.BoolType,
			"no_alert_for_skipped_runs":  types.BoolType,
		},
	}
}

type JobParameter_SdkV2 struct {
	// The optional default value of the parameter
	Default types.String `tfsdk:"default"`
	// The name of the parameter
	Name types.String `tfsdk:"name"`
	// The value used in the run
	Value types.String `tfsdk:"value"`
}

func (to *JobParameter_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobParameter_SdkV2) {
}

func (to *JobParameter_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobParameter_SdkV2) {
}

func (m JobParameter_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default"] = attrs["default"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["value"] = attrs["value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobParameter.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobParameter_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobParameter_SdkV2
// only implements ToObjectValue() and Type().
func (m JobParameter_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default": m.Default,
			"name":    m.Name,
			"value":   m.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobParameter_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default": types.StringType,
			"name":    types.StringType,
			"value":   types.StringType,
		},
	}
}

type JobParameterDefinition_SdkV2 struct {
	// Default value of the parameter.
	Default types.String `tfsdk:"default"`
	// The name of the defined parameter. May only contain alphanumeric
	// characters, `_`, `-`, and `.`
	Name types.String `tfsdk:"name"`
}

func (to *JobParameterDefinition_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobParameterDefinition_SdkV2) {
}

func (to *JobParameterDefinition_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobParameterDefinition_SdkV2) {
}

func (m JobParameterDefinition_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default"] = attrs["default"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobParameterDefinition.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobParameterDefinition_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobParameterDefinition_SdkV2
// only implements ToObjectValue() and Type().
func (m JobParameterDefinition_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default": m.Default,
			"name":    m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobParameterDefinition_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default": types.StringType,
			"name":    types.StringType,
		},
	}
}

type JobPermission_SdkV2 struct {
	Inherited types.Bool `tfsdk:"inherited"`

	InheritedFromObject types.List `tfsdk:"inherited_from_object"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *JobPermission_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermission_SdkV2) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (to *JobPermission_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobPermission_SdkV2) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (m JobPermission_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited"] = attrs["inherited"].SetOptional()
	attrs["inherited_from_object"] = attrs["inherited_from_object"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermission.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermission_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"inherited_from_object": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermission_SdkV2
// only implements ToObjectValue() and Type().
func (m JobPermission_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited":             m.Inherited,
			"inherited_from_object": m.InheritedFromObject,
			"permission_level":      m.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermission_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited": types.BoolType,
			"inherited_from_object": basetypes.ListType{
				ElemType: types.StringType,
			},
			"permission_level": types.StringType,
		},
	}
}

// GetInheritedFromObject returns the value of the InheritedFromObject field in JobPermission_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobPermission_SdkV2) GetInheritedFromObject(ctx context.Context) ([]types.String, bool) {
	if m.InheritedFromObject.IsNull() || m.InheritedFromObject.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.InheritedFromObject.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInheritedFromObject sets the value of the InheritedFromObject field in JobPermission_SdkV2.
func (m *JobPermission_SdkV2) SetInheritedFromObject(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["inherited_from_object"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.InheritedFromObject = types.ListValueMust(t, vs)
}

type JobPermissions_SdkV2 struct {
	AccessControlList types.List `tfsdk:"access_control_list"`

	ObjectId types.String `tfsdk:"object_id"`

	ObjectType types.String `tfsdk:"object_type"`
}

func (to *JobPermissions_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermissions_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *JobPermissions_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobPermissions_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (m JobPermissions_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["object_id"] = attrs["object_id"].SetOptional()
	attrs["object_type"] = attrs["object_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermissions_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(JobAccessControlResponse_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermissions_SdkV2
// only implements ToObjectValue() and Type().
func (m JobPermissions_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": m.AccessControlList,
			"object_id":           m.ObjectId,
			"object_type":         m.ObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermissions_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlResponse_SdkV2{}.Type(ctx),
			},
			"object_id":   types.StringType,
			"object_type": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in JobPermissions_SdkV2 as
// a slice of JobAccessControlResponse_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobPermissions_SdkV2) GetAccessControlList(ctx context.Context) ([]JobAccessControlResponse_SdkV2, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlResponse_SdkV2
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in JobPermissions_SdkV2.
func (m *JobPermissions_SdkV2) SetAccessControlList(ctx context.Context, v []JobAccessControlResponse_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

type JobPermissionsDescription_SdkV2 struct {
	Description types.String `tfsdk:"description"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *JobPermissionsDescription_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermissionsDescription_SdkV2) {
}

func (to *JobPermissionsDescription_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobPermissionsDescription_SdkV2) {
}

func (m JobPermissionsDescription_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermissionsDescription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermissionsDescription_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermissionsDescription_SdkV2
// only implements ToObjectValue() and Type().
func (m JobPermissionsDescription_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":      m.Description,
			"permission_level": m.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermissionsDescription_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":      types.StringType,
			"permission_level": types.StringType,
		},
	}
}

type JobPermissionsRequest_SdkV2 struct {
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The job for which to get or manage permissions.
	JobId types.String `tfsdk:"-"`
}

func (to *JobPermissionsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermissionsRequest_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *JobPermissionsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobPermissionsRequest_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (m JobPermissionsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermissionsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(JobAccessControlRequest_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermissionsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m JobPermissionsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": m.AccessControlList,
			"job_id":              m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermissionsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlRequest_SdkV2{}.Type(ctx),
			},
			"job_id": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in JobPermissionsRequest_SdkV2 as
// a slice of JobAccessControlRequest_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobPermissionsRequest_SdkV2) GetAccessControlList(ctx context.Context) ([]JobAccessControlRequest_SdkV2, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlRequest_SdkV2
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in JobPermissionsRequest_SdkV2.
func (m *JobPermissionsRequest_SdkV2) SetAccessControlList(ctx context.Context, v []JobAccessControlRequest_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

// Write-only setting. Specifies the user or service principal that the job runs
// as. If not specified, the job runs as the user who created the job.
//
// Either `user_name` or `service_principal_name` should be specified. If not,
// an error is thrown.
type JobRunAs_SdkV2 struct {
	// Application ID of an active service principal. Setting this field
	// requires the `servicePrincipal/user` role.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// The email of an active workspace user. Non-admin users can only set this
	// field to their own email.
	UserName types.String `tfsdk:"user_name"`
}

func (to *JobRunAs_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobRunAs_SdkV2) {
}

func (to *JobRunAs_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobRunAs_SdkV2) {
}

func (m JobRunAs_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobRunAs.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobRunAs_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobRunAs_SdkV2
// only implements ToObjectValue() and Type().
func (m JobRunAs_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"service_principal_name": m.ServicePrincipalName,
			"user_name":              m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobRunAs_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type JobSettings_SdkV2 struct {
	// The id of the user specified budget policy to use for this job. If not
	// specified, a default budget policy may be applied when creating or
	// modifying the job. See `effective_budget_policy_id` for the budget policy
	// used by this workload.
	BudgetPolicyId types.String `tfsdk:"budget_policy_id"`
	// An optional continuous property for this job. The continuous property
	// will ensure that there is always one run executing. Only one of
	// `schedule` and `continuous` can be used.
	Continuous types.List `tfsdk:"continuous"`
	// Deployment information for jobs managed by external sources.
	Deployment types.List `tfsdk:"deployment"`
	// An optional description for the job. The maximum length is 27700
	// characters in UTF-8 encoding.
	Description types.String `tfsdk:"description"`
	// Edit mode of the job.
	//
	// * `UI_LOCKED`: The job is in a locked UI state and cannot be modified. *
	// `EDITABLE`: The job is in an editable state and can be modified.
	EditMode types.String `tfsdk:"edit_mode"`
	// An optional set of email addresses that is notified when runs of this job
	// begin or complete as well as when this job is deleted.
	EmailNotifications types.List `tfsdk:"email_notifications"`
	// A list of task execution environment specifications that can be
	// referenced by serverless tasks of this job. An environment is required to
	// be present for serverless tasks. For serverless notebook tasks, the
	// environment is accessible in the notebook environment panel. For other
	// serverless tasks, the task environment is required to be specified using
	// environment_key in the task settings.
	Environments types.List `tfsdk:"environment"`
	// Used to tell what is the format of the job. This field is ignored in
	// Create/Update/Reset calls. When using the Jobs API 2.1 this value is
	// always set to `"MULTI_TASK"`.
	Format types.String `tfsdk:"format"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.List `tfsdk:"git_source"`

	Health types.List `tfsdk:"health"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings.
	JobClusters types.List `tfsdk:"job_cluster"`
	// An optional maximum allowed number of concurrent runs of the job. Set
	// this value if you want to be able to execute multiple runs of the same
	// job concurrently. This is useful for example if you trigger your job on a
	// frequent schedule and want to allow consecutive runs to overlap with each
	// other, or if you want to trigger multiple runs which differ by their
	// input parameters. This setting affects only new runs. For example,
	// suppose the job’s concurrency is 4 and there are 4 concurrent active
	// runs. Then setting the concurrency to 3 won’t kill any of the active
	// runs. However, from then on, new runs are skipped unless there are fewer
	// than 3 active runs. This value cannot exceed 1000. Setting this value to
	// `0` causes all new runs to be skipped.
	MaxConcurrentRuns types.Int64 `tfsdk:"max_concurrent_runs"`
	// An optional name for the job. The maximum length is 4096 bytes in UTF-8
	// encoding.
	Name types.String `tfsdk:"name"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// job.
	NotificationSettings types.List `tfsdk:"notification_settings"`
	// Job-level parameter definitions
	Parameters types.List `tfsdk:"parameter"`
	// The performance mode on a serverless job. This field determines the level
	// of compute performance or cost-efficiency for the run.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// The queue settings of the job.
	Queue types.List `tfsdk:"queue"`
	// The user or service principal that the job runs as, if specified in the
	// request. This field indicates the explicit configuration of `run_as` for
	// the job. To find the value in all cases, explicit or implicit, use
	// `run_as_user_name`.
	RunAs types.List `tfsdk:"run_as"`
	// An optional periodic schedule for this job. The default behavior is that
	// the job only runs when triggered by clicking “Run Now” in the Jobs UI
	// or sending an API request to `runNow`.
	Schedule types.List `tfsdk:"schedule"`
	// A map of tags associated with the job. These are forwarded to the cluster
	// as cluster tags for jobs clusters, and are subject to the same
	// limitations as cluster tags. A maximum of 25 tags can be added to the
	// job.
	Tags types.Map `tfsdk:"tags"`
	// A list of task specifications to be executed by this job. It supports up
	// to 1000 elements in write endpoints (:method:jobs/create,
	// :method:jobs/reset, :method:jobs/update, :method:jobs/submit). Read
	// endpoints return only 100 tasks. If more than 100 tasks are available,
	// you can paginate through them using :method:jobs/get. Use the
	// `next_page_token` field at the object root to determine if more results
	// are available.
	Tasks types.List `tfsdk:"task"`
	// An optional timeout applied to each run of this job. A value of `0` means
	// no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A configuration to trigger a run when certain conditions are met. The
	// default behavior is that the job runs only when triggered by clicking
	// “Run Now” in the Jobs UI or sending an API request to `runNow`.
	Trigger types.List `tfsdk:"trigger"`
	// The id of the user specified usage policy to use for this job. If not
	// specified, a default usage policy may be applied when creating or
	// modifying the job. See `effective_usage_policy_id` for the usage policy
	// used by this workload.
	UsagePolicyId types.String `tfsdk:"usage_policy_id"`
	// A collection of system notification IDs to notify when runs of this job
	// begin or complete.
	WebhookNotifications types.List `tfsdk:"webhook_notifications"`
}

func (to *JobSettings_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobSettings_SdkV2) {
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				// Recursively sync the fields of Continuous
				toContinuous.SyncFieldsDuringCreateOrUpdate(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				// Recursively sync the fields of Deployment
				toDeployment.SyncFieldsDuringCreateOrUpdate(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				// Recursively sync the fields of RunAs
				toRunAs.SyncFieldsDuringCreateOrUpdate(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				// Recursively sync the fields of Trigger
				toTrigger.SyncFieldsDuringCreateOrUpdate(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *JobSettings_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobSettings_SdkV2) {
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				toContinuous.SyncFieldsDuringRead(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				toDeployment.SyncFieldsDuringRead(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				toRunAs.SyncFieldsDuringRead(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				toTrigger.SyncFieldsDuringRead(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m JobSettings_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetOptional()
	attrs["continuous"] = attrs["continuous"].SetOptional()
	attrs["continuous"] = attrs["continuous"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["deployment"] = attrs["deployment"].SetOptional()
	attrs["deployment"] = attrs["deployment"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["description"] = attrs["description"].SetOptional()
	attrs["edit_mode"] = attrs["edit_mode"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["environment"] = attrs["environment"].SetOptional()
	attrs["format"] = attrs["format"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["git_source"] = attrs["git_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["health"] = attrs["health"].SetOptional()
	attrs["health"] = attrs["health"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["job_cluster"] = attrs["job_cluster"].SetOptional()
	attrs["max_concurrent_runs"] = attrs["max_concurrent_runs"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["parameter"] = attrs["parameter"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["queue"] = attrs["queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_as"] = attrs["run_as"].SetOptional()
	attrs["run_as"] = attrs["run_as"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["tags"] = attrs["tags"].SetOptional()
	attrs["task"] = attrs["task"].SetOptional()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["trigger"] = attrs["trigger"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobSettings_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"continuous":            reflect.TypeOf(Continuous_SdkV2{}),
		"deployment":            reflect.TypeOf(JobDeployment_SdkV2{}),
		"email_notifications":   reflect.TypeOf(JobEmailNotifications_SdkV2{}),
		"environment":           reflect.TypeOf(JobEnvironment_SdkV2{}),
		"git_source":            reflect.TypeOf(GitSource_SdkV2{}),
		"health":                reflect.TypeOf(JobsHealthRules_SdkV2{}),
		"job_cluster":           reflect.TypeOf(JobCluster_SdkV2{}),
		"notification_settings": reflect.TypeOf(JobNotificationSettings_SdkV2{}),
		"parameter":             reflect.TypeOf(JobParameterDefinition_SdkV2{}),
		"queue":                 reflect.TypeOf(QueueSettings_SdkV2{}),
		"run_as":                reflect.TypeOf(JobRunAs_SdkV2{}),
		"schedule":              reflect.TypeOf(CronSchedule_SdkV2{}),
		"tags":                  reflect.TypeOf(types.String{}),
		"task":                  reflect.TypeOf(Task_SdkV2{}),
		"trigger":               reflect.TypeOf(TriggerSettings_SdkV2{}),
		"webhook_notifications": reflect.TypeOf(WebhookNotifications_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobSettings_SdkV2
// only implements ToObjectValue() and Type().
func (m JobSettings_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"budget_policy_id":      m.BudgetPolicyId,
			"continuous":            m.Continuous,
			"deployment":            m.Deployment,
			"description":           m.Description,
			"edit_mode":             m.EditMode,
			"email_notifications":   m.EmailNotifications,
			"environment":           m.Environments,
			"format":                m.Format,
			"git_source":            m.GitSource,
			"health":                m.Health,
			"job_cluster":           m.JobClusters,
			"max_concurrent_runs":   m.MaxConcurrentRuns,
			"name":                  m.Name,
			"notification_settings": m.NotificationSettings,
			"parameter":             m.Parameters,
			"performance_target":    m.PerformanceTarget,
			"queue":                 m.Queue,
			"run_as":                m.RunAs,
			"schedule":              m.Schedule,
			"tags":                  m.Tags,
			"task":                  m.Tasks,
			"timeout_seconds":       m.TimeoutSeconds,
			"trigger":               m.Trigger,
			"usage_policy_id":       m.UsagePolicyId,
			"webhook_notifications": m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobSettings_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"budget_policy_id": types.StringType,
			"continuous": basetypes.ListType{
				ElemType: Continuous_SdkV2{}.Type(ctx),
			},
			"deployment": basetypes.ListType{
				ElemType: JobDeployment_SdkV2{}.Type(ctx),
			},
			"description": types.StringType,
			"edit_mode":   types.StringType,
			"email_notifications": basetypes.ListType{
				ElemType: JobEmailNotifications_SdkV2{}.Type(ctx),
			},
			"environment": basetypes.ListType{
				ElemType: JobEnvironment_SdkV2{}.Type(ctx),
			},
			"format": types.StringType,
			"git_source": basetypes.ListType{
				ElemType: GitSource_SdkV2{}.Type(ctx),
			},
			"health": basetypes.ListType{
				ElemType: JobsHealthRules_SdkV2{}.Type(ctx),
			},
			"job_cluster": basetypes.ListType{
				ElemType: JobCluster_SdkV2{}.Type(ctx),
			},
			"max_concurrent_runs": types.Int64Type,
			"name":                types.StringType,
			"notification_settings": basetypes.ListType{
				ElemType: JobNotificationSettings_SdkV2{}.Type(ctx),
			},
			"parameter": basetypes.ListType{
				ElemType: JobParameterDefinition_SdkV2{}.Type(ctx),
			},
			"performance_target": types.StringType,
			"queue": basetypes.ListType{
				ElemType: QueueSettings_SdkV2{}.Type(ctx),
			},
			"run_as": basetypes.ListType{
				ElemType: JobRunAs_SdkV2{}.Type(ctx),
			},
			"schedule": basetypes.ListType{
				ElemType: CronSchedule_SdkV2{}.Type(ctx),
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"task": basetypes.ListType{
				ElemType: Task_SdkV2{}.Type(ctx),
			},
			"timeout_seconds": types.Int64Type,
			"trigger": basetypes.ListType{
				ElemType: TriggerSettings_SdkV2{}.Type(ctx),
			},
			"usage_policy_id": types.StringType,
			"webhook_notifications": basetypes.ListType{
				ElemType: WebhookNotifications_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetContinuous returns the value of the Continuous field in JobSettings_SdkV2 as
// a Continuous_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetContinuous(ctx context.Context) (Continuous_SdkV2, bool) {
	var e Continuous_SdkV2
	if m.Continuous.IsNull() || m.Continuous.IsUnknown() {
		return e, false
	}
	var v []Continuous_SdkV2
	d := m.Continuous.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetContinuous sets the value of the Continuous field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetContinuous(ctx context.Context, v Continuous_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["continuous"]
	m.Continuous = types.ListValueMust(t, vs)
}

// GetDeployment returns the value of the Deployment field in JobSettings_SdkV2 as
// a JobDeployment_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetDeployment(ctx context.Context) (JobDeployment_SdkV2, bool) {
	var e JobDeployment_SdkV2
	if m.Deployment.IsNull() || m.Deployment.IsUnknown() {
		return e, false
	}
	var v []JobDeployment_SdkV2
	d := m.Deployment.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDeployment sets the value of the Deployment field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetDeployment(ctx context.Context, v JobDeployment_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["deployment"]
	m.Deployment = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in JobSettings_SdkV2 as
// a JobEmailNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetEmailNotifications(ctx context.Context) (JobEmailNotifications_SdkV2, bool) {
	var e JobEmailNotifications_SdkV2
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v []JobEmailNotifications_SdkV2
	d := m.EmailNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEmailNotifications sets the value of the EmailNotifications field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetEmailNotifications(ctx context.Context, v JobEmailNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_notifications"]
	m.EmailNotifications = types.ListValueMust(t, vs)
}

// GetEnvironments returns the value of the Environments field in JobSettings_SdkV2 as
// a slice of JobEnvironment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetEnvironments(ctx context.Context) ([]JobEnvironment_SdkV2, bool) {
	if m.Environments.IsNull() || m.Environments.IsUnknown() {
		return nil, false
	}
	var v []JobEnvironment_SdkV2
	d := m.Environments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEnvironments sets the value of the Environments field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetEnvironments(ctx context.Context, v []JobEnvironment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["environment"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Environments = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in JobSettings_SdkV2 as
// a GitSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetGitSource(ctx context.Context) (GitSource_SdkV2, bool) {
	var e GitSource_SdkV2
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v []GitSource_SdkV2
	d := m.GitSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSource sets the value of the GitSource field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetGitSource(ctx context.Context, v GitSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_source"]
	m.GitSource = types.ListValueMust(t, vs)
}

// GetHealth returns the value of the Health field in JobSettings_SdkV2 as
// a JobsHealthRules_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetHealth(ctx context.Context) (JobsHealthRules_SdkV2, bool) {
	var e JobsHealthRules_SdkV2
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v []JobsHealthRules_SdkV2
	d := m.Health.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetHealth sets the value of the Health field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetHealth(ctx context.Context, v JobsHealthRules_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["health"]
	m.Health = types.ListValueMust(t, vs)
}

// GetJobClusters returns the value of the JobClusters field in JobSettings_SdkV2 as
// a slice of JobCluster_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetJobClusters(ctx context.Context) ([]JobCluster_SdkV2, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster_SdkV2
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetJobClusters(ctx context.Context, v []JobCluster_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_cluster"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in JobSettings_SdkV2 as
// a JobNotificationSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetNotificationSettings(ctx context.Context) (JobNotificationSettings_SdkV2, bool) {
	var e JobNotificationSettings_SdkV2
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v []JobNotificationSettings_SdkV2
	d := m.NotificationSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotificationSettings sets the value of the NotificationSettings field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetNotificationSettings(ctx context.Context, v JobNotificationSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notification_settings"]
	m.NotificationSettings = types.ListValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in JobSettings_SdkV2 as
// a slice of JobParameterDefinition_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetParameters(ctx context.Context) ([]JobParameterDefinition_SdkV2, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameterDefinition_SdkV2
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetParameters(ctx context.Context, v []JobParameterDefinition_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameter"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in JobSettings_SdkV2 as
// a QueueSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetQueue(ctx context.Context) (QueueSettings_SdkV2, bool) {
	var e QueueSettings_SdkV2
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v []QueueSettings_SdkV2
	d := m.Queue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQueue sets the value of the Queue field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetQueue(ctx context.Context, v QueueSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["queue"]
	m.Queue = types.ListValueMust(t, vs)
}

// GetRunAs returns the value of the RunAs field in JobSettings_SdkV2 as
// a JobRunAs_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetRunAs(ctx context.Context) (JobRunAs_SdkV2, bool) {
	var e JobRunAs_SdkV2
	if m.RunAs.IsNull() || m.RunAs.IsUnknown() {
		return e, false
	}
	var v []JobRunAs_SdkV2
	d := m.RunAs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunAs sets the value of the RunAs field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetRunAs(ctx context.Context, v JobRunAs_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_as"]
	m.RunAs = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in JobSettings_SdkV2 as
// a CronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetSchedule(ctx context.Context) (CronSchedule_SdkV2, bool) {
	var e CronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []CronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetSchedule(ctx context.Context, v CronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetTags returns the value of the Tags field in JobSettings_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetTags(ctx context.Context) (map[string]types.String, bool) {
	if m.Tags.IsNull() || m.Tags.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Tags.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTags sets the value of the Tags field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetTags(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tags"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tags = types.MapValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in JobSettings_SdkV2 as
// a slice of Task_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetTasks(ctx context.Context) ([]Task_SdkV2, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []Task_SdkV2
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetTasks(ctx context.Context, v []Task_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTrigger returns the value of the Trigger field in JobSettings_SdkV2 as
// a TriggerSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetTrigger(ctx context.Context) (TriggerSettings_SdkV2, bool) {
	var e TriggerSettings_SdkV2
	if m.Trigger.IsNull() || m.Trigger.IsUnknown() {
		return e, false
	}
	var v []TriggerSettings_SdkV2
	d := m.Trigger.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTrigger sets the value of the Trigger field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetTrigger(ctx context.Context, v TriggerSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["trigger"]
	m.Trigger = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in JobSettings_SdkV2 as
// a WebhookNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings_SdkV2) GetWebhookNotifications(ctx context.Context) (WebhookNotifications_SdkV2, bool) {
	var e WebhookNotifications_SdkV2
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v []WebhookNotifications_SdkV2
	d := m.WebhookNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in JobSettings_SdkV2.
func (m *JobSettings_SdkV2) SetWebhookNotifications(ctx context.Context, v WebhookNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["webhook_notifications"]
	m.WebhookNotifications = types.ListValueMust(t, vs)
}

// The source of the job specification in the remote repository when the job is
// source controlled.
type JobSource_SdkV2 struct {
	// Dirty state indicates the job is not fully synced with the job
	// specification in the remote repository.
	//
	// Possible values are: * `NOT_SYNCED`: The job is not yet synced with the
	// remote job specification. Import the remote job specification from UI to
	// make the job fully synced. * `DISCONNECTED`: The job is temporary
	// disconnected from the remote job specification and is allowed for live
	// edit. Import the remote job specification again from UI to make the job
	// fully synced.
	DirtyState types.String `tfsdk:"dirty_state"`
	// Name of the branch which the job is imported from.
	ImportFromGitBranch types.String `tfsdk:"import_from_git_branch"`
	// Path of the job YAML file that contains the job specification.
	JobConfigPath types.String `tfsdk:"job_config_path"`
}

func (to *JobSource_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobSource_SdkV2) {
}

func (to *JobSource_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobSource_SdkV2) {
}

func (m JobSource_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dirty_state"] = attrs["dirty_state"].SetOptional()
	attrs["import_from_git_branch"] = attrs["import_from_git_branch"].SetRequired()
	attrs["job_config_path"] = attrs["job_config_path"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobSource.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobSource_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobSource_SdkV2
// only implements ToObjectValue() and Type().
func (m JobSource_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dirty_state":            m.DirtyState,
			"import_from_git_branch": m.ImportFromGitBranch,
			"job_config_path":        m.JobConfigPath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobSource_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dirty_state":            types.StringType,
			"import_from_git_branch": types.StringType,
			"job_config_path":        types.StringType,
		},
	}
}

type JobsHealthRule_SdkV2 struct {
	Metric types.String `tfsdk:"metric"`

	Op types.String `tfsdk:"op"`
	// Specifies the threshold value that the health metric should obey to
	// satisfy the health rule.
	Value types.Int64 `tfsdk:"value"`
}

func (to *JobsHealthRule_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobsHealthRule_SdkV2) {
}

func (to *JobsHealthRule_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobsHealthRule_SdkV2) {
}

func (m JobsHealthRule_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metric"] = attrs["metric"].SetRequired()
	attrs["op"] = attrs["op"].SetRequired()
	attrs["value"] = attrs["value"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobsHealthRule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobsHealthRule_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobsHealthRule_SdkV2
// only implements ToObjectValue() and Type().
func (m JobsHealthRule_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metric": m.Metric,
			"op":     m.Op,
			"value":  m.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobsHealthRule_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metric": types.StringType,
			"op":     types.StringType,
			"value":  types.Int64Type,
		},
	}
}

// An optional set of health rules that can be defined for this job.
type JobsHealthRules_SdkV2 struct {
	Rules types.List `tfsdk:"rules"`
}

func (to *JobsHealthRules_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobsHealthRules_SdkV2) {
	if !from.Rules.IsNull() && !from.Rules.IsUnknown() && to.Rules.IsNull() && len(from.Rules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Rules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Rules = from.Rules
	}
}

func (to *JobsHealthRules_SdkV2) SyncFieldsDuringRead(ctx context.Context, from JobsHealthRules_SdkV2) {
	if !from.Rules.IsNull() && !from.Rules.IsUnknown() && to.Rules.IsNull() && len(from.Rules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Rules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Rules = from.Rules
	}
}

func (m JobsHealthRules_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["rules"] = attrs["rules"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobsHealthRules.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobsHealthRules_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"rules": reflect.TypeOf(JobsHealthRule_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobsHealthRules_SdkV2
// only implements ToObjectValue() and Type().
func (m JobsHealthRules_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"rules": m.Rules,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobsHealthRules_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"rules": basetypes.ListType{
				ElemType: JobsHealthRule_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetRules returns the value of the Rules field in JobsHealthRules_SdkV2 as
// a slice of JobsHealthRule_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobsHealthRules_SdkV2) GetRules(ctx context.Context) ([]JobsHealthRule_SdkV2, bool) {
	if m.Rules.IsNull() || m.Rules.IsUnknown() {
		return nil, false
	}
	var v []JobsHealthRule_SdkV2
	d := m.Rules.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRules sets the value of the Rules field in JobsHealthRules_SdkV2.
func (m *JobsHealthRules_SdkV2) SetRules(ctx context.Context, v []JobsHealthRule_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["rules"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Rules = types.ListValueMust(t, vs)
}

type ListJobComplianceForPolicyResponse_SdkV2 struct {
	// A list of jobs and their policy compliance statuses.
	Jobs types.List `tfsdk:"jobs"`
	// This field represents the pagination token to retrieve the next page of
	// results. If this field is not in the response, it means no further
	// results for the request.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// This field represents the pagination token to retrieve the previous page
	// of results. If this field is not in the response, it means no further
	// results for the request.
	PrevPageToken types.String `tfsdk:"prev_page_token"`
}

func (to *ListJobComplianceForPolicyResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobComplianceForPolicyResponse_SdkV2) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (to *ListJobComplianceForPolicyResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListJobComplianceForPolicyResponse_SdkV2) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (m ListJobComplianceForPolicyResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["jobs"] = attrs["jobs"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["prev_page_token"] = attrs["prev_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobComplianceForPolicyResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobComplianceForPolicyResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"jobs": reflect.TypeOf(JobCompliance_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobComplianceForPolicyResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListJobComplianceForPolicyResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"jobs":            m.Jobs,
			"next_page_token": m.NextPageToken,
			"prev_page_token": m.PrevPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobComplianceForPolicyResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"jobs": basetypes.ListType{
				ElemType: JobCompliance_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
			"prev_page_token": types.StringType,
		},
	}
}

// GetJobs returns the value of the Jobs field in ListJobComplianceForPolicyResponse_SdkV2 as
// a slice of JobCompliance_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListJobComplianceForPolicyResponse_SdkV2) GetJobs(ctx context.Context) ([]JobCompliance_SdkV2, bool) {
	if m.Jobs.IsNull() || m.Jobs.IsUnknown() {
		return nil, false
	}
	var v []JobCompliance_SdkV2
	d := m.Jobs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobs sets the value of the Jobs field in ListJobComplianceForPolicyResponse_SdkV2.
func (m *ListJobComplianceForPolicyResponse_SdkV2) SetJobs(ctx context.Context, v []JobCompliance_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jobs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Jobs = types.ListValueMust(t, vs)
}

type ListJobComplianceRequest_SdkV2 struct {
	// Use this field to specify the maximum number of results to be returned by
	// the server. The server may further constrain the maximum number of
	// results returned in a single page.
	PageSize types.Int64 `tfsdk:"-"`
	// A page token that can be used to navigate to the next page or previous
	// page as returned by `next_page_token` or `prev_page_token`.
	PageToken types.String `tfsdk:"-"`
	// Canonical unique identifier for the cluster policy.
	PolicyId types.String `tfsdk:"-"`
}

func (to *ListJobComplianceRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobComplianceRequest_SdkV2) {
}

func (to *ListJobComplianceRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListJobComplianceRequest_SdkV2) {
}

func (m ListJobComplianceRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["policy_id"] = attrs["policy_id"].SetRequired()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["page_size"] = attrs["page_size"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobComplianceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobComplianceRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobComplianceRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListJobComplianceRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":  m.PageSize,
			"page_token": m.PageToken,
			"policy_id":  m.PolicyId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobComplianceRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
			"policy_id":  types.StringType,
		},
	}
}

type ListJobsRequest_SdkV2 struct {
	// Whether to include task and cluster details in the response. Note that
	// only the first 100 elements will be shown. Use :method:jobs/get to
	// paginate through all tasks and clusters.
	ExpandTasks types.Bool `tfsdk:"-"`
	// The number of jobs to return. This value must be greater than 0 and less
	// or equal to 100. The default value is 20.
	Limit types.Int64 `tfsdk:"-"`
	// A filter on the list based on the exact (case insensitive) job name.
	Name types.String `tfsdk:"-"`
	// The offset of the first job to return, relative to the most recently
	// created job. Deprecated since June 2023. Use `page_token` to iterate
	// through the pages instead.
	Offset types.Int64 `tfsdk:"-"`
	// Use `next_page_token` or `prev_page_token` returned from the previous
	// request to list the next or previous page of jobs respectively.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListJobsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobsRequest_SdkV2) {
}

func (to *ListJobsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListJobsRequest_SdkV2) {
}

func (m ListJobsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["offset"] = attrs["offset"].SetOptional()
	attrs["limit"] = attrs["limit"].SetOptional()
	attrs["expand_tasks"] = attrs["expand_tasks"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListJobsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"expand_tasks": m.ExpandTasks,
			"limit":        m.Limit,
			"name":         m.Name,
			"offset":       m.Offset,
			"page_token":   m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"expand_tasks": types.BoolType,
			"limit":        types.Int64Type,
			"name":         types.StringType,
			"offset":       types.Int64Type,
			"page_token":   types.StringType,
		},
	}
}

// List of jobs was retrieved successfully.
type ListJobsResponse_SdkV2 struct {
	// If true, additional jobs matching the provided filter are available for
	// listing.
	HasMore types.Bool `tfsdk:"has_more"`
	// The list of jobs. Only included in the response if there are jobs to
	// list.
	Jobs types.List `tfsdk:"jobs"`
	// A token that can be used to list the next page of jobs (if applicable).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// A token that can be used to list the previous page of jobs (if
	// applicable).
	PrevPageToken types.String `tfsdk:"prev_page_token"`
}

func (to *ListJobsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobsResponse_SdkV2) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (to *ListJobsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListJobsResponse_SdkV2) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (m ListJobsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["jobs"] = attrs["jobs"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["prev_page_token"] = attrs["prev_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"jobs": reflect.TypeOf(BaseJob_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListJobsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_more":        m.HasMore,
			"jobs":            m.Jobs,
			"next_page_token": m.NextPageToken,
			"prev_page_token": m.PrevPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_more": types.BoolType,
			"jobs": basetypes.ListType{
				ElemType: BaseJob_SdkV2{}.Type(ctx),
			},
			"next_page_token": types.StringType,
			"prev_page_token": types.StringType,
		},
	}
}

// GetJobs returns the value of the Jobs field in ListJobsResponse_SdkV2 as
// a slice of BaseJob_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListJobsResponse_SdkV2) GetJobs(ctx context.Context) ([]BaseJob_SdkV2, bool) {
	if m.Jobs.IsNull() || m.Jobs.IsUnknown() {
		return nil, false
	}
	var v []BaseJob_SdkV2
	d := m.Jobs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobs sets the value of the Jobs field in ListJobsResponse_SdkV2.
func (m *ListJobsResponse_SdkV2) SetJobs(ctx context.Context, v []BaseJob_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jobs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Jobs = types.ListValueMust(t, vs)
}

type ListRunsRequest_SdkV2 struct {
	// If active_only is `true`, only active runs are included in the results;
	// otherwise, lists both active and completed runs. An active run is a run
	// in the `QUEUED`, `PENDING`, `RUNNING`, or `TERMINATING`. This field
	// cannot be `true` when completed_only is `true`.
	ActiveOnly types.Bool `tfsdk:"-"`
	// If completed_only is `true`, only completed runs are included in the
	// results; otherwise, lists both active and completed runs. This field
	// cannot be `true` when active_only is `true`.
	CompletedOnly types.Bool `tfsdk:"-"`
	// Whether to include task and cluster details in the response. Note that
	// only the first 100 elements will be shown. Use :method:jobs/getrun to
	// paginate through all tasks and clusters.
	ExpandTasks types.Bool `tfsdk:"-"`
	// The job for which to list runs. If omitted, the Jobs service lists runs
	// from all jobs.
	JobId types.Int64 `tfsdk:"-"`
	// The number of runs to return. This value must be greater than 0 and less
	// than 25. The default value is 20. If a request specifies a limit of 0,
	// the service instead uses the maximum limit.
	Limit types.Int64 `tfsdk:"-"`
	// The offset of the first run to return, relative to the most recent run.
	// Deprecated since June 2023. Use `page_token` to iterate through the pages
	// instead.
	Offset types.Int64 `tfsdk:"-"`
	// Use `next_page_token` or `prev_page_token` returned from the previous
	// request to list the next or previous page of runs respectively.
	PageToken types.String `tfsdk:"-"`
	// The type of runs to return. For a description of run types, see
	// :method:jobs/getRun.
	RunType types.String `tfsdk:"-"`
	// Show runs that started _at or after_ this value. The value must be a UTC
	// timestamp in milliseconds. Can be combined with _start_time_to_ to filter
	// by a time range.
	StartTimeFrom types.Int64 `tfsdk:"-"`
	// Show runs that started _at or before_ this value. The value must be a UTC
	// timestamp in milliseconds. Can be combined with _start_time_from_ to
	// filter by a time range.
	StartTimeTo types.Int64 `tfsdk:"-"`
}

func (to *ListRunsRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRunsRequest_SdkV2) {
}

func (to *ListRunsRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListRunsRequest_SdkV2) {
}

func (m ListRunsRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["active_only"] = attrs["active_only"].SetOptional()
	attrs["completed_only"] = attrs["completed_only"].SetOptional()
	attrs["offset"] = attrs["offset"].SetOptional()
	attrs["limit"] = attrs["limit"].SetOptional()
	attrs["run_type"] = attrs["run_type"].SetOptional()
	attrs["expand_tasks"] = attrs["expand_tasks"].SetOptional()
	attrs["start_time_from"] = attrs["start_time_from"].SetOptional()
	attrs["start_time_to"] = attrs["start_time_to"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRunsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRunsRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRunsRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListRunsRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active_only":     m.ActiveOnly,
			"completed_only":  m.CompletedOnly,
			"expand_tasks":    m.ExpandTasks,
			"job_id":          m.JobId,
			"limit":           m.Limit,
			"offset":          m.Offset,
			"page_token":      m.PageToken,
			"run_type":        m.RunType,
			"start_time_from": m.StartTimeFrom,
			"start_time_to":   m.StartTimeTo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRunsRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active_only":     types.BoolType,
			"completed_only":  types.BoolType,
			"expand_tasks":    types.BoolType,
			"job_id":          types.Int64Type,
			"limit":           types.Int64Type,
			"offset":          types.Int64Type,
			"page_token":      types.StringType,
			"run_type":        types.StringType,
			"start_time_from": types.Int64Type,
			"start_time_to":   types.Int64Type,
		},
	}
}

// List of runs was retrieved successfully.
type ListRunsResponse_SdkV2 struct {
	// If true, additional runs matching the provided filter are available for
	// listing.
	HasMore types.Bool `tfsdk:"has_more"`
	// A token that can be used to list the next page of runs (if applicable).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// A token that can be used to list the previous page of runs (if
	// applicable).
	PrevPageToken types.String `tfsdk:"prev_page_token"`
	// A list of runs, from most recently started to least. Only included in the
	// response if there are runs to list.
	Runs types.List `tfsdk:"runs"`
}

func (to *ListRunsResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRunsResponse_SdkV2) {
	if !from.Runs.IsNull() && !from.Runs.IsUnknown() && to.Runs.IsNull() && len(from.Runs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Runs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Runs = from.Runs
	}
}

func (to *ListRunsResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListRunsResponse_SdkV2) {
	if !from.Runs.IsNull() && !from.Runs.IsUnknown() && to.Runs.IsNull() && len(from.Runs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Runs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Runs = from.Runs
	}
}

func (m ListRunsResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["prev_page_token"] = attrs["prev_page_token"].SetOptional()
	attrs["runs"] = attrs["runs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRunsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRunsResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"runs": reflect.TypeOf(BaseRun_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRunsResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListRunsResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_more":        m.HasMore,
			"next_page_token": m.NextPageToken,
			"prev_page_token": m.PrevPageToken,
			"runs":            m.Runs,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRunsResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_more":        types.BoolType,
			"next_page_token": types.StringType,
			"prev_page_token": types.StringType,
			"runs": basetypes.ListType{
				ElemType: BaseRun_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetRuns returns the value of the Runs field in ListRunsResponse_SdkV2 as
// a slice of BaseRun_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListRunsResponse_SdkV2) GetRuns(ctx context.Context) ([]BaseRun_SdkV2, bool) {
	if m.Runs.IsNull() || m.Runs.IsUnknown() {
		return nil, false
	}
	var v []BaseRun_SdkV2
	d := m.Runs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRuns sets the value of the Runs field in ListRunsResponse_SdkV2.
func (m *ListRunsResponse_SdkV2) SetRuns(ctx context.Context, v []BaseRun_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["runs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Runs = types.ListValueMust(t, vs)
}

type NotebookOutput_SdkV2 struct {
	// The value passed to
	// [dbutils.notebook.exit()](/notebooks/notebook-workflows.html#notebook-workflows-exit).
	// Databricks restricts this API to return the first 5 MB of the value. For
	// a larger result, your job can store the results in a cloud storage
	// service. This field is absent if `dbutils.notebook.exit()` was never
	// called.
	Result types.String `tfsdk:"result"`
	// Whether or not the result was truncated.
	Truncated types.Bool `tfsdk:"truncated"`
}

func (to *NotebookOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from NotebookOutput_SdkV2) {
}

func (to *NotebookOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from NotebookOutput_SdkV2) {
}

func (m NotebookOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["result"] = attrs["result"].SetOptional()
	attrs["truncated"] = attrs["truncated"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NotebookOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m NotebookOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NotebookOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m NotebookOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"result":    m.Result,
			"truncated": m.Truncated,
		})
}

// Type implements basetypes.ObjectValuable.
func (m NotebookOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"result":    types.StringType,
			"truncated": types.BoolType,
		},
	}
}

type NotebookTask_SdkV2 struct {
	// Base parameters to be used for each run of this job. If the run is
	// initiated by a call to :method:jobs/run Now with parameters specified,
	// the two parameters maps are merged. If the same key is specified in
	// `base_parameters` and in `run-now`, the value from `run-now` is used. Use
	// [Task parameter variables] to set parameters containing information about
	// job runs.
	//
	// If the notebook takes a parameter that is not specified in the job’s
	// `base_parameters` or the `run-now` override parameters, the default value
	// from the notebook is used.
	//
	// Retrieve these parameters in a notebook using [dbutils.widgets.get].
	//
	// The JSON representation of this field cannot exceed 1MB.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html#dbutils-widgets
	BaseParameters types.Map `tfsdk:"base_parameters"`
	// The path of the notebook to be run in the Databricks workspace or remote
	// repository. For notebooks stored in the Databricks workspace, the path
	// must be absolute and begin with a slash. For notebooks stored in a remote
	// repository, the path must be relative. This field is required.
	NotebookPath types.String `tfsdk:"notebook_path"`
	// Optional location type of the notebook. When set to `WORKSPACE`, the
	// notebook will be retrieved from the local Databricks workspace. When set
	// to `GIT`, the notebook will be retrieved from a Git repository defined in
	// `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise. * `WORKSPACE`:
	// Notebook is located in Databricks workspace. * `GIT`: Notebook is located
	// in cloud Git provider.
	Source types.String `tfsdk:"source"`
	// Optional `warehouse_id` to run the notebook on a SQL warehouse. Classic
	// SQL warehouses are NOT supported, please use serverless or pro SQL
	// warehouses.
	//
	// Note that SQL warehouses only support SQL cells; if the notebook contains
	// non-SQL cells, the run will fail.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *NotebookTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from NotebookTask_SdkV2) {
}

func (to *NotebookTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from NotebookTask_SdkV2) {
}

func (m NotebookTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["base_parameters"] = attrs["base_parameters"].SetOptional()
	attrs["notebook_path"] = attrs["notebook_path"].SetRequired()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NotebookTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m NotebookTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"base_parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NotebookTask_SdkV2
// only implements ToObjectValue() and Type().
func (m NotebookTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"base_parameters": m.BaseParameters,
			"notebook_path":   m.NotebookPath,
			"source":          m.Source,
			"warehouse_id":    m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m NotebookTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"base_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_path": types.StringType,
			"source":        types.StringType,
			"warehouse_id":  types.StringType,
		},
	}
}

// GetBaseParameters returns the value of the BaseParameters field in NotebookTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *NotebookTask_SdkV2) GetBaseParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.BaseParameters.IsNull() || m.BaseParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.BaseParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBaseParameters sets the value of the BaseParameters field in NotebookTask_SdkV2.
func (m *NotebookTask_SdkV2) SetBaseParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["base_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.BaseParameters = types.MapValueMust(t, vs)
}

// Stores the catalog name, schema name, and the output schema expiration time
// for the clean room run.
type OutputSchemaInfo_SdkV2 struct {
	CatalogName types.String `tfsdk:"catalog_name"`
	// The expiration time for the output schema as a Unix timestamp in
	// milliseconds.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	SchemaName types.String `tfsdk:"schema_name"`
}

func (to *OutputSchemaInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OutputSchemaInfo_SdkV2) {
}

func (to *OutputSchemaInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from OutputSchemaInfo_SdkV2) {
}

func (m OutputSchemaInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OutputSchemaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OutputSchemaInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OutputSchemaInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m OutputSchemaInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":    m.CatalogName,
			"expiration_time": m.ExpirationTime,
			"schema_name":     m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m OutputSchemaInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":    types.StringType,
			"expiration_time": types.Int64Type,
			"schema_name":     types.StringType,
		},
	}
}

type PeriodicTriggerConfiguration_SdkV2 struct {
	// The interval at which the trigger should run.
	Interval types.Int64 `tfsdk:"interval"`
	// The unit of time for the interval.
	Unit types.String `tfsdk:"unit"`
}

func (to *PeriodicTriggerConfiguration_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PeriodicTriggerConfiguration_SdkV2) {
}

func (to *PeriodicTriggerConfiguration_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PeriodicTriggerConfiguration_SdkV2) {
}

func (m PeriodicTriggerConfiguration_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["interval"] = attrs["interval"].SetRequired()
	attrs["unit"] = attrs["unit"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PeriodicTriggerConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PeriodicTriggerConfiguration_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PeriodicTriggerConfiguration_SdkV2
// only implements ToObjectValue() and Type().
func (m PeriodicTriggerConfiguration_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"interval": m.Interval,
			"unit":     m.Unit,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PeriodicTriggerConfiguration_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"interval": types.Int64Type,
			"unit":     types.StringType,
		},
	}
}

type PipelineParams_SdkV2 struct {
	// If true, triggers a full refresh on the delta live table.
	FullRefresh types.Bool `tfsdk:"full_refresh"`
}

func (to *PipelineParams_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PipelineParams_SdkV2) {
}

func (to *PipelineParams_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PipelineParams_SdkV2) {
}

func (m PipelineParams_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_refresh"] = attrs["full_refresh"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PipelineParams.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PipelineParams_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PipelineParams_SdkV2
// only implements ToObjectValue() and Type().
func (m PipelineParams_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_refresh": m.FullRefresh,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PipelineParams_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_refresh": types.BoolType,
		},
	}
}

type PipelineTask_SdkV2 struct {
	// If true, triggers a full refresh on the delta live table.
	FullRefresh types.Bool `tfsdk:"full_refresh"`
	// The full name of the pipeline task to execute.
	PipelineId types.String `tfsdk:"pipeline_id"`
}

func (to *PipelineTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PipelineTask_SdkV2) {
}

func (to *PipelineTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PipelineTask_SdkV2) {
}

func (m PipelineTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_refresh"] = attrs["full_refresh"].SetOptional()
	attrs["pipeline_id"] = attrs["pipeline_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PipelineTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PipelineTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PipelineTask_SdkV2
// only implements ToObjectValue() and Type().
func (m PipelineTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_refresh": m.FullRefresh,
			"pipeline_id":  m.PipelineId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PipelineTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_refresh": types.BoolType,
			"pipeline_id":  types.StringType,
		},
	}
}

type PowerBiModel_SdkV2 struct {
	// How the published Power BI model authenticates to Databricks
	AuthenticationMethod types.String `tfsdk:"authentication_method"`
	// The name of the Power BI model
	ModelName types.String `tfsdk:"model_name"`
	// Whether to overwrite existing Power BI models
	OverwriteExisting types.Bool `tfsdk:"overwrite_existing"`
	// The default storage mode of the Power BI model
	StorageMode types.String `tfsdk:"storage_mode"`
	// The name of the Power BI workspace of the model
	WorkspaceName types.String `tfsdk:"workspace_name"`
}

func (to *PowerBiModel_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PowerBiModel_SdkV2) {
}

func (to *PowerBiModel_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PowerBiModel_SdkV2) {
}

func (m PowerBiModel_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["authentication_method"] = attrs["authentication_method"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["overwrite_existing"] = attrs["overwrite_existing"].SetOptional()
	attrs["storage_mode"] = attrs["storage_mode"].SetOptional()
	attrs["workspace_name"] = attrs["workspace_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PowerBiModel.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PowerBiModel_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PowerBiModel_SdkV2
// only implements ToObjectValue() and Type().
func (m PowerBiModel_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"authentication_method": m.AuthenticationMethod,
			"model_name":            m.ModelName,
			"overwrite_existing":    m.OverwriteExisting,
			"storage_mode":          m.StorageMode,
			"workspace_name":        m.WorkspaceName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PowerBiModel_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"authentication_method": types.StringType,
			"model_name":            types.StringType,
			"overwrite_existing":    types.BoolType,
			"storage_mode":          types.StringType,
			"workspace_name":        types.StringType,
		},
	}
}

type PowerBiTable_SdkV2 struct {
	// The catalog name in Databricks
	Catalog types.String `tfsdk:"catalog"`
	// The table name in Databricks
	Name types.String `tfsdk:"name"`
	// The schema name in Databricks
	Schema types.String `tfsdk:"schema"`
	// The Power BI storage mode of the table
	StorageMode types.String `tfsdk:"storage_mode"`
}

func (to *PowerBiTable_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PowerBiTable_SdkV2) {
}

func (to *PowerBiTable_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PowerBiTable_SdkV2) {
}

func (m PowerBiTable_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog"] = attrs["catalog"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["schema"] = attrs["schema"].SetOptional()
	attrs["storage_mode"] = attrs["storage_mode"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PowerBiTable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PowerBiTable_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PowerBiTable_SdkV2
// only implements ToObjectValue() and Type().
func (m PowerBiTable_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog":      m.Catalog,
			"name":         m.Name,
			"schema":       m.Schema,
			"storage_mode": m.StorageMode,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PowerBiTable_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog":      types.StringType,
			"name":         types.StringType,
			"schema":       types.StringType,
			"storage_mode": types.StringType,
		},
	}
}

type PowerBiTask_SdkV2 struct {
	// The resource name of the UC connection to authenticate from Databricks to
	// Power BI
	ConnectionResourceName types.String `tfsdk:"connection_resource_name"`
	// The semantic model to update
	PowerBiModel types.List `tfsdk:"power_bi_model"`
	// Whether the model should be refreshed after the update
	RefreshAfterUpdate types.Bool `tfsdk:"refresh_after_update"`
	// The tables to be exported to Power BI
	Tables types.List `tfsdk:"tables"`
	// The SQL warehouse ID to use as the Power BI data source
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *PowerBiTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PowerBiTask_SdkV2) {
	if !from.PowerBiModel.IsNull() && !from.PowerBiModel.IsUnknown() {
		if toPowerBiModel, ok := to.GetPowerBiModel(ctx); ok {
			if fromPowerBiModel, ok := from.GetPowerBiModel(ctx); ok {
				// Recursively sync the fields of PowerBiModel
				toPowerBiModel.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiModel)
				to.SetPowerBiModel(ctx, toPowerBiModel)
			}
		}
	}
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (to *PowerBiTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PowerBiTask_SdkV2) {
	if !from.PowerBiModel.IsNull() && !from.PowerBiModel.IsUnknown() {
		if toPowerBiModel, ok := to.GetPowerBiModel(ctx); ok {
			if fromPowerBiModel, ok := from.GetPowerBiModel(ctx); ok {
				toPowerBiModel.SyncFieldsDuringRead(ctx, fromPowerBiModel)
				to.SetPowerBiModel(ctx, toPowerBiModel)
			}
		}
	}
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (m PowerBiTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_resource_name"] = attrs["connection_resource_name"].SetOptional()
	attrs["power_bi_model"] = attrs["power_bi_model"].SetOptional()
	attrs["power_bi_model"] = attrs["power_bi_model"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["refresh_after_update"] = attrs["refresh_after_update"].SetOptional()
	attrs["tables"] = attrs["tables"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PowerBiTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PowerBiTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"power_bi_model": reflect.TypeOf(PowerBiModel_SdkV2{}),
		"tables":         reflect.TypeOf(PowerBiTable_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PowerBiTask_SdkV2
// only implements ToObjectValue() and Type().
func (m PowerBiTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_resource_name": m.ConnectionResourceName,
			"power_bi_model":           m.PowerBiModel,
			"refresh_after_update":     m.RefreshAfterUpdate,
			"tables":                   m.Tables,
			"warehouse_id":             m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PowerBiTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_resource_name": types.StringType,
			"power_bi_model": basetypes.ListType{
				ElemType: PowerBiModel_SdkV2{}.Type(ctx),
			},
			"refresh_after_update": types.BoolType,
			"tables": basetypes.ListType{
				ElemType: PowerBiTable_SdkV2{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetPowerBiModel returns the value of the PowerBiModel field in PowerBiTask_SdkV2 as
// a PowerBiModel_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *PowerBiTask_SdkV2) GetPowerBiModel(ctx context.Context) (PowerBiModel_SdkV2, bool) {
	var e PowerBiModel_SdkV2
	if m.PowerBiModel.IsNull() || m.PowerBiModel.IsUnknown() {
		return e, false
	}
	var v []PowerBiModel_SdkV2
	d := m.PowerBiModel.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPowerBiModel sets the value of the PowerBiModel field in PowerBiTask_SdkV2.
func (m *PowerBiTask_SdkV2) SetPowerBiModel(ctx context.Context, v PowerBiModel_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["power_bi_model"]
	m.PowerBiModel = types.ListValueMust(t, vs)
}

// GetTables returns the value of the Tables field in PowerBiTask_SdkV2 as
// a slice of PowerBiTable_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *PowerBiTask_SdkV2) GetTables(ctx context.Context) ([]PowerBiTable_SdkV2, bool) {
	if m.Tables.IsNull() || m.Tables.IsUnknown() {
		return nil, false
	}
	var v []PowerBiTable_SdkV2
	d := m.Tables.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTables sets the value of the Tables field in PowerBiTask_SdkV2.
func (m *PowerBiTask_SdkV2) SetTables(ctx context.Context, v []PowerBiTable_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tables"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tables = types.ListValueMust(t, vs)
}

type PythonWheelTask_SdkV2 struct {
	// Named entry point to use, if it does not exist in the metadata of the
	// package it executes the function from the package directly using
	// `$packageName.$entryPoint()`
	EntryPoint types.String `tfsdk:"entry_point"`
	// Command-line parameters passed to Python wheel task in the form of
	// `["--name=task", "--data=dbfs:/path/to/data.json"]`. Leave it empty if
	// `parameters` is not null.
	NamedParameters types.Map `tfsdk:"named_parameters"`
	// Name of the package to execute
	PackageName types.String `tfsdk:"package_name"`
	// Command-line parameters passed to Python wheel task. Leave it empty if
	// `named_parameters` is not null.
	Parameters types.List `tfsdk:"parameters"`
}

func (to *PythonWheelTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PythonWheelTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *PythonWheelTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PythonWheelTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m PythonWheelTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entry_point"] = attrs["entry_point"].SetRequired()
	attrs["named_parameters"] = attrs["named_parameters"].SetOptional()
	attrs["package_name"] = attrs["package_name"].SetRequired()
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PythonWheelTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PythonWheelTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"named_parameters": reflect.TypeOf(types.String{}),
		"parameters":       reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PythonWheelTask_SdkV2
// only implements ToObjectValue() and Type().
func (m PythonWheelTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entry_point":      m.EntryPoint,
			"named_parameters": m.NamedParameters,
			"package_name":     m.PackageName,
			"parameters":       m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PythonWheelTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entry_point": types.StringType,
			"named_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"package_name": types.StringType,
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetNamedParameters returns the value of the NamedParameters field in PythonWheelTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PythonWheelTask_SdkV2) GetNamedParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.NamedParameters.IsNull() || m.NamedParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NamedParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNamedParameters sets the value of the NamedParameters field in PythonWheelTask_SdkV2.
func (m *PythonWheelTask_SdkV2) SetNamedParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["named_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NamedParameters = types.MapValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in PythonWheelTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PythonWheelTask_SdkV2) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in PythonWheelTask_SdkV2.
func (m *PythonWheelTask_SdkV2) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type QueueDetails_SdkV2 struct {
	Code types.String `tfsdk:"code"`
	// A descriptive message with the queuing details. This field is
	// unstructured, and its exact format is subject to change.
	Message types.String `tfsdk:"message"`
}

func (to *QueueDetails_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from QueueDetails_SdkV2) {
}

func (to *QueueDetails_SdkV2) SyncFieldsDuringRead(ctx context.Context, from QueueDetails_SdkV2) {
}

func (m QueueDetails_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["code"] = attrs["code"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QueueDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m QueueDetails_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QueueDetails_SdkV2
// only implements ToObjectValue() and Type().
func (m QueueDetails_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"code":    m.Code,
			"message": m.Message,
		})
}

// Type implements basetypes.ObjectValuable.
func (m QueueDetails_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"code":    types.StringType,
			"message": types.StringType,
		},
	}
}

type QueueSettings_SdkV2 struct {
	// If true, enable queueing for the job. This is a required field.
	Enabled types.Bool `tfsdk:"enabled"`
}

func (to *QueueSettings_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from QueueSettings_SdkV2) {
}

func (to *QueueSettings_SdkV2) SyncFieldsDuringRead(ctx context.Context, from QueueSettings_SdkV2) {
}

func (m QueueSettings_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["enabled"] = attrs["enabled"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QueueSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m QueueSettings_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QueueSettings_SdkV2
// only implements ToObjectValue() and Type().
func (m QueueSettings_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"enabled": m.Enabled,
		})
}

// Type implements basetypes.ObjectValuable.
func (m QueueSettings_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"enabled": types.BoolType,
		},
	}
}

type RepairHistoryItem_SdkV2 struct {
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// The end time of the (repaired) run.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The ID of the repair. Only returned for the items that represent a repair
	// in `repair_history`.
	Id types.Int64 `tfsdk:"id"`
	// The start time of the (repaired) run.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.List `tfsdk:"state"`

	Status types.List `tfsdk:"status"`
	// The run IDs of the task runs that ran as part of this repair history
	// item.
	TaskRunIds types.List `tfsdk:"task_run_ids"`
	// The repair history item type. Indicates whether a run is the original run
	// or a repair run.
	Type_ types.String `tfsdk:"type"`
}

func (to *RepairHistoryItem_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RepairHistoryItem_SdkV2) {
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.TaskRunIds.IsNull() && !from.TaskRunIds.IsUnknown() && to.TaskRunIds.IsNull() && len(from.TaskRunIds.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TaskRunIds, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TaskRunIds = from.TaskRunIds
	}
}

func (to *RepairHistoryItem_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RepairHistoryItem_SdkV2) {
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.TaskRunIds.IsNull() && !from.TaskRunIds.IsUnknown() && to.TaskRunIds.IsNull() && len(from.TaskRunIds.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TaskRunIds, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TaskRunIds = from.TaskRunIds
	}
}

func (m RepairHistoryItem_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetOptional()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["state"] = attrs["state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["status"] = attrs["status"].SetOptional()
	attrs["status"] = attrs["status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["task_run_ids"] = attrs["task_run_ids"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RepairHistoryItem.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RepairHistoryItem_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"state":        reflect.TypeOf(RunState_SdkV2{}),
		"status":       reflect.TypeOf(RunStatus_SdkV2{}),
		"task_run_ids": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RepairHistoryItem_SdkV2
// only implements ToObjectValue() and Type().
func (m RepairHistoryItem_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"effective_performance_target": m.EffectivePerformanceTarget,
			"end_time":                     m.EndTime,
			"id":                           m.Id,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"task_run_ids":                 m.TaskRunIds,
			"type":                         m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RepairHistoryItem_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"effective_performance_target": types.StringType,
			"end_time":                     types.Int64Type,
			"id":                           types.Int64Type,
			"start_time":                   types.Int64Type,
			"state": basetypes.ListType{
				ElemType: RunState_SdkV2{}.Type(ctx),
			},
			"status": basetypes.ListType{
				ElemType: RunStatus_SdkV2{}.Type(ctx),
			},
			"task_run_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"type": types.StringType,
		},
	}
}

// GetState returns the value of the State field in RepairHistoryItem_SdkV2 as
// a RunState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairHistoryItem_SdkV2) GetState(ctx context.Context) (RunState_SdkV2, bool) {
	var e RunState_SdkV2
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v []RunState_SdkV2
	d := m.State.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetState sets the value of the State field in RepairHistoryItem_SdkV2.
func (m *RepairHistoryItem_SdkV2) SetState(ctx context.Context, v RunState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["state"]
	m.State = types.ListValueMust(t, vs)
}

// GetStatus returns the value of the Status field in RepairHistoryItem_SdkV2 as
// a RunStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairHistoryItem_SdkV2) GetStatus(ctx context.Context) (RunStatus_SdkV2, bool) {
	var e RunStatus_SdkV2
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v []RunStatus_SdkV2
	d := m.Status.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetStatus sets the value of the Status field in RepairHistoryItem_SdkV2.
func (m *RepairHistoryItem_SdkV2) SetStatus(ctx context.Context, v RunStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["status"]
	m.Status = types.ListValueMust(t, vs)
}

// GetTaskRunIds returns the value of the TaskRunIds field in RepairHistoryItem_SdkV2 as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairHistoryItem_SdkV2) GetTaskRunIds(ctx context.Context) ([]types.Int64, bool) {
	if m.TaskRunIds.IsNull() || m.TaskRunIds.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.TaskRunIds.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTaskRunIds sets the value of the TaskRunIds field in RepairHistoryItem_SdkV2.
func (m *RepairHistoryItem_SdkV2) SetTaskRunIds(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task_run_ids"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TaskRunIds = types.ListValueMust(t, vs)
}

type RepairRun_SdkV2 struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// Job-level parameters used in the run. for example `"param":
	// "overriding_val"`
	JobParameters types.Map `tfsdk:"job_parameters"`
	// The ID of the latest repair. This parameter is not required when
	// repairing a run for the first time, but must be provided on subsequent
	// requests to repair the same run.
	LatestRepairId types.Int64 `tfsdk:"latest_repair_id"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// The performance mode on a serverless job. The performance target
	// determines the level of compute performance or cost-efficiency for the
	// run. This field overrides the performance target defined on the job
	// level.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.List `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// If true, repair all failed tasks. Only one of `rerun_tasks` or
	// `rerun_all_failed_tasks` can be used.
	RerunAllFailedTasks types.Bool `tfsdk:"rerun_all_failed_tasks"`
	// If true, repair all tasks that depend on the tasks in `rerun_tasks`, even
	// if they were previously successful. Can be also used in combination with
	// `rerun_all_failed_tasks`.
	RerunDependentTasks types.Bool `tfsdk:"rerun_dependent_tasks"`
	// The task keys of the task runs to repair.
	RerunTasks types.List `tfsdk:"rerun_tasks"`
	// The job run ID of the run to repair. The run must not be in progress.
	RunId types.Int64 `tfsdk:"run_id"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RepairRun_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RepairRun_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.RerunTasks.IsNull() && !from.RerunTasks.IsUnknown() && to.RerunTasks.IsNull() && len(from.RerunTasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RerunTasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RerunTasks = from.RerunTasks
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RepairRun_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RepairRun_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.RerunTasks.IsNull() && !from.RerunTasks.IsUnknown() && to.RerunTasks.IsNull() && len(from.RerunTasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RerunTasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RerunTasks = from.RerunTasks
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RepairRun_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["latest_repair_id"] = attrs["latest_repair_id"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["rerun_all_failed_tasks"] = attrs["rerun_all_failed_tasks"].SetOptional()
	attrs["rerun_dependent_tasks"] = attrs["rerun_dependent_tasks"].SetOptional()
	attrs["rerun_tasks"] = attrs["rerun_tasks"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetRequired()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RepairRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RepairRun_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"job_parameters":      reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams_SdkV2{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"rerun_tasks":         reflect.TypeOf(types.String{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RepairRun_SdkV2
// only implements ToObjectValue() and Type().
func (m RepairRun_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":           m.DbtCommands,
			"jar_params":             m.JarParams,
			"job_parameters":         m.JobParameters,
			"latest_repair_id":       m.LatestRepairId,
			"notebook_params":        m.NotebookParams,
			"performance_target":     m.PerformanceTarget,
			"pipeline_params":        m.PipelineParams,
			"python_named_params":    m.PythonNamedParams,
			"python_params":          m.PythonParams,
			"rerun_all_failed_tasks": m.RerunAllFailedTasks,
			"rerun_dependent_tasks":  m.RerunDependentTasks,
			"rerun_tasks":            m.RerunTasks,
			"run_id":                 m.RunId,
			"spark_submit_params":    m.SparkSubmitParams,
			"sql_params":             m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RepairRun_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"latest_repair_id": types.Int64Type,
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"performance_target": types.StringType,
			"pipeline_params": basetypes.ListType{
				ElemType: PipelineParams_SdkV2{}.Type(ctx),
			},
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rerun_all_failed_tasks": types.BoolType,
			"rerun_dependent_tasks":  types.BoolType,
			"rerun_tasks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"run_id": types.Int64Type,
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RepairRun_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RepairRun_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in RepairRun_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RepairRun_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RepairRun_SdkV2 as
// a PipelineParams_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetPipelineParams(ctx context.Context) (PipelineParams_SdkV2, bool) {
	var e PipelineParams_SdkV2
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v []PipelineParams_SdkV2
	d := m.PipelineParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineParams sets the value of the PipelineParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetPipelineParams(ctx context.Context, v PipelineParams_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_params"]
	m.PipelineParams = types.ListValueMust(t, vs)
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RepairRun_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RepairRun_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetRerunTasks returns the value of the RerunTasks field in RepairRun_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetRerunTasks(ctx context.Context) ([]types.String, bool) {
	if m.RerunTasks.IsNull() || m.RerunTasks.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.RerunTasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRerunTasks sets the value of the RerunTasks field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetRerunTasks(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["rerun_tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RerunTasks = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RepairRun_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RepairRun_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun_SdkV2) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RepairRun_SdkV2.
func (m *RepairRun_SdkV2) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

// Run repair was initiated.
type RepairRunResponse_SdkV2 struct {
	// The ID of the repair. Must be provided in subsequent repairs using the
	// `latest_repair_id` field to ensure sequential repairs.
	RepairId types.Int64 `tfsdk:"repair_id"`
}

func (to *RepairRunResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RepairRunResponse_SdkV2) {
}

func (to *RepairRunResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RepairRunResponse_SdkV2) {
}

func (m RepairRunResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["repair_id"] = attrs["repair_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RepairRunResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RepairRunResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RepairRunResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m RepairRunResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"repair_id": m.RepairId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RepairRunResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"repair_id": types.Int64Type,
		},
	}
}

type ResetJob_SdkV2 struct {
	// The canonical identifier of the job to reset. This field is required.
	JobId types.Int64 `tfsdk:"job_id"`
	// The new settings of the job. These settings completely replace the old
	// settings.
	//
	// Changes to the field `JobBaseSettings.timeout_seconds` are applied to
	// active runs. Changes to other fields are applied to future runs only.
	NewSettings types.List `tfsdk:"new_settings"`
}

func (to *ResetJob_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResetJob_SdkV2) {
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				// Recursively sync the fields of NewSettings
				toNewSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (to *ResetJob_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResetJob_SdkV2) {
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				toNewSettings.SyncFieldsDuringRead(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (m ResetJob_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["new_settings"] = attrs["new_settings"].SetRequired()
	attrs["new_settings"] = attrs["new_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResetJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResetJob_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"new_settings": reflect.TypeOf(JobSettings_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResetJob_SdkV2
// only implements ToObjectValue() and Type().
func (m ResetJob_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id":       m.JobId,
			"new_settings": m.NewSettings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResetJob_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
			"new_settings": basetypes.ListType{
				ElemType: JobSettings_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetNewSettings returns the value of the NewSettings field in ResetJob_SdkV2 as
// a JobSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResetJob_SdkV2) GetNewSettings(ctx context.Context) (JobSettings_SdkV2, bool) {
	var e JobSettings_SdkV2
	if m.NewSettings.IsNull() || m.NewSettings.IsUnknown() {
		return e, false
	}
	var v []JobSettings_SdkV2
	d := m.NewSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewSettings sets the value of the NewSettings field in ResetJob_SdkV2.
func (m *ResetJob_SdkV2) SetNewSettings(ctx context.Context, v JobSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_settings"]
	m.NewSettings = types.ListValueMust(t, vs)
}

type ResolvedConditionTaskValues_SdkV2 struct {
	Left types.String `tfsdk:"left"`

	Right types.String `tfsdk:"right"`
}

func (to *ResolvedConditionTaskValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedConditionTaskValues_SdkV2) {
}

func (to *ResolvedConditionTaskValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedConditionTaskValues_SdkV2) {
}

func (m ResolvedConditionTaskValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["left"] = attrs["left"].SetOptional()
	attrs["right"] = attrs["right"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedConditionTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedConditionTaskValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedConditionTaskValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedConditionTaskValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"left":  m.Left,
			"right": m.Right,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedConditionTaskValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"left":  types.StringType,
			"right": types.StringType,
		},
	}
}

type ResolvedDbtTaskValues_SdkV2 struct {
	Commands types.List `tfsdk:"commands"`
}

func (to *ResolvedDbtTaskValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedDbtTaskValues_SdkV2) {
	if !from.Commands.IsNull() && !from.Commands.IsUnknown() && to.Commands.IsNull() && len(from.Commands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Commands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Commands = from.Commands
	}
}

func (to *ResolvedDbtTaskValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedDbtTaskValues_SdkV2) {
	if !from.Commands.IsNull() && !from.Commands.IsUnknown() && to.Commands.IsNull() && len(from.Commands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Commands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Commands = from.Commands
	}
}

func (m ResolvedDbtTaskValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["commands"] = attrs["commands"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedDbtTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedDbtTaskValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"commands": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedDbtTaskValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedDbtTaskValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"commands": m.Commands,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedDbtTaskValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"commands": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetCommands returns the value of the Commands field in ResolvedDbtTaskValues_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedDbtTaskValues_SdkV2) GetCommands(ctx context.Context) ([]types.String, bool) {
	if m.Commands.IsNull() || m.Commands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Commands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCommands sets the value of the Commands field in ResolvedDbtTaskValues_SdkV2.
func (m *ResolvedDbtTaskValues_SdkV2) SetCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Commands = types.ListValueMust(t, vs)
}

type ResolvedNotebookTaskValues_SdkV2 struct {
	BaseParameters types.Map `tfsdk:"base_parameters"`
}

func (to *ResolvedNotebookTaskValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedNotebookTaskValues_SdkV2) {
}

func (to *ResolvedNotebookTaskValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedNotebookTaskValues_SdkV2) {
}

func (m ResolvedNotebookTaskValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["base_parameters"] = attrs["base_parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedNotebookTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedNotebookTaskValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"base_parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedNotebookTaskValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedNotebookTaskValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"base_parameters": m.BaseParameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedNotebookTaskValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"base_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetBaseParameters returns the value of the BaseParameters field in ResolvedNotebookTaskValues_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedNotebookTaskValues_SdkV2) GetBaseParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.BaseParameters.IsNull() || m.BaseParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.BaseParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBaseParameters sets the value of the BaseParameters field in ResolvedNotebookTaskValues_SdkV2.
func (m *ResolvedNotebookTaskValues_SdkV2) SetBaseParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["base_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.BaseParameters = types.MapValueMust(t, vs)
}

type ResolvedParamPairValues_SdkV2 struct {
	Parameters types.Map `tfsdk:"parameters"`
}

func (to *ResolvedParamPairValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedParamPairValues_SdkV2) {
}

func (to *ResolvedParamPairValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedParamPairValues_SdkV2) {
}

func (m ResolvedParamPairValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedParamPairValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedParamPairValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedParamPairValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedParamPairValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedParamPairValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in ResolvedParamPairValues_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedParamPairValues_SdkV2) GetParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedParamPairValues_SdkV2.
func (m *ResolvedParamPairValues_SdkV2) SetParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.MapValueMust(t, vs)
}

type ResolvedPythonWheelTaskValues_SdkV2 struct {
	NamedParameters types.Map `tfsdk:"named_parameters"`

	Parameters types.List `tfsdk:"parameters"`
}

func (to *ResolvedPythonWheelTaskValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedPythonWheelTaskValues_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *ResolvedPythonWheelTaskValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedPythonWheelTaskValues_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m ResolvedPythonWheelTaskValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["named_parameters"] = attrs["named_parameters"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedPythonWheelTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedPythonWheelTaskValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"named_parameters": reflect.TypeOf(types.String{}),
		"parameters":       reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedPythonWheelTaskValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedPythonWheelTaskValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"named_parameters": m.NamedParameters,
			"parameters":       m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedPythonWheelTaskValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"named_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetNamedParameters returns the value of the NamedParameters field in ResolvedPythonWheelTaskValues_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedPythonWheelTaskValues_SdkV2) GetNamedParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.NamedParameters.IsNull() || m.NamedParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NamedParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNamedParameters sets the value of the NamedParameters field in ResolvedPythonWheelTaskValues_SdkV2.
func (m *ResolvedPythonWheelTaskValues_SdkV2) SetNamedParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["named_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NamedParameters = types.MapValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in ResolvedPythonWheelTaskValues_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedPythonWheelTaskValues_SdkV2) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedPythonWheelTaskValues_SdkV2.
func (m *ResolvedPythonWheelTaskValues_SdkV2) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type ResolvedRunJobTaskValues_SdkV2 struct {
	JobParameters types.Map `tfsdk:"job_parameters"`

	Parameters types.Map `tfsdk:"parameters"`
}

func (to *ResolvedRunJobTaskValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedRunJobTaskValues_SdkV2) {
}

func (to *ResolvedRunJobTaskValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedRunJobTaskValues_SdkV2) {
}

func (m ResolvedRunJobTaskValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedRunJobTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedRunJobTaskValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"job_parameters": reflect.TypeOf(types.String{}),
		"parameters":     reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedRunJobTaskValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedRunJobTaskValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_parameters": m.JobParameters,
			"parameters":     m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedRunJobTaskValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetJobParameters returns the value of the JobParameters field in ResolvedRunJobTaskValues_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedRunJobTaskValues_SdkV2) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in ResolvedRunJobTaskValues_SdkV2.
func (m *ResolvedRunJobTaskValues_SdkV2) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in ResolvedRunJobTaskValues_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedRunJobTaskValues_SdkV2) GetParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedRunJobTaskValues_SdkV2.
func (m *ResolvedRunJobTaskValues_SdkV2) SetParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.MapValueMust(t, vs)
}

type ResolvedStringParamsValues_SdkV2 struct {
	Parameters types.List `tfsdk:"parameters"`
}

func (to *ResolvedStringParamsValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedStringParamsValues_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *ResolvedStringParamsValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedStringParamsValues_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m ResolvedStringParamsValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedStringParamsValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedStringParamsValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedStringParamsValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedStringParamsValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedStringParamsValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in ResolvedStringParamsValues_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedStringParamsValues_SdkV2) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedStringParamsValues_SdkV2.
func (m *ResolvedStringParamsValues_SdkV2) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type ResolvedValues_SdkV2 struct {
	ConditionTask types.List `tfsdk:"condition_task"`

	DbtTask types.List `tfsdk:"dbt_task"`

	NotebookTask types.List `tfsdk:"notebook_task"`

	PythonWheelTask types.List `tfsdk:"python_wheel_task"`

	RunJobTask types.List `tfsdk:"run_job_task"`

	SimulationTask types.List `tfsdk:"simulation_task"`

	SparkJarTask types.List `tfsdk:"spark_jar_task"`

	SparkPythonTask types.List `tfsdk:"spark_python_task"`

	SparkSubmitTask types.List `tfsdk:"spark_submit_task"`

	SqlTask types.List `tfsdk:"sql_task"`
}

func (to *ResolvedValues_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedValues_SdkV2) {
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SimulationTask.IsNull() && !from.SimulationTask.IsUnknown() {
		if toSimulationTask, ok := to.GetSimulationTask(ctx); ok {
			if fromSimulationTask, ok := from.GetSimulationTask(ctx); ok {
				// Recursively sync the fields of SimulationTask
				toSimulationTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSimulationTask)
				to.SetSimulationTask(ctx, toSimulationTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
}

func (to *ResolvedValues_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ResolvedValues_SdkV2) {
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SimulationTask.IsNull() && !from.SimulationTask.IsUnknown() {
		if toSimulationTask, ok := to.GetSimulationTask(ctx); ok {
			if fromSimulationTask, ok := from.GetSimulationTask(ctx); ok {
				toSimulationTask.SyncFieldsDuringRead(ctx, fromSimulationTask)
				to.SetSimulationTask(ctx, toSimulationTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
}

func (m ResolvedValues_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["simulation_task"] = attrs["simulation_task"].SetOptional()
	attrs["simulation_task"] = attrs["simulation_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedValues_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"condition_task":    reflect.TypeOf(ResolvedConditionTaskValues_SdkV2{}),
		"dbt_task":          reflect.TypeOf(ResolvedDbtTaskValues_SdkV2{}),
		"notebook_task":     reflect.TypeOf(ResolvedNotebookTaskValues_SdkV2{}),
		"python_wheel_task": reflect.TypeOf(ResolvedPythonWheelTaskValues_SdkV2{}),
		"run_job_task":      reflect.TypeOf(ResolvedRunJobTaskValues_SdkV2{}),
		"simulation_task":   reflect.TypeOf(ResolvedParamPairValues_SdkV2{}),
		"spark_jar_task":    reflect.TypeOf(ResolvedStringParamsValues_SdkV2{}),
		"spark_python_task": reflect.TypeOf(ResolvedStringParamsValues_SdkV2{}),
		"spark_submit_task": reflect.TypeOf(ResolvedStringParamsValues_SdkV2{}),
		"sql_task":          reflect.TypeOf(ResolvedParamPairValues_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedValues_SdkV2
// only implements ToObjectValue() and Type().
func (m ResolvedValues_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"condition_task":    m.ConditionTask,
			"dbt_task":          m.DbtTask,
			"notebook_task":     m.NotebookTask,
			"python_wheel_task": m.PythonWheelTask,
			"run_job_task":      m.RunJobTask,
			"simulation_task":   m.SimulationTask,
			"spark_jar_task":    m.SparkJarTask,
			"spark_python_task": m.SparkPythonTask,
			"spark_submit_task": m.SparkSubmitTask,
			"sql_task":          m.SqlTask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedValues_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"condition_task": basetypes.ListType{
				ElemType: ResolvedConditionTaskValues_SdkV2{}.Type(ctx),
			},
			"dbt_task": basetypes.ListType{
				ElemType: ResolvedDbtTaskValues_SdkV2{}.Type(ctx),
			},
			"notebook_task": basetypes.ListType{
				ElemType: ResolvedNotebookTaskValues_SdkV2{}.Type(ctx),
			},
			"python_wheel_task": basetypes.ListType{
				ElemType: ResolvedPythonWheelTaskValues_SdkV2{}.Type(ctx),
			},
			"run_job_task": basetypes.ListType{
				ElemType: ResolvedRunJobTaskValues_SdkV2{}.Type(ctx),
			},
			"simulation_task": basetypes.ListType{
				ElemType: ResolvedParamPairValues_SdkV2{}.Type(ctx),
			},
			"spark_jar_task": basetypes.ListType{
				ElemType: ResolvedStringParamsValues_SdkV2{}.Type(ctx),
			},
			"spark_python_task": basetypes.ListType{
				ElemType: ResolvedStringParamsValues_SdkV2{}.Type(ctx),
			},
			"spark_submit_task": basetypes.ListType{
				ElemType: ResolvedStringParamsValues_SdkV2{}.Type(ctx),
			},
			"sql_task": basetypes.ListType{
				ElemType: ResolvedParamPairValues_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetConditionTask returns the value of the ConditionTask field in ResolvedValues_SdkV2 as
// a ResolvedConditionTaskValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetConditionTask(ctx context.Context) (ResolvedConditionTaskValues_SdkV2, bool) {
	var e ResolvedConditionTaskValues_SdkV2
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedConditionTaskValues_SdkV2
	d := m.ConditionTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetConditionTask sets the value of the ConditionTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetConditionTask(ctx context.Context, v ResolvedConditionTaskValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["condition_task"]
	m.ConditionTask = types.ListValueMust(t, vs)
}

// GetDbtTask returns the value of the DbtTask field in ResolvedValues_SdkV2 as
// a ResolvedDbtTaskValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetDbtTask(ctx context.Context) (ResolvedDbtTaskValues_SdkV2, bool) {
	var e ResolvedDbtTaskValues_SdkV2
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedDbtTaskValues_SdkV2
	d := m.DbtTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtTask sets the value of the DbtTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetDbtTask(ctx context.Context, v ResolvedDbtTaskValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_task"]
	m.DbtTask = types.ListValueMust(t, vs)
}

// GetNotebookTask returns the value of the NotebookTask field in ResolvedValues_SdkV2 as
// a ResolvedNotebookTaskValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetNotebookTask(ctx context.Context) (ResolvedNotebookTaskValues_SdkV2, bool) {
	var e ResolvedNotebookTaskValues_SdkV2
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedNotebookTaskValues_SdkV2
	d := m.NotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotebookTask sets the value of the NotebookTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetNotebookTask(ctx context.Context, v ResolvedNotebookTaskValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_task"]
	m.NotebookTask = types.ListValueMust(t, vs)
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in ResolvedValues_SdkV2 as
// a ResolvedPythonWheelTaskValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetPythonWheelTask(ctx context.Context) (ResolvedPythonWheelTaskValues_SdkV2, bool) {
	var e ResolvedPythonWheelTaskValues_SdkV2
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedPythonWheelTaskValues_SdkV2
	d := m.PythonWheelTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetPythonWheelTask(ctx context.Context, v ResolvedPythonWheelTaskValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_wheel_task"]
	m.PythonWheelTask = types.ListValueMust(t, vs)
}

// GetRunJobTask returns the value of the RunJobTask field in ResolvedValues_SdkV2 as
// a ResolvedRunJobTaskValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetRunJobTask(ctx context.Context) (ResolvedRunJobTaskValues_SdkV2, bool) {
	var e ResolvedRunJobTaskValues_SdkV2
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedRunJobTaskValues_SdkV2
	d := m.RunJobTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunJobTask sets the value of the RunJobTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetRunJobTask(ctx context.Context, v ResolvedRunJobTaskValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_job_task"]
	m.RunJobTask = types.ListValueMust(t, vs)
}

// GetSimulationTask returns the value of the SimulationTask field in ResolvedValues_SdkV2 as
// a ResolvedParamPairValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetSimulationTask(ctx context.Context) (ResolvedParamPairValues_SdkV2, bool) {
	var e ResolvedParamPairValues_SdkV2
	if m.SimulationTask.IsNull() || m.SimulationTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedParamPairValues_SdkV2
	d := m.SimulationTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSimulationTask sets the value of the SimulationTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetSimulationTask(ctx context.Context, v ResolvedParamPairValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["simulation_task"]
	m.SimulationTask = types.ListValueMust(t, vs)
}

// GetSparkJarTask returns the value of the SparkJarTask field in ResolvedValues_SdkV2 as
// a ResolvedStringParamsValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetSparkJarTask(ctx context.Context) (ResolvedStringParamsValues_SdkV2, bool) {
	var e ResolvedStringParamsValues_SdkV2
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedStringParamsValues_SdkV2
	d := m.SparkJarTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkJarTask sets the value of the SparkJarTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetSparkJarTask(ctx context.Context, v ResolvedStringParamsValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_jar_task"]
	m.SparkJarTask = types.ListValueMust(t, vs)
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in ResolvedValues_SdkV2 as
// a ResolvedStringParamsValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetSparkPythonTask(ctx context.Context) (ResolvedStringParamsValues_SdkV2, bool) {
	var e ResolvedStringParamsValues_SdkV2
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedStringParamsValues_SdkV2
	d := m.SparkPythonTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetSparkPythonTask(ctx context.Context, v ResolvedStringParamsValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_python_task"]
	m.SparkPythonTask = types.ListValueMust(t, vs)
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in ResolvedValues_SdkV2 as
// a ResolvedStringParamsValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetSparkSubmitTask(ctx context.Context) (ResolvedStringParamsValues_SdkV2, bool) {
	var e ResolvedStringParamsValues_SdkV2
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedStringParamsValues_SdkV2
	d := m.SparkSubmitTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetSparkSubmitTask(ctx context.Context, v ResolvedStringParamsValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_task"]
	m.SparkSubmitTask = types.ListValueMust(t, vs)
}

// GetSqlTask returns the value of the SqlTask field in ResolvedValues_SdkV2 as
// a ResolvedParamPairValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues_SdkV2) GetSqlTask(ctx context.Context) (ResolvedParamPairValues_SdkV2, bool) {
	var e ResolvedParamPairValues_SdkV2
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v []ResolvedParamPairValues_SdkV2
	d := m.SqlTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSqlTask sets the value of the SqlTask field in ResolvedValues_SdkV2.
func (m *ResolvedValues_SdkV2) SetSqlTask(ctx context.Context, v ResolvedParamPairValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_task"]
	m.SqlTask = types.ListValueMust(t, vs)
}

// Run was retrieved successfully
type Run_SdkV2 struct {
	// The sequence number of this run attempt for a triggered job run. The
	// initial attempt of a run has an attempt_number of 0. If the initial run
	// attempt fails, and the job has a retry policy (`max_retries` > 0),
	// subsequent runs are created with an `original_attempt_run_id` of the
	// original attempt’s ID and an incrementing `attempt_number`. Runs are
	// retried only until they succeed, and the maximum `attempt_number` is the
	// same as the `max_retries` value for the job.
	AttemptNumber types.Int64 `tfsdk:"attempt_number"`
	// The time in milliseconds it took to terminate the cluster and clean up
	// any associated artifacts. The duration of a task run is the sum of the
	// `setup_duration`, `execution_duration`, and the `cleanup_duration`. The
	// `cleanup_duration` field is set to 0 for multitask job runs. The total
	// duration of a multitask job run is the value of the `run_duration` field.
	CleanupDuration types.Int64 `tfsdk:"cleanup_duration"`
	// The cluster used for this run. If the run is specified to use a new
	// cluster, this field is set once the Jobs service has requested a cluster
	// for the run.
	ClusterInstance types.List `tfsdk:"cluster_instance"`
	// A snapshot of the job’s cluster specification when this run was
	// created.
	ClusterSpec types.List `tfsdk:"cluster_spec"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// Description of the run
	Description types.String `tfsdk:"description"`
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// The id of the usage policy used by this run for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// The time at which this run ended in epoch milliseconds (milliseconds
	// since 1/1/1970 UTC). This field is set to 0 if the job is still running.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The time in milliseconds it took to execute the commands in the JAR or
	// notebook until they completed, failed, timed out, were cancelled, or
	// encountered an unexpected error. The duration of a task run is the sum of
	// the `setup_duration`, `execution_duration`, and the `cleanup_duration`.
	// The `execution_duration` field is set to 0 for multitask job runs. The
	// total duration of a multitask job run is the value of the `run_duration`
	// field.
	ExecutionDuration types.Int64 `tfsdk:"execution_duration"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.List `tfsdk:"git_source"`
	// Indicates if the run has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/getrun
	// endpoint. It is only relevant for API 2.2 :method:jobs/listruns requests
	// with `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// Only populated by for-each iterations. The parent for-each task is
	// located in tasks array.
	Iterations types.List `tfsdk:"iterations"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings. If more than 100
	// job clusters are available, you can paginate through them using
	// :method:jobs/getrun.
	JobClusters types.List `tfsdk:"job_clusters"`
	// The canonical identifier of the job that contains this run.
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used in the run
	JobParameters types.List `tfsdk:"job_parameters"`
	// ID of the job run that this run belongs to. For legacy and single-task
	// job runs the field is populated with the job run ID. For task runs, the
	// field is populated with the ID of the job run that the task run belongs
	// to.
	JobRunId types.Int64 `tfsdk:"job_run_id"`
	// A token that can be used to list the next page of array properties.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// A unique identifier for this job run. This is set to the same value as
	// `run_id`.
	NumberInJob types.Int64 `tfsdk:"number_in_job"`
	// If this run is a retry of a prior run attempt, this field contains the
	// run_id of the original attempt; otherwise, it is the same as the run_id.
	OriginalAttemptRunId types.Int64 `tfsdk:"original_attempt_run_id"`
	// The parameters used for this run.
	OverridingParameters types.List `tfsdk:"overriding_parameters"`
	// The time in milliseconds that the run has spent in the queue.
	QueueDuration types.Int64 `tfsdk:"queue_duration"`
	// The repair history of the run.
	RepairHistory types.List `tfsdk:"repair_history"`
	// The time in milliseconds it took the job run and all of its repairs to
	// finish.
	RunDuration types.Int64 `tfsdk:"run_duration"`
	// The canonical identifier of the run. This ID is unique across all runs of
	// all jobs.
	RunId types.Int64 `tfsdk:"run_id"`
	// An optional name for the run. The maximum length is 4096 bytes in UTF-8
	// encoding.
	RunName types.String `tfsdk:"run_name"`
	// The URL to the detail page of the run.
	RunPageUrl types.String `tfsdk:"run_page_url"`

	RunType types.String `tfsdk:"run_type"`
	// The cron schedule that triggered this run if it was triggered by the
	// periodic scheduler.
	Schedule types.List `tfsdk:"schedule"`
	// The time in milliseconds it took to set up the cluster. For runs that run
	// on new clusters this is the cluster creation time, for runs that run on
	// existing clusters this time should be very short. The duration of a task
	// run is the sum of the `setup_duration`, `execution_duration`, and the
	// `cleanup_duration`. The `setup_duration` field is set to 0 for multitask
	// job runs. The total duration of a multitask job run is the value of the
	// `run_duration` field.
	SetupDuration types.Int64 `tfsdk:"setup_duration"`
	// The time at which this run was started in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC). This may not be the time when the job
	// task starts executing, for example, if the job is scheduled to run on a
	// new cluster, this is the time the cluster creation call is issued.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.List `tfsdk:"state"`

	Status types.List `tfsdk:"status"`
	// The list of tasks performed by the run. Each task has its own `run_id`
	// which you can use to call `JobsGetOutput` to retrieve the run resutls. If
	// more than 100 tasks are available, you can paginate through them using
	// :method:jobs/getrun. Use the `next_page_token` field at the object root
	// to determine if more results are available.
	Tasks types.List `tfsdk:"tasks"`

	Trigger types.String `tfsdk:"trigger"`

	TriggerInfo types.List `tfsdk:"trigger_info"`
}

func (to *Run_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Run_SdkV2) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				// Recursively sync the fields of ClusterInstance
				toClusterInstance.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				// Recursively sync the fields of ClusterSpec
				toClusterSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Iterations.IsNull() && !from.Iterations.IsUnknown() && to.Iterations.IsNull() && len(from.Iterations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Iterations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Iterations = from.Iterations
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				// Recursively sync the fields of OverridingParameters
				toOverridingParameters.SyncFieldsDuringCreateOrUpdate(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				// Recursively sync the fields of TriggerInfo
				toTriggerInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (to *Run_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Run_SdkV2) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				toClusterInstance.SyncFieldsDuringRead(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				toClusterSpec.SyncFieldsDuringRead(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Iterations.IsNull() && !from.Iterations.IsUnknown() && to.Iterations.IsNull() && len(from.Iterations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Iterations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Iterations = from.Iterations
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				toOverridingParameters.SyncFieldsDuringRead(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				toTriggerInfo.SyncFieldsDuringRead(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (m Run_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attempt_number"] = attrs["attempt_number"].SetOptional()
	attrs["cleanup_duration"] = attrs["cleanup_duration"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cluster_spec"] = attrs["cluster_spec"].SetOptional()
	attrs["cluster_spec"] = attrs["cluster_spec"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetOptional()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["execution_duration"] = attrs["execution_duration"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["git_source"] = attrs["git_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["iterations"] = attrs["iterations"].SetOptional()
	attrs["job_clusters"] = attrs["job_clusters"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["job_run_id"] = attrs["job_run_id"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["number_in_job"] = attrs["number_in_job"].SetOptional()
	attrs["original_attempt_run_id"] = attrs["original_attempt_run_id"].SetOptional()
	attrs["overriding_parameters"] = attrs["overriding_parameters"].SetOptional()
	attrs["overriding_parameters"] = attrs["overriding_parameters"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["queue_duration"] = attrs["queue_duration"].SetOptional()
	attrs["repair_history"] = attrs["repair_history"].SetOptional()
	attrs["run_duration"] = attrs["run_duration"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_name"] = attrs["run_name"].SetOptional()
	attrs["run_page_url"] = attrs["run_page_url"].SetOptional()
	attrs["run_type"] = attrs["run_type"].SetOptional()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["schedule"] = attrs["schedule"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["setup_duration"] = attrs["setup_duration"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["state"] = attrs["state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["status"] = attrs["status"].SetOptional()
	attrs["status"] = attrs["status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["tasks"] = attrs["tasks"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["trigger_info"] = attrs["trigger_info"].SetOptional()
	attrs["trigger_info"] = attrs["trigger_info"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Run.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Run_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"cluster_instance":      reflect.TypeOf(ClusterInstance_SdkV2{}),
		"cluster_spec":          reflect.TypeOf(ClusterSpec_SdkV2{}),
		"git_source":            reflect.TypeOf(GitSource_SdkV2{}),
		"iterations":            reflect.TypeOf(RunTask_SdkV2{}),
		"job_clusters":          reflect.TypeOf(JobCluster_SdkV2{}),
		"job_parameters":        reflect.TypeOf(JobParameter_SdkV2{}),
		"overriding_parameters": reflect.TypeOf(RunParameters_SdkV2{}),
		"repair_history":        reflect.TypeOf(RepairHistoryItem_SdkV2{}),
		"schedule":              reflect.TypeOf(CronSchedule_SdkV2{}),
		"state":                 reflect.TypeOf(RunState_SdkV2{}),
		"status":                reflect.TypeOf(RunStatus_SdkV2{}),
		"tasks":                 reflect.TypeOf(RunTask_SdkV2{}),
		"trigger_info":          reflect.TypeOf(TriggerInfo_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Run_SdkV2
// only implements ToObjectValue() and Type().
func (m Run_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attempt_number":               m.AttemptNumber,
			"cleanup_duration":             m.CleanupDuration,
			"cluster_instance":             m.ClusterInstance,
			"cluster_spec":                 m.ClusterSpec,
			"creator_user_name":            m.CreatorUserName,
			"description":                  m.Description,
			"effective_performance_target": m.EffectivePerformanceTarget,
			"effective_usage_policy_id":    m.EffectiveUsagePolicyId,
			"end_time":                     m.EndTime,
			"execution_duration":           m.ExecutionDuration,
			"git_source":                   m.GitSource,
			"has_more":                     m.HasMore,
			"iterations":                   m.Iterations,
			"job_clusters":                 m.JobClusters,
			"job_id":                       m.JobId,
			"job_parameters":               m.JobParameters,
			"job_run_id":                   m.JobRunId,
			"next_page_token":              m.NextPageToken,
			"number_in_job":                m.NumberInJob,
			"original_attempt_run_id":      m.OriginalAttemptRunId,
			"overriding_parameters":        m.OverridingParameters,
			"queue_duration":               m.QueueDuration,
			"repair_history":               m.RepairHistory,
			"run_duration":                 m.RunDuration,
			"run_id":                       m.RunId,
			"run_name":                     m.RunName,
			"run_page_url":                 m.RunPageUrl,
			"run_type":                     m.RunType,
			"schedule":                     m.Schedule,
			"setup_duration":               m.SetupDuration,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"tasks":                        m.Tasks,
			"trigger":                      m.Trigger,
			"trigger_info":                 m.TriggerInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Run_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attempt_number":   types.Int64Type,
			"cleanup_duration": types.Int64Type,
			"cluster_instance": basetypes.ListType{
				ElemType: ClusterInstance_SdkV2{}.Type(ctx),
			},
			"cluster_spec": basetypes.ListType{
				ElemType: ClusterSpec_SdkV2{}.Type(ctx),
			},
			"creator_user_name":            types.StringType,
			"description":                  types.StringType,
			"effective_performance_target": types.StringType,
			"effective_usage_policy_id":    types.StringType,
			"end_time":                     types.Int64Type,
			"execution_duration":           types.Int64Type,
			"git_source": basetypes.ListType{
				ElemType: GitSource_SdkV2{}.Type(ctx),
			},
			"has_more": types.BoolType,
			"iterations": basetypes.ListType{
				ElemType: RunTask_SdkV2{}.Type(ctx),
			},
			"job_clusters": basetypes.ListType{
				ElemType: JobCluster_SdkV2{}.Type(ctx),
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.ListType{
				ElemType: JobParameter_SdkV2{}.Type(ctx),
			},
			"job_run_id":              types.Int64Type,
			"next_page_token":         types.StringType,
			"number_in_job":           types.Int64Type,
			"original_attempt_run_id": types.Int64Type,
			"overriding_parameters": basetypes.ListType{
				ElemType: RunParameters_SdkV2{}.Type(ctx),
			},
			"queue_duration": types.Int64Type,
			"repair_history": basetypes.ListType{
				ElemType: RepairHistoryItem_SdkV2{}.Type(ctx),
			},
			"run_duration": types.Int64Type,
			"run_id":       types.Int64Type,
			"run_name":     types.StringType,
			"run_page_url": types.StringType,
			"run_type":     types.StringType,
			"schedule": basetypes.ListType{
				ElemType: CronSchedule_SdkV2{}.Type(ctx),
			},
			"setup_duration": types.Int64Type,
			"start_time":     types.Int64Type,
			"state": basetypes.ListType{
				ElemType: RunState_SdkV2{}.Type(ctx),
			},
			"status": basetypes.ListType{
				ElemType: RunStatus_SdkV2{}.Type(ctx),
			},
			"tasks": basetypes.ListType{
				ElemType: RunTask_SdkV2{}.Type(ctx),
			},
			"trigger": types.StringType,
			"trigger_info": basetypes.ListType{
				ElemType: TriggerInfo_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetClusterInstance returns the value of the ClusterInstance field in Run_SdkV2 as
// a ClusterInstance_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetClusterInstance(ctx context.Context) (ClusterInstance_SdkV2, bool) {
	var e ClusterInstance_SdkV2
	if m.ClusterInstance.IsNull() || m.ClusterInstance.IsUnknown() {
		return e, false
	}
	var v []ClusterInstance_SdkV2
	d := m.ClusterInstance.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetClusterInstance sets the value of the ClusterInstance field in Run_SdkV2.
func (m *Run_SdkV2) SetClusterInstance(ctx context.Context, v ClusterInstance_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cluster_instance"]
	m.ClusterInstance = types.ListValueMust(t, vs)
}

// GetClusterSpec returns the value of the ClusterSpec field in Run_SdkV2 as
// a ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetClusterSpec(ctx context.Context) (ClusterSpec_SdkV2, bool) {
	var e ClusterSpec_SdkV2
	if m.ClusterSpec.IsNull() || m.ClusterSpec.IsUnknown() {
		return e, false
	}
	var v []ClusterSpec_SdkV2
	d := m.ClusterSpec.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetClusterSpec sets the value of the ClusterSpec field in Run_SdkV2.
func (m *Run_SdkV2) SetClusterSpec(ctx context.Context, v ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cluster_spec"]
	m.ClusterSpec = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in Run_SdkV2 as
// a GitSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetGitSource(ctx context.Context) (GitSource_SdkV2, bool) {
	var e GitSource_SdkV2
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v []GitSource_SdkV2
	d := m.GitSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSource sets the value of the GitSource field in Run_SdkV2.
func (m *Run_SdkV2) SetGitSource(ctx context.Context, v GitSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_source"]
	m.GitSource = types.ListValueMust(t, vs)
}

// GetIterations returns the value of the Iterations field in Run_SdkV2 as
// a slice of RunTask_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetIterations(ctx context.Context) ([]RunTask_SdkV2, bool) {
	if m.Iterations.IsNull() || m.Iterations.IsUnknown() {
		return nil, false
	}
	var v []RunTask_SdkV2
	d := m.Iterations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetIterations sets the value of the Iterations field in Run_SdkV2.
func (m *Run_SdkV2) SetIterations(ctx context.Context, v []RunTask_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["iterations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Iterations = types.ListValueMust(t, vs)
}

// GetJobClusters returns the value of the JobClusters field in Run_SdkV2 as
// a slice of JobCluster_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetJobClusters(ctx context.Context) ([]JobCluster_SdkV2, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster_SdkV2
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in Run_SdkV2.
func (m *Run_SdkV2) SetJobClusters(ctx context.Context, v []JobCluster_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_clusters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in Run_SdkV2 as
// a slice of JobParameter_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetJobParameters(ctx context.Context) ([]JobParameter_SdkV2, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameter_SdkV2
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in Run_SdkV2.
func (m *Run_SdkV2) SetJobParameters(ctx context.Context, v []JobParameter_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.ListValueMust(t, vs)
}

// GetOverridingParameters returns the value of the OverridingParameters field in Run_SdkV2 as
// a RunParameters_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetOverridingParameters(ctx context.Context) (RunParameters_SdkV2, bool) {
	var e RunParameters_SdkV2
	if m.OverridingParameters.IsNull() || m.OverridingParameters.IsUnknown() {
		return e, false
	}
	var v []RunParameters_SdkV2
	d := m.OverridingParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetOverridingParameters sets the value of the OverridingParameters field in Run_SdkV2.
func (m *Run_SdkV2) SetOverridingParameters(ctx context.Context, v RunParameters_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["overriding_parameters"]
	m.OverridingParameters = types.ListValueMust(t, vs)
}

// GetRepairHistory returns the value of the RepairHistory field in Run_SdkV2 as
// a slice of RepairHistoryItem_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetRepairHistory(ctx context.Context) ([]RepairHistoryItem_SdkV2, bool) {
	if m.RepairHistory.IsNull() || m.RepairHistory.IsUnknown() {
		return nil, false
	}
	var v []RepairHistoryItem_SdkV2
	d := m.RepairHistory.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRepairHistory sets the value of the RepairHistory field in Run_SdkV2.
func (m *Run_SdkV2) SetRepairHistory(ctx context.Context, v []RepairHistoryItem_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["repair_history"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RepairHistory = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in Run_SdkV2 as
// a CronSchedule_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetSchedule(ctx context.Context) (CronSchedule_SdkV2, bool) {
	var e CronSchedule_SdkV2
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v []CronSchedule_SdkV2
	d := m.Schedule.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSchedule sets the value of the Schedule field in Run_SdkV2.
func (m *Run_SdkV2) SetSchedule(ctx context.Context, v CronSchedule_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedule"]
	m.Schedule = types.ListValueMust(t, vs)
}

// GetState returns the value of the State field in Run_SdkV2 as
// a RunState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetState(ctx context.Context) (RunState_SdkV2, bool) {
	var e RunState_SdkV2
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v []RunState_SdkV2
	d := m.State.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetState sets the value of the State field in Run_SdkV2.
func (m *Run_SdkV2) SetState(ctx context.Context, v RunState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["state"]
	m.State = types.ListValueMust(t, vs)
}

// GetStatus returns the value of the Status field in Run_SdkV2 as
// a RunStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetStatus(ctx context.Context) (RunStatus_SdkV2, bool) {
	var e RunStatus_SdkV2
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v []RunStatus_SdkV2
	d := m.Status.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetStatus sets the value of the Status field in Run_SdkV2.
func (m *Run_SdkV2) SetStatus(ctx context.Context, v RunStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["status"]
	m.Status = types.ListValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in Run_SdkV2 as
// a slice of RunTask_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetTasks(ctx context.Context) ([]RunTask_SdkV2, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []RunTask_SdkV2
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in Run_SdkV2.
func (m *Run_SdkV2) SetTasks(ctx context.Context, v []RunTask_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTriggerInfo returns the value of the TriggerInfo field in Run_SdkV2 as
// a TriggerInfo_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run_SdkV2) GetTriggerInfo(ctx context.Context) (TriggerInfo_SdkV2, bool) {
	var e TriggerInfo_SdkV2
	if m.TriggerInfo.IsNull() || m.TriggerInfo.IsUnknown() {
		return e, false
	}
	var v []TriggerInfo_SdkV2
	d := m.TriggerInfo.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTriggerInfo sets the value of the TriggerInfo field in Run_SdkV2.
func (m *Run_SdkV2) SetTriggerInfo(ctx context.Context, v TriggerInfo_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["trigger_info"]
	m.TriggerInfo = types.ListValueMust(t, vs)
}

type RunConditionTask_SdkV2 struct {
	// The left operand of the condition task. Can be either a string value or a
	// job state or parameter reference.
	Left types.String `tfsdk:"left"`
	// * `EQUAL_TO`, `NOT_EQUAL` operators perform string comparison of their
	// operands. This means that `“12.0” == “12”` will evaluate to
	// `false`. * `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`,
	// `LESS_THAN_OR_EQUAL` operators perform numeric comparison of their
	// operands. `“12.0” >= “12”` will evaluate to `true`, `“10.0”
	// >= “12”` will evaluate to `false`.
	//
	// The boolean comparison to task values can be implemented with operators
	// `EQUAL_TO`, `NOT_EQUAL`. If a task value was set to a boolean value, it
	// will be serialized to `“true”` or `“false”` for the comparison.
	Op types.String `tfsdk:"op"`
	// The condition expression evaluation result. Filled in if the task was
	// successfully completed. Can be `"true"` or `"false"`
	Outcome types.String `tfsdk:"outcome"`
	// The right operand of the condition task. Can be either a string value or
	// a job state or parameter reference.
	Right types.String `tfsdk:"right"`
}

func (to *RunConditionTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunConditionTask_SdkV2) {
}

func (to *RunConditionTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunConditionTask_SdkV2) {
}

func (m RunConditionTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["left"] = attrs["left"].SetRequired()
	attrs["op"] = attrs["op"].SetRequired()
	attrs["outcome"] = attrs["outcome"].SetOptional()
	attrs["right"] = attrs["right"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunConditionTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunConditionTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunConditionTask_SdkV2
// only implements ToObjectValue() and Type().
func (m RunConditionTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"left":    m.Left,
			"op":      m.Op,
			"outcome": m.Outcome,
			"right":   m.Right,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunConditionTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"left":    types.StringType,
			"op":      types.StringType,
			"outcome": types.StringType,
			"right":   types.StringType,
		},
	}
}

type RunForEachTask_SdkV2 struct {
	// An optional maximum allowed number of concurrent runs of the task. Set
	// this value if you want to be able to execute multiple runs of the task
	// concurrently.
	Concurrency types.Int64 `tfsdk:"concurrency"`
	// Array for task to iterate on. This can be a JSON string or a reference to
	// an array parameter.
	Inputs types.String `tfsdk:"inputs"`
	// Read only field. Populated for GetRun and ListRuns RPC calls and stores
	// the execution stats of an For each task
	Stats types.List `tfsdk:"stats"`
	// Configuration for the task that will be run for each element in the array
	Task types.List `tfsdk:"task"`
}

func (to *RunForEachTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunForEachTask_SdkV2) {
	if !from.Stats.IsNull() && !from.Stats.IsUnknown() {
		if toStats, ok := to.GetStats(ctx); ok {
			if fromStats, ok := from.GetStats(ctx); ok {
				// Recursively sync the fields of Stats
				toStats.SyncFieldsDuringCreateOrUpdate(ctx, fromStats)
				to.SetStats(ctx, toStats)
			}
		}
	}
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				// Recursively sync the fields of Task
				toTask.SyncFieldsDuringCreateOrUpdate(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (to *RunForEachTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunForEachTask_SdkV2) {
	if !from.Stats.IsNull() && !from.Stats.IsUnknown() {
		if toStats, ok := to.GetStats(ctx); ok {
			if fromStats, ok := from.GetStats(ctx); ok {
				toStats.SyncFieldsDuringRead(ctx, fromStats)
				to.SetStats(ctx, toStats)
			}
		}
	}
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				toTask.SyncFieldsDuringRead(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (m RunForEachTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["concurrency"] = attrs["concurrency"].SetOptional()
	attrs["inputs"] = attrs["inputs"].SetRequired()
	attrs["stats"] = attrs["stats"].SetOptional()
	attrs["stats"] = attrs["stats"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["task"] = attrs["task"].SetRequired()
	attrs["task"] = attrs["task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunForEachTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunForEachTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"stats": reflect.TypeOf(ForEachStats_SdkV2{}),
		"task":  reflect.TypeOf(Task_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunForEachTask_SdkV2
// only implements ToObjectValue() and Type().
func (m RunForEachTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"concurrency": m.Concurrency,
			"inputs":      m.Inputs,
			"stats":       m.Stats,
			"task":        m.Task,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunForEachTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"concurrency": types.Int64Type,
			"inputs":      types.StringType,
			"stats": basetypes.ListType{
				ElemType: ForEachStats_SdkV2{}.Type(ctx),
			},
			"task": basetypes.ListType{
				ElemType: Task_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetStats returns the value of the Stats field in RunForEachTask_SdkV2 as
// a ForEachStats_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunForEachTask_SdkV2) GetStats(ctx context.Context) (ForEachStats_SdkV2, bool) {
	var e ForEachStats_SdkV2
	if m.Stats.IsNull() || m.Stats.IsUnknown() {
		return e, false
	}
	var v []ForEachStats_SdkV2
	d := m.Stats.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetStats sets the value of the Stats field in RunForEachTask_SdkV2.
func (m *RunForEachTask_SdkV2) SetStats(ctx context.Context, v ForEachStats_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["stats"]
	m.Stats = types.ListValueMust(t, vs)
}

// GetTask returns the value of the Task field in RunForEachTask_SdkV2 as
// a Task_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunForEachTask_SdkV2) GetTask(ctx context.Context) (Task_SdkV2, bool) {
	var e Task_SdkV2
	if m.Task.IsNull() || m.Task.IsUnknown() {
		return e, false
	}
	var v []Task_SdkV2
	d := m.Task.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTask sets the value of the Task field in RunForEachTask_SdkV2.
func (m *RunForEachTask_SdkV2) SetTask(ctx context.Context, v Task_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task"]
	m.Task = types.ListValueMust(t, vs)
}

type RunJobOutput_SdkV2 struct {
	// The run id of the triggered job run
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *RunJobOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunJobOutput_SdkV2) {
}

func (to *RunJobOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunJobOutput_SdkV2) {
}

func (m RunJobOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunJobOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunJobOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunJobOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m RunJobOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunJobOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type RunJobTask_SdkV2 struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// ID of the job to trigger.
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used to trigger the job.
	JobParameters types.Map `tfsdk:"job_parameters"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.List `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RunJobTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunJobTask_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RunJobTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunJobTask_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RunJobTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunJobTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunJobTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"job_parameters":      reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams_SdkV2{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunJobTask_SdkV2
// only implements ToObjectValue() and Type().
func (m RunJobTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":        m.DbtCommands,
			"jar_params":          m.JarParams,
			"job_id":              m.JobId,
			"job_parameters":      m.JobParameters,
			"notebook_params":     m.NotebookParams,
			"pipeline_params":     m.PipelineParams,
			"python_named_params": m.PythonNamedParams,
			"python_params":       m.PythonParams,
			"spark_submit_params": m.SparkSubmitParams,
			"sql_params":          m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunJobTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"pipeline_params": basetypes.ListType{
				ElemType: PipelineParams_SdkV2{}.Type(ctx),
			},
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RunJobTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RunJobTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in RunJobTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RunJobTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RunJobTask_SdkV2 as
// a PipelineParams_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetPipelineParams(ctx context.Context) (PipelineParams_SdkV2, bool) {
	var e PipelineParams_SdkV2
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v []PipelineParams_SdkV2
	d := m.PipelineParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineParams sets the value of the PipelineParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetPipelineParams(ctx context.Context, v PipelineParams_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_params"]
	m.PipelineParams = types.ListValueMust(t, vs)
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RunJobTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RunJobTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RunJobTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RunJobTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask_SdkV2) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RunJobTask_SdkV2.
func (m *RunJobTask_SdkV2) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

type RunNow_SdkV2 struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// An optional token to guarantee the idempotency of job run requests. If a
	// run with the provided token already exists, the request does not create a
	// new run but returns the ID of the existing run instead. If a run with the
	// provided token is deleted, an error is returned.
	//
	// If you specify the idempotency token, upon failure you can retry until
	// the request succeeds. Databricks guarantees that exactly one run is
	// launched with that idempotency token.
	//
	// This token must have at most 64 characters.
	//
	// For more information, see [How to ensure idempotency for jobs].
	//
	// [How to ensure idempotency for jobs]: https://kb.databricks.com/jobs/jobs-idempotency.html
	IdempotencyToken types.String `tfsdk:"idempotency_token"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// The ID of the job to be executed
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used in the run. for example `"param":
	// "overriding_val"`
	JobParameters types.Map `tfsdk:"job_parameters"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// A list of task keys to run inside of the job. If this field is not
	// provided, all tasks in the job will be run.
	Only types.List `tfsdk:"only"`
	// The performance mode on a serverless job. The performance target
	// determines the level of compute performance or cost-efficiency for the
	// run. This field overrides the performance target defined on the job
	// level.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.List `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// The queue settings of the run.
	Queue types.List `tfsdk:"queue"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RunNow_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunNow_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.Only.IsNull() && !from.Only.IsUnknown() && to.Only.IsNull() && len(from.Only.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Only, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Only = from.Only
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RunNow_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunNow_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.Only.IsNull() && !from.Only.IsUnknown() && to.Only.IsNull() && len(from.Only.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Only, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Only = from.Only
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RunNow_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["idempotency_token"] = attrs["idempotency_token"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["only"] = attrs["only"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["queue"] = attrs["queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunNow.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunNow_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"job_parameters":      reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"only":                reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams_SdkV2{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"queue":               reflect.TypeOf(QueueSettings_SdkV2{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunNow_SdkV2
// only implements ToObjectValue() and Type().
func (m RunNow_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":        m.DbtCommands,
			"idempotency_token":   m.IdempotencyToken,
			"jar_params":          m.JarParams,
			"job_id":              m.JobId,
			"job_parameters":      m.JobParameters,
			"notebook_params":     m.NotebookParams,
			"only":                m.Only,
			"performance_target":  m.PerformanceTarget,
			"pipeline_params":     m.PipelineParams,
			"python_named_params": m.PythonNamedParams,
			"python_params":       m.PythonParams,
			"queue":               m.Queue,
			"spark_submit_params": m.SparkSubmitParams,
			"sql_params":          m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunNow_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"idempotency_token": types.StringType,
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"only": basetypes.ListType{
				ElemType: types.StringType,
			},
			"performance_target": types.StringType,
			"pipeline_params": basetypes.ListType{
				ElemType: PipelineParams_SdkV2{}.Type(ctx),
			},
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"queue": basetypes.ListType{
				ElemType: QueueSettings_SdkV2{}.Type(ctx),
			},
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RunNow_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RunNow_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in RunNow_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RunNow_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetOnly returns the value of the Only field in RunNow_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetOnly(ctx context.Context) ([]types.String, bool) {
	if m.Only.IsNull() || m.Only.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Only.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnly sets the value of the Only field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetOnly(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["only"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Only = types.ListValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RunNow_SdkV2 as
// a PipelineParams_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetPipelineParams(ctx context.Context) (PipelineParams_SdkV2, bool) {
	var e PipelineParams_SdkV2
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v []PipelineParams_SdkV2
	d := m.PipelineParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineParams sets the value of the PipelineParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetPipelineParams(ctx context.Context, v PipelineParams_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_params"]
	m.PipelineParams = types.ListValueMust(t, vs)
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RunNow_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RunNow_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in RunNow_SdkV2 as
// a QueueSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetQueue(ctx context.Context) (QueueSettings_SdkV2, bool) {
	var e QueueSettings_SdkV2
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v []QueueSettings_SdkV2
	d := m.Queue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQueue sets the value of the Queue field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetQueue(ctx context.Context, v QueueSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["queue"]
	m.Queue = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RunNow_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RunNow_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow_SdkV2) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RunNow_SdkV2.
func (m *RunNow_SdkV2) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

// Run was started successfully.
type RunNowResponse_SdkV2 struct {
	// A unique identifier for this job run. This is set to the same value as
	// `run_id`.
	NumberInJob types.Int64 `tfsdk:"number_in_job"`
	// The globally unique ID of the newly triggered run.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *RunNowResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunNowResponse_SdkV2) {
}

func (to *RunNowResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunNowResponse_SdkV2) {
}

func (m RunNowResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["number_in_job"] = attrs["number_in_job"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunNowResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunNowResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunNowResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m RunNowResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"number_in_job": m.NumberInJob,
			"run_id":        m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunNowResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"number_in_job": types.Int64Type,
			"run_id":        types.Int64Type,
		},
	}
}

// Run output was retrieved successfully.
type RunOutput_SdkV2 struct {
	// The output of a clean rooms notebook task, if available
	CleanRoomsNotebookOutput types.List `tfsdk:"clean_rooms_notebook_output"`
	// The output of a dashboard task, if available
	DashboardOutput types.List `tfsdk:"dashboard_output"`
	// Deprecated in favor of the new dbt_platform_output
	DbtCloudOutput types.List `tfsdk:"dbt_cloud_output"`
	// The output of a dbt task, if available.
	DbtOutput types.List `tfsdk:"dbt_output"`

	DbtPlatformOutput types.List `tfsdk:"dbt_platform_output"`
	// An error message indicating why a task failed or why output is not
	// available. The message is unstructured, and its exact format is subject
	// to change.
	Error types.String `tfsdk:"error"`
	// If there was an error executing the run, this field contains any
	// available stack traces.
	ErrorTrace types.String `tfsdk:"error_trace"`

	Info types.String `tfsdk:"info"`
	// The output from tasks that write to standard streams (stdout/stderr) such
	// as spark_jar_task, spark_python_task, python_wheel_task.
	//
	// It's not supported for the notebook_task, pipeline_task or
	// spark_submit_task.
	//
	// Databricks restricts this API to return the last 5 MB of these logs.
	Logs types.String `tfsdk:"logs"`
	// Whether the logs are truncated.
	LogsTruncated types.Bool `tfsdk:"logs_truncated"`
	// All details of the run except for its output.
	Metadata types.List `tfsdk:"metadata"`
	// The output of a notebook task, if available. A notebook task that
	// terminates (either successfully or with a failure) without calling
	// `dbutils.notebook.exit()` is considered to have an empty output. This
	// field is set but its result value is empty. Databricks restricts this API
	// to return the first 5 MB of the output. To return a larger result, use
	// the [ClusterLogConf] field to configure log storage for the job cluster.
	//
	// [ClusterLogConf]: https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterlogconf
	NotebookOutput types.List `tfsdk:"notebook_output"`
	// The output of a run job task, if available
	RunJobOutput types.List `tfsdk:"run_job_output"`
	// The output of a SQL task, if available.
	SqlOutput types.List `tfsdk:"sql_output"`
}

func (to *RunOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunOutput_SdkV2) {
	if !from.CleanRoomsNotebookOutput.IsNull() && !from.CleanRoomsNotebookOutput.IsUnknown() {
		if toCleanRoomsNotebookOutput, ok := to.GetCleanRoomsNotebookOutput(ctx); ok {
			if fromCleanRoomsNotebookOutput, ok := from.GetCleanRoomsNotebookOutput(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookOutput
				toCleanRoomsNotebookOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookOutput)
				to.SetCleanRoomsNotebookOutput(ctx, toCleanRoomsNotebookOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				// Recursively sync the fields of DashboardOutput
				toDashboardOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.DbtCloudOutput.IsNull() && !from.DbtCloudOutput.IsUnknown() {
		if toDbtCloudOutput, ok := to.GetDbtCloudOutput(ctx); ok {
			if fromDbtCloudOutput, ok := from.GetDbtCloudOutput(ctx); ok {
				// Recursively sync the fields of DbtCloudOutput
				toDbtCloudOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudOutput)
				to.SetDbtCloudOutput(ctx, toDbtCloudOutput)
			}
		}
	}
	if !from.DbtOutput.IsNull() && !from.DbtOutput.IsUnknown() {
		if toDbtOutput, ok := to.GetDbtOutput(ctx); ok {
			if fromDbtOutput, ok := from.GetDbtOutput(ctx); ok {
				// Recursively sync the fields of DbtOutput
				toDbtOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtOutput)
				to.SetDbtOutput(ctx, toDbtOutput)
			}
		}
	}
	if !from.DbtPlatformOutput.IsNull() && !from.DbtPlatformOutput.IsUnknown() {
		if toDbtPlatformOutput, ok := to.GetDbtPlatformOutput(ctx); ok {
			if fromDbtPlatformOutput, ok := from.GetDbtPlatformOutput(ctx); ok {
				// Recursively sync the fields of DbtPlatformOutput
				toDbtPlatformOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformOutput)
				to.SetDbtPlatformOutput(ctx, toDbtPlatformOutput)
			}
		}
	}
	if !from.Metadata.IsNull() && !from.Metadata.IsUnknown() {
		if toMetadata, ok := to.GetMetadata(ctx); ok {
			if fromMetadata, ok := from.GetMetadata(ctx); ok {
				// Recursively sync the fields of Metadata
				toMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromMetadata)
				to.SetMetadata(ctx, toMetadata)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				// Recursively sync the fields of NotebookOutput
				toNotebookOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.RunJobOutput.IsNull() && !from.RunJobOutput.IsUnknown() {
		if toRunJobOutput, ok := to.GetRunJobOutput(ctx); ok {
			if fromRunJobOutput, ok := from.GetRunJobOutput(ctx); ok {
				// Recursively sync the fields of RunJobOutput
				toRunJobOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobOutput)
				to.SetRunJobOutput(ctx, toRunJobOutput)
			}
		}
	}
	if !from.SqlOutput.IsNull() && !from.SqlOutput.IsUnknown() {
		if toSqlOutput, ok := to.GetSqlOutput(ctx); ok {
			if fromSqlOutput, ok := from.GetSqlOutput(ctx); ok {
				// Recursively sync the fields of SqlOutput
				toSqlOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlOutput)
				to.SetSqlOutput(ctx, toSqlOutput)
			}
		}
	}
}

func (to *RunOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunOutput_SdkV2) {
	if !from.CleanRoomsNotebookOutput.IsNull() && !from.CleanRoomsNotebookOutput.IsUnknown() {
		if toCleanRoomsNotebookOutput, ok := to.GetCleanRoomsNotebookOutput(ctx); ok {
			if fromCleanRoomsNotebookOutput, ok := from.GetCleanRoomsNotebookOutput(ctx); ok {
				toCleanRoomsNotebookOutput.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookOutput)
				to.SetCleanRoomsNotebookOutput(ctx, toCleanRoomsNotebookOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				toDashboardOutput.SyncFieldsDuringRead(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.DbtCloudOutput.IsNull() && !from.DbtCloudOutput.IsUnknown() {
		if toDbtCloudOutput, ok := to.GetDbtCloudOutput(ctx); ok {
			if fromDbtCloudOutput, ok := from.GetDbtCloudOutput(ctx); ok {
				toDbtCloudOutput.SyncFieldsDuringRead(ctx, fromDbtCloudOutput)
				to.SetDbtCloudOutput(ctx, toDbtCloudOutput)
			}
		}
	}
	if !from.DbtOutput.IsNull() && !from.DbtOutput.IsUnknown() {
		if toDbtOutput, ok := to.GetDbtOutput(ctx); ok {
			if fromDbtOutput, ok := from.GetDbtOutput(ctx); ok {
				toDbtOutput.SyncFieldsDuringRead(ctx, fromDbtOutput)
				to.SetDbtOutput(ctx, toDbtOutput)
			}
		}
	}
	if !from.DbtPlatformOutput.IsNull() && !from.DbtPlatformOutput.IsUnknown() {
		if toDbtPlatformOutput, ok := to.GetDbtPlatformOutput(ctx); ok {
			if fromDbtPlatformOutput, ok := from.GetDbtPlatformOutput(ctx); ok {
				toDbtPlatformOutput.SyncFieldsDuringRead(ctx, fromDbtPlatformOutput)
				to.SetDbtPlatformOutput(ctx, toDbtPlatformOutput)
			}
		}
	}
	if !from.Metadata.IsNull() && !from.Metadata.IsUnknown() {
		if toMetadata, ok := to.GetMetadata(ctx); ok {
			if fromMetadata, ok := from.GetMetadata(ctx); ok {
				toMetadata.SyncFieldsDuringRead(ctx, fromMetadata)
				to.SetMetadata(ctx, toMetadata)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				toNotebookOutput.SyncFieldsDuringRead(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.RunJobOutput.IsNull() && !from.RunJobOutput.IsUnknown() {
		if toRunJobOutput, ok := to.GetRunJobOutput(ctx); ok {
			if fromRunJobOutput, ok := from.GetRunJobOutput(ctx); ok {
				toRunJobOutput.SyncFieldsDuringRead(ctx, fromRunJobOutput)
				to.SetRunJobOutput(ctx, toRunJobOutput)
			}
		}
	}
	if !from.SqlOutput.IsNull() && !from.SqlOutput.IsUnknown() {
		if toSqlOutput, ok := to.GetSqlOutput(ctx); ok {
			if fromSqlOutput, ok := from.GetSqlOutput(ctx); ok {
				toSqlOutput.SyncFieldsDuringRead(ctx, fromSqlOutput)
				to.SetSqlOutput(ctx, toSqlOutput)
			}
		}
	}
}

func (m RunOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_rooms_notebook_output"] = attrs["clean_rooms_notebook_output"].SetOptional()
	attrs["clean_rooms_notebook_output"] = attrs["clean_rooms_notebook_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dashboard_output"] = attrs["dashboard_output"].SetOptional()
	attrs["dashboard_output"] = attrs["dashboard_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_cloud_output"] = attrs["dbt_cloud_output"].SetOptional()
	attrs["dbt_cloud_output"] = attrs["dbt_cloud_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_output"] = attrs["dbt_output"].SetOptional()
	attrs["dbt_output"] = attrs["dbt_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_platform_output"] = attrs["dbt_platform_output"].SetOptional()
	attrs["dbt_platform_output"] = attrs["dbt_platform_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["error"] = attrs["error"].SetOptional()
	attrs["error_trace"] = attrs["error_trace"].SetOptional()
	attrs["info"] = attrs["info"].SetOptional()
	attrs["logs"] = attrs["logs"].SetOptional()
	attrs["logs_truncated"] = attrs["logs_truncated"].SetOptional()
	attrs["metadata"] = attrs["metadata"].SetOptional()
	attrs["metadata"] = attrs["metadata"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notebook_output"] = attrs["notebook_output"].SetOptional()
	attrs["notebook_output"] = attrs["notebook_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_job_output"] = attrs["run_job_output"].SetOptional()
	attrs["run_job_output"] = attrs["run_job_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["sql_output"] = attrs["sql_output"].SetOptional()
	attrs["sql_output"] = attrs["sql_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_output": reflect.TypeOf(CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2{}),
		"dashboard_output":            reflect.TypeOf(DashboardTaskOutput_SdkV2{}),
		"dbt_cloud_output":            reflect.TypeOf(DbtCloudTaskOutput_SdkV2{}),
		"dbt_output":                  reflect.TypeOf(DbtOutput_SdkV2{}),
		"dbt_platform_output":         reflect.TypeOf(DbtPlatformTaskOutput_SdkV2{}),
		"metadata":                    reflect.TypeOf(Run_SdkV2{}),
		"notebook_output":             reflect.TypeOf(NotebookOutput_SdkV2{}),
		"run_job_output":              reflect.TypeOf(RunJobOutput_SdkV2{}),
		"sql_output":                  reflect.TypeOf(SqlOutput_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m RunOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_rooms_notebook_output": m.CleanRoomsNotebookOutput,
			"dashboard_output":            m.DashboardOutput,
			"dbt_cloud_output":            m.DbtCloudOutput,
			"dbt_output":                  m.DbtOutput,
			"dbt_platform_output":         m.DbtPlatformOutput,
			"error":                       m.Error,
			"error_trace":                 m.ErrorTrace,
			"info":                        m.Info,
			"logs":                        m.Logs,
			"logs_truncated":              m.LogsTruncated,
			"metadata":                    m.Metadata,
			"notebook_output":             m.NotebookOutput,
			"run_job_output":              m.RunJobOutput,
			"sql_output":                  m.SqlOutput,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_rooms_notebook_output": basetypes.ListType{
				ElemType: CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2{}.Type(ctx),
			},
			"dashboard_output": basetypes.ListType{
				ElemType: DashboardTaskOutput_SdkV2{}.Type(ctx),
			},
			"dbt_cloud_output": basetypes.ListType{
				ElemType: DbtCloudTaskOutput_SdkV2{}.Type(ctx),
			},
			"dbt_output": basetypes.ListType{
				ElemType: DbtOutput_SdkV2{}.Type(ctx),
			},
			"dbt_platform_output": basetypes.ListType{
				ElemType: DbtPlatformTaskOutput_SdkV2{}.Type(ctx),
			},
			"error":          types.StringType,
			"error_trace":    types.StringType,
			"info":           types.StringType,
			"logs":           types.StringType,
			"logs_truncated": types.BoolType,
			"metadata": basetypes.ListType{
				ElemType: Run_SdkV2{}.Type(ctx),
			},
			"notebook_output": basetypes.ListType{
				ElemType: NotebookOutput_SdkV2{}.Type(ctx),
			},
			"run_job_output": basetypes.ListType{
				ElemType: RunJobOutput_SdkV2{}.Type(ctx),
			},
			"sql_output": basetypes.ListType{
				ElemType: SqlOutput_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCleanRoomsNotebookOutput returns the value of the CleanRoomsNotebookOutput field in RunOutput_SdkV2 as
// a CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetCleanRoomsNotebookOutput(ctx context.Context) (CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2, bool) {
	var e CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2
	if m.CleanRoomsNotebookOutput.IsNull() || m.CleanRoomsNotebookOutput.IsUnknown() {
		return e, false
	}
	var v []CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2
	d := m.CleanRoomsNotebookOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCleanRoomsNotebookOutput sets the value of the CleanRoomsNotebookOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetCleanRoomsNotebookOutput(ctx context.Context, v CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["clean_rooms_notebook_output"]
	m.CleanRoomsNotebookOutput = types.ListValueMust(t, vs)
}

// GetDashboardOutput returns the value of the DashboardOutput field in RunOutput_SdkV2 as
// a DashboardTaskOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetDashboardOutput(ctx context.Context) (DashboardTaskOutput_SdkV2, bool) {
	var e DashboardTaskOutput_SdkV2
	if m.DashboardOutput.IsNull() || m.DashboardOutput.IsUnknown() {
		return e, false
	}
	var v []DashboardTaskOutput_SdkV2
	d := m.DashboardOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDashboardOutput sets the value of the DashboardOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetDashboardOutput(ctx context.Context, v DashboardTaskOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboard_output"]
	m.DashboardOutput = types.ListValueMust(t, vs)
}

// GetDbtCloudOutput returns the value of the DbtCloudOutput field in RunOutput_SdkV2 as
// a DbtCloudTaskOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetDbtCloudOutput(ctx context.Context) (DbtCloudTaskOutput_SdkV2, bool) {
	var e DbtCloudTaskOutput_SdkV2
	if m.DbtCloudOutput.IsNull() || m.DbtCloudOutput.IsUnknown() {
		return e, false
	}
	var v []DbtCloudTaskOutput_SdkV2
	d := m.DbtCloudOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtCloudOutput sets the value of the DbtCloudOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetDbtCloudOutput(ctx context.Context, v DbtCloudTaskOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_cloud_output"]
	m.DbtCloudOutput = types.ListValueMust(t, vs)
}

// GetDbtOutput returns the value of the DbtOutput field in RunOutput_SdkV2 as
// a DbtOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetDbtOutput(ctx context.Context) (DbtOutput_SdkV2, bool) {
	var e DbtOutput_SdkV2
	if m.DbtOutput.IsNull() || m.DbtOutput.IsUnknown() {
		return e, false
	}
	var v []DbtOutput_SdkV2
	d := m.DbtOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtOutput sets the value of the DbtOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetDbtOutput(ctx context.Context, v DbtOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_output"]
	m.DbtOutput = types.ListValueMust(t, vs)
}

// GetDbtPlatformOutput returns the value of the DbtPlatformOutput field in RunOutput_SdkV2 as
// a DbtPlatformTaskOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetDbtPlatformOutput(ctx context.Context) (DbtPlatformTaskOutput_SdkV2, bool) {
	var e DbtPlatformTaskOutput_SdkV2
	if m.DbtPlatformOutput.IsNull() || m.DbtPlatformOutput.IsUnknown() {
		return e, false
	}
	var v []DbtPlatformTaskOutput_SdkV2
	d := m.DbtPlatformOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtPlatformOutput sets the value of the DbtPlatformOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetDbtPlatformOutput(ctx context.Context, v DbtPlatformTaskOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_platform_output"]
	m.DbtPlatformOutput = types.ListValueMust(t, vs)
}

// GetMetadata returns the value of the Metadata field in RunOutput_SdkV2 as
// a Run_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetMetadata(ctx context.Context) (Run_SdkV2, bool) {
	var e Run_SdkV2
	if m.Metadata.IsNull() || m.Metadata.IsUnknown() {
		return e, false
	}
	var v []Run_SdkV2
	d := m.Metadata.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetMetadata sets the value of the Metadata field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetMetadata(ctx context.Context, v Run_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["metadata"]
	m.Metadata = types.ListValueMust(t, vs)
}

// GetNotebookOutput returns the value of the NotebookOutput field in RunOutput_SdkV2 as
// a NotebookOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetNotebookOutput(ctx context.Context) (NotebookOutput_SdkV2, bool) {
	var e NotebookOutput_SdkV2
	if m.NotebookOutput.IsNull() || m.NotebookOutput.IsUnknown() {
		return e, false
	}
	var v []NotebookOutput_SdkV2
	d := m.NotebookOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotebookOutput sets the value of the NotebookOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetNotebookOutput(ctx context.Context, v NotebookOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_output"]
	m.NotebookOutput = types.ListValueMust(t, vs)
}

// GetRunJobOutput returns the value of the RunJobOutput field in RunOutput_SdkV2 as
// a RunJobOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetRunJobOutput(ctx context.Context) (RunJobOutput_SdkV2, bool) {
	var e RunJobOutput_SdkV2
	if m.RunJobOutput.IsNull() || m.RunJobOutput.IsUnknown() {
		return e, false
	}
	var v []RunJobOutput_SdkV2
	d := m.RunJobOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunJobOutput sets the value of the RunJobOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetRunJobOutput(ctx context.Context, v RunJobOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_job_output"]
	m.RunJobOutput = types.ListValueMust(t, vs)
}

// GetSqlOutput returns the value of the SqlOutput field in RunOutput_SdkV2 as
// a SqlOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput_SdkV2) GetSqlOutput(ctx context.Context) (SqlOutput_SdkV2, bool) {
	var e SqlOutput_SdkV2
	if m.SqlOutput.IsNull() || m.SqlOutput.IsUnknown() {
		return e, false
	}
	var v []SqlOutput_SdkV2
	d := m.SqlOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSqlOutput sets the value of the SqlOutput field in RunOutput_SdkV2.
func (m *RunOutput_SdkV2) SetSqlOutput(ctx context.Context, v SqlOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_output"]
	m.SqlOutput = types.ListValueMust(t, vs)
}

type RunParameters_SdkV2 struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.List `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RunParameters_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunParameters_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RunParameters_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunParameters_SdkV2) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RunParameters_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunParameters.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunParameters_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams_SdkV2{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunParameters_SdkV2
// only implements ToObjectValue() and Type().
func (m RunParameters_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":        m.DbtCommands,
			"jar_params":          m.JarParams,
			"notebook_params":     m.NotebookParams,
			"pipeline_params":     m.PipelineParams,
			"python_named_params": m.PythonNamedParams,
			"python_params":       m.PythonParams,
			"spark_submit_params": m.SparkSubmitParams,
			"sql_params":          m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunParameters_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"pipeline_params": basetypes.ListType{
				ElemType: PipelineParams_SdkV2{}.Type(ctx),
			},
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RunParameters_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RunParameters_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RunParameters_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RunParameters_SdkV2 as
// a PipelineParams_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetPipelineParams(ctx context.Context) (PipelineParams_SdkV2, bool) {
	var e PipelineParams_SdkV2
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v []PipelineParams_SdkV2
	d := m.PipelineParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineParams sets the value of the PipelineParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetPipelineParams(ctx context.Context, v PipelineParams_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_params"]
	m.PipelineParams = types.ListValueMust(t, vs)
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RunParameters_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RunParameters_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RunParameters_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RunParameters_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters_SdkV2) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RunParameters_SdkV2.
func (m *RunParameters_SdkV2) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

// The current state of the run.
type RunState_SdkV2 struct {
	// A value indicating the run's current lifecycle state. This field is
	// always available in the response. Note: Additional states might be
	// introduced in future releases.
	LifeCycleState types.String `tfsdk:"life_cycle_state"`
	// The reason indicating why the run was queued.
	QueueReason types.String `tfsdk:"queue_reason"`
	// A value indicating the run's result. This field is only available for
	// terminal lifecycle states. Note: Additional states might be introduced in
	// future releases.
	ResultState types.String `tfsdk:"result_state"`
	// A descriptive message for the current state. This field is unstructured,
	// and its exact format is subject to change.
	StateMessage types.String `tfsdk:"state_message"`
	// A value indicating whether a run was canceled manually by a user or by
	// the scheduler because the run timed out.
	UserCancelledOrTimedout types.Bool `tfsdk:"user_cancelled_or_timedout"`
}

func (to *RunState_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunState_SdkV2) {
}

func (to *RunState_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunState_SdkV2) {
}

func (m RunState_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["life_cycle_state"] = attrs["life_cycle_state"].SetOptional()
	attrs["queue_reason"] = attrs["queue_reason"].SetOptional()
	attrs["result_state"] = attrs["result_state"].SetOptional()
	attrs["state_message"] = attrs["state_message"].SetOptional()
	attrs["user_cancelled_or_timedout"] = attrs["user_cancelled_or_timedout"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunState_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunState_SdkV2
// only implements ToObjectValue() and Type().
func (m RunState_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"life_cycle_state":           m.LifeCycleState,
			"queue_reason":               m.QueueReason,
			"result_state":               m.ResultState,
			"state_message":              m.StateMessage,
			"user_cancelled_or_timedout": m.UserCancelledOrTimedout,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunState_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"life_cycle_state":           types.StringType,
			"queue_reason":               types.StringType,
			"result_state":               types.StringType,
			"state_message":              types.StringType,
			"user_cancelled_or_timedout": types.BoolType,
		},
	}
}

// The current status of the run
type RunStatus_SdkV2 struct {
	// If the run was queued, details about the reason for queuing the run.
	QueueDetails types.List `tfsdk:"queue_details"`

	State types.String `tfsdk:"state"`
	// If the run is in a TERMINATING or TERMINATED state, details about the
	// reason for terminating the run.
	TerminationDetails types.List `tfsdk:"termination_details"`
}

func (to *RunStatus_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunStatus_SdkV2) {
	if !from.QueueDetails.IsNull() && !from.QueueDetails.IsUnknown() {
		if toQueueDetails, ok := to.GetQueueDetails(ctx); ok {
			if fromQueueDetails, ok := from.GetQueueDetails(ctx); ok {
				// Recursively sync the fields of QueueDetails
				toQueueDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromQueueDetails)
				to.SetQueueDetails(ctx, toQueueDetails)
			}
		}
	}
	if !from.TerminationDetails.IsNull() && !from.TerminationDetails.IsUnknown() {
		if toTerminationDetails, ok := to.GetTerminationDetails(ctx); ok {
			if fromTerminationDetails, ok := from.GetTerminationDetails(ctx); ok {
				// Recursively sync the fields of TerminationDetails
				toTerminationDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromTerminationDetails)
				to.SetTerminationDetails(ctx, toTerminationDetails)
			}
		}
	}
}

func (to *RunStatus_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunStatus_SdkV2) {
	if !from.QueueDetails.IsNull() && !from.QueueDetails.IsUnknown() {
		if toQueueDetails, ok := to.GetQueueDetails(ctx); ok {
			if fromQueueDetails, ok := from.GetQueueDetails(ctx); ok {
				toQueueDetails.SyncFieldsDuringRead(ctx, fromQueueDetails)
				to.SetQueueDetails(ctx, toQueueDetails)
			}
		}
	}
	if !from.TerminationDetails.IsNull() && !from.TerminationDetails.IsUnknown() {
		if toTerminationDetails, ok := to.GetTerminationDetails(ctx); ok {
			if fromTerminationDetails, ok := from.GetTerminationDetails(ctx); ok {
				toTerminationDetails.SyncFieldsDuringRead(ctx, fromTerminationDetails)
				to.SetTerminationDetails(ctx, toTerminationDetails)
			}
		}
	}
}

func (m RunStatus_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["queue_details"] = attrs["queue_details"].SetOptional()
	attrs["queue_details"] = attrs["queue_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["state"] = attrs["state"].SetOptional()
	attrs["termination_details"] = attrs["termination_details"].SetOptional()
	attrs["termination_details"] = attrs["termination_details"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunStatus_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"queue_details":       reflect.TypeOf(QueueDetails_SdkV2{}),
		"termination_details": reflect.TypeOf(TerminationDetails_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunStatus_SdkV2
// only implements ToObjectValue() and Type().
func (m RunStatus_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"queue_details":       m.QueueDetails,
			"state":               m.State,
			"termination_details": m.TerminationDetails,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunStatus_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"queue_details": basetypes.ListType{
				ElemType: QueueDetails_SdkV2{}.Type(ctx),
			},
			"state": types.StringType,
			"termination_details": basetypes.ListType{
				ElemType: TerminationDetails_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetQueueDetails returns the value of the QueueDetails field in RunStatus_SdkV2 as
// a QueueDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunStatus_SdkV2) GetQueueDetails(ctx context.Context) (QueueDetails_SdkV2, bool) {
	var e QueueDetails_SdkV2
	if m.QueueDetails.IsNull() || m.QueueDetails.IsUnknown() {
		return e, false
	}
	var v []QueueDetails_SdkV2
	d := m.QueueDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQueueDetails sets the value of the QueueDetails field in RunStatus_SdkV2.
func (m *RunStatus_SdkV2) SetQueueDetails(ctx context.Context, v QueueDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["queue_details"]
	m.QueueDetails = types.ListValueMust(t, vs)
}

// GetTerminationDetails returns the value of the TerminationDetails field in RunStatus_SdkV2 as
// a TerminationDetails_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunStatus_SdkV2) GetTerminationDetails(ctx context.Context) (TerminationDetails_SdkV2, bool) {
	var e TerminationDetails_SdkV2
	if m.TerminationDetails.IsNull() || m.TerminationDetails.IsUnknown() {
		return e, false
	}
	var v []TerminationDetails_SdkV2
	d := m.TerminationDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTerminationDetails sets the value of the TerminationDetails field in RunStatus_SdkV2.
func (m *RunStatus_SdkV2) SetTerminationDetails(ctx context.Context, v TerminationDetails_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["termination_details"]
	m.TerminationDetails = types.ListValueMust(t, vs)
}

// Used when outputting a child run, in GetRun or ListRuns.
type RunTask_SdkV2 struct {
	// The sequence number of this run attempt for a triggered job run. The
	// initial attempt of a run has an attempt_number of 0. If the initial run
	// attempt fails, and the job has a retry policy (`max_retries` > 0),
	// subsequent runs are created with an `original_attempt_run_id` of the
	// original attempt’s ID and an incrementing `attempt_number`. Runs are
	// retried only until they succeed, and the maximum `attempt_number` is the
	// same as the `max_retries` value for the job.
	AttemptNumber types.Int64 `tfsdk:"attempt_number"`
	// The task runs a [clean rooms] notebook when the
	// `clean_rooms_notebook_task` field is present.
	//
	// [clean rooms]: https://docs.databricks.com/clean-rooms/index.html
	CleanRoomsNotebookTask types.List `tfsdk:"clean_rooms_notebook_task"`
	// The time in milliseconds it took to terminate the cluster and clean up
	// any associated artifacts. The duration of a task run is the sum of the
	// `setup_duration`, `execution_duration`, and the `cleanup_duration`. The
	// `cleanup_duration` field is set to 0 for multitask job runs. The total
	// duration of a multitask job run is the value of the `run_duration` field.
	CleanupDuration types.Int64 `tfsdk:"cleanup_duration"`
	// The cluster used for this run. If the run is specified to use a new
	// cluster, this field is set once the Jobs service has requested a cluster
	// for the run.
	ClusterInstance types.List `tfsdk:"cluster_instance"`
	// The task evaluates a condition that can be used to control the execution
	// of other tasks when the `condition_task` field is present. The condition
	// task does not require a cluster to execute and does not support retries
	// or notifications.
	ConditionTask types.List `tfsdk:"condition_task"`
	// The task refreshes a dashboard and sends a snapshot to subscribers.
	DashboardTask types.List `tfsdk:"dashboard_task"`
	// Task type for dbt cloud, deprecated in favor of the new name
	// dbt_platform_task
	DbtCloudTask types.List `tfsdk:"dbt_cloud_task"`

	DbtPlatformTask types.List `tfsdk:"dbt_platform_task"`
	// The task runs one or more dbt commands when the `dbt_task` field is
	// present. The dbt task requires both Databricks SQL and the ability to use
	// a serverless or a pro SQL warehouse.
	DbtTask types.List `tfsdk:"dbt_task"`
	// An optional array of objects specifying the dependency graph of the task.
	// All tasks specified in this field must complete successfully before
	// executing this task. The key is `task_key`, and the value is the name
	// assigned to the dependent task.
	DependsOn types.List `tfsdk:"depends_on"`
	// An optional description for this task.
	Description types.String `tfsdk:"description"`
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// An optional set of email addresses notified when the task run begins or
	// completes. The default behavior is to not send any emails.
	EmailNotifications types.List `tfsdk:"email_notifications"`
	// The time at which this run ended in epoch milliseconds (milliseconds
	// since 1/1/1970 UTC). This field is set to 0 if the job is still running.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The key that references an environment spec in a job. This field is
	// required for Python script, Python wheel and dbt tasks when using
	// serverless compute.
	EnvironmentKey types.String `tfsdk:"environment_key"`
	// The time in milliseconds it took to execute the commands in the JAR or
	// notebook until they completed, failed, timed out, were cancelled, or
	// encountered an unexpected error. The duration of a task run is the sum of
	// the `setup_duration`, `execution_duration`, and the `cleanup_duration`.
	// The `execution_duration` field is set to 0 for multitask job runs. The
	// total duration of a multitask job run is the value of the `run_duration`
	// field.
	ExecutionDuration types.Int64 `tfsdk:"execution_duration"`
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// The task executes a nested task for every input provided when the
	// `for_each_task` field is present.
	ForEachTask types.List `tfsdk:"for_each_task"`

	GenAiComputeTask types.List `tfsdk:"gen_ai_compute_task"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks. If `git_source` is set,
	// these tasks retrieve the file from the remote repository by default.
	// However, this behavior can be overridden by setting `source` to
	// `WORKSPACE` on the task. Note: dbt and SQL File tasks support only
	// version-controlled sources. If dbt or SQL File tasks are used,
	// `git_source` must be defined on the job.
	GitSource types.List `tfsdk:"git_source"`
	// If job_cluster_key, this task is executed reusing the cluster specified
	// in `job.settings.job_clusters`.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.List `tfsdk:"new_cluster"`
	// The task runs a notebook when the `notebook_task` field is present.
	NotebookTask types.List `tfsdk:"notebook_task"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// task run.
	NotificationSettings types.List `tfsdk:"notification_settings"`
	// The task triggers a pipeline update when the `pipeline_task` field is
	// present. Only pipelines configured to use triggered more are supported.
	PipelineTask types.List `tfsdk:"pipeline_task"`
	// The task triggers a Power BI semantic model update when the
	// `power_bi_task` field is present.
	PowerBiTask types.List `tfsdk:"power_bi_task"`
	// The task runs a Python wheel when the `python_wheel_task` field is
	// present.
	PythonWheelTask types.List `tfsdk:"python_wheel_task"`
	// The time in milliseconds that the run has spent in the queue.
	QueueDuration types.Int64 `tfsdk:"queue_duration"`
	// Parameter values including resolved references
	ResolvedValues types.List `tfsdk:"resolved_values"`
	// The time in milliseconds it took the job run and all of its repairs to
	// finish.
	RunDuration types.Int64 `tfsdk:"run_duration"`
	// The ID of the task run.
	RunId types.Int64 `tfsdk:"run_id"`
	// An optional value indicating the condition that determines whether the
	// task should be run once its dependencies have been completed. When
	// omitted, defaults to `ALL_SUCCESS`. See :method:jobs/create for a list of
	// possible values.
	RunIf types.String `tfsdk:"run_if"`
	// The task triggers another job when the `run_job_task` field is present.
	RunJobTask types.List `tfsdk:"run_job_task"`

	RunPageUrl types.String `tfsdk:"run_page_url"`
	// The time in milliseconds it took to set up the cluster. For runs that run
	// on new clusters this is the cluster creation time, for runs that run on
	// existing clusters this time should be very short. The duration of a task
	// run is the sum of the `setup_duration`, `execution_duration`, and the
	// `cleanup_duration`. The `setup_duration` field is set to 0 for multitask
	// job runs. The total duration of a multitask job run is the value of the
	// `run_duration` field.
	SetupDuration types.Int64 `tfsdk:"setup_duration"`
	// The task runs a JAR when the `spark_jar_task` field is present.
	SparkJarTask types.List `tfsdk:"spark_jar_task"`
	// The task runs a Python file when the `spark_python_task` field is
	// present.
	SparkPythonTask types.List `tfsdk:"spark_python_task"`
	// (Legacy) The task runs the spark-submit script when the spark_submit_task
	// field is present. Databricks recommends using the spark_jar_task instead;
	// see [Spark Submit task for jobs](/jobs/spark-submit).
	SparkSubmitTask types.List `tfsdk:"spark_submit_task"`
	// The task runs a SQL query or file, or it refreshes a SQL alert or a
	// legacy SQL dashboard when the `sql_task` field is present.
	SqlTask types.List `tfsdk:"sql_task"`
	// The time at which this run was started in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC). This may not be the time when the job
	// task starts executing, for example, if the job is scheduled to run on a
	// new cluster, this is the time the cluster creation call is issued.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.List `tfsdk:"state"`

	Status types.List `tfsdk:"status"`
	// A unique name for the task. This field is used to refer to this task from
	// other tasks. This field is required and must be unique within its parent
	// job. On Update or Reset, this field is used to reference the tasks to be
	// updated or reset.
	TaskKey types.String `tfsdk:"task_key"`
	// An optional timeout applied to each run of this job task. A value of `0`
	// means no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A collection of system notification IDs to notify when the run begins or
	// completes. The default behavior is to not send any system notifications.
	// Task webhooks respect the task notification settings.
	WebhookNotifications types.List `tfsdk:"webhook_notifications"`
}

func (to *RunTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunTask_SdkV2) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookTask
				toCleanRoomsNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				// Recursively sync the fields of ClusterInstance
				toClusterInstance.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				// Recursively sync the fields of DashboardTask
				toDashboardTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				// Recursively sync the fields of DbtCloudTask
				toDbtCloudTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				// Recursively sync the fields of DbtPlatformTask
				toDbtPlatformTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				// Recursively sync the fields of ForEachTask
				toForEachTask.SyncFieldsDuringCreateOrUpdate(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				// Recursively sync the fields of GenAiComputeTask
				toGenAiComputeTask.SyncFieldsDuringCreateOrUpdate(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				// Recursively sync the fields of PipelineTask
				toPipelineTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				// Recursively sync the fields of PowerBiTask
				toPowerBiTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.ResolvedValues.IsNull() && !from.ResolvedValues.IsUnknown() {
		if toResolvedValues, ok := to.GetResolvedValues(ctx); ok {
			if fromResolvedValues, ok := from.GetResolvedValues(ctx); ok {
				// Recursively sync the fields of ResolvedValues
				toResolvedValues.SyncFieldsDuringCreateOrUpdate(ctx, fromResolvedValues)
				to.SetResolvedValues(ctx, toResolvedValues)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *RunTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RunTask_SdkV2) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				toCleanRoomsNotebookTask.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				toClusterInstance.SyncFieldsDuringRead(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				toDashboardTask.SyncFieldsDuringRead(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				toDbtCloudTask.SyncFieldsDuringRead(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				toDbtPlatformTask.SyncFieldsDuringRead(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				toForEachTask.SyncFieldsDuringRead(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				toGenAiComputeTask.SyncFieldsDuringRead(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				toPipelineTask.SyncFieldsDuringRead(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				toPowerBiTask.SyncFieldsDuringRead(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.ResolvedValues.IsNull() && !from.ResolvedValues.IsUnknown() {
		if toResolvedValues, ok := to.GetResolvedValues(ctx); ok {
			if fromResolvedValues, ok := from.GetResolvedValues(ctx); ok {
				toResolvedValues.SyncFieldsDuringRead(ctx, fromResolvedValues)
				to.SetResolvedValues(ctx, toResolvedValues)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m RunTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attempt_number"] = attrs["attempt_number"].SetOptional()
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].SetOptional()
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["cleanup_duration"] = attrs["cleanup_duration"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dashboard_task"] = attrs["dashboard_task"].SetOptional()
	attrs["dashboard_task"] = attrs["dashboard_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].SetOptional()
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].SetOptional()
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["depends_on"] = attrs["depends_on"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetComputed()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["environment_key"] = attrs["environment_key"].SetOptional()
	attrs["execution_duration"] = attrs["execution_duration"].SetOptional()
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].SetOptional()
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["git_source"] = attrs["git_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["pipeline_task"] = attrs["pipeline_task"].SetOptional()
	attrs["pipeline_task"] = attrs["pipeline_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["power_bi_task"] = attrs["power_bi_task"].SetOptional()
	attrs["power_bi_task"] = attrs["power_bi_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["queue_duration"] = attrs["queue_duration"].SetOptional()
	attrs["resolved_values"] = attrs["resolved_values"].SetOptional()
	attrs["resolved_values"] = attrs["resolved_values"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_duration"] = attrs["run_duration"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_if"] = attrs["run_if"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_page_url"] = attrs["run_page_url"].SetOptional()
	attrs["setup_duration"] = attrs["setup_duration"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["state"] = attrs["state"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["status"] = attrs["status"].SetOptional()
	attrs["status"] = attrs["status"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["task_key"] = attrs["task_key"].SetRequired()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_task": reflect.TypeOf(CleanRoomsNotebookTask_SdkV2{}),
		"cluster_instance":          reflect.TypeOf(ClusterInstance_SdkV2{}),
		"condition_task":            reflect.TypeOf(RunConditionTask_SdkV2{}),
		"dashboard_task":            reflect.TypeOf(DashboardTask_SdkV2{}),
		"dbt_cloud_task":            reflect.TypeOf(DbtCloudTask_SdkV2{}),
		"dbt_platform_task":         reflect.TypeOf(DbtPlatformTask_SdkV2{}),
		"dbt_task":                  reflect.TypeOf(DbtTask_SdkV2{}),
		"depends_on":                reflect.TypeOf(TaskDependency_SdkV2{}),
		"email_notifications":       reflect.TypeOf(JobEmailNotifications_SdkV2{}),
		"for_each_task":             reflect.TypeOf(RunForEachTask_SdkV2{}),
		"gen_ai_compute_task":       reflect.TypeOf(GenAiComputeTask_SdkV2{}),
		"git_source":                reflect.TypeOf(GitSource_SdkV2{}),
		"library":                   reflect.TypeOf(compute_tf.Library_SdkV2{}),
		"new_cluster":               reflect.TypeOf(compute_tf.ClusterSpec_SdkV2{}),
		"notebook_task":             reflect.TypeOf(NotebookTask_SdkV2{}),
		"notification_settings":     reflect.TypeOf(TaskNotificationSettings_SdkV2{}),
		"pipeline_task":             reflect.TypeOf(PipelineTask_SdkV2{}),
		"power_bi_task":             reflect.TypeOf(PowerBiTask_SdkV2{}),
		"python_wheel_task":         reflect.TypeOf(PythonWheelTask_SdkV2{}),
		"resolved_values":           reflect.TypeOf(ResolvedValues_SdkV2{}),
		"run_job_task":              reflect.TypeOf(RunJobTask_SdkV2{}),
		"spark_jar_task":            reflect.TypeOf(SparkJarTask_SdkV2{}),
		"spark_python_task":         reflect.TypeOf(SparkPythonTask_SdkV2{}),
		"spark_submit_task":         reflect.TypeOf(SparkSubmitTask_SdkV2{}),
		"sql_task":                  reflect.TypeOf(SqlTask_SdkV2{}),
		"state":                     reflect.TypeOf(RunState_SdkV2{}),
		"status":                    reflect.TypeOf(RunStatus_SdkV2{}),
		"webhook_notifications":     reflect.TypeOf(WebhookNotifications_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunTask_SdkV2
// only implements ToObjectValue() and Type().
func (m RunTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attempt_number":               m.AttemptNumber,
			"clean_rooms_notebook_task":    m.CleanRoomsNotebookTask,
			"cleanup_duration":             m.CleanupDuration,
			"cluster_instance":             m.ClusterInstance,
			"condition_task":               m.ConditionTask,
			"dashboard_task":               m.DashboardTask,
			"dbt_cloud_task":               m.DbtCloudTask,
			"dbt_platform_task":            m.DbtPlatformTask,
			"dbt_task":                     m.DbtTask,
			"depends_on":                   m.DependsOn,
			"description":                  m.Description,
			"effective_performance_target": m.EffectivePerformanceTarget,
			"email_notifications":          m.EmailNotifications,
			"end_time":                     m.EndTime,
			"environment_key":              m.EnvironmentKey,
			"execution_duration":           m.ExecutionDuration,
			"existing_cluster_id":          m.ExistingClusterId,
			"for_each_task":                m.ForEachTask,
			"gen_ai_compute_task":          m.GenAiComputeTask,
			"git_source":                   m.GitSource,
			"job_cluster_key":              m.JobClusterKey,
			"library":                      m.Libraries,
			"new_cluster":                  m.NewCluster,
			"notebook_task":                m.NotebookTask,
			"notification_settings":        m.NotificationSettings,
			"pipeline_task":                m.PipelineTask,
			"power_bi_task":                m.PowerBiTask,
			"python_wheel_task":            m.PythonWheelTask,
			"queue_duration":               m.QueueDuration,
			"resolved_values":              m.ResolvedValues,
			"run_duration":                 m.RunDuration,
			"run_id":                       m.RunId,
			"run_if":                       m.RunIf,
			"run_job_task":                 m.RunJobTask,
			"run_page_url":                 m.RunPageUrl,
			"setup_duration":               m.SetupDuration,
			"spark_jar_task":               m.SparkJarTask,
			"spark_python_task":            m.SparkPythonTask,
			"spark_submit_task":            m.SparkSubmitTask,
			"sql_task":                     m.SqlTask,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"task_key":                     m.TaskKey,
			"timeout_seconds":              m.TimeoutSeconds,
			"webhook_notifications":        m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attempt_number": types.Int64Type,
			"clean_rooms_notebook_task": basetypes.ListType{
				ElemType: CleanRoomsNotebookTask_SdkV2{}.Type(ctx),
			},
			"cleanup_duration": types.Int64Type,
			"cluster_instance": basetypes.ListType{
				ElemType: ClusterInstance_SdkV2{}.Type(ctx),
			},
			"condition_task": basetypes.ListType{
				ElemType: RunConditionTask_SdkV2{}.Type(ctx),
			},
			"dashboard_task": basetypes.ListType{
				ElemType: DashboardTask_SdkV2{}.Type(ctx),
			},
			"dbt_cloud_task": basetypes.ListType{
				ElemType: DbtCloudTask_SdkV2{}.Type(ctx),
			},
			"dbt_platform_task": basetypes.ListType{
				ElemType: DbtPlatformTask_SdkV2{}.Type(ctx),
			},
			"dbt_task": basetypes.ListType{
				ElemType: DbtTask_SdkV2{}.Type(ctx),
			},
			"depends_on": basetypes.ListType{
				ElemType: TaskDependency_SdkV2{}.Type(ctx),
			},
			"description":                  types.StringType,
			"effective_performance_target": types.StringType,
			"email_notifications": basetypes.ListType{
				ElemType: JobEmailNotifications_SdkV2{}.Type(ctx),
			},
			"end_time":            types.Int64Type,
			"environment_key":     types.StringType,
			"execution_duration":  types.Int64Type,
			"existing_cluster_id": types.StringType,
			"for_each_task": basetypes.ListType{
				ElemType: RunForEachTask_SdkV2{}.Type(ctx),
			},
			"gen_ai_compute_task": basetypes.ListType{
				ElemType: GenAiComputeTask_SdkV2{}.Type(ctx),
			},
			"git_source": basetypes.ListType{
				ElemType: GitSource_SdkV2{}.Type(ctx),
			},
			"job_cluster_key": types.StringType,
			"library": basetypes.ListType{
				ElemType: compute_tf.Library_SdkV2{}.Type(ctx),
			},
			"new_cluster": basetypes.ListType{
				ElemType: compute_tf.ClusterSpec_SdkV2{}.Type(ctx),
			},
			"notebook_task": basetypes.ListType{
				ElemType: NotebookTask_SdkV2{}.Type(ctx),
			},
			"notification_settings": basetypes.ListType{
				ElemType: TaskNotificationSettings_SdkV2{}.Type(ctx),
			},
			"pipeline_task": basetypes.ListType{
				ElemType: PipelineTask_SdkV2{}.Type(ctx),
			},
			"power_bi_task": basetypes.ListType{
				ElemType: PowerBiTask_SdkV2{}.Type(ctx),
			},
			"python_wheel_task": basetypes.ListType{
				ElemType: PythonWheelTask_SdkV2{}.Type(ctx),
			},
			"queue_duration": types.Int64Type,
			"resolved_values": basetypes.ListType{
				ElemType: ResolvedValues_SdkV2{}.Type(ctx),
			},
			"run_duration": types.Int64Type,
			"run_id":       types.Int64Type,
			"run_if":       types.StringType,
			"run_job_task": basetypes.ListType{
				ElemType: RunJobTask_SdkV2{}.Type(ctx),
			},
			"run_page_url":   types.StringType,
			"setup_duration": types.Int64Type,
			"spark_jar_task": basetypes.ListType{
				ElemType: SparkJarTask_SdkV2{}.Type(ctx),
			},
			"spark_python_task": basetypes.ListType{
				ElemType: SparkPythonTask_SdkV2{}.Type(ctx),
			},
			"spark_submit_task": basetypes.ListType{
				ElemType: SparkSubmitTask_SdkV2{}.Type(ctx),
			},
			"sql_task": basetypes.ListType{
				ElemType: SqlTask_SdkV2{}.Type(ctx),
			},
			"start_time": types.Int64Type,
			"state": basetypes.ListType{
				ElemType: RunState_SdkV2{}.Type(ctx),
			},
			"status": basetypes.ListType{
				ElemType: RunStatus_SdkV2{}.Type(ctx),
			},
			"task_key":        types.StringType,
			"timeout_seconds": types.Int64Type,
			"webhook_notifications": basetypes.ListType{
				ElemType: WebhookNotifications_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCleanRoomsNotebookTask returns the value of the CleanRoomsNotebookTask field in RunTask_SdkV2 as
// a CleanRoomsNotebookTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetCleanRoomsNotebookTask(ctx context.Context) (CleanRoomsNotebookTask_SdkV2, bool) {
	var e CleanRoomsNotebookTask_SdkV2
	if m.CleanRoomsNotebookTask.IsNull() || m.CleanRoomsNotebookTask.IsUnknown() {
		return e, false
	}
	var v []CleanRoomsNotebookTask_SdkV2
	d := m.CleanRoomsNotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCleanRoomsNotebookTask sets the value of the CleanRoomsNotebookTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetCleanRoomsNotebookTask(ctx context.Context, v CleanRoomsNotebookTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["clean_rooms_notebook_task"]
	m.CleanRoomsNotebookTask = types.ListValueMust(t, vs)
}

// GetClusterInstance returns the value of the ClusterInstance field in RunTask_SdkV2 as
// a ClusterInstance_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetClusterInstance(ctx context.Context) (ClusterInstance_SdkV2, bool) {
	var e ClusterInstance_SdkV2
	if m.ClusterInstance.IsNull() || m.ClusterInstance.IsUnknown() {
		return e, false
	}
	var v []ClusterInstance_SdkV2
	d := m.ClusterInstance.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetClusterInstance sets the value of the ClusterInstance field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetClusterInstance(ctx context.Context, v ClusterInstance_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["cluster_instance"]
	m.ClusterInstance = types.ListValueMust(t, vs)
}

// GetConditionTask returns the value of the ConditionTask field in RunTask_SdkV2 as
// a RunConditionTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetConditionTask(ctx context.Context) (RunConditionTask_SdkV2, bool) {
	var e RunConditionTask_SdkV2
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v []RunConditionTask_SdkV2
	d := m.ConditionTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetConditionTask sets the value of the ConditionTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetConditionTask(ctx context.Context, v RunConditionTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["condition_task"]
	m.ConditionTask = types.ListValueMust(t, vs)
}

// GetDashboardTask returns the value of the DashboardTask field in RunTask_SdkV2 as
// a DashboardTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetDashboardTask(ctx context.Context) (DashboardTask_SdkV2, bool) {
	var e DashboardTask_SdkV2
	if m.DashboardTask.IsNull() || m.DashboardTask.IsUnknown() {
		return e, false
	}
	var v []DashboardTask_SdkV2
	d := m.DashboardTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDashboardTask sets the value of the DashboardTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetDashboardTask(ctx context.Context, v DashboardTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboard_task"]
	m.DashboardTask = types.ListValueMust(t, vs)
}

// GetDbtCloudTask returns the value of the DbtCloudTask field in RunTask_SdkV2 as
// a DbtCloudTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetDbtCloudTask(ctx context.Context) (DbtCloudTask_SdkV2, bool) {
	var e DbtCloudTask_SdkV2
	if m.DbtCloudTask.IsNull() || m.DbtCloudTask.IsUnknown() {
		return e, false
	}
	var v []DbtCloudTask_SdkV2
	d := m.DbtCloudTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtCloudTask sets the value of the DbtCloudTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetDbtCloudTask(ctx context.Context, v DbtCloudTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_cloud_task"]
	m.DbtCloudTask = types.ListValueMust(t, vs)
}

// GetDbtPlatformTask returns the value of the DbtPlatformTask field in RunTask_SdkV2 as
// a DbtPlatformTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetDbtPlatformTask(ctx context.Context) (DbtPlatformTask_SdkV2, bool) {
	var e DbtPlatformTask_SdkV2
	if m.DbtPlatformTask.IsNull() || m.DbtPlatformTask.IsUnknown() {
		return e, false
	}
	var v []DbtPlatformTask_SdkV2
	d := m.DbtPlatformTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtPlatformTask sets the value of the DbtPlatformTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetDbtPlatformTask(ctx context.Context, v DbtPlatformTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_platform_task"]
	m.DbtPlatformTask = types.ListValueMust(t, vs)
}

// GetDbtTask returns the value of the DbtTask field in RunTask_SdkV2 as
// a DbtTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetDbtTask(ctx context.Context) (DbtTask_SdkV2, bool) {
	var e DbtTask_SdkV2
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v []DbtTask_SdkV2
	d := m.DbtTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtTask sets the value of the DbtTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetDbtTask(ctx context.Context, v DbtTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_task"]
	m.DbtTask = types.ListValueMust(t, vs)
}

// GetDependsOn returns the value of the DependsOn field in RunTask_SdkV2 as
// a slice of TaskDependency_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetDependsOn(ctx context.Context) ([]TaskDependency_SdkV2, bool) {
	if m.DependsOn.IsNull() || m.DependsOn.IsUnknown() {
		return nil, false
	}
	var v []TaskDependency_SdkV2
	d := m.DependsOn.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependsOn sets the value of the DependsOn field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetDependsOn(ctx context.Context, v []TaskDependency_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["depends_on"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DependsOn = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in RunTask_SdkV2 as
// a JobEmailNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetEmailNotifications(ctx context.Context) (JobEmailNotifications_SdkV2, bool) {
	var e JobEmailNotifications_SdkV2
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v []JobEmailNotifications_SdkV2
	d := m.EmailNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEmailNotifications sets the value of the EmailNotifications field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetEmailNotifications(ctx context.Context, v JobEmailNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_notifications"]
	m.EmailNotifications = types.ListValueMust(t, vs)
}

// GetForEachTask returns the value of the ForEachTask field in RunTask_SdkV2 as
// a RunForEachTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetForEachTask(ctx context.Context) (RunForEachTask_SdkV2, bool) {
	var e RunForEachTask_SdkV2
	if m.ForEachTask.IsNull() || m.ForEachTask.IsUnknown() {
		return e, false
	}
	var v []RunForEachTask_SdkV2
	d := m.ForEachTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetForEachTask sets the value of the ForEachTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetForEachTask(ctx context.Context, v RunForEachTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["for_each_task"]
	m.ForEachTask = types.ListValueMust(t, vs)
}

// GetGenAiComputeTask returns the value of the GenAiComputeTask field in RunTask_SdkV2 as
// a GenAiComputeTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetGenAiComputeTask(ctx context.Context) (GenAiComputeTask_SdkV2, bool) {
	var e GenAiComputeTask_SdkV2
	if m.GenAiComputeTask.IsNull() || m.GenAiComputeTask.IsUnknown() {
		return e, false
	}
	var v []GenAiComputeTask_SdkV2
	d := m.GenAiComputeTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGenAiComputeTask sets the value of the GenAiComputeTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetGenAiComputeTask(ctx context.Context, v GenAiComputeTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gen_ai_compute_task"]
	m.GenAiComputeTask = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in RunTask_SdkV2 as
// a GitSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetGitSource(ctx context.Context) (GitSource_SdkV2, bool) {
	var e GitSource_SdkV2
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v []GitSource_SdkV2
	d := m.GitSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSource sets the value of the GitSource field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetGitSource(ctx context.Context, v GitSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_source"]
	m.GitSource = types.ListValueMust(t, vs)
}

// GetLibraries returns the value of the Libraries field in RunTask_SdkV2 as
// a slice of compute_tf.Library_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetLibraries(ctx context.Context) ([]compute_tf.Library_SdkV2, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library_SdkV2
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetLibraries(ctx context.Context, v []compute_tf.Library_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in RunTask_SdkV2 as
// a compute_tf.ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec_SdkV2, bool) {
	var e compute_tf.ClusterSpec_SdkV2
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v []compute_tf.ClusterSpec_SdkV2
	d := m.NewCluster.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewCluster sets the value of the NewCluster field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_cluster"]
	m.NewCluster = types.ListValueMust(t, vs)
}

// GetNotebookTask returns the value of the NotebookTask field in RunTask_SdkV2 as
// a NotebookTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetNotebookTask(ctx context.Context) (NotebookTask_SdkV2, bool) {
	var e NotebookTask_SdkV2
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v []NotebookTask_SdkV2
	d := m.NotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotebookTask sets the value of the NotebookTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetNotebookTask(ctx context.Context, v NotebookTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_task"]
	m.NotebookTask = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in RunTask_SdkV2 as
// a TaskNotificationSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetNotificationSettings(ctx context.Context) (TaskNotificationSettings_SdkV2, bool) {
	var e TaskNotificationSettings_SdkV2
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v []TaskNotificationSettings_SdkV2
	d := m.NotificationSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotificationSettings sets the value of the NotificationSettings field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetNotificationSettings(ctx context.Context, v TaskNotificationSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notification_settings"]
	m.NotificationSettings = types.ListValueMust(t, vs)
}

// GetPipelineTask returns the value of the PipelineTask field in RunTask_SdkV2 as
// a PipelineTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetPipelineTask(ctx context.Context) (PipelineTask_SdkV2, bool) {
	var e PipelineTask_SdkV2
	if m.PipelineTask.IsNull() || m.PipelineTask.IsUnknown() {
		return e, false
	}
	var v []PipelineTask_SdkV2
	d := m.PipelineTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineTask sets the value of the PipelineTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetPipelineTask(ctx context.Context, v PipelineTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_task"]
	m.PipelineTask = types.ListValueMust(t, vs)
}

// GetPowerBiTask returns the value of the PowerBiTask field in RunTask_SdkV2 as
// a PowerBiTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetPowerBiTask(ctx context.Context) (PowerBiTask_SdkV2, bool) {
	var e PowerBiTask_SdkV2
	if m.PowerBiTask.IsNull() || m.PowerBiTask.IsUnknown() {
		return e, false
	}
	var v []PowerBiTask_SdkV2
	d := m.PowerBiTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPowerBiTask sets the value of the PowerBiTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetPowerBiTask(ctx context.Context, v PowerBiTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["power_bi_task"]
	m.PowerBiTask = types.ListValueMust(t, vs)
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in RunTask_SdkV2 as
// a PythonWheelTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetPythonWheelTask(ctx context.Context) (PythonWheelTask_SdkV2, bool) {
	var e PythonWheelTask_SdkV2
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v []PythonWheelTask_SdkV2
	d := m.PythonWheelTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetPythonWheelTask(ctx context.Context, v PythonWheelTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_wheel_task"]
	m.PythonWheelTask = types.ListValueMust(t, vs)
}

// GetResolvedValues returns the value of the ResolvedValues field in RunTask_SdkV2 as
// a ResolvedValues_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetResolvedValues(ctx context.Context) (ResolvedValues_SdkV2, bool) {
	var e ResolvedValues_SdkV2
	if m.ResolvedValues.IsNull() || m.ResolvedValues.IsUnknown() {
		return e, false
	}
	var v []ResolvedValues_SdkV2
	d := m.ResolvedValues.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetResolvedValues sets the value of the ResolvedValues field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetResolvedValues(ctx context.Context, v ResolvedValues_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["resolved_values"]
	m.ResolvedValues = types.ListValueMust(t, vs)
}

// GetRunJobTask returns the value of the RunJobTask field in RunTask_SdkV2 as
// a RunJobTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetRunJobTask(ctx context.Context) (RunJobTask_SdkV2, bool) {
	var e RunJobTask_SdkV2
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v []RunJobTask_SdkV2
	d := m.RunJobTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunJobTask sets the value of the RunJobTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetRunJobTask(ctx context.Context, v RunJobTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_job_task"]
	m.RunJobTask = types.ListValueMust(t, vs)
}

// GetSparkJarTask returns the value of the SparkJarTask field in RunTask_SdkV2 as
// a SparkJarTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetSparkJarTask(ctx context.Context) (SparkJarTask_SdkV2, bool) {
	var e SparkJarTask_SdkV2
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v []SparkJarTask_SdkV2
	d := m.SparkJarTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkJarTask sets the value of the SparkJarTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetSparkJarTask(ctx context.Context, v SparkJarTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_jar_task"]
	m.SparkJarTask = types.ListValueMust(t, vs)
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in RunTask_SdkV2 as
// a SparkPythonTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetSparkPythonTask(ctx context.Context) (SparkPythonTask_SdkV2, bool) {
	var e SparkPythonTask_SdkV2
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v []SparkPythonTask_SdkV2
	d := m.SparkPythonTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetSparkPythonTask(ctx context.Context, v SparkPythonTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_python_task"]
	m.SparkPythonTask = types.ListValueMust(t, vs)
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in RunTask_SdkV2 as
// a SparkSubmitTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetSparkSubmitTask(ctx context.Context) (SparkSubmitTask_SdkV2, bool) {
	var e SparkSubmitTask_SdkV2
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v []SparkSubmitTask_SdkV2
	d := m.SparkSubmitTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetSparkSubmitTask(ctx context.Context, v SparkSubmitTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_task"]
	m.SparkSubmitTask = types.ListValueMust(t, vs)
}

// GetSqlTask returns the value of the SqlTask field in RunTask_SdkV2 as
// a SqlTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetSqlTask(ctx context.Context) (SqlTask_SdkV2, bool) {
	var e SqlTask_SdkV2
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v []SqlTask_SdkV2
	d := m.SqlTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSqlTask sets the value of the SqlTask field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetSqlTask(ctx context.Context, v SqlTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_task"]
	m.SqlTask = types.ListValueMust(t, vs)
}

// GetState returns the value of the State field in RunTask_SdkV2 as
// a RunState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetState(ctx context.Context) (RunState_SdkV2, bool) {
	var e RunState_SdkV2
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v []RunState_SdkV2
	d := m.State.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetState sets the value of the State field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetState(ctx context.Context, v RunState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["state"]
	m.State = types.ListValueMust(t, vs)
}

// GetStatus returns the value of the Status field in RunTask_SdkV2 as
// a RunStatus_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetStatus(ctx context.Context) (RunStatus_SdkV2, bool) {
	var e RunStatus_SdkV2
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v []RunStatus_SdkV2
	d := m.Status.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetStatus sets the value of the Status field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetStatus(ctx context.Context, v RunStatus_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["status"]
	m.Status = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in RunTask_SdkV2 as
// a WebhookNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask_SdkV2) GetWebhookNotifications(ctx context.Context) (WebhookNotifications_SdkV2, bool) {
	var e WebhookNotifications_SdkV2
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v []WebhookNotifications_SdkV2
	d := m.WebhookNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in RunTask_SdkV2.
func (m *RunTask_SdkV2) SetWebhookNotifications(ctx context.Context, v WebhookNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["webhook_notifications"]
	m.WebhookNotifications = types.ListValueMust(t, vs)
}

type SparkJarTask_SdkV2 struct {
	// Deprecated since 04/2016. Provide a `jar` through the `libraries` field
	// instead. For an example, see :method:jobs/create.
	JarUri types.String `tfsdk:"jar_uri"`
	// The full name of the class containing the main method to be executed.
	// This class must be contained in a JAR provided as a library.
	//
	// The code must use `SparkContext.getOrCreate` to obtain a Spark context;
	// otherwise, runs of the job fail.
	MainClassName types.String `tfsdk:"main_class_name"`
	// Parameters passed to the main method.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	Parameters types.List `tfsdk:"parameters"`
	// Deprecated. A value of `false` is no longer supported.
	RunAsRepl types.Bool `tfsdk:"run_as_repl"`
}

func (to *SparkJarTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SparkJarTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *SparkJarTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SparkJarTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m SparkJarTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["jar_uri"] = attrs["jar_uri"].SetOptional()
	attrs["main_class_name"] = attrs["main_class_name"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()
	attrs["run_as_repl"] = attrs["run_as_repl"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SparkJarTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SparkJarTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SparkJarTask_SdkV2
// only implements ToObjectValue() and Type().
func (m SparkJarTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"jar_uri":         m.JarUri,
			"main_class_name": m.MainClassName,
			"parameters":      m.Parameters,
			"run_as_repl":     m.RunAsRepl,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SparkJarTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"jar_uri":         types.StringType,
			"main_class_name": types.StringType,
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"run_as_repl": types.BoolType,
		},
	}
}

// GetParameters returns the value of the Parameters field in SparkJarTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SparkJarTask_SdkV2) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SparkJarTask_SdkV2.
func (m *SparkJarTask_SdkV2) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type SparkPythonTask_SdkV2 struct {
	// Command line parameters passed to the Python file.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	Parameters types.List `tfsdk:"parameters"`
	// The Python file to be executed. Cloud file URIs (such as dbfs:/, s3:/,
	// adls:/, gcs:/) and workspace paths are supported. For python files stored
	// in the Databricks workspace, the path must be absolute and begin with
	// `/`. For files stored in a remote repository, the path must be relative.
	// This field is required.
	PythonFile types.String `tfsdk:"python_file"`
	// Optional location type of the Python file. When set to `WORKSPACE` or not
	// specified, the file will be retrieved from the local Databricks workspace
	// or cloud location (if the `python_file` has a URI format). When set to
	// `GIT`, the Python file will be retrieved from a Git repository defined in
	// `git_source`.
	//
	// * `WORKSPACE`: The Python file is located in a Databricks workspace or at
	// a cloud filesystem URI. * `GIT`: The Python file is located in a remote
	// Git repository.
	Source types.String `tfsdk:"source"`
}

func (to *SparkPythonTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SparkPythonTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *SparkPythonTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SparkPythonTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m SparkPythonTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()
	attrs["python_file"] = attrs["python_file"].SetRequired()
	attrs["source"] = attrs["source"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SparkPythonTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SparkPythonTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SparkPythonTask_SdkV2
// only implements ToObjectValue() and Type().
func (m SparkPythonTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters":  m.Parameters,
			"python_file": m.PythonFile,
			"source":      m.Source,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SparkPythonTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"python_file": types.StringType,
			"source":      types.StringType,
		},
	}
}

// GetParameters returns the value of the Parameters field in SparkPythonTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SparkPythonTask_SdkV2) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SparkPythonTask_SdkV2.
func (m *SparkPythonTask_SdkV2) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type SparkSubmitTask_SdkV2 struct {
	// Command-line parameters passed to spark submit.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	Parameters types.List `tfsdk:"parameters"`
}

func (to *SparkSubmitTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SparkSubmitTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *SparkSubmitTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SparkSubmitTask_SdkV2) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m SparkSubmitTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SparkSubmitTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SparkSubmitTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SparkSubmitTask_SdkV2
// only implements ToObjectValue() and Type().
func (m SparkSubmitTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SparkSubmitTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in SparkSubmitTask_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SparkSubmitTask_SdkV2) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SparkSubmitTask_SdkV2.
func (m *SparkSubmitTask_SdkV2) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type SqlAlertOutput_SdkV2 struct {
	AlertState types.String `tfsdk:"alert_state"`
	// The link to find the output results.
	OutputLink types.String `tfsdk:"output_link"`
	// The text of the SQL query. Can Run permission of the SQL query associated
	// with the SQL alert is required to view this field.
	QueryText types.String `tfsdk:"query_text"`
	// Information about SQL statements executed in the run.
	SqlStatements types.List `tfsdk:"sql_statements"`
	// The canonical identifier of the SQL warehouse.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *SqlAlertOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlAlertOutput_SdkV2) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (to *SqlAlertOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlAlertOutput_SdkV2) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (m SqlAlertOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_state"] = attrs["alert_state"].SetOptional()
	attrs["output_link"] = attrs["output_link"].SetOptional()
	attrs["query_text"] = attrs["query_text"].SetOptional()
	attrs["sql_statements"] = attrs["sql_statements"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlAlertOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlAlertOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"sql_statements": reflect.TypeOf(SqlStatementOutput_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlAlertOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlAlertOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_state":    m.AlertState,
			"output_link":    m.OutputLink,
			"query_text":     m.QueryText,
			"sql_statements": m.SqlStatements,
			"warehouse_id":   m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlAlertOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_state": types.StringType,
			"output_link": types.StringType,
			"query_text":  types.StringType,
			"sql_statements": basetypes.ListType{
				ElemType: SqlStatementOutput_SdkV2{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetSqlStatements returns the value of the SqlStatements field in SqlAlertOutput_SdkV2 as
// a slice of SqlStatementOutput_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlAlertOutput_SdkV2) GetSqlStatements(ctx context.Context) ([]SqlStatementOutput_SdkV2, bool) {
	if m.SqlStatements.IsNull() || m.SqlStatements.IsUnknown() {
		return nil, false
	}
	var v []SqlStatementOutput_SdkV2
	d := m.SqlStatements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlStatements sets the value of the SqlStatements field in SqlAlertOutput_SdkV2.
func (m *SqlAlertOutput_SdkV2) SetSqlStatements(ctx context.Context, v []SqlStatementOutput_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_statements"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlStatements = types.ListValueMust(t, vs)
}

type SqlDashboardOutput_SdkV2 struct {
	// The canonical identifier of the SQL warehouse.
	WarehouseId types.String `tfsdk:"warehouse_id"`
	// Widgets executed in the run. Only SQL query based widgets are listed.
	Widgets types.List `tfsdk:"widgets"`
}

func (to *SqlDashboardOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlDashboardOutput_SdkV2) {
	if !from.Widgets.IsNull() && !from.Widgets.IsUnknown() && to.Widgets.IsNull() && len(from.Widgets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Widgets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Widgets = from.Widgets
	}
}

func (to *SqlDashboardOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlDashboardOutput_SdkV2) {
	if !from.Widgets.IsNull() && !from.Widgets.IsUnknown() && to.Widgets.IsNull() && len(from.Widgets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Widgets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Widgets = from.Widgets
	}
}

func (m SqlDashboardOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["widgets"] = attrs["widgets"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlDashboardOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlDashboardOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"widgets": reflect.TypeOf(SqlDashboardWidgetOutput_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlDashboardOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlDashboardOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"warehouse_id": m.WarehouseId,
			"widgets":      m.Widgets,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlDashboardOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"warehouse_id": types.StringType,
			"widgets": basetypes.ListType{
				ElemType: SqlDashboardWidgetOutput_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetWidgets returns the value of the Widgets field in SqlDashboardOutput_SdkV2 as
// a slice of SqlDashboardWidgetOutput_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlDashboardOutput_SdkV2) GetWidgets(ctx context.Context) ([]SqlDashboardWidgetOutput_SdkV2, bool) {
	if m.Widgets.IsNull() || m.Widgets.IsUnknown() {
		return nil, false
	}
	var v []SqlDashboardWidgetOutput_SdkV2
	d := m.Widgets.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWidgets sets the value of the Widgets field in SqlDashboardOutput_SdkV2.
func (m *SqlDashboardOutput_SdkV2) SetWidgets(ctx context.Context, v []SqlDashboardWidgetOutput_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["widgets"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Widgets = types.ListValueMust(t, vs)
}

type SqlDashboardWidgetOutput_SdkV2 struct {
	// Time (in epoch milliseconds) when execution of the SQL widget ends.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The information about the error when execution fails.
	Error types.List `tfsdk:"error"`
	// The link to find the output results.
	OutputLink types.String `tfsdk:"output_link"`
	// Time (in epoch milliseconds) when execution of the SQL widget starts.
	StartTime types.Int64 `tfsdk:"start_time"`
	// The execution status of the SQL widget.
	Status types.String `tfsdk:"status"`
	// The canonical identifier of the SQL widget.
	WidgetId types.String `tfsdk:"widget_id"`
	// The title of the SQL widget.
	WidgetTitle types.String `tfsdk:"widget_title"`
}

func (to *SqlDashboardWidgetOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlDashboardWidgetOutput_SdkV2) {
	if !from.Error.IsNull() && !from.Error.IsUnknown() {
		if toError, ok := to.GetError(ctx); ok {
			if fromError, ok := from.GetError(ctx); ok {
				// Recursively sync the fields of Error
				toError.SyncFieldsDuringCreateOrUpdate(ctx, fromError)
				to.SetError(ctx, toError)
			}
		}
	}
}

func (to *SqlDashboardWidgetOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlDashboardWidgetOutput_SdkV2) {
	if !from.Error.IsNull() && !from.Error.IsUnknown() {
		if toError, ok := to.GetError(ctx); ok {
			if fromError, ok := from.GetError(ctx); ok {
				toError.SyncFieldsDuringRead(ctx, fromError)
				to.SetError(ctx, toError)
			}
		}
	}
}

func (m SqlDashboardWidgetOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["error"] = attrs["error"].SetOptional()
	attrs["error"] = attrs["error"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["output_link"] = attrs["output_link"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["widget_id"] = attrs["widget_id"].SetOptional()
	attrs["widget_title"] = attrs["widget_title"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlDashboardWidgetOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlDashboardWidgetOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"error": reflect.TypeOf(SqlOutputError_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlDashboardWidgetOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlDashboardWidgetOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"end_time":     m.EndTime,
			"error":        m.Error,
			"output_link":  m.OutputLink,
			"start_time":   m.StartTime,
			"status":       m.Status,
			"widget_id":    m.WidgetId,
			"widget_title": m.WidgetTitle,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlDashboardWidgetOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"end_time": types.Int64Type,
			"error": basetypes.ListType{
				ElemType: SqlOutputError_SdkV2{}.Type(ctx),
			},
			"output_link":  types.StringType,
			"start_time":   types.Int64Type,
			"status":       types.StringType,
			"widget_id":    types.StringType,
			"widget_title": types.StringType,
		},
	}
}

// GetError returns the value of the Error field in SqlDashboardWidgetOutput_SdkV2 as
// a SqlOutputError_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlDashboardWidgetOutput_SdkV2) GetError(ctx context.Context) (SqlOutputError_SdkV2, bool) {
	var e SqlOutputError_SdkV2
	if m.Error.IsNull() || m.Error.IsUnknown() {
		return e, false
	}
	var v []SqlOutputError_SdkV2
	d := m.Error.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetError sets the value of the Error field in SqlDashboardWidgetOutput_SdkV2.
func (m *SqlDashboardWidgetOutput_SdkV2) SetError(ctx context.Context, v SqlOutputError_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["error"]
	m.Error = types.ListValueMust(t, vs)
}

type SqlOutput_SdkV2 struct {
	// The output of a SQL alert task, if available.
	AlertOutput types.List `tfsdk:"alert_output"`
	// The output of a SQL dashboard task, if available.
	DashboardOutput types.List `tfsdk:"dashboard_output"`
	// The output of a SQL query task, if available.
	QueryOutput types.List `tfsdk:"query_output"`
}

func (to *SqlOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlOutput_SdkV2) {
	if !from.AlertOutput.IsNull() && !from.AlertOutput.IsUnknown() {
		if toAlertOutput, ok := to.GetAlertOutput(ctx); ok {
			if fromAlertOutput, ok := from.GetAlertOutput(ctx); ok {
				// Recursively sync the fields of AlertOutput
				toAlertOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromAlertOutput)
				to.SetAlertOutput(ctx, toAlertOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				// Recursively sync the fields of DashboardOutput
				toDashboardOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.QueryOutput.IsNull() && !from.QueryOutput.IsUnknown() {
		if toQueryOutput, ok := to.GetQueryOutput(ctx); ok {
			if fromQueryOutput, ok := from.GetQueryOutput(ctx); ok {
				// Recursively sync the fields of QueryOutput
				toQueryOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromQueryOutput)
				to.SetQueryOutput(ctx, toQueryOutput)
			}
		}
	}
}

func (to *SqlOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlOutput_SdkV2) {
	if !from.AlertOutput.IsNull() && !from.AlertOutput.IsUnknown() {
		if toAlertOutput, ok := to.GetAlertOutput(ctx); ok {
			if fromAlertOutput, ok := from.GetAlertOutput(ctx); ok {
				toAlertOutput.SyncFieldsDuringRead(ctx, fromAlertOutput)
				to.SetAlertOutput(ctx, toAlertOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				toDashboardOutput.SyncFieldsDuringRead(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.QueryOutput.IsNull() && !from.QueryOutput.IsUnknown() {
		if toQueryOutput, ok := to.GetQueryOutput(ctx); ok {
			if fromQueryOutput, ok := from.GetQueryOutput(ctx); ok {
				toQueryOutput.SyncFieldsDuringRead(ctx, fromQueryOutput)
				to.SetQueryOutput(ctx, toQueryOutput)
			}
		}
	}
}

func (m SqlOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_output"] = attrs["alert_output"].SetOptional()
	attrs["alert_output"] = attrs["alert_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dashboard_output"] = attrs["dashboard_output"].SetOptional()
	attrs["dashboard_output"] = attrs["dashboard_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["query_output"] = attrs["query_output"].SetOptional()
	attrs["query_output"] = attrs["query_output"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"alert_output":     reflect.TypeOf(SqlAlertOutput_SdkV2{}),
		"dashboard_output": reflect.TypeOf(SqlDashboardOutput_SdkV2{}),
		"query_output":     reflect.TypeOf(SqlQueryOutput_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_output":     m.AlertOutput,
			"dashboard_output": m.DashboardOutput,
			"query_output":     m.QueryOutput,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_output": basetypes.ListType{
				ElemType: SqlAlertOutput_SdkV2{}.Type(ctx),
			},
			"dashboard_output": basetypes.ListType{
				ElemType: SqlDashboardOutput_SdkV2{}.Type(ctx),
			},
			"query_output": basetypes.ListType{
				ElemType: SqlQueryOutput_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetAlertOutput returns the value of the AlertOutput field in SqlOutput_SdkV2 as
// a SqlAlertOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlOutput_SdkV2) GetAlertOutput(ctx context.Context) (SqlAlertOutput_SdkV2, bool) {
	var e SqlAlertOutput_SdkV2
	if m.AlertOutput.IsNull() || m.AlertOutput.IsUnknown() {
		return e, false
	}
	var v []SqlAlertOutput_SdkV2
	d := m.AlertOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAlertOutput sets the value of the AlertOutput field in SqlOutput_SdkV2.
func (m *SqlOutput_SdkV2) SetAlertOutput(ctx context.Context, v SqlAlertOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["alert_output"]
	m.AlertOutput = types.ListValueMust(t, vs)
}

// GetDashboardOutput returns the value of the DashboardOutput field in SqlOutput_SdkV2 as
// a SqlDashboardOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlOutput_SdkV2) GetDashboardOutput(ctx context.Context) (SqlDashboardOutput_SdkV2, bool) {
	var e SqlDashboardOutput_SdkV2
	if m.DashboardOutput.IsNull() || m.DashboardOutput.IsUnknown() {
		return e, false
	}
	var v []SqlDashboardOutput_SdkV2
	d := m.DashboardOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDashboardOutput sets the value of the DashboardOutput field in SqlOutput_SdkV2.
func (m *SqlOutput_SdkV2) SetDashboardOutput(ctx context.Context, v SqlDashboardOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboard_output"]
	m.DashboardOutput = types.ListValueMust(t, vs)
}

// GetQueryOutput returns the value of the QueryOutput field in SqlOutput_SdkV2 as
// a SqlQueryOutput_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlOutput_SdkV2) GetQueryOutput(ctx context.Context) (SqlQueryOutput_SdkV2, bool) {
	var e SqlQueryOutput_SdkV2
	if m.QueryOutput.IsNull() || m.QueryOutput.IsUnknown() {
		return e, false
	}
	var v []SqlQueryOutput_SdkV2
	d := m.QueryOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQueryOutput sets the value of the QueryOutput field in SqlOutput_SdkV2.
func (m *SqlOutput_SdkV2) SetQueryOutput(ctx context.Context, v SqlQueryOutput_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["query_output"]
	m.QueryOutput = types.ListValueMust(t, vs)
}

type SqlOutputError_SdkV2 struct {
	// The error message when execution fails.
	Message types.String `tfsdk:"message"`
}

func (to *SqlOutputError_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlOutputError_SdkV2) {
}

func (to *SqlOutputError_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlOutputError_SdkV2) {
}

func (m SqlOutputError_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlOutputError.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlOutputError_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlOutputError_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlOutputError_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message": m.Message,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlOutputError_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message": types.StringType,
		},
	}
}

type SqlQueryOutput_SdkV2 struct {
	EndpointId types.String `tfsdk:"endpoint_id"`
	// The link to find the output results.
	OutputLink types.String `tfsdk:"output_link"`
	// The text of the SQL query. Can Run permission of the SQL query is
	// required to view this field.
	QueryText types.String `tfsdk:"query_text"`
	// Information about SQL statements executed in the run.
	SqlStatements types.List `tfsdk:"sql_statements"`
	// The canonical identifier of the SQL warehouse.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *SqlQueryOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlQueryOutput_SdkV2) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (to *SqlQueryOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlQueryOutput_SdkV2) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (m SqlQueryOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["endpoint_id"] = attrs["endpoint_id"].SetOptional()
	attrs["output_link"] = attrs["output_link"].SetOptional()
	attrs["query_text"] = attrs["query_text"].SetOptional()
	attrs["sql_statements"] = attrs["sql_statements"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlQueryOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlQueryOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"sql_statements": reflect.TypeOf(SqlStatementOutput_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlQueryOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlQueryOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"endpoint_id":    m.EndpointId,
			"output_link":    m.OutputLink,
			"query_text":     m.QueryText,
			"sql_statements": m.SqlStatements,
			"warehouse_id":   m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlQueryOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"endpoint_id": types.StringType,
			"output_link": types.StringType,
			"query_text":  types.StringType,
			"sql_statements": basetypes.ListType{
				ElemType: SqlStatementOutput_SdkV2{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetSqlStatements returns the value of the SqlStatements field in SqlQueryOutput_SdkV2 as
// a slice of SqlStatementOutput_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlQueryOutput_SdkV2) GetSqlStatements(ctx context.Context) ([]SqlStatementOutput_SdkV2, bool) {
	if m.SqlStatements.IsNull() || m.SqlStatements.IsUnknown() {
		return nil, false
	}
	var v []SqlStatementOutput_SdkV2
	d := m.SqlStatements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlStatements sets the value of the SqlStatements field in SqlQueryOutput_SdkV2.
func (m *SqlQueryOutput_SdkV2) SetSqlStatements(ctx context.Context, v []SqlStatementOutput_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_statements"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlStatements = types.ListValueMust(t, vs)
}

type SqlStatementOutput_SdkV2 struct {
	// A key that can be used to look up query details.
	LookupKey types.String `tfsdk:"lookup_key"`
}

func (to *SqlStatementOutput_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlStatementOutput_SdkV2) {
}

func (to *SqlStatementOutput_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlStatementOutput_SdkV2) {
}

func (m SqlStatementOutput_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["lookup_key"] = attrs["lookup_key"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlStatementOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlStatementOutput_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlStatementOutput_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlStatementOutput_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"lookup_key": m.LookupKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlStatementOutput_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"lookup_key": types.StringType,
		},
	}
}

type SqlTask_SdkV2 struct {
	// If alert, indicates that this job must refresh a SQL alert.
	Alert types.List `tfsdk:"alert"`
	// If dashboard, indicates that this job must refresh a SQL dashboard.
	Dashboard types.List `tfsdk:"dashboard"`
	// If file, indicates that this job runs a SQL file in a remote Git
	// repository.
	File types.List `tfsdk:"file"`
	// Parameters to be used for each run of this job. The SQL alert task does
	// not support custom parameters.
	Parameters types.Map `tfsdk:"parameters"`
	// If query, indicates that this job must execute a SQL query.
	Query types.List `tfsdk:"query"`
	// The canonical identifier of the SQL warehouse. Recommended to use with
	// serverless or pro SQL warehouses. Classic SQL warehouses are only
	// supported for SQL alert, dashboard and query tasks and are limited to
	// scheduled single-task jobs.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *SqlTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTask_SdkV2) {
	if !from.Alert.IsNull() && !from.Alert.IsUnknown() {
		if toAlert, ok := to.GetAlert(ctx); ok {
			if fromAlert, ok := from.GetAlert(ctx); ok {
				// Recursively sync the fields of Alert
				toAlert.SyncFieldsDuringCreateOrUpdate(ctx, fromAlert)
				to.SetAlert(ctx, toAlert)
			}
		}
	}
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				// Recursively sync the fields of Dashboard
				toDashboard.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
	if !from.File.IsNull() && !from.File.IsUnknown() {
		if toFile, ok := to.GetFile(ctx); ok {
			if fromFile, ok := from.GetFile(ctx); ok {
				// Recursively sync the fields of File
				toFile.SyncFieldsDuringCreateOrUpdate(ctx, fromFile)
				to.SetFile(ctx, toFile)
			}
		}
	}
	if !from.Query.IsNull() && !from.Query.IsUnknown() {
		if toQuery, ok := to.GetQuery(ctx); ok {
			if fromQuery, ok := from.GetQuery(ctx); ok {
				// Recursively sync the fields of Query
				toQuery.SyncFieldsDuringCreateOrUpdate(ctx, fromQuery)
				to.SetQuery(ctx, toQuery)
			}
		}
	}
}

func (to *SqlTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlTask_SdkV2) {
	if !from.Alert.IsNull() && !from.Alert.IsUnknown() {
		if toAlert, ok := to.GetAlert(ctx); ok {
			if fromAlert, ok := from.GetAlert(ctx); ok {
				toAlert.SyncFieldsDuringRead(ctx, fromAlert)
				to.SetAlert(ctx, toAlert)
			}
		}
	}
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				toDashboard.SyncFieldsDuringRead(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
	if !from.File.IsNull() && !from.File.IsUnknown() {
		if toFile, ok := to.GetFile(ctx); ok {
			if fromFile, ok := from.GetFile(ctx); ok {
				toFile.SyncFieldsDuringRead(ctx, fromFile)
				to.SetFile(ctx, toFile)
			}
		}
	}
	if !from.Query.IsNull() && !from.Query.IsUnknown() {
		if toQuery, ok := to.GetQuery(ctx); ok {
			if fromQuery, ok := from.GetQuery(ctx); ok {
				toQuery.SyncFieldsDuringRead(ctx, fromQuery)
				to.SetQuery(ctx, toQuery)
			}
		}
	}
}

func (m SqlTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert"] = attrs["alert"].SetOptional()
	attrs["alert"] = attrs["alert"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dashboard"] = attrs["dashboard"].SetOptional()
	attrs["dashboard"] = attrs["dashboard"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["file"] = attrs["file"].SetOptional()
	attrs["file"] = attrs["file"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["parameters"] = attrs["parameters"].SetOptional()
	attrs["query"] = attrs["query"].SetOptional()
	attrs["query"] = attrs["query"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["warehouse_id"] = attrs["warehouse_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"alert":      reflect.TypeOf(SqlTaskAlert_SdkV2{}),
		"dashboard":  reflect.TypeOf(SqlTaskDashboard_SdkV2{}),
		"file":       reflect.TypeOf(SqlTaskFile_SdkV2{}),
		"parameters": reflect.TypeOf(types.String{}),
		"query":      reflect.TypeOf(SqlTaskQuery_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTask_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert":        m.Alert,
			"dashboard":    m.Dashboard,
			"file":         m.File,
			"parameters":   m.Parameters,
			"query":        m.Query,
			"warehouse_id": m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert": basetypes.ListType{
				ElemType: SqlTaskAlert_SdkV2{}.Type(ctx),
			},
			"dashboard": basetypes.ListType{
				ElemType: SqlTaskDashboard_SdkV2{}.Type(ctx),
			},
			"file": basetypes.ListType{
				ElemType: SqlTaskFile_SdkV2{}.Type(ctx),
			},
			"parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"query": basetypes.ListType{
				ElemType: SqlTaskQuery_SdkV2{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetAlert returns the value of the Alert field in SqlTask_SdkV2 as
// a SqlTaskAlert_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask_SdkV2) GetAlert(ctx context.Context) (SqlTaskAlert_SdkV2, bool) {
	var e SqlTaskAlert_SdkV2
	if m.Alert.IsNull() || m.Alert.IsUnknown() {
		return e, false
	}
	var v []SqlTaskAlert_SdkV2
	d := m.Alert.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAlert sets the value of the Alert field in SqlTask_SdkV2.
func (m *SqlTask_SdkV2) SetAlert(ctx context.Context, v SqlTaskAlert_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["alert"]
	m.Alert = types.ListValueMust(t, vs)
}

// GetDashboard returns the value of the Dashboard field in SqlTask_SdkV2 as
// a SqlTaskDashboard_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask_SdkV2) GetDashboard(ctx context.Context) (SqlTaskDashboard_SdkV2, bool) {
	var e SqlTaskDashboard_SdkV2
	if m.Dashboard.IsNull() || m.Dashboard.IsUnknown() {
		return e, false
	}
	var v []SqlTaskDashboard_SdkV2
	d := m.Dashboard.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDashboard sets the value of the Dashboard field in SqlTask_SdkV2.
func (m *SqlTask_SdkV2) SetDashboard(ctx context.Context, v SqlTaskDashboard_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboard"]
	m.Dashboard = types.ListValueMust(t, vs)
}

// GetFile returns the value of the File field in SqlTask_SdkV2 as
// a SqlTaskFile_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask_SdkV2) GetFile(ctx context.Context) (SqlTaskFile_SdkV2, bool) {
	var e SqlTaskFile_SdkV2
	if m.File.IsNull() || m.File.IsUnknown() {
		return e, false
	}
	var v []SqlTaskFile_SdkV2
	d := m.File.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFile sets the value of the File field in SqlTask_SdkV2.
func (m *SqlTask_SdkV2) SetFile(ctx context.Context, v SqlTaskFile_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file"]
	m.File = types.ListValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in SqlTask_SdkV2 as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask_SdkV2) GetParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SqlTask_SdkV2.
func (m *SqlTask_SdkV2) SetParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.MapValueMust(t, vs)
}

// GetQuery returns the value of the Query field in SqlTask_SdkV2 as
// a SqlTaskQuery_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask_SdkV2) GetQuery(ctx context.Context) (SqlTaskQuery_SdkV2, bool) {
	var e SqlTaskQuery_SdkV2
	if m.Query.IsNull() || m.Query.IsUnknown() {
		return e, false
	}
	var v []SqlTaskQuery_SdkV2
	d := m.Query.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQuery sets the value of the Query field in SqlTask_SdkV2.
func (m *SqlTask_SdkV2) SetQuery(ctx context.Context, v SqlTaskQuery_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["query"]
	m.Query = types.ListValueMust(t, vs)
}

type SqlTaskAlert_SdkV2 struct {
	// The canonical identifier of the SQL alert.
	AlertId types.String `tfsdk:"alert_id"`
	// If true, the alert notifications are not sent to subscribers.
	PauseSubscriptions types.Bool `tfsdk:"pause_subscriptions"`
	// If specified, alert notifications are sent to subscribers.
	Subscriptions types.List `tfsdk:"subscriptions"`
}

func (to *SqlTaskAlert_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskAlert_SdkV2) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (to *SqlTaskAlert_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlTaskAlert_SdkV2) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (m SqlTaskAlert_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_id"] = attrs["alert_id"].SetRequired()
	attrs["pause_subscriptions"] = attrs["pause_subscriptions"].SetOptional()
	attrs["subscriptions"] = attrs["subscriptions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskAlert.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskAlert_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscriptions": reflect.TypeOf(SqlTaskSubscription_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskAlert_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlTaskAlert_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_id":            m.AlertId,
			"pause_subscriptions": m.PauseSubscriptions,
			"subscriptions":       m.Subscriptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskAlert_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_id":            types.StringType,
			"pause_subscriptions": types.BoolType,
			"subscriptions": basetypes.ListType{
				ElemType: SqlTaskSubscription_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSubscriptions returns the value of the Subscriptions field in SqlTaskAlert_SdkV2 as
// a slice of SqlTaskSubscription_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTaskAlert_SdkV2) GetSubscriptions(ctx context.Context) ([]SqlTaskSubscription_SdkV2, bool) {
	if m.Subscriptions.IsNull() || m.Subscriptions.IsUnknown() {
		return nil, false
	}
	var v []SqlTaskSubscription_SdkV2
	d := m.Subscriptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscriptions sets the value of the Subscriptions field in SqlTaskAlert_SdkV2.
func (m *SqlTaskAlert_SdkV2) SetSubscriptions(ctx context.Context, v []SqlTaskSubscription_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscriptions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscriptions = types.ListValueMust(t, vs)
}

type SqlTaskDashboard_SdkV2 struct {
	// Subject of the email sent to subscribers of this task.
	CustomSubject types.String `tfsdk:"custom_subject"`
	// The canonical identifier of the SQL dashboard.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// If true, the dashboard snapshot is not taken, and emails are not sent to
	// subscribers.
	PauseSubscriptions types.Bool `tfsdk:"pause_subscriptions"`
	// If specified, dashboard snapshots are sent to subscriptions.
	Subscriptions types.List `tfsdk:"subscriptions"`
}

func (to *SqlTaskDashboard_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskDashboard_SdkV2) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (to *SqlTaskDashboard_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlTaskDashboard_SdkV2) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (m SqlTaskDashboard_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["custom_subject"] = attrs["custom_subject"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["pause_subscriptions"] = attrs["pause_subscriptions"].SetOptional()
	attrs["subscriptions"] = attrs["subscriptions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskDashboard.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskDashboard_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscriptions": reflect.TypeOf(SqlTaskSubscription_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskDashboard_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlTaskDashboard_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"custom_subject":      m.CustomSubject,
			"dashboard_id":        m.DashboardId,
			"pause_subscriptions": m.PauseSubscriptions,
			"subscriptions":       m.Subscriptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskDashboard_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"custom_subject":      types.StringType,
			"dashboard_id":        types.StringType,
			"pause_subscriptions": types.BoolType,
			"subscriptions": basetypes.ListType{
				ElemType: SqlTaskSubscription_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSubscriptions returns the value of the Subscriptions field in SqlTaskDashboard_SdkV2 as
// a slice of SqlTaskSubscription_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTaskDashboard_SdkV2) GetSubscriptions(ctx context.Context) ([]SqlTaskSubscription_SdkV2, bool) {
	if m.Subscriptions.IsNull() || m.Subscriptions.IsUnknown() {
		return nil, false
	}
	var v []SqlTaskSubscription_SdkV2
	d := m.Subscriptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscriptions sets the value of the Subscriptions field in SqlTaskDashboard_SdkV2.
func (m *SqlTaskDashboard_SdkV2) SetSubscriptions(ctx context.Context, v []SqlTaskSubscription_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscriptions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscriptions = types.ListValueMust(t, vs)
}

type SqlTaskFile_SdkV2 struct {
	// Path of the SQL file. Must be relative if the source is a remote Git
	// repository and absolute for workspace paths.
	Path types.String `tfsdk:"path"`
	// Optional location type of the SQL file. When set to `WORKSPACE`, the SQL
	// file will be retrieved from the local Databricks workspace. When set to
	// `GIT`, the SQL file will be retrieved from a Git repository defined in
	// `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise.
	//
	// * `WORKSPACE`: SQL file is located in Databricks workspace. * `GIT`: SQL
	// file is located in cloud Git provider.
	Source types.String `tfsdk:"source"`
}

func (to *SqlTaskFile_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskFile_SdkV2) {
}

func (to *SqlTaskFile_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlTaskFile_SdkV2) {
}

func (m SqlTaskFile_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["path"] = attrs["path"].SetRequired()
	attrs["source"] = attrs["source"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskFile.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskFile_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskFile_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlTaskFile_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"path":   m.Path,
			"source": m.Source,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskFile_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"path":   types.StringType,
			"source": types.StringType,
		},
	}
}

type SqlTaskQuery_SdkV2 struct {
	// The canonical identifier of the SQL query.
	QueryId types.String `tfsdk:"query_id"`
}

func (to *SqlTaskQuery_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskQuery_SdkV2) {
}

func (to *SqlTaskQuery_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlTaskQuery_SdkV2) {
}

func (m SqlTaskQuery_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["query_id"] = attrs["query_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskQuery.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskQuery_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskQuery_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlTaskQuery_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"query_id": m.QueryId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskQuery_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"query_id": types.StringType,
		},
	}
}

type SqlTaskSubscription_SdkV2 struct {
	// The canonical identifier of the destination to receive email
	// notification. This parameter is mutually exclusive with user_name. You
	// cannot set both destination_id and user_name for subscription
	// notifications.
	DestinationId types.String `tfsdk:"destination_id"`
	// The user name to receive the subscription email. This parameter is
	// mutually exclusive with destination_id. You cannot set both
	// destination_id and user_name for subscription notifications.
	UserName types.String `tfsdk:"user_name"`
}

func (to *SqlTaskSubscription_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskSubscription_SdkV2) {
}

func (to *SqlTaskSubscription_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SqlTaskSubscription_SdkV2) {
}

func (m SqlTaskSubscription_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskSubscription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskSubscription_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskSubscription_SdkV2
// only implements ToObjectValue() and Type().
func (m SqlTaskSubscription_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id": m.DestinationId,
			"user_name":      m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskSubscription_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id": types.StringType,
			"user_name":      types.StringType,
		},
	}
}

type SubmitRun_SdkV2 struct {
	// List of permissions to set on the job.
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The user specified id of the budget policy to use for this one-time run.
	// If not specified, the run will be not be attributed to any budget policy.
	BudgetPolicyId types.String `tfsdk:"budget_policy_id"`
	// An optional set of email addresses notified when the run begins or
	// completes.
	EmailNotifications types.List `tfsdk:"email_notifications"`
	// A list of task execution environment specifications that can be
	// referenced by tasks of this run.
	Environments types.List `tfsdk:"environments"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.List `tfsdk:"git_source"`

	Health types.List `tfsdk:"health"`
	// An optional token that can be used to guarantee the idempotency of job
	// run requests. If a run with the provided token already exists, the
	// request does not create a new run but returns the ID of the existing run
	// instead. If a run with the provided token is deleted, an error is
	// returned.
	//
	// If you specify the idempotency token, upon failure you can retry until
	// the request succeeds. Databricks guarantees that exactly one run is
	// launched with that idempotency token.
	//
	// This token must have at most 64 characters.
	//
	// For more information, see [How to ensure idempotency for jobs].
	//
	// [How to ensure idempotency for jobs]: https://kb.databricks.com/jobs/jobs-idempotency.html
	IdempotencyToken types.String `tfsdk:"idempotency_token"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// run.
	NotificationSettings types.List `tfsdk:"notification_settings"`
	// The queue settings of the one-time run.
	Queue types.List `tfsdk:"queue"`
	// Specifies the user or service principal that the job runs as. If not
	// specified, the job runs as the user who submits the request.
	RunAs types.List `tfsdk:"run_as"`
	// An optional name for the run. The default value is `Untitled`.
	RunName types.String `tfsdk:"run_name"`

	Tasks types.List `tfsdk:"tasks"`
	// An optional timeout applied to each run of this job. A value of `0` means
	// no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// The user specified id of the usage policy to use for this one-time run.
	// If not specified, a default usage policy may be applied when creating or
	// modifying the job.
	UsagePolicyId types.String `tfsdk:"usage_policy_id"`
	// A collection of system notification IDs to notify when the run begins or
	// completes.
	WebhookNotifications types.List `tfsdk:"webhook_notifications"`
}

func (to *SubmitRun_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubmitRun_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.BudgetPolicyId.IsUnknown() && !from.BudgetPolicyId.IsNull() {
		// BudgetPolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.BudgetPolicyId = from.BudgetPolicyId
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				// Recursively sync the fields of RunAs
				toRunAs.SyncFieldsDuringCreateOrUpdate(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.UsagePolicyId.IsUnknown() && !from.UsagePolicyId.IsNull() {
		// UsagePolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.UsagePolicyId = from.UsagePolicyId
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *SubmitRun_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SubmitRun_SdkV2) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.BudgetPolicyId.IsUnknown() && !from.BudgetPolicyId.IsNull() {
		// BudgetPolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.BudgetPolicyId = from.BudgetPolicyId
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				toRunAs.SyncFieldsDuringRead(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.UsagePolicyId.IsUnknown() && !from.UsagePolicyId.IsNull() {
		// UsagePolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.UsagePolicyId = from.UsagePolicyId
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m SubmitRun_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetOptional()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetComputed()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["environments"] = attrs["environments"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["git_source"] = attrs["git_source"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["health"] = attrs["health"].SetOptional()
	attrs["health"] = attrs["health"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["idempotency_token"] = attrs["idempotency_token"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["queue"] = attrs["queue"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_as"] = attrs["run_as"].SetOptional()
	attrs["run_as"] = attrs["run_as"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_name"] = attrs["run_name"].SetOptional()
	attrs["tasks"] = attrs["tasks"].SetOptional()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetOptional()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetComputed()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubmitRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubmitRun_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list":   reflect.TypeOf(JobAccessControlRequest_SdkV2{}),
		"email_notifications":   reflect.TypeOf(JobEmailNotifications_SdkV2{}),
		"environments":          reflect.TypeOf(JobEnvironment_SdkV2{}),
		"git_source":            reflect.TypeOf(GitSource_SdkV2{}),
		"health":                reflect.TypeOf(JobsHealthRules_SdkV2{}),
		"notification_settings": reflect.TypeOf(JobNotificationSettings_SdkV2{}),
		"queue":                 reflect.TypeOf(QueueSettings_SdkV2{}),
		"run_as":                reflect.TypeOf(JobRunAs_SdkV2{}),
		"tasks":                 reflect.TypeOf(SubmitTask_SdkV2{}),
		"webhook_notifications": reflect.TypeOf(WebhookNotifications_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubmitRun_SdkV2
// only implements ToObjectValue() and Type().
func (m SubmitRun_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list":   m.AccessControlList,
			"budget_policy_id":      m.BudgetPolicyId,
			"email_notifications":   m.EmailNotifications,
			"environments":          m.Environments,
			"git_source":            m.GitSource,
			"health":                m.Health,
			"idempotency_token":     m.IdempotencyToken,
			"notification_settings": m.NotificationSettings,
			"queue":                 m.Queue,
			"run_as":                m.RunAs,
			"run_name":              m.RunName,
			"tasks":                 m.Tasks,
			"timeout_seconds":       m.TimeoutSeconds,
			"usage_policy_id":       m.UsagePolicyId,
			"webhook_notifications": m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubmitRun_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlRequest_SdkV2{}.Type(ctx),
			},
			"budget_policy_id": types.StringType,
			"email_notifications": basetypes.ListType{
				ElemType: JobEmailNotifications_SdkV2{}.Type(ctx),
			},
			"environments": basetypes.ListType{
				ElemType: JobEnvironment_SdkV2{}.Type(ctx),
			},
			"git_source": basetypes.ListType{
				ElemType: GitSource_SdkV2{}.Type(ctx),
			},
			"health": basetypes.ListType{
				ElemType: JobsHealthRules_SdkV2{}.Type(ctx),
			},
			"idempotency_token": types.StringType,
			"notification_settings": basetypes.ListType{
				ElemType: JobNotificationSettings_SdkV2{}.Type(ctx),
			},
			"queue": basetypes.ListType{
				ElemType: QueueSettings_SdkV2{}.Type(ctx),
			},
			"run_as": basetypes.ListType{
				ElemType: JobRunAs_SdkV2{}.Type(ctx),
			},
			"run_name": types.StringType,
			"tasks": basetypes.ListType{
				ElemType: SubmitTask_SdkV2{}.Type(ctx),
			},
			"timeout_seconds": types.Int64Type,
			"usage_policy_id": types.StringType,
			"webhook_notifications": basetypes.ListType{
				ElemType: WebhookNotifications_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in SubmitRun_SdkV2 as
// a slice of JobAccessControlRequest_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetAccessControlList(ctx context.Context) ([]JobAccessControlRequest_SdkV2, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlRequest_SdkV2
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetAccessControlList(ctx context.Context, v []JobAccessControlRequest_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in SubmitRun_SdkV2 as
// a JobEmailNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetEmailNotifications(ctx context.Context) (JobEmailNotifications_SdkV2, bool) {
	var e JobEmailNotifications_SdkV2
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v []JobEmailNotifications_SdkV2
	d := m.EmailNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEmailNotifications sets the value of the EmailNotifications field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetEmailNotifications(ctx context.Context, v JobEmailNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_notifications"]
	m.EmailNotifications = types.ListValueMust(t, vs)
}

// GetEnvironments returns the value of the Environments field in SubmitRun_SdkV2 as
// a slice of JobEnvironment_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetEnvironments(ctx context.Context) ([]JobEnvironment_SdkV2, bool) {
	if m.Environments.IsNull() || m.Environments.IsUnknown() {
		return nil, false
	}
	var v []JobEnvironment_SdkV2
	d := m.Environments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEnvironments sets the value of the Environments field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetEnvironments(ctx context.Context, v []JobEnvironment_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["environments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Environments = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in SubmitRun_SdkV2 as
// a GitSource_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetGitSource(ctx context.Context) (GitSource_SdkV2, bool) {
	var e GitSource_SdkV2
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v []GitSource_SdkV2
	d := m.GitSource.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGitSource sets the value of the GitSource field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetGitSource(ctx context.Context, v GitSource_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["git_source"]
	m.GitSource = types.ListValueMust(t, vs)
}

// GetHealth returns the value of the Health field in SubmitRun_SdkV2 as
// a JobsHealthRules_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetHealth(ctx context.Context) (JobsHealthRules_SdkV2, bool) {
	var e JobsHealthRules_SdkV2
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v []JobsHealthRules_SdkV2
	d := m.Health.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetHealth sets the value of the Health field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetHealth(ctx context.Context, v JobsHealthRules_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["health"]
	m.Health = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in SubmitRun_SdkV2 as
// a JobNotificationSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetNotificationSettings(ctx context.Context) (JobNotificationSettings_SdkV2, bool) {
	var e JobNotificationSettings_SdkV2
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v []JobNotificationSettings_SdkV2
	d := m.NotificationSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotificationSettings sets the value of the NotificationSettings field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetNotificationSettings(ctx context.Context, v JobNotificationSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notification_settings"]
	m.NotificationSettings = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in SubmitRun_SdkV2 as
// a QueueSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetQueue(ctx context.Context) (QueueSettings_SdkV2, bool) {
	var e QueueSettings_SdkV2
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v []QueueSettings_SdkV2
	d := m.Queue.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQueue sets the value of the Queue field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetQueue(ctx context.Context, v QueueSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["queue"]
	m.Queue = types.ListValueMust(t, vs)
}

// GetRunAs returns the value of the RunAs field in SubmitRun_SdkV2 as
// a JobRunAs_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetRunAs(ctx context.Context) (JobRunAs_SdkV2, bool) {
	var e JobRunAs_SdkV2
	if m.RunAs.IsNull() || m.RunAs.IsUnknown() {
		return e, false
	}
	var v []JobRunAs_SdkV2
	d := m.RunAs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunAs sets the value of the RunAs field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetRunAs(ctx context.Context, v JobRunAs_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_as"]
	m.RunAs = types.ListValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in SubmitRun_SdkV2 as
// a slice of SubmitTask_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetTasks(ctx context.Context) ([]SubmitTask_SdkV2, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []SubmitTask_SdkV2
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetTasks(ctx context.Context, v []SubmitTask_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in SubmitRun_SdkV2 as
// a WebhookNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun_SdkV2) GetWebhookNotifications(ctx context.Context) (WebhookNotifications_SdkV2, bool) {
	var e WebhookNotifications_SdkV2
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v []WebhookNotifications_SdkV2
	d := m.WebhookNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in SubmitRun_SdkV2.
func (m *SubmitRun_SdkV2) SetWebhookNotifications(ctx context.Context, v WebhookNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["webhook_notifications"]
	m.WebhookNotifications = types.ListValueMust(t, vs)
}

// Run was created and started successfully.
type SubmitRunResponse_SdkV2 struct {
	// The canonical identifier for the newly submitted run.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *SubmitRunResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubmitRunResponse_SdkV2) {
}

func (to *SubmitRunResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SubmitRunResponse_SdkV2) {
}

func (m SubmitRunResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubmitRunResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubmitRunResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubmitRunResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m SubmitRunResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubmitRunResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type SubmitTask_SdkV2 struct {
	// The task runs a [clean rooms] notebook when the
	// `clean_rooms_notebook_task` field is present.
	//
	// [clean rooms]: https://docs.databricks.com/clean-rooms/index.html
	CleanRoomsNotebookTask types.List `tfsdk:"clean_rooms_notebook_task"`
	// The task evaluates a condition that can be used to control the execution
	// of other tasks when the `condition_task` field is present. The condition
	// task does not require a cluster to execute and does not support retries
	// or notifications.
	ConditionTask types.List `tfsdk:"condition_task"`
	// The task refreshes a dashboard and sends a snapshot to subscribers.
	DashboardTask types.List `tfsdk:"dashboard_task"`
	// Task type for dbt cloud, deprecated in favor of the new name
	// dbt_platform_task
	DbtCloudTask types.List `tfsdk:"dbt_cloud_task"`

	DbtPlatformTask types.List `tfsdk:"dbt_platform_task"`
	// The task runs one or more dbt commands when the `dbt_task` field is
	// present. The dbt task requires both Databricks SQL and the ability to use
	// a serverless or a pro SQL warehouse.
	DbtTask types.List `tfsdk:"dbt_task"`
	// An optional array of objects specifying the dependency graph of the task.
	// All tasks specified in this field must complete successfully before
	// executing this task. The key is `task_key`, and the value is the name
	// assigned to the dependent task.
	DependsOn types.List `tfsdk:"depends_on"`
	// An optional description for this task.
	Description types.String `tfsdk:"description"`
	// An optional set of email addresses notified when the task run begins or
	// completes. The default behavior is to not send any emails.
	EmailNotifications types.List `tfsdk:"email_notifications"`
	// The key that references an environment spec in a job. This field is
	// required for Python script, Python wheel and dbt tasks when using
	// serverless compute.
	EnvironmentKey types.String `tfsdk:"environment_key"`
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// The task executes a nested task for every input provided when the
	// `for_each_task` field is present.
	ForEachTask types.List `tfsdk:"for_each_task"`

	GenAiComputeTask types.List `tfsdk:"gen_ai_compute_task"`

	Health types.List `tfsdk:"health"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.List `tfsdk:"new_cluster"`
	// The task runs a notebook when the `notebook_task` field is present.
	NotebookTask types.List `tfsdk:"notebook_task"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// task run.
	NotificationSettings types.List `tfsdk:"notification_settings"`
	// The task triggers a pipeline update when the `pipeline_task` field is
	// present. Only pipelines configured to use triggered more are supported.
	PipelineTask types.List `tfsdk:"pipeline_task"`
	// The task triggers a Power BI semantic model update when the
	// `power_bi_task` field is present.
	PowerBiTask types.List `tfsdk:"power_bi_task"`
	// The task runs a Python wheel when the `python_wheel_task` field is
	// present.
	PythonWheelTask types.List `tfsdk:"python_wheel_task"`
	// An optional value indicating the condition that determines whether the
	// task should be run once its dependencies have been completed. When
	// omitted, defaults to `ALL_SUCCESS`. See :method:jobs/create for a list of
	// possible values.
	RunIf types.String `tfsdk:"run_if"`
	// The task triggers another job when the `run_job_task` field is present.
	RunJobTask types.List `tfsdk:"run_job_task"`
	// The task runs a JAR when the `spark_jar_task` field is present.
	SparkJarTask types.List `tfsdk:"spark_jar_task"`
	// The task runs a Python file when the `spark_python_task` field is
	// present.
	SparkPythonTask types.List `tfsdk:"spark_python_task"`
	// (Legacy) The task runs the spark-submit script when the spark_submit_task
	// field is present. Databricks recommends using the spark_jar_task instead;
	// see [Spark Submit task for jobs](/jobs/spark-submit).
	SparkSubmitTask types.List `tfsdk:"spark_submit_task"`
	// The task runs a SQL query or file, or it refreshes a SQL alert or a
	// legacy SQL dashboard when the `sql_task` field is present.
	SqlTask types.List `tfsdk:"sql_task"`
	// A unique name for the task. This field is used to refer to this task from
	// other tasks. This field is required and must be unique within its parent
	// job. On Update or Reset, this field is used to reference the tasks to be
	// updated or reset.
	TaskKey types.String `tfsdk:"task_key"`
	// An optional timeout applied to each run of this job task. A value of `0`
	// means no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A collection of system notification IDs to notify when the run begins or
	// completes. The default behavior is to not send any system notifications.
	// Task webhooks respect the task notification settings.
	WebhookNotifications types.List `tfsdk:"webhook_notifications"`
}

func (to *SubmitTask_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubmitTask_SdkV2) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookTask
				toCleanRoomsNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				// Recursively sync the fields of DashboardTask
				toDashboardTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				// Recursively sync the fields of DbtCloudTask
				toDbtCloudTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				// Recursively sync the fields of DbtPlatformTask
				toDbtPlatformTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				// Recursively sync the fields of ForEachTask
				toForEachTask.SyncFieldsDuringCreateOrUpdate(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				// Recursively sync the fields of GenAiComputeTask
				toGenAiComputeTask.SyncFieldsDuringCreateOrUpdate(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				// Recursively sync the fields of PipelineTask
				toPipelineTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				// Recursively sync the fields of PowerBiTask
				toPowerBiTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *SubmitTask_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SubmitTask_SdkV2) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				toCleanRoomsNotebookTask.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				toDashboardTask.SyncFieldsDuringRead(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				toDbtCloudTask.SyncFieldsDuringRead(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				toDbtPlatformTask.SyncFieldsDuringRead(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				toForEachTask.SyncFieldsDuringRead(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				toGenAiComputeTask.SyncFieldsDuringRead(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				toPipelineTask.SyncFieldsDuringRead(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				toPowerBiTask.SyncFieldsDuringRead(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m SubmitTask_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].SetOptional()
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dashboard_task"] = attrs["dashboard_task"].SetOptional()
	attrs["dashboard_task"] = attrs["dashboard_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].SetOptional()
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].SetOptional()
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["depends_on"] = attrs["depends_on"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["environment_key"] = attrs["environment_key"].SetOptional()
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].SetOptional()
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["health"] = attrs["health"].SetOptional()
	attrs["health"] = attrs["health"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["library"] = attrs["library"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["pipeline_task"] = attrs["pipeline_task"].SetOptional()
	attrs["pipeline_task"] = attrs["pipeline_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["power_bi_task"] = attrs["power_bi_task"].SetOptional()
	attrs["power_bi_task"] = attrs["power_bi_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["run_if"] = attrs["run_if"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["task_key"] = attrs["task_key"].SetRequired()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubmitTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubmitTask_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_task": reflect.TypeOf(CleanRoomsNotebookTask_SdkV2{}),
		"condition_task":            reflect.TypeOf(ConditionTask_SdkV2{}),
		"dashboard_task":            reflect.TypeOf(DashboardTask_SdkV2{}),
		"dbt_cloud_task":            reflect.TypeOf(DbtCloudTask_SdkV2{}),
		"dbt_platform_task":         reflect.TypeOf(DbtPlatformTask_SdkV2{}),
		"dbt_task":                  reflect.TypeOf(DbtTask_SdkV2{}),
		"depends_on":                reflect.TypeOf(TaskDependency_SdkV2{}),
		"email_notifications":       reflect.TypeOf(JobEmailNotifications_SdkV2{}),
		"for_each_task":             reflect.TypeOf(ForEachTask_SdkV2{}),
		"gen_ai_compute_task":       reflect.TypeOf(GenAiComputeTask_SdkV2{}),
		"health":                    reflect.TypeOf(JobsHealthRules_SdkV2{}),
		"library":                   reflect.TypeOf(compute_tf.Library_SdkV2{}),
		"new_cluster":               reflect.TypeOf(compute_tf.ClusterSpec_SdkV2{}),
		"notebook_task":             reflect.TypeOf(NotebookTask_SdkV2{}),
		"notification_settings":     reflect.TypeOf(TaskNotificationSettings_SdkV2{}),
		"pipeline_task":             reflect.TypeOf(PipelineTask_SdkV2{}),
		"power_bi_task":             reflect.TypeOf(PowerBiTask_SdkV2{}),
		"python_wheel_task":         reflect.TypeOf(PythonWheelTask_SdkV2{}),
		"run_job_task":              reflect.TypeOf(RunJobTask_SdkV2{}),
		"spark_jar_task":            reflect.TypeOf(SparkJarTask_SdkV2{}),
		"spark_python_task":         reflect.TypeOf(SparkPythonTask_SdkV2{}),
		"spark_submit_task":         reflect.TypeOf(SparkSubmitTask_SdkV2{}),
		"sql_task":                  reflect.TypeOf(SqlTask_SdkV2{}),
		"webhook_notifications":     reflect.TypeOf(WebhookNotifications_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubmitTask_SdkV2
// only implements ToObjectValue() and Type().
func (m SubmitTask_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_rooms_notebook_task": m.CleanRoomsNotebookTask,
			"condition_task":            m.ConditionTask,
			"dashboard_task":            m.DashboardTask,
			"dbt_cloud_task":            m.DbtCloudTask,
			"dbt_platform_task":         m.DbtPlatformTask,
			"dbt_task":                  m.DbtTask,
			"depends_on":                m.DependsOn,
			"description":               m.Description,
			"email_notifications":       m.EmailNotifications,
			"environment_key":           m.EnvironmentKey,
			"existing_cluster_id":       m.ExistingClusterId,
			"for_each_task":             m.ForEachTask,
			"gen_ai_compute_task":       m.GenAiComputeTask,
			"health":                    m.Health,
			"library":                   m.Libraries,
			"new_cluster":               m.NewCluster,
			"notebook_task":             m.NotebookTask,
			"notification_settings":     m.NotificationSettings,
			"pipeline_task":             m.PipelineTask,
			"power_bi_task":             m.PowerBiTask,
			"python_wheel_task":         m.PythonWheelTask,
			"run_if":                    m.RunIf,
			"run_job_task":              m.RunJobTask,
			"spark_jar_task":            m.SparkJarTask,
			"spark_python_task":         m.SparkPythonTask,
			"spark_submit_task":         m.SparkSubmitTask,
			"sql_task":                  m.SqlTask,
			"task_key":                  m.TaskKey,
			"timeout_seconds":           m.TimeoutSeconds,
			"webhook_notifications":     m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubmitTask_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_rooms_notebook_task": basetypes.ListType{
				ElemType: CleanRoomsNotebookTask_SdkV2{}.Type(ctx),
			},
			"condition_task": basetypes.ListType{
				ElemType: ConditionTask_SdkV2{}.Type(ctx),
			},
			"dashboard_task": basetypes.ListType{
				ElemType: DashboardTask_SdkV2{}.Type(ctx),
			},
			"dbt_cloud_task": basetypes.ListType{
				ElemType: DbtCloudTask_SdkV2{}.Type(ctx),
			},
			"dbt_platform_task": basetypes.ListType{
				ElemType: DbtPlatformTask_SdkV2{}.Type(ctx),
			},
			"dbt_task": basetypes.ListType{
				ElemType: DbtTask_SdkV2{}.Type(ctx),
			},
			"depends_on": basetypes.ListType{
				ElemType: TaskDependency_SdkV2{}.Type(ctx),
			},
			"description": types.StringType,
			"email_notifications": basetypes.ListType{
				ElemType: JobEmailNotifications_SdkV2{}.Type(ctx),
			},
			"environment_key":     types.StringType,
			"existing_cluster_id": types.StringType,
			"for_each_task": basetypes.ListType{
				ElemType: ForEachTask_SdkV2{}.Type(ctx),
			},
			"gen_ai_compute_task": basetypes.ListType{
				ElemType: GenAiComputeTask_SdkV2{}.Type(ctx),
			},
			"health": basetypes.ListType{
				ElemType: JobsHealthRules_SdkV2{}.Type(ctx),
			},
			"library": basetypes.ListType{
				ElemType: compute_tf.Library_SdkV2{}.Type(ctx),
			},
			"new_cluster": basetypes.ListType{
				ElemType: compute_tf.ClusterSpec_SdkV2{}.Type(ctx),
			},
			"notebook_task": basetypes.ListType{
				ElemType: NotebookTask_SdkV2{}.Type(ctx),
			},
			"notification_settings": basetypes.ListType{
				ElemType: TaskNotificationSettings_SdkV2{}.Type(ctx),
			},
			"pipeline_task": basetypes.ListType{
				ElemType: PipelineTask_SdkV2{}.Type(ctx),
			},
			"power_bi_task": basetypes.ListType{
				ElemType: PowerBiTask_SdkV2{}.Type(ctx),
			},
			"python_wheel_task": basetypes.ListType{
				ElemType: PythonWheelTask_SdkV2{}.Type(ctx),
			},
			"run_if": types.StringType,
			"run_job_task": basetypes.ListType{
				ElemType: RunJobTask_SdkV2{}.Type(ctx),
			},
			"spark_jar_task": basetypes.ListType{
				ElemType: SparkJarTask_SdkV2{}.Type(ctx),
			},
			"spark_python_task": basetypes.ListType{
				ElemType: SparkPythonTask_SdkV2{}.Type(ctx),
			},
			"spark_submit_task": basetypes.ListType{
				ElemType: SparkSubmitTask_SdkV2{}.Type(ctx),
			},
			"sql_task": basetypes.ListType{
				ElemType: SqlTask_SdkV2{}.Type(ctx),
			},
			"task_key":        types.StringType,
			"timeout_seconds": types.Int64Type,
			"webhook_notifications": basetypes.ListType{
				ElemType: WebhookNotifications_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCleanRoomsNotebookTask returns the value of the CleanRoomsNotebookTask field in SubmitTask_SdkV2 as
// a CleanRoomsNotebookTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetCleanRoomsNotebookTask(ctx context.Context) (CleanRoomsNotebookTask_SdkV2, bool) {
	var e CleanRoomsNotebookTask_SdkV2
	if m.CleanRoomsNotebookTask.IsNull() || m.CleanRoomsNotebookTask.IsUnknown() {
		return e, false
	}
	var v []CleanRoomsNotebookTask_SdkV2
	d := m.CleanRoomsNotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCleanRoomsNotebookTask sets the value of the CleanRoomsNotebookTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetCleanRoomsNotebookTask(ctx context.Context, v CleanRoomsNotebookTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["clean_rooms_notebook_task"]
	m.CleanRoomsNotebookTask = types.ListValueMust(t, vs)
}

// GetConditionTask returns the value of the ConditionTask field in SubmitTask_SdkV2 as
// a ConditionTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetConditionTask(ctx context.Context) (ConditionTask_SdkV2, bool) {
	var e ConditionTask_SdkV2
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v []ConditionTask_SdkV2
	d := m.ConditionTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetConditionTask sets the value of the ConditionTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetConditionTask(ctx context.Context, v ConditionTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["condition_task"]
	m.ConditionTask = types.ListValueMust(t, vs)
}

// GetDashboardTask returns the value of the DashboardTask field in SubmitTask_SdkV2 as
// a DashboardTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetDashboardTask(ctx context.Context) (DashboardTask_SdkV2, bool) {
	var e DashboardTask_SdkV2
	if m.DashboardTask.IsNull() || m.DashboardTask.IsUnknown() {
		return e, false
	}
	var v []DashboardTask_SdkV2
	d := m.DashboardTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDashboardTask sets the value of the DashboardTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetDashboardTask(ctx context.Context, v DashboardTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboard_task"]
	m.DashboardTask = types.ListValueMust(t, vs)
}

// GetDbtCloudTask returns the value of the DbtCloudTask field in SubmitTask_SdkV2 as
// a DbtCloudTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetDbtCloudTask(ctx context.Context) (DbtCloudTask_SdkV2, bool) {
	var e DbtCloudTask_SdkV2
	if m.DbtCloudTask.IsNull() || m.DbtCloudTask.IsUnknown() {
		return e, false
	}
	var v []DbtCloudTask_SdkV2
	d := m.DbtCloudTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtCloudTask sets the value of the DbtCloudTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetDbtCloudTask(ctx context.Context, v DbtCloudTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_cloud_task"]
	m.DbtCloudTask = types.ListValueMust(t, vs)
}

// GetDbtPlatformTask returns the value of the DbtPlatformTask field in SubmitTask_SdkV2 as
// a DbtPlatformTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetDbtPlatformTask(ctx context.Context) (DbtPlatformTask_SdkV2, bool) {
	var e DbtPlatformTask_SdkV2
	if m.DbtPlatformTask.IsNull() || m.DbtPlatformTask.IsUnknown() {
		return e, false
	}
	var v []DbtPlatformTask_SdkV2
	d := m.DbtPlatformTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtPlatformTask sets the value of the DbtPlatformTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetDbtPlatformTask(ctx context.Context, v DbtPlatformTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_platform_task"]
	m.DbtPlatformTask = types.ListValueMust(t, vs)
}

// GetDbtTask returns the value of the DbtTask field in SubmitTask_SdkV2 as
// a DbtTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetDbtTask(ctx context.Context) (DbtTask_SdkV2, bool) {
	var e DbtTask_SdkV2
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v []DbtTask_SdkV2
	d := m.DbtTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtTask sets the value of the DbtTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetDbtTask(ctx context.Context, v DbtTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_task"]
	m.DbtTask = types.ListValueMust(t, vs)
}

// GetDependsOn returns the value of the DependsOn field in SubmitTask_SdkV2 as
// a slice of TaskDependency_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetDependsOn(ctx context.Context) ([]TaskDependency_SdkV2, bool) {
	if m.DependsOn.IsNull() || m.DependsOn.IsUnknown() {
		return nil, false
	}
	var v []TaskDependency_SdkV2
	d := m.DependsOn.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependsOn sets the value of the DependsOn field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetDependsOn(ctx context.Context, v []TaskDependency_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["depends_on"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DependsOn = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in SubmitTask_SdkV2 as
// a JobEmailNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetEmailNotifications(ctx context.Context) (JobEmailNotifications_SdkV2, bool) {
	var e JobEmailNotifications_SdkV2
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v []JobEmailNotifications_SdkV2
	d := m.EmailNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEmailNotifications sets the value of the EmailNotifications field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetEmailNotifications(ctx context.Context, v JobEmailNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_notifications"]
	m.EmailNotifications = types.ListValueMust(t, vs)
}

// GetForEachTask returns the value of the ForEachTask field in SubmitTask_SdkV2 as
// a ForEachTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetForEachTask(ctx context.Context) (ForEachTask_SdkV2, bool) {
	var e ForEachTask_SdkV2
	if m.ForEachTask.IsNull() || m.ForEachTask.IsUnknown() {
		return e, false
	}
	var v []ForEachTask_SdkV2
	d := m.ForEachTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetForEachTask sets the value of the ForEachTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetForEachTask(ctx context.Context, v ForEachTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["for_each_task"]
	m.ForEachTask = types.ListValueMust(t, vs)
}

// GetGenAiComputeTask returns the value of the GenAiComputeTask field in SubmitTask_SdkV2 as
// a GenAiComputeTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetGenAiComputeTask(ctx context.Context) (GenAiComputeTask_SdkV2, bool) {
	var e GenAiComputeTask_SdkV2
	if m.GenAiComputeTask.IsNull() || m.GenAiComputeTask.IsUnknown() {
		return e, false
	}
	var v []GenAiComputeTask_SdkV2
	d := m.GenAiComputeTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGenAiComputeTask sets the value of the GenAiComputeTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetGenAiComputeTask(ctx context.Context, v GenAiComputeTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gen_ai_compute_task"]
	m.GenAiComputeTask = types.ListValueMust(t, vs)
}

// GetHealth returns the value of the Health field in SubmitTask_SdkV2 as
// a JobsHealthRules_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetHealth(ctx context.Context) (JobsHealthRules_SdkV2, bool) {
	var e JobsHealthRules_SdkV2
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v []JobsHealthRules_SdkV2
	d := m.Health.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetHealth sets the value of the Health field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetHealth(ctx context.Context, v JobsHealthRules_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["health"]
	m.Health = types.ListValueMust(t, vs)
}

// GetLibraries returns the value of the Libraries field in SubmitTask_SdkV2 as
// a slice of compute_tf.Library_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetLibraries(ctx context.Context) ([]compute_tf.Library_SdkV2, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library_SdkV2
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetLibraries(ctx context.Context, v []compute_tf.Library_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in SubmitTask_SdkV2 as
// a compute_tf.ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec_SdkV2, bool) {
	var e compute_tf.ClusterSpec_SdkV2
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v []compute_tf.ClusterSpec_SdkV2
	d := m.NewCluster.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewCluster sets the value of the NewCluster field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_cluster"]
	m.NewCluster = types.ListValueMust(t, vs)
}

// GetNotebookTask returns the value of the NotebookTask field in SubmitTask_SdkV2 as
// a NotebookTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetNotebookTask(ctx context.Context) (NotebookTask_SdkV2, bool) {
	var e NotebookTask_SdkV2
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v []NotebookTask_SdkV2
	d := m.NotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotebookTask sets the value of the NotebookTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetNotebookTask(ctx context.Context, v NotebookTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_task"]
	m.NotebookTask = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in SubmitTask_SdkV2 as
// a TaskNotificationSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetNotificationSettings(ctx context.Context) (TaskNotificationSettings_SdkV2, bool) {
	var e TaskNotificationSettings_SdkV2
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v []TaskNotificationSettings_SdkV2
	d := m.NotificationSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotificationSettings sets the value of the NotificationSettings field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetNotificationSettings(ctx context.Context, v TaskNotificationSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notification_settings"]
	m.NotificationSettings = types.ListValueMust(t, vs)
}

// GetPipelineTask returns the value of the PipelineTask field in SubmitTask_SdkV2 as
// a PipelineTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetPipelineTask(ctx context.Context) (PipelineTask_SdkV2, bool) {
	var e PipelineTask_SdkV2
	if m.PipelineTask.IsNull() || m.PipelineTask.IsUnknown() {
		return e, false
	}
	var v []PipelineTask_SdkV2
	d := m.PipelineTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineTask sets the value of the PipelineTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetPipelineTask(ctx context.Context, v PipelineTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_task"]
	m.PipelineTask = types.ListValueMust(t, vs)
}

// GetPowerBiTask returns the value of the PowerBiTask field in SubmitTask_SdkV2 as
// a PowerBiTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetPowerBiTask(ctx context.Context) (PowerBiTask_SdkV2, bool) {
	var e PowerBiTask_SdkV2
	if m.PowerBiTask.IsNull() || m.PowerBiTask.IsUnknown() {
		return e, false
	}
	var v []PowerBiTask_SdkV2
	d := m.PowerBiTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPowerBiTask sets the value of the PowerBiTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetPowerBiTask(ctx context.Context, v PowerBiTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["power_bi_task"]
	m.PowerBiTask = types.ListValueMust(t, vs)
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in SubmitTask_SdkV2 as
// a PythonWheelTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetPythonWheelTask(ctx context.Context) (PythonWheelTask_SdkV2, bool) {
	var e PythonWheelTask_SdkV2
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v []PythonWheelTask_SdkV2
	d := m.PythonWheelTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetPythonWheelTask(ctx context.Context, v PythonWheelTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_wheel_task"]
	m.PythonWheelTask = types.ListValueMust(t, vs)
}

// GetRunJobTask returns the value of the RunJobTask field in SubmitTask_SdkV2 as
// a RunJobTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetRunJobTask(ctx context.Context) (RunJobTask_SdkV2, bool) {
	var e RunJobTask_SdkV2
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v []RunJobTask_SdkV2
	d := m.RunJobTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunJobTask sets the value of the RunJobTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetRunJobTask(ctx context.Context, v RunJobTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_job_task"]
	m.RunJobTask = types.ListValueMust(t, vs)
}

// GetSparkJarTask returns the value of the SparkJarTask field in SubmitTask_SdkV2 as
// a SparkJarTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetSparkJarTask(ctx context.Context) (SparkJarTask_SdkV2, bool) {
	var e SparkJarTask_SdkV2
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v []SparkJarTask_SdkV2
	d := m.SparkJarTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkJarTask sets the value of the SparkJarTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetSparkJarTask(ctx context.Context, v SparkJarTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_jar_task"]
	m.SparkJarTask = types.ListValueMust(t, vs)
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in SubmitTask_SdkV2 as
// a SparkPythonTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetSparkPythonTask(ctx context.Context) (SparkPythonTask_SdkV2, bool) {
	var e SparkPythonTask_SdkV2
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v []SparkPythonTask_SdkV2
	d := m.SparkPythonTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetSparkPythonTask(ctx context.Context, v SparkPythonTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_python_task"]
	m.SparkPythonTask = types.ListValueMust(t, vs)
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in SubmitTask_SdkV2 as
// a SparkSubmitTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetSparkSubmitTask(ctx context.Context) (SparkSubmitTask_SdkV2, bool) {
	var e SparkSubmitTask_SdkV2
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v []SparkSubmitTask_SdkV2
	d := m.SparkSubmitTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetSparkSubmitTask(ctx context.Context, v SparkSubmitTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_task"]
	m.SparkSubmitTask = types.ListValueMust(t, vs)
}

// GetSqlTask returns the value of the SqlTask field in SubmitTask_SdkV2 as
// a SqlTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetSqlTask(ctx context.Context) (SqlTask_SdkV2, bool) {
	var e SqlTask_SdkV2
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v []SqlTask_SdkV2
	d := m.SqlTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSqlTask sets the value of the SqlTask field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetSqlTask(ctx context.Context, v SqlTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_task"]
	m.SqlTask = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in SubmitTask_SdkV2 as
// a WebhookNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask_SdkV2) GetWebhookNotifications(ctx context.Context) (WebhookNotifications_SdkV2, bool) {
	var e WebhookNotifications_SdkV2
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v []WebhookNotifications_SdkV2
	d := m.WebhookNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in SubmitTask_SdkV2.
func (m *SubmitTask_SdkV2) SetWebhookNotifications(ctx context.Context, v WebhookNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["webhook_notifications"]
	m.WebhookNotifications = types.ListValueMust(t, vs)
}

type Subscription_SdkV2 struct {
	// Optional: Allows users to specify a custom subject line on the email sent
	// to subscribers.
	CustomSubject types.String `tfsdk:"custom_subject"`
	// When true, the subscription will not send emails.
	Paused types.Bool `tfsdk:"paused"`
	// The list of subscribers to send the snapshot of the dashboard to.
	Subscribers types.List `tfsdk:"subscribers"`
}

func (to *Subscription_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Subscription_SdkV2) {
	if !from.Subscribers.IsNull() && !from.Subscribers.IsUnknown() && to.Subscribers.IsNull() && len(from.Subscribers.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscribers, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscribers = from.Subscribers
	}
}

func (to *Subscription_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Subscription_SdkV2) {
	if !from.Subscribers.IsNull() && !from.Subscribers.IsUnknown() && to.Subscribers.IsNull() && len(from.Subscribers.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscribers, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscribers = from.Subscribers
	}
}

func (m Subscription_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["custom_subject"] = attrs["custom_subject"].SetOptional()
	attrs["paused"] = attrs["paused"].SetOptional()
	attrs["subscribers"] = attrs["subscribers"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Subscription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Subscription_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscribers": reflect.TypeOf(SubscriptionSubscriber_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Subscription_SdkV2
// only implements ToObjectValue() and Type().
func (m Subscription_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"custom_subject": m.CustomSubject,
			"paused":         m.Paused,
			"subscribers":    m.Subscribers,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Subscription_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"custom_subject": types.StringType,
			"paused":         types.BoolType,
			"subscribers": basetypes.ListType{
				ElemType: SubscriptionSubscriber_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetSubscribers returns the value of the Subscribers field in Subscription_SdkV2 as
// a slice of SubscriptionSubscriber_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Subscription_SdkV2) GetSubscribers(ctx context.Context) ([]SubscriptionSubscriber_SdkV2, bool) {
	if m.Subscribers.IsNull() || m.Subscribers.IsUnknown() {
		return nil, false
	}
	var v []SubscriptionSubscriber_SdkV2
	d := m.Subscribers.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscribers sets the value of the Subscribers field in Subscription_SdkV2.
func (m *Subscription_SdkV2) SetSubscribers(ctx context.Context, v []SubscriptionSubscriber_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscribers"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscribers = types.ListValueMust(t, vs)
}

type SubscriptionSubscriber_SdkV2 struct {
	// A snapshot of the dashboard will be sent to the destination when the
	// `destination_id` field is present.
	DestinationId types.String `tfsdk:"destination_id"`
	// A snapshot of the dashboard will be sent to the user's email when the
	// `user_name` field is present.
	UserName types.String `tfsdk:"user_name"`
}

func (to *SubscriptionSubscriber_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubscriptionSubscriber_SdkV2) {
}

func (to *SubscriptionSubscriber_SdkV2) SyncFieldsDuringRead(ctx context.Context, from SubscriptionSubscriber_SdkV2) {
}

func (m SubscriptionSubscriber_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetComputed()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubscriptionSubscriber.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubscriptionSubscriber_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubscriptionSubscriber_SdkV2
// only implements ToObjectValue() and Type().
func (m SubscriptionSubscriber_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id": m.DestinationId,
			"user_name":      m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubscriptionSubscriber_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id": types.StringType,
			"user_name":      types.StringType,
		},
	}
}

type TableState_SdkV2 struct {
	// Whether or not the table has seen updates since either the creation of
	// the trigger or the last successful evaluation of the trigger
	HasSeenUpdates types.Bool `tfsdk:"has_seen_updates"`
	// Full table name of the table to monitor, e.g.
	// `mycatalog.myschema.mytable`
	TableName types.String `tfsdk:"table_name"`
}

func (to *TableState_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableState_SdkV2) {
}

func (to *TableState_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableState_SdkV2) {
}

func (m TableState_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_seen_updates"] = attrs["has_seen_updates"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableState_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableState_SdkV2
// only implements ToObjectValue() and Type().
func (m TableState_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_seen_updates": m.HasSeenUpdates,
			"table_name":       m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableState_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_seen_updates": types.BoolType,
			"table_name":       types.StringType,
		},
	}
}

type TableTriggerState_SdkV2 struct {
	LastSeenTableStates types.List `tfsdk:"last_seen_table_states"`
	// Indicates whether the trigger is using scalable monitoring.
	UsingScalableMonitoring types.Bool `tfsdk:"using_scalable_monitoring"`
}

func (to *TableTriggerState_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableTriggerState_SdkV2) {
	if !from.LastSeenTableStates.IsNull() && !from.LastSeenTableStates.IsUnknown() && to.LastSeenTableStates.IsNull() && len(from.LastSeenTableStates.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for LastSeenTableStates, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.LastSeenTableStates = from.LastSeenTableStates
	}
}

func (to *TableTriggerState_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableTriggerState_SdkV2) {
	if !from.LastSeenTableStates.IsNull() && !from.LastSeenTableStates.IsUnknown() && to.LastSeenTableStates.IsNull() && len(from.LastSeenTableStates.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for LastSeenTableStates, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.LastSeenTableStates = from.LastSeenTableStates
	}
}

func (m TableTriggerState_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_seen_table_states"] = attrs["last_seen_table_states"].SetOptional()
	attrs["using_scalable_monitoring"] = attrs["using_scalable_monitoring"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableTriggerState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableTriggerState_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"last_seen_table_states": reflect.TypeOf(TableState_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableTriggerState_SdkV2
// only implements ToObjectValue() and Type().
func (m TableTriggerState_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_seen_table_states":    m.LastSeenTableStates,
			"using_scalable_monitoring": m.UsingScalableMonitoring,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableTriggerState_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_seen_table_states": basetypes.ListType{
				ElemType: TableState_SdkV2{}.Type(ctx),
			},
			"using_scalable_monitoring": types.BoolType,
		},
	}
}

// GetLastSeenTableStates returns the value of the LastSeenTableStates field in TableTriggerState_SdkV2 as
// a slice of TableState_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableTriggerState_SdkV2) GetLastSeenTableStates(ctx context.Context) ([]TableState_SdkV2, bool) {
	if m.LastSeenTableStates.IsNull() || m.LastSeenTableStates.IsUnknown() {
		return nil, false
	}
	var v []TableState_SdkV2
	d := m.LastSeenTableStates.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLastSeenTableStates sets the value of the LastSeenTableStates field in TableTriggerState_SdkV2.
func (m *TableTriggerState_SdkV2) SetLastSeenTableStates(ctx context.Context, v []TableState_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["last_seen_table_states"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.LastSeenTableStates = types.ListValueMust(t, vs)
}

type TableUpdateTriggerConfiguration_SdkV2 struct {
	// The table(s) condition based on which to trigger a job run.
	Condition types.String `tfsdk:"condition"`
	// If set, the trigger starts a run only after the specified amount of time
	// has passed since the last time the trigger fired. The minimum allowed
	// value is 60 seconds.
	MinTimeBetweenTriggersSeconds types.Int64 `tfsdk:"min_time_between_triggers_seconds"`
	// A list of Delta tables to monitor for changes. The table name must be in
	// the format `catalog_name.schema_name.table_name`.
	TableNames types.List `tfsdk:"table_names"`
	// If set, the trigger starts a run only after no table updates have
	// occurred for the specified time and can be used to wait for a series of
	// table updates before triggering a run. The minimum allowed value is 60
	// seconds.
	WaitAfterLastChangeSeconds types.Int64 `tfsdk:"wait_after_last_change_seconds"`
}

func (to *TableUpdateTriggerConfiguration_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableUpdateTriggerConfiguration_SdkV2) {
	if !from.TableNames.IsNull() && !from.TableNames.IsUnknown() && to.TableNames.IsNull() && len(from.TableNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TableNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TableNames = from.TableNames
	}
}

func (to *TableUpdateTriggerConfiguration_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TableUpdateTriggerConfiguration_SdkV2) {
	if !from.TableNames.IsNull() && !from.TableNames.IsUnknown() && to.TableNames.IsNull() && len(from.TableNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TableNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TableNames = from.TableNames
	}
}

func (m TableUpdateTriggerConfiguration_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["condition"] = attrs["condition"].SetOptional()
	attrs["min_time_between_triggers_seconds"] = attrs["min_time_between_triggers_seconds"].SetOptional()
	attrs["table_names"] = attrs["table_names"].SetOptional()
	attrs["wait_after_last_change_seconds"] = attrs["wait_after_last_change_seconds"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableUpdateTriggerConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableUpdateTriggerConfiguration_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"table_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableUpdateTriggerConfiguration_SdkV2
// only implements ToObjectValue() and Type().
func (m TableUpdateTriggerConfiguration_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"condition":                         m.Condition,
			"min_time_between_triggers_seconds": m.MinTimeBetweenTriggersSeconds,
			"table_names":                       m.TableNames,
			"wait_after_last_change_seconds":    m.WaitAfterLastChangeSeconds,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableUpdateTriggerConfiguration_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"condition":                         types.StringType,
			"min_time_between_triggers_seconds": types.Int64Type,
			"table_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wait_after_last_change_seconds": types.Int64Type,
		},
	}
}

// GetTableNames returns the value of the TableNames field in TableUpdateTriggerConfiguration_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableUpdateTriggerConfiguration_SdkV2) GetTableNames(ctx context.Context) ([]types.String, bool) {
	if m.TableNames.IsNull() || m.TableNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.TableNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTableNames sets the value of the TableNames field in TableUpdateTriggerConfiguration_SdkV2.
func (m *TableUpdateTriggerConfiguration_SdkV2) SetTableNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TableNames = types.ListValueMust(t, vs)
}

type Task_SdkV2 struct {
	// The task runs a [clean rooms] notebook when the
	// `clean_rooms_notebook_task` field is present.
	//
	// [clean rooms]: https://docs.databricks.com/clean-rooms/index.html
	CleanRoomsNotebookTask types.List `tfsdk:"clean_rooms_notebook_task"`
	// The task evaluates a condition that can be used to control the execution
	// of other tasks when the `condition_task` field is present. The condition
	// task does not require a cluster to execute and does not support retries
	// or notifications.
	ConditionTask types.List `tfsdk:"condition_task"`
	// The task refreshes a dashboard and sends a snapshot to subscribers.
	DashboardTask types.List `tfsdk:"dashboard_task"`
	// Task type for dbt cloud, deprecated in favor of the new name
	// dbt_platform_task
	DbtCloudTask types.List `tfsdk:"dbt_cloud_task"`

	DbtPlatformTask types.List `tfsdk:"dbt_platform_task"`
	// The task runs one or more dbt commands when the `dbt_task` field is
	// present. The dbt task requires both Databricks SQL and the ability to use
	// a serverless or a pro SQL warehouse.
	DbtTask types.List `tfsdk:"dbt_task"`
	// An optional array of objects specifying the dependency graph of the task.
	// All tasks specified in this field must complete before executing this
	// task. The task will run only if the `run_if` condition is true. The key
	// is `task_key`, and the value is the name assigned to the dependent task.
	DependsOn types.List `tfsdk:"depends_on"`
	// An optional description for this task.
	Description types.String `tfsdk:"description"`
	// An option to disable auto optimization in serverless
	DisableAutoOptimization types.Bool `tfsdk:"disable_auto_optimization"`
	// An optional flag to disable the task. If set to true, the task will not
	// run even if it is part of a job.
	Disabled types.Bool `tfsdk:"disabled"`
	// An optional set of email addresses that is notified when runs of this
	// task begin or complete as well as when this task is deleted. The default
	// behavior is to not send any emails.
	EmailNotifications types.List `tfsdk:"email_notifications"`
	// The key that references an environment spec in a job. This field is
	// required for Python script, Python wheel and dbt tasks when using
	// serverless compute.
	EnvironmentKey types.String `tfsdk:"environment_key"`
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// The task executes a nested task for every input provided when the
	// `for_each_task` field is present.
	ForEachTask types.List `tfsdk:"for_each_task"`

	GenAiComputeTask types.List `tfsdk:"gen_ai_compute_task"`

	Health types.List `tfsdk:"health"`
	// If job_cluster_key, this task is executed reusing the cluster specified
	// in `job.settings.job_clusters`.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// An optional maximum number of times to retry an unsuccessful run. A run
	// is considered to be unsuccessful if it completes with the `FAILED`
	// result_state or `INTERNAL_ERROR` `life_cycle_state`. The value `-1` means
	// to retry indefinitely and the value `0` means to never retry.
	MaxRetries types.Int64 `tfsdk:"max_retries"`
	// An optional minimal interval in milliseconds between the start of the
	// failed run and the subsequent retry run. The default behavior is that
	// unsuccessful runs are immediately retried.
	MinRetryIntervalMillis types.Int64 `tfsdk:"min_retry_interval_millis"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.List `tfsdk:"new_cluster"`
	// The task runs a notebook when the `notebook_task` field is present.
	NotebookTask types.List `tfsdk:"notebook_task"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// task.
	NotificationSettings types.List `tfsdk:"notification_settings"`
	// The task triggers a pipeline update when the `pipeline_task` field is
	// present. Only pipelines configured to use triggered more are supported.
	PipelineTask types.List `tfsdk:"pipeline_task"`
	// The task triggers a Power BI semantic model update when the
	// `power_bi_task` field is present.
	PowerBiTask types.List `tfsdk:"power_bi_task"`
	// The task runs a Python wheel when the `python_wheel_task` field is
	// present.
	PythonWheelTask types.List `tfsdk:"python_wheel_task"`
	// An optional policy to specify whether to retry a job when it times out.
	// The default behavior is to not retry on timeout.
	RetryOnTimeout types.Bool `tfsdk:"retry_on_timeout"`
	// An optional value specifying the condition determining whether the task
	// is run once its dependencies have been completed.
	//
	// * `ALL_SUCCESS`: All dependencies have executed and succeeded *
	// `AT_LEAST_ONE_SUCCESS`: At least one dependency has succeeded *
	// `NONE_FAILED`: None of the dependencies have failed and at least one was
	// executed * `ALL_DONE`: All dependencies have been completed *
	// `AT_LEAST_ONE_FAILED`: At least one dependency failed * `ALL_FAILED`: ALl
	// dependencies have failed
	RunIf types.String `tfsdk:"run_if"`
	// The task triggers another job when the `run_job_task` field is present.
	RunJobTask types.List `tfsdk:"run_job_task"`
	// The task runs a JAR when the `spark_jar_task` field is present.
	SparkJarTask types.List `tfsdk:"spark_jar_task"`
	// The task runs a Python file when the `spark_python_task` field is
	// present.
	SparkPythonTask types.List `tfsdk:"spark_python_task"`
	// (Legacy) The task runs the spark-submit script when the spark_submit_task
	// field is present. Databricks recommends using the spark_jar_task instead;
	// see [Spark Submit task for jobs](/jobs/spark-submit).
	SparkSubmitTask types.List `tfsdk:"spark_submit_task"`
	// The task runs a SQL query or file, or it refreshes a SQL alert or a
	// legacy SQL dashboard when the `sql_task` field is present.
	SqlTask types.List `tfsdk:"sql_task"`
	// A unique name for the task. This field is used to refer to this task from
	// other tasks. This field is required and must be unique within its parent
	// job. On Update or Reset, this field is used to reference the tasks to be
	// updated or reset.
	TaskKey types.String `tfsdk:"task_key"`
	// An optional timeout applied to each run of this job task. A value of `0`
	// means no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A collection of system notification IDs to notify when runs of this task
	// begin or complete. The default behavior is to not send any system
	// notifications.
	WebhookNotifications types.List `tfsdk:"webhook_notifications"`
}

func (to *Task_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Task_SdkV2) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookTask
				toCleanRoomsNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				// Recursively sync the fields of DashboardTask
				toDashboardTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				// Recursively sync the fields of DbtCloudTask
				toDbtCloudTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				// Recursively sync the fields of DbtPlatformTask
				toDbtPlatformTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				// Recursively sync the fields of ForEachTask
				toForEachTask.SyncFieldsDuringCreateOrUpdate(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				// Recursively sync the fields of GenAiComputeTask
				toGenAiComputeTask.SyncFieldsDuringCreateOrUpdate(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				// Recursively sync the fields of PipelineTask
				toPipelineTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				// Recursively sync the fields of PowerBiTask
				toPowerBiTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *Task_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Task_SdkV2) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				toCleanRoomsNotebookTask.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				toDashboardTask.SyncFieldsDuringRead(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				toDbtCloudTask.SyncFieldsDuringRead(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				toDbtPlatformTask.SyncFieldsDuringRead(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				toForEachTask.SyncFieldsDuringRead(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				toGenAiComputeTask.SyncFieldsDuringRead(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				toPipelineTask.SyncFieldsDuringRead(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				toPowerBiTask.SyncFieldsDuringRead(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m Task_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].SetOptional()
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dashboard_task"] = attrs["dashboard_task"].SetOptional()
	attrs["dashboard_task"] = attrs["dashboard_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].SetOptional()
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].SetOptional()
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["depends_on"] = attrs["depends_on"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["disable_auto_optimization"] = attrs["disable_auto_optimization"].SetOptional()
	attrs["disabled"] = attrs["disabled"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["environment_key"] = attrs["environment_key"].SetOptional()
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].SetOptional()
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["health"] = attrs["health"].SetOptional()
	attrs["health"] = attrs["health"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["max_retries"] = attrs["max_retries"].SetOptional()
	attrs["min_retry_interval_millis"] = attrs["min_retry_interval_millis"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["pipeline_task"] = attrs["pipeline_task"].SetOptional()
	attrs["pipeline_task"] = attrs["pipeline_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["power_bi_task"] = attrs["power_bi_task"].SetOptional()
	attrs["power_bi_task"] = attrs["power_bi_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["retry_on_timeout"] = attrs["retry_on_timeout"].SetOptional()
	attrs["run_if"] = attrs["run_if"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["task_key"] = attrs["task_key"].SetRequired()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Task.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Task_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_task": reflect.TypeOf(CleanRoomsNotebookTask_SdkV2{}),
		"condition_task":            reflect.TypeOf(ConditionTask_SdkV2{}),
		"dashboard_task":            reflect.TypeOf(DashboardTask_SdkV2{}),
		"dbt_cloud_task":            reflect.TypeOf(DbtCloudTask_SdkV2{}),
		"dbt_platform_task":         reflect.TypeOf(DbtPlatformTask_SdkV2{}),
		"dbt_task":                  reflect.TypeOf(DbtTask_SdkV2{}),
		"depends_on":                reflect.TypeOf(TaskDependency_SdkV2{}),
		"email_notifications":       reflect.TypeOf(TaskEmailNotifications_SdkV2{}),
		"for_each_task":             reflect.TypeOf(ForEachTask_SdkV2{}),
		"gen_ai_compute_task":       reflect.TypeOf(GenAiComputeTask_SdkV2{}),
		"health":                    reflect.TypeOf(JobsHealthRules_SdkV2{}),
		"library":                   reflect.TypeOf(compute_tf.Library_SdkV2{}),
		"new_cluster":               reflect.TypeOf(compute_tf.ClusterSpec_SdkV2{}),
		"notebook_task":             reflect.TypeOf(NotebookTask_SdkV2{}),
		"notification_settings":     reflect.TypeOf(TaskNotificationSettings_SdkV2{}),
		"pipeline_task":             reflect.TypeOf(PipelineTask_SdkV2{}),
		"power_bi_task":             reflect.TypeOf(PowerBiTask_SdkV2{}),
		"python_wheel_task":         reflect.TypeOf(PythonWheelTask_SdkV2{}),
		"run_job_task":              reflect.TypeOf(RunJobTask_SdkV2{}),
		"spark_jar_task":            reflect.TypeOf(SparkJarTask_SdkV2{}),
		"spark_python_task":         reflect.TypeOf(SparkPythonTask_SdkV2{}),
		"spark_submit_task":         reflect.TypeOf(SparkSubmitTask_SdkV2{}),
		"sql_task":                  reflect.TypeOf(SqlTask_SdkV2{}),
		"webhook_notifications":     reflect.TypeOf(WebhookNotifications_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Task_SdkV2
// only implements ToObjectValue() and Type().
func (m Task_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_rooms_notebook_task": m.CleanRoomsNotebookTask,
			"condition_task":            m.ConditionTask,
			"dashboard_task":            m.DashboardTask,
			"dbt_cloud_task":            m.DbtCloudTask,
			"dbt_platform_task":         m.DbtPlatformTask,
			"dbt_task":                  m.DbtTask,
			"depends_on":                m.DependsOn,
			"description":               m.Description,
			"disable_auto_optimization": m.DisableAutoOptimization,
			"disabled":                  m.Disabled,
			"email_notifications":       m.EmailNotifications,
			"environment_key":           m.EnvironmentKey,
			"existing_cluster_id":       m.ExistingClusterId,
			"for_each_task":             m.ForEachTask,
			"gen_ai_compute_task":       m.GenAiComputeTask,
			"health":                    m.Health,
			"job_cluster_key":           m.JobClusterKey,
			"library":                   m.Libraries,
			"max_retries":               m.MaxRetries,
			"min_retry_interval_millis": m.MinRetryIntervalMillis,
			"new_cluster":               m.NewCluster,
			"notebook_task":             m.NotebookTask,
			"notification_settings":     m.NotificationSettings,
			"pipeline_task":             m.PipelineTask,
			"power_bi_task":             m.PowerBiTask,
			"python_wheel_task":         m.PythonWheelTask,
			"retry_on_timeout":          m.RetryOnTimeout,
			"run_if":                    m.RunIf,
			"run_job_task":              m.RunJobTask,
			"spark_jar_task":            m.SparkJarTask,
			"spark_python_task":         m.SparkPythonTask,
			"spark_submit_task":         m.SparkSubmitTask,
			"sql_task":                  m.SqlTask,
			"task_key":                  m.TaskKey,
			"timeout_seconds":           m.TimeoutSeconds,
			"webhook_notifications":     m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Task_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_rooms_notebook_task": basetypes.ListType{
				ElemType: CleanRoomsNotebookTask_SdkV2{}.Type(ctx),
			},
			"condition_task": basetypes.ListType{
				ElemType: ConditionTask_SdkV2{}.Type(ctx),
			},
			"dashboard_task": basetypes.ListType{
				ElemType: DashboardTask_SdkV2{}.Type(ctx),
			},
			"dbt_cloud_task": basetypes.ListType{
				ElemType: DbtCloudTask_SdkV2{}.Type(ctx),
			},
			"dbt_platform_task": basetypes.ListType{
				ElemType: DbtPlatformTask_SdkV2{}.Type(ctx),
			},
			"dbt_task": basetypes.ListType{
				ElemType: DbtTask_SdkV2{}.Type(ctx),
			},
			"depends_on": basetypes.ListType{
				ElemType: TaskDependency_SdkV2{}.Type(ctx),
			},
			"description":               types.StringType,
			"disable_auto_optimization": types.BoolType,
			"disabled":                  types.BoolType,
			"email_notifications": basetypes.ListType{
				ElemType: TaskEmailNotifications_SdkV2{}.Type(ctx),
			},
			"environment_key":     types.StringType,
			"existing_cluster_id": types.StringType,
			"for_each_task": basetypes.ListType{
				ElemType: ForEachTask_SdkV2{}.Type(ctx),
			},
			"gen_ai_compute_task": basetypes.ListType{
				ElemType: GenAiComputeTask_SdkV2{}.Type(ctx),
			},
			"health": basetypes.ListType{
				ElemType: JobsHealthRules_SdkV2{}.Type(ctx),
			},
			"job_cluster_key": types.StringType,
			"library": basetypes.ListType{
				ElemType: compute_tf.Library_SdkV2{}.Type(ctx),
			},
			"max_retries":               types.Int64Type,
			"min_retry_interval_millis": types.Int64Type,
			"new_cluster": basetypes.ListType{
				ElemType: compute_tf.ClusterSpec_SdkV2{}.Type(ctx),
			},
			"notebook_task": basetypes.ListType{
				ElemType: NotebookTask_SdkV2{}.Type(ctx),
			},
			"notification_settings": basetypes.ListType{
				ElemType: TaskNotificationSettings_SdkV2{}.Type(ctx),
			},
			"pipeline_task": basetypes.ListType{
				ElemType: PipelineTask_SdkV2{}.Type(ctx),
			},
			"power_bi_task": basetypes.ListType{
				ElemType: PowerBiTask_SdkV2{}.Type(ctx),
			},
			"python_wheel_task": basetypes.ListType{
				ElemType: PythonWheelTask_SdkV2{}.Type(ctx),
			},
			"retry_on_timeout": types.BoolType,
			"run_if":           types.StringType,
			"run_job_task": basetypes.ListType{
				ElemType: RunJobTask_SdkV2{}.Type(ctx),
			},
			"spark_jar_task": basetypes.ListType{
				ElemType: SparkJarTask_SdkV2{}.Type(ctx),
			},
			"spark_python_task": basetypes.ListType{
				ElemType: SparkPythonTask_SdkV2{}.Type(ctx),
			},
			"spark_submit_task": basetypes.ListType{
				ElemType: SparkSubmitTask_SdkV2{}.Type(ctx),
			},
			"sql_task": basetypes.ListType{
				ElemType: SqlTask_SdkV2{}.Type(ctx),
			},
			"task_key":        types.StringType,
			"timeout_seconds": types.Int64Type,
			"webhook_notifications": basetypes.ListType{
				ElemType: WebhookNotifications_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetCleanRoomsNotebookTask returns the value of the CleanRoomsNotebookTask field in Task_SdkV2 as
// a CleanRoomsNotebookTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetCleanRoomsNotebookTask(ctx context.Context) (CleanRoomsNotebookTask_SdkV2, bool) {
	var e CleanRoomsNotebookTask_SdkV2
	if m.CleanRoomsNotebookTask.IsNull() || m.CleanRoomsNotebookTask.IsUnknown() {
		return e, false
	}
	var v []CleanRoomsNotebookTask_SdkV2
	d := m.CleanRoomsNotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetCleanRoomsNotebookTask sets the value of the CleanRoomsNotebookTask field in Task_SdkV2.
func (m *Task_SdkV2) SetCleanRoomsNotebookTask(ctx context.Context, v CleanRoomsNotebookTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["clean_rooms_notebook_task"]
	m.CleanRoomsNotebookTask = types.ListValueMust(t, vs)
}

// GetConditionTask returns the value of the ConditionTask field in Task_SdkV2 as
// a ConditionTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetConditionTask(ctx context.Context) (ConditionTask_SdkV2, bool) {
	var e ConditionTask_SdkV2
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v []ConditionTask_SdkV2
	d := m.ConditionTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetConditionTask sets the value of the ConditionTask field in Task_SdkV2.
func (m *Task_SdkV2) SetConditionTask(ctx context.Context, v ConditionTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["condition_task"]
	m.ConditionTask = types.ListValueMust(t, vs)
}

// GetDashboardTask returns the value of the DashboardTask field in Task_SdkV2 as
// a DashboardTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetDashboardTask(ctx context.Context) (DashboardTask_SdkV2, bool) {
	var e DashboardTask_SdkV2
	if m.DashboardTask.IsNull() || m.DashboardTask.IsUnknown() {
		return e, false
	}
	var v []DashboardTask_SdkV2
	d := m.DashboardTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDashboardTask sets the value of the DashboardTask field in Task_SdkV2.
func (m *Task_SdkV2) SetDashboardTask(ctx context.Context, v DashboardTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboard_task"]
	m.DashboardTask = types.ListValueMust(t, vs)
}

// GetDbtCloudTask returns the value of the DbtCloudTask field in Task_SdkV2 as
// a DbtCloudTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetDbtCloudTask(ctx context.Context) (DbtCloudTask_SdkV2, bool) {
	var e DbtCloudTask_SdkV2
	if m.DbtCloudTask.IsNull() || m.DbtCloudTask.IsUnknown() {
		return e, false
	}
	var v []DbtCloudTask_SdkV2
	d := m.DbtCloudTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtCloudTask sets the value of the DbtCloudTask field in Task_SdkV2.
func (m *Task_SdkV2) SetDbtCloudTask(ctx context.Context, v DbtCloudTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_cloud_task"]
	m.DbtCloudTask = types.ListValueMust(t, vs)
}

// GetDbtPlatformTask returns the value of the DbtPlatformTask field in Task_SdkV2 as
// a DbtPlatformTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetDbtPlatformTask(ctx context.Context) (DbtPlatformTask_SdkV2, bool) {
	var e DbtPlatformTask_SdkV2
	if m.DbtPlatformTask.IsNull() || m.DbtPlatformTask.IsUnknown() {
		return e, false
	}
	var v []DbtPlatformTask_SdkV2
	d := m.DbtPlatformTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtPlatformTask sets the value of the DbtPlatformTask field in Task_SdkV2.
func (m *Task_SdkV2) SetDbtPlatformTask(ctx context.Context, v DbtPlatformTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_platform_task"]
	m.DbtPlatformTask = types.ListValueMust(t, vs)
}

// GetDbtTask returns the value of the DbtTask field in Task_SdkV2 as
// a DbtTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetDbtTask(ctx context.Context) (DbtTask_SdkV2, bool) {
	var e DbtTask_SdkV2
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v []DbtTask_SdkV2
	d := m.DbtTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetDbtTask sets the value of the DbtTask field in Task_SdkV2.
func (m *Task_SdkV2) SetDbtTask(ctx context.Context, v DbtTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_task"]
	m.DbtTask = types.ListValueMust(t, vs)
}

// GetDependsOn returns the value of the DependsOn field in Task_SdkV2 as
// a slice of TaskDependency_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetDependsOn(ctx context.Context) ([]TaskDependency_SdkV2, bool) {
	if m.DependsOn.IsNull() || m.DependsOn.IsUnknown() {
		return nil, false
	}
	var v []TaskDependency_SdkV2
	d := m.DependsOn.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependsOn sets the value of the DependsOn field in Task_SdkV2.
func (m *Task_SdkV2) SetDependsOn(ctx context.Context, v []TaskDependency_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["depends_on"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DependsOn = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in Task_SdkV2 as
// a TaskEmailNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetEmailNotifications(ctx context.Context) (TaskEmailNotifications_SdkV2, bool) {
	var e TaskEmailNotifications_SdkV2
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v []TaskEmailNotifications_SdkV2
	d := m.EmailNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetEmailNotifications sets the value of the EmailNotifications field in Task_SdkV2.
func (m *Task_SdkV2) SetEmailNotifications(ctx context.Context, v TaskEmailNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["email_notifications"]
	m.EmailNotifications = types.ListValueMust(t, vs)
}

// GetForEachTask returns the value of the ForEachTask field in Task_SdkV2 as
// a ForEachTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetForEachTask(ctx context.Context) (ForEachTask_SdkV2, bool) {
	var e ForEachTask_SdkV2
	if m.ForEachTask.IsNull() || m.ForEachTask.IsUnknown() {
		return e, false
	}
	var v []ForEachTask_SdkV2
	d := m.ForEachTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetForEachTask sets the value of the ForEachTask field in Task_SdkV2.
func (m *Task_SdkV2) SetForEachTask(ctx context.Context, v ForEachTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["for_each_task"]
	m.ForEachTask = types.ListValueMust(t, vs)
}

// GetGenAiComputeTask returns the value of the GenAiComputeTask field in Task_SdkV2 as
// a GenAiComputeTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetGenAiComputeTask(ctx context.Context) (GenAiComputeTask_SdkV2, bool) {
	var e GenAiComputeTask_SdkV2
	if m.GenAiComputeTask.IsNull() || m.GenAiComputeTask.IsUnknown() {
		return e, false
	}
	var v []GenAiComputeTask_SdkV2
	d := m.GenAiComputeTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetGenAiComputeTask sets the value of the GenAiComputeTask field in Task_SdkV2.
func (m *Task_SdkV2) SetGenAiComputeTask(ctx context.Context, v GenAiComputeTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["gen_ai_compute_task"]
	m.GenAiComputeTask = types.ListValueMust(t, vs)
}

// GetHealth returns the value of the Health field in Task_SdkV2 as
// a JobsHealthRules_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetHealth(ctx context.Context) (JobsHealthRules_SdkV2, bool) {
	var e JobsHealthRules_SdkV2
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v []JobsHealthRules_SdkV2
	d := m.Health.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetHealth sets the value of the Health field in Task_SdkV2.
func (m *Task_SdkV2) SetHealth(ctx context.Context, v JobsHealthRules_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["health"]
	m.Health = types.ListValueMust(t, vs)
}

// GetLibraries returns the value of the Libraries field in Task_SdkV2 as
// a slice of compute_tf.Library_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetLibraries(ctx context.Context) ([]compute_tf.Library_SdkV2, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library_SdkV2
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in Task_SdkV2.
func (m *Task_SdkV2) SetLibraries(ctx context.Context, v []compute_tf.Library_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in Task_SdkV2 as
// a compute_tf.ClusterSpec_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec_SdkV2, bool) {
	var e compute_tf.ClusterSpec_SdkV2
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v []compute_tf.ClusterSpec_SdkV2
	d := m.NewCluster.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewCluster sets the value of the NewCluster field in Task_SdkV2.
func (m *Task_SdkV2) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_cluster"]
	m.NewCluster = types.ListValueMust(t, vs)
}

// GetNotebookTask returns the value of the NotebookTask field in Task_SdkV2 as
// a NotebookTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetNotebookTask(ctx context.Context) (NotebookTask_SdkV2, bool) {
	var e NotebookTask_SdkV2
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v []NotebookTask_SdkV2
	d := m.NotebookTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotebookTask sets the value of the NotebookTask field in Task_SdkV2.
func (m *Task_SdkV2) SetNotebookTask(ctx context.Context, v NotebookTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_task"]
	m.NotebookTask = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in Task_SdkV2 as
// a TaskNotificationSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetNotificationSettings(ctx context.Context) (TaskNotificationSettings_SdkV2, bool) {
	var e TaskNotificationSettings_SdkV2
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v []TaskNotificationSettings_SdkV2
	d := m.NotificationSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNotificationSettings sets the value of the NotificationSettings field in Task_SdkV2.
func (m *Task_SdkV2) SetNotificationSettings(ctx context.Context, v TaskNotificationSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notification_settings"]
	m.NotificationSettings = types.ListValueMust(t, vs)
}

// GetPipelineTask returns the value of the PipelineTask field in Task_SdkV2 as
// a PipelineTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetPipelineTask(ctx context.Context) (PipelineTask_SdkV2, bool) {
	var e PipelineTask_SdkV2
	if m.PipelineTask.IsNull() || m.PipelineTask.IsUnknown() {
		return e, false
	}
	var v []PipelineTask_SdkV2
	d := m.PipelineTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPipelineTask sets the value of the PipelineTask field in Task_SdkV2.
func (m *Task_SdkV2) SetPipelineTask(ctx context.Context, v PipelineTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["pipeline_task"]
	m.PipelineTask = types.ListValueMust(t, vs)
}

// GetPowerBiTask returns the value of the PowerBiTask field in Task_SdkV2 as
// a PowerBiTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetPowerBiTask(ctx context.Context) (PowerBiTask_SdkV2, bool) {
	var e PowerBiTask_SdkV2
	if m.PowerBiTask.IsNull() || m.PowerBiTask.IsUnknown() {
		return e, false
	}
	var v []PowerBiTask_SdkV2
	d := m.PowerBiTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPowerBiTask sets the value of the PowerBiTask field in Task_SdkV2.
func (m *Task_SdkV2) SetPowerBiTask(ctx context.Context, v PowerBiTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["power_bi_task"]
	m.PowerBiTask = types.ListValueMust(t, vs)
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in Task_SdkV2 as
// a PythonWheelTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetPythonWheelTask(ctx context.Context) (PythonWheelTask_SdkV2, bool) {
	var e PythonWheelTask_SdkV2
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v []PythonWheelTask_SdkV2
	d := m.PythonWheelTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in Task_SdkV2.
func (m *Task_SdkV2) SetPythonWheelTask(ctx context.Context, v PythonWheelTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_wheel_task"]
	m.PythonWheelTask = types.ListValueMust(t, vs)
}

// GetRunJobTask returns the value of the RunJobTask field in Task_SdkV2 as
// a RunJobTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetRunJobTask(ctx context.Context) (RunJobTask_SdkV2, bool) {
	var e RunJobTask_SdkV2
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v []RunJobTask_SdkV2
	d := m.RunJobTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRunJobTask sets the value of the RunJobTask field in Task_SdkV2.
func (m *Task_SdkV2) SetRunJobTask(ctx context.Context, v RunJobTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["run_job_task"]
	m.RunJobTask = types.ListValueMust(t, vs)
}

// GetSparkJarTask returns the value of the SparkJarTask field in Task_SdkV2 as
// a SparkJarTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetSparkJarTask(ctx context.Context) (SparkJarTask_SdkV2, bool) {
	var e SparkJarTask_SdkV2
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v []SparkJarTask_SdkV2
	d := m.SparkJarTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkJarTask sets the value of the SparkJarTask field in Task_SdkV2.
func (m *Task_SdkV2) SetSparkJarTask(ctx context.Context, v SparkJarTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_jar_task"]
	m.SparkJarTask = types.ListValueMust(t, vs)
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in Task_SdkV2 as
// a SparkPythonTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetSparkPythonTask(ctx context.Context) (SparkPythonTask_SdkV2, bool) {
	var e SparkPythonTask_SdkV2
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v []SparkPythonTask_SdkV2
	d := m.SparkPythonTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in Task_SdkV2.
func (m *Task_SdkV2) SetSparkPythonTask(ctx context.Context, v SparkPythonTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_python_task"]
	m.SparkPythonTask = types.ListValueMust(t, vs)
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in Task_SdkV2 as
// a SparkSubmitTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetSparkSubmitTask(ctx context.Context) (SparkSubmitTask_SdkV2, bool) {
	var e SparkSubmitTask_SdkV2
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v []SparkSubmitTask_SdkV2
	d := m.SparkSubmitTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in Task_SdkV2.
func (m *Task_SdkV2) SetSparkSubmitTask(ctx context.Context, v SparkSubmitTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_task"]
	m.SparkSubmitTask = types.ListValueMust(t, vs)
}

// GetSqlTask returns the value of the SqlTask field in Task_SdkV2 as
// a SqlTask_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetSqlTask(ctx context.Context) (SqlTask_SdkV2, bool) {
	var e SqlTask_SdkV2
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v []SqlTask_SdkV2
	d := m.SqlTask.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetSqlTask sets the value of the SqlTask field in Task_SdkV2.
func (m *Task_SdkV2) SetSqlTask(ctx context.Context, v SqlTask_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_task"]
	m.SqlTask = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in Task_SdkV2 as
// a WebhookNotifications_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task_SdkV2) GetWebhookNotifications(ctx context.Context) (WebhookNotifications_SdkV2, bool) {
	var e WebhookNotifications_SdkV2
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v []WebhookNotifications_SdkV2
	d := m.WebhookNotifications.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in Task_SdkV2.
func (m *Task_SdkV2) SetWebhookNotifications(ctx context.Context, v WebhookNotifications_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["webhook_notifications"]
	m.WebhookNotifications = types.ListValueMust(t, vs)
}

type TaskDependency_SdkV2 struct {
	// Can only be specified on condition task dependencies. The outcome of the
	// dependent task that must be met for this task to run.
	Outcome types.String `tfsdk:"outcome"`
	// The name of the task this task depends on.
	TaskKey types.String `tfsdk:"task_key"`
}

func (to *TaskDependency_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TaskDependency_SdkV2) {
}

func (to *TaskDependency_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TaskDependency_SdkV2) {
}

func (m TaskDependency_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["outcome"] = attrs["outcome"].SetOptional()
	attrs["task_key"] = attrs["task_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TaskDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TaskDependency_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TaskDependency_SdkV2
// only implements ToObjectValue() and Type().
func (m TaskDependency_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"outcome":  m.Outcome,
			"task_key": m.TaskKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TaskDependency_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"outcome":  types.StringType,
			"task_key": types.StringType,
		},
	}
}

type TaskEmailNotifications_SdkV2 struct {
	// If true, do not send email to recipients specified in `on_failure` if the
	// run is skipped. This field is `deprecated`. Please use the
	// `notification_settings.no_alert_for_skipped_runs` field.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
	// A list of email addresses to be notified when the duration of a run
	// exceeds the threshold specified for the `RUN_DURATION_SECONDS` metric in
	// the `health` field. If no rule for the `RUN_DURATION_SECONDS` metric is
	// specified in the `health` field for the job, notifications are not sent.
	OnDurationWarningThresholdExceeded types.List `tfsdk:"on_duration_warning_threshold_exceeded"`
	// A list of email addresses to be notified when a run unsuccessfully
	// completes. A run is considered to have completed unsuccessfully if it
	// ends with an `INTERNAL_ERROR` `life_cycle_state` or a `FAILED`, or
	// `TIMED_OUT` result_state. If this is not specified on job creation,
	// reset, or update the list is empty, and notifications are not sent.
	OnFailure types.List `tfsdk:"on_failure"`
	// A list of email addresses to be notified when a run begins. If not
	// specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnStart types.List `tfsdk:"on_start"`
	// A list of email addresses to notify when any streaming backlog thresholds
	// are exceeded for any stream. Streaming backlog thresholds can be set in
	// the `health` field using the following metrics:
	// `STREAMING_BACKLOG_BYTES`, `STREAMING_BACKLOG_RECORDS`,
	// `STREAMING_BACKLOG_SECONDS`, or `STREAMING_BACKLOG_FILES`. Alerting is
	// based on the 10-minute average of these metrics. If the issue persists,
	// notifications are resent every 30 minutes.
	OnStreamingBacklogExceeded types.List `tfsdk:"on_streaming_backlog_exceeded"`
	// A list of email addresses to be notified when a run successfully
	// completes. A run is considered to have completed successfully if it ends
	// with a `TERMINATED` `life_cycle_state` and a `SUCCESS` result_state. If
	// not specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnSuccess types.List `tfsdk:"on_success"`
}

func (to *TaskEmailNotifications_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TaskEmailNotifications_SdkV2) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (to *TaskEmailNotifications_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TaskEmailNotifications_SdkV2) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (m TaskEmailNotifications_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()
	attrs["on_duration_warning_threshold_exceeded"] = attrs["on_duration_warning_threshold_exceeded"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_start"] = attrs["on_start"].SetOptional()
	attrs["on_streaming_backlog_exceeded"] = attrs["on_streaming_backlog_exceeded"].SetOptional()
	attrs["on_success"] = attrs["on_success"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TaskEmailNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TaskEmailNotifications_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_duration_warning_threshold_exceeded": reflect.TypeOf(types.String{}),
		"on_failure":                             reflect.TypeOf(types.String{}),
		"on_start":                               reflect.TypeOf(types.String{}),
		"on_streaming_backlog_exceeded":          reflect.TypeOf(types.String{}),
		"on_success":                             reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TaskEmailNotifications_SdkV2
// only implements ToObjectValue() and Type().
func (m TaskEmailNotifications_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"no_alert_for_skipped_runs":              m.NoAlertForSkippedRuns,
			"on_duration_warning_threshold_exceeded": m.OnDurationWarningThresholdExceeded,
			"on_failure":                             m.OnFailure,
			"on_start":                               m.OnStart,
			"on_streaming_backlog_exceeded":          m.OnStreamingBacklogExceeded,
			"on_success":                             m.OnSuccess,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TaskEmailNotifications_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"no_alert_for_skipped_runs": types.BoolType,
			"on_duration_warning_threshold_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_failure": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_start": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_streaming_backlog_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_success": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOnDurationWarningThresholdExceeded returns the value of the OnDurationWarningThresholdExceeded field in TaskEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications_SdkV2) GetOnDurationWarningThresholdExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnDurationWarningThresholdExceeded.IsNull() || m.OnDurationWarningThresholdExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnDurationWarningThresholdExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnDurationWarningThresholdExceeded sets the value of the OnDurationWarningThresholdExceeded field in TaskEmailNotifications_SdkV2.
func (m *TaskEmailNotifications_SdkV2) SetOnDurationWarningThresholdExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_duration_warning_threshold_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnDurationWarningThresholdExceeded = types.ListValueMust(t, vs)
}

// GetOnFailure returns the value of the OnFailure field in TaskEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications_SdkV2) GetOnFailure(ctx context.Context) ([]types.String, bool) {
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in TaskEmailNotifications_SdkV2.
func (m *TaskEmailNotifications_SdkV2) SetOnFailure(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnStart returns the value of the OnStart field in TaskEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications_SdkV2) GetOnStart(ctx context.Context) ([]types.String, bool) {
	if m.OnStart.IsNull() || m.OnStart.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStart.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStart sets the value of the OnStart field in TaskEmailNotifications_SdkV2.
func (m *TaskEmailNotifications_SdkV2) SetOnStart(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_start"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStart = types.ListValueMust(t, vs)
}

// GetOnStreamingBacklogExceeded returns the value of the OnStreamingBacklogExceeded field in TaskEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications_SdkV2) GetOnStreamingBacklogExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnStreamingBacklogExceeded.IsNull() || m.OnStreamingBacklogExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStreamingBacklogExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStreamingBacklogExceeded sets the value of the OnStreamingBacklogExceeded field in TaskEmailNotifications_SdkV2.
func (m *TaskEmailNotifications_SdkV2) SetOnStreamingBacklogExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_streaming_backlog_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStreamingBacklogExceeded = types.ListValueMust(t, vs)
}

// GetOnSuccess returns the value of the OnSuccess field in TaskEmailNotifications_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications_SdkV2) GetOnSuccess(ctx context.Context) ([]types.String, bool) {
	if m.OnSuccess.IsNull() || m.OnSuccess.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnSuccess.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnSuccess sets the value of the OnSuccess field in TaskEmailNotifications_SdkV2.
func (m *TaskEmailNotifications_SdkV2) SetOnSuccess(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_success"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnSuccess = types.ListValueMust(t, vs)
}

type TaskNotificationSettings_SdkV2 struct {
	// If true, do not send notifications to recipients specified in `on_start`
	// for the retried runs and do not send notifications to recipients
	// specified in `on_failure` until the last retry of the run.
	AlertOnLastAttempt types.Bool `tfsdk:"alert_on_last_attempt"`
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is canceled.
	NoAlertForCanceledRuns types.Bool `tfsdk:"no_alert_for_canceled_runs"`
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is skipped.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
}

func (to *TaskNotificationSettings_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TaskNotificationSettings_SdkV2) {
}

func (to *TaskNotificationSettings_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TaskNotificationSettings_SdkV2) {
}

func (m TaskNotificationSettings_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_on_last_attempt"] = attrs["alert_on_last_attempt"].SetOptional()
	attrs["no_alert_for_canceled_runs"] = attrs["no_alert_for_canceled_runs"].SetOptional()
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TaskNotificationSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TaskNotificationSettings_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TaskNotificationSettings_SdkV2
// only implements ToObjectValue() and Type().
func (m TaskNotificationSettings_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_on_last_attempt":      m.AlertOnLastAttempt,
			"no_alert_for_canceled_runs": m.NoAlertForCanceledRuns,
			"no_alert_for_skipped_runs":  m.NoAlertForSkippedRuns,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TaskNotificationSettings_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_on_last_attempt":      types.BoolType,
			"no_alert_for_canceled_runs": types.BoolType,
			"no_alert_for_skipped_runs":  types.BoolType,
		},
	}
}

type TerminationDetails_SdkV2 struct {
	Code types.String `tfsdk:"code"`
	// A descriptive message with the termination details. This field is
	// unstructured and the format might change.
	Message types.String `tfsdk:"message"`

	Type_ types.String `tfsdk:"type"`
}

func (to *TerminationDetails_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TerminationDetails_SdkV2) {
}

func (to *TerminationDetails_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TerminationDetails_SdkV2) {
}

func (m TerminationDetails_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["code"] = attrs["code"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TerminationDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TerminationDetails_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TerminationDetails_SdkV2
// only implements ToObjectValue() and Type().
func (m TerminationDetails_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"code":    m.Code,
			"message": m.Message,
			"type":    m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TerminationDetails_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"code":    types.StringType,
			"message": types.StringType,
			"type":    types.StringType,
		},
	}
}

// Additional details about what triggered the run
type TriggerInfo_SdkV2 struct {
	// The run id of the Run Job task run
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *TriggerInfo_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggerInfo_SdkV2) {
}

func (to *TriggerInfo_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TriggerInfo_SdkV2) {
}

func (m TriggerInfo_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggerInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggerInfo_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggerInfo_SdkV2
// only implements ToObjectValue() and Type().
func (m TriggerInfo_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggerInfo_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type TriggerSettings_SdkV2 struct {
	// File arrival trigger settings.
	FileArrival types.List `tfsdk:"file_arrival"`
	// Whether this trigger is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// Periodic trigger settings.
	Periodic types.List `tfsdk:"periodic"`
	// Old table trigger settings name. Deprecated in favor of `table_update`.
	Table types.List `tfsdk:"table"`

	TableUpdate types.List `tfsdk:"table_update"`
}

func (to *TriggerSettings_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggerSettings_SdkV2) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				// Recursively sync the fields of FileArrival
				toFileArrival.SyncFieldsDuringCreateOrUpdate(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Periodic.IsNull() && !from.Periodic.IsUnknown() {
		if toPeriodic, ok := to.GetPeriodic(ctx); ok {
			if fromPeriodic, ok := from.GetPeriodic(ctx); ok {
				// Recursively sync the fields of Periodic
				toPeriodic.SyncFieldsDuringCreateOrUpdate(ctx, fromPeriodic)
				to.SetPeriodic(ctx, toPeriodic)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
	if !from.TableUpdate.IsNull() && !from.TableUpdate.IsUnknown() {
		if toTableUpdate, ok := to.GetTableUpdate(ctx); ok {
			if fromTableUpdate, ok := from.GetTableUpdate(ctx); ok {
				// Recursively sync the fields of TableUpdate
				toTableUpdate.SyncFieldsDuringCreateOrUpdate(ctx, fromTableUpdate)
				to.SetTableUpdate(ctx, toTableUpdate)
			}
		}
	}
}

func (to *TriggerSettings_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TriggerSettings_SdkV2) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				toFileArrival.SyncFieldsDuringRead(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Periodic.IsNull() && !from.Periodic.IsUnknown() {
		if toPeriodic, ok := to.GetPeriodic(ctx); ok {
			if fromPeriodic, ok := from.GetPeriodic(ctx); ok {
				toPeriodic.SyncFieldsDuringRead(ctx, fromPeriodic)
				to.SetPeriodic(ctx, toPeriodic)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
	if !from.TableUpdate.IsNull() && !from.TableUpdate.IsUnknown() {
		if toTableUpdate, ok := to.GetTableUpdate(ctx); ok {
			if fromTableUpdate, ok := from.GetTableUpdate(ctx); ok {
				toTableUpdate.SyncFieldsDuringRead(ctx, fromTableUpdate)
				to.SetTableUpdate(ctx, toTableUpdate)
			}
		}
	}
}

func (m TriggerSettings_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["file_arrival"] = attrs["file_arrival"].SetOptional()
	attrs["file_arrival"] = attrs["file_arrival"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["periodic"] = attrs["periodic"].SetOptional()
	attrs["periodic"] = attrs["periodic"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table"] = attrs["table"].SetOptional()
	attrs["table"] = attrs["table"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table_update"] = attrs["table_update"].SetOptional()
	attrs["table_update"] = attrs["table_update"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggerSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggerSettings_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"file_arrival": reflect.TypeOf(FileArrivalTriggerConfiguration_SdkV2{}),
		"periodic":     reflect.TypeOf(PeriodicTriggerConfiguration_SdkV2{}),
		"table":        reflect.TypeOf(TableUpdateTriggerConfiguration_SdkV2{}),
		"table_update": reflect.TypeOf(TableUpdateTriggerConfiguration_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggerSettings_SdkV2
// only implements ToObjectValue() and Type().
func (m TriggerSettings_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"file_arrival": m.FileArrival,
			"pause_status": m.PauseStatus,
			"periodic":     m.Periodic,
			"table":        m.Table,
			"table_update": m.TableUpdate,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggerSettings_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"file_arrival": basetypes.ListType{
				ElemType: FileArrivalTriggerConfiguration_SdkV2{}.Type(ctx),
			},
			"pause_status": types.StringType,
			"periodic": basetypes.ListType{
				ElemType: PeriodicTriggerConfiguration_SdkV2{}.Type(ctx),
			},
			"table": basetypes.ListType{
				ElemType: TableUpdateTriggerConfiguration_SdkV2{}.Type(ctx),
			},
			"table_update": basetypes.ListType{
				ElemType: TableUpdateTriggerConfiguration_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetFileArrival returns the value of the FileArrival field in TriggerSettings_SdkV2 as
// a FileArrivalTriggerConfiguration_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings_SdkV2) GetFileArrival(ctx context.Context) (FileArrivalTriggerConfiguration_SdkV2, bool) {
	var e FileArrivalTriggerConfiguration_SdkV2
	if m.FileArrival.IsNull() || m.FileArrival.IsUnknown() {
		return e, false
	}
	var v []FileArrivalTriggerConfiguration_SdkV2
	d := m.FileArrival.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFileArrival sets the value of the FileArrival field in TriggerSettings_SdkV2.
func (m *TriggerSettings_SdkV2) SetFileArrival(ctx context.Context, v FileArrivalTriggerConfiguration_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file_arrival"]
	m.FileArrival = types.ListValueMust(t, vs)
}

// GetPeriodic returns the value of the Periodic field in TriggerSettings_SdkV2 as
// a PeriodicTriggerConfiguration_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings_SdkV2) GetPeriodic(ctx context.Context) (PeriodicTriggerConfiguration_SdkV2, bool) {
	var e PeriodicTriggerConfiguration_SdkV2
	if m.Periodic.IsNull() || m.Periodic.IsUnknown() {
		return e, false
	}
	var v []PeriodicTriggerConfiguration_SdkV2
	d := m.Periodic.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPeriodic sets the value of the Periodic field in TriggerSettings_SdkV2.
func (m *TriggerSettings_SdkV2) SetPeriodic(ctx context.Context, v PeriodicTriggerConfiguration_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["periodic"]
	m.Periodic = types.ListValueMust(t, vs)
}

// GetTable returns the value of the Table field in TriggerSettings_SdkV2 as
// a TableUpdateTriggerConfiguration_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings_SdkV2) GetTable(ctx context.Context) (TableUpdateTriggerConfiguration_SdkV2, bool) {
	var e TableUpdateTriggerConfiguration_SdkV2
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v []TableUpdateTriggerConfiguration_SdkV2
	d := m.Table.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTable sets the value of the Table field in TriggerSettings_SdkV2.
func (m *TriggerSettings_SdkV2) SetTable(ctx context.Context, v TableUpdateTriggerConfiguration_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table"]
	m.Table = types.ListValueMust(t, vs)
}

// GetTableUpdate returns the value of the TableUpdate field in TriggerSettings_SdkV2 as
// a TableUpdateTriggerConfiguration_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings_SdkV2) GetTableUpdate(ctx context.Context) (TableUpdateTriggerConfiguration_SdkV2, bool) {
	var e TableUpdateTriggerConfiguration_SdkV2
	if m.TableUpdate.IsNull() || m.TableUpdate.IsUnknown() {
		return e, false
	}
	var v []TableUpdateTriggerConfiguration_SdkV2
	d := m.TableUpdate.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTableUpdate sets the value of the TableUpdate field in TriggerSettings_SdkV2.
func (m *TriggerSettings_SdkV2) SetTableUpdate(ctx context.Context, v TableUpdateTriggerConfiguration_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table_update"]
	m.TableUpdate = types.ListValueMust(t, vs)
}

type TriggerStateProto_SdkV2 struct {
	FileArrival types.List `tfsdk:"file_arrival"`

	Table types.List `tfsdk:"table"`
}

func (to *TriggerStateProto_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggerStateProto_SdkV2) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				// Recursively sync the fields of FileArrival
				toFileArrival.SyncFieldsDuringCreateOrUpdate(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (to *TriggerStateProto_SdkV2) SyncFieldsDuringRead(ctx context.Context, from TriggerStateProto_SdkV2) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				toFileArrival.SyncFieldsDuringRead(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (m TriggerStateProto_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["file_arrival"] = attrs["file_arrival"].SetOptional()
	attrs["file_arrival"] = attrs["file_arrival"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["table"] = attrs["table"].SetOptional()
	attrs["table"] = attrs["table"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggerStateProto.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggerStateProto_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"file_arrival": reflect.TypeOf(FileArrivalTriggerState_SdkV2{}),
		"table":        reflect.TypeOf(TableTriggerState_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggerStateProto_SdkV2
// only implements ToObjectValue() and Type().
func (m TriggerStateProto_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"file_arrival": m.FileArrival,
			"table":        m.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggerStateProto_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"file_arrival": basetypes.ListType{
				ElemType: FileArrivalTriggerState_SdkV2{}.Type(ctx),
			},
			"table": basetypes.ListType{
				ElemType: TableTriggerState_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetFileArrival returns the value of the FileArrival field in TriggerStateProto_SdkV2 as
// a FileArrivalTriggerState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerStateProto_SdkV2) GetFileArrival(ctx context.Context) (FileArrivalTriggerState_SdkV2, bool) {
	var e FileArrivalTriggerState_SdkV2
	if m.FileArrival.IsNull() || m.FileArrival.IsUnknown() {
		return e, false
	}
	var v []FileArrivalTriggerState_SdkV2
	d := m.FileArrival.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetFileArrival sets the value of the FileArrival field in TriggerStateProto_SdkV2.
func (m *TriggerStateProto_SdkV2) SetFileArrival(ctx context.Context, v FileArrivalTriggerState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["file_arrival"]
	m.FileArrival = types.ListValueMust(t, vs)
}

// GetTable returns the value of the Table field in TriggerStateProto_SdkV2 as
// a TableTriggerState_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerStateProto_SdkV2) GetTable(ctx context.Context) (TableTriggerState_SdkV2, bool) {
	var e TableTriggerState_SdkV2
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v []TableTriggerState_SdkV2
	d := m.Table.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetTable sets the value of the Table field in TriggerStateProto_SdkV2.
func (m *TriggerStateProto_SdkV2) SetTable(ctx context.Context, v TableTriggerState_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table"]
	m.Table = types.ListValueMust(t, vs)
}

type UpdateJob_SdkV2 struct {
	// Remove top-level fields in the job settings. Removing nested fields is
	// not supported, except for tasks and job clusters (`tasks/task_1`). This
	// field is optional.
	FieldsToRemove types.List `tfsdk:"fields_to_remove"`
	// The canonical identifier of the job to update. This field is required.
	JobId types.Int64 `tfsdk:"job_id"`
	// The new settings for the job.
	//
	// Top-level fields specified in `new_settings` are completely replaced,
	// except for arrays which are merged. That is, new and existing entries are
	// completely replaced based on the respective key fields, i.e. `task_key`
	// or `job_cluster_key`, while previous entries are kept.
	//
	// Partially updating nested fields is not supported.
	//
	// Changes to the field `JobSettings.timeout_seconds` are applied to active
	// runs. Changes to other fields are applied to future runs only.
	NewSettings types.List `tfsdk:"new_settings"`
}

func (to *UpdateJob_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateJob_SdkV2) {
	if !from.FieldsToRemove.IsNull() && !from.FieldsToRemove.IsUnknown() && to.FieldsToRemove.IsNull() && len(from.FieldsToRemove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for FieldsToRemove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.FieldsToRemove = from.FieldsToRemove
	}
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				// Recursively sync the fields of NewSettings
				toNewSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (to *UpdateJob_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateJob_SdkV2) {
	if !from.FieldsToRemove.IsNull() && !from.FieldsToRemove.IsUnknown() && to.FieldsToRemove.IsNull() && len(from.FieldsToRemove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for FieldsToRemove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.FieldsToRemove = from.FieldsToRemove
	}
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				toNewSettings.SyncFieldsDuringRead(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (m UpdateJob_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["fields_to_remove"] = attrs["fields_to_remove"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["new_settings"] = attrs["new_settings"].SetOptional()
	attrs["new_settings"] = attrs["new_settings"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateJob_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"fields_to_remove": reflect.TypeOf(types.String{}),
		"new_settings":     reflect.TypeOf(JobSettings_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateJob_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateJob_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"fields_to_remove": m.FieldsToRemove,
			"job_id":           m.JobId,
			"new_settings":     m.NewSettings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateJob_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"fields_to_remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_id": types.Int64Type,
			"new_settings": basetypes.ListType{
				ElemType: JobSettings_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetFieldsToRemove returns the value of the FieldsToRemove field in UpdateJob_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateJob_SdkV2) GetFieldsToRemove(ctx context.Context) ([]types.String, bool) {
	if m.FieldsToRemove.IsNull() || m.FieldsToRemove.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.FieldsToRemove.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFieldsToRemove sets the value of the FieldsToRemove field in UpdateJob_SdkV2.
func (m *UpdateJob_SdkV2) SetFieldsToRemove(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["fields_to_remove"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.FieldsToRemove = types.ListValueMust(t, vs)
}

// GetNewSettings returns the value of the NewSettings field in UpdateJob_SdkV2 as
// a JobSettings_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateJob_SdkV2) GetNewSettings(ctx context.Context) (JobSettings_SdkV2, bool) {
	var e JobSettings_SdkV2
	if m.NewSettings.IsNull() || m.NewSettings.IsUnknown() {
		return e, false
	}
	var v []JobSettings_SdkV2
	d := m.NewSettings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetNewSettings sets the value of the NewSettings field in UpdateJob_SdkV2.
func (m *UpdateJob_SdkV2) SetNewSettings(ctx context.Context, v JobSettings_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["new_settings"]
	m.NewSettings = types.ListValueMust(t, vs)
}

type ViewItem_SdkV2 struct {
	// Content of the view.
	Content types.String `tfsdk:"content"`
	// Name of the view item. In the case of code view, it would be the
	// notebook’s name. In the case of dashboard view, it would be the
	// dashboard’s name.
	Name types.String `tfsdk:"name"`
	// Type of the view item.
	Type_ types.String `tfsdk:"type"`
}

func (to *ViewItem_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ViewItem_SdkV2) {
}

func (to *ViewItem_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ViewItem_SdkV2) {
}

func (m ViewItem_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["content"] = attrs["content"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ViewItem.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ViewItem_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ViewItem_SdkV2
// only implements ToObjectValue() and Type().
func (m ViewItem_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"content": m.Content,
			"name":    m.Name,
			"type":    m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ViewItem_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"content": types.StringType,
			"name":    types.StringType,
			"type":    types.StringType,
		},
	}
}

type Webhook_SdkV2 struct {
	Id types.String `tfsdk:"id"`
}

func (to *Webhook_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Webhook_SdkV2) {
}

func (to *Webhook_SdkV2) SyncFieldsDuringRead(ctx context.Context, from Webhook_SdkV2) {
}

func (m Webhook_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Webhook.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Webhook_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Webhook_SdkV2
// only implements ToObjectValue() and Type().
func (m Webhook_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Webhook_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type WebhookNotifications_SdkV2 struct {
	// An optional list of system notification IDs to call when the duration of
	// a run exceeds the threshold specified for the `RUN_DURATION_SECONDS`
	// metric in the `health` field. A maximum of 3 destinations can be
	// specified for the `on_duration_warning_threshold_exceeded` property.
	OnDurationWarningThresholdExceeded types.List `tfsdk:"on_duration_warning_threshold_exceeded"`
	// An optional list of system notification IDs to call when the run fails. A
	// maximum of 3 destinations can be specified for the `on_failure` property.
	OnFailure types.List `tfsdk:"on_failure"`
	// An optional list of system notification IDs to call when the run starts.
	// A maximum of 3 destinations can be specified for the `on_start` property.
	OnStart types.List `tfsdk:"on_start"`
	// An optional list of system notification IDs to call when any streaming
	// backlog thresholds are exceeded for any stream. Streaming backlog
	// thresholds can be set in the `health` field using the following metrics:
	// `STREAMING_BACKLOG_BYTES`, `STREAMING_BACKLOG_RECORDS`,
	// `STREAMING_BACKLOG_SECONDS`, or `STREAMING_BACKLOG_FILES`. Alerting is
	// based on the 10-minute average of these metrics. If the issue persists,
	// notifications are resent every 30 minutes. A maximum of 3 destinations
	// can be specified for the `on_streaming_backlog_exceeded` property.
	OnStreamingBacklogExceeded types.List `tfsdk:"on_streaming_backlog_exceeded"`
	// An optional list of system notification IDs to call when the run
	// completes successfully. A maximum of 3 destinations can be specified for
	// the `on_success` property.
	OnSuccess types.List `tfsdk:"on_success"`
}

func (to *WebhookNotifications_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from WebhookNotifications_SdkV2) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (to *WebhookNotifications_SdkV2) SyncFieldsDuringRead(ctx context.Context, from WebhookNotifications_SdkV2) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (m WebhookNotifications_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_duration_warning_threshold_exceeded"] = attrs["on_duration_warning_threshold_exceeded"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_start"] = attrs["on_start"].SetOptional()
	attrs["on_streaming_backlog_exceeded"] = attrs["on_streaming_backlog_exceeded"].SetOptional()
	attrs["on_success"] = attrs["on_success"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WebhookNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m WebhookNotifications_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_duration_warning_threshold_exceeded": reflect.TypeOf(Webhook_SdkV2{}),
		"on_failure":                             reflect.TypeOf(Webhook_SdkV2{}),
		"on_start":                               reflect.TypeOf(Webhook_SdkV2{}),
		"on_streaming_backlog_exceeded":          reflect.TypeOf(Webhook_SdkV2{}),
		"on_success":                             reflect.TypeOf(Webhook_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WebhookNotifications_SdkV2
// only implements ToObjectValue() and Type().
func (m WebhookNotifications_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"on_duration_warning_threshold_exceeded": m.OnDurationWarningThresholdExceeded,
			"on_failure":                             m.OnFailure,
			"on_start":                               m.OnStart,
			"on_streaming_backlog_exceeded":          m.OnStreamingBacklogExceeded,
			"on_success":                             m.OnSuccess,
		})
}

// Type implements basetypes.ObjectValuable.
func (m WebhookNotifications_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"on_duration_warning_threshold_exceeded": basetypes.ListType{
				ElemType: Webhook_SdkV2{}.Type(ctx),
			},
			"on_failure": basetypes.ListType{
				ElemType: Webhook_SdkV2{}.Type(ctx),
			},
			"on_start": basetypes.ListType{
				ElemType: Webhook_SdkV2{}.Type(ctx),
			},
			"on_streaming_backlog_exceeded": basetypes.ListType{
				ElemType: Webhook_SdkV2{}.Type(ctx),
			},
			"on_success": basetypes.ListType{
				ElemType: Webhook_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetOnDurationWarningThresholdExceeded returns the value of the OnDurationWarningThresholdExceeded field in WebhookNotifications_SdkV2 as
// a slice of Webhook_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications_SdkV2) GetOnDurationWarningThresholdExceeded(ctx context.Context) ([]Webhook_SdkV2, bool) {
	if m.OnDurationWarningThresholdExceeded.IsNull() || m.OnDurationWarningThresholdExceeded.IsUnknown() {
		return nil, false
	}
	var v []Webhook_SdkV2
	d := m.OnDurationWarningThresholdExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnDurationWarningThresholdExceeded sets the value of the OnDurationWarningThresholdExceeded field in WebhookNotifications_SdkV2.
func (m *WebhookNotifications_SdkV2) SetOnDurationWarningThresholdExceeded(ctx context.Context, v []Webhook_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_duration_warning_threshold_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnDurationWarningThresholdExceeded = types.ListValueMust(t, vs)
}

// GetOnFailure returns the value of the OnFailure field in WebhookNotifications_SdkV2 as
// a slice of Webhook_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications_SdkV2) GetOnFailure(ctx context.Context) ([]Webhook_SdkV2, bool) {
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return nil, false
	}
	var v []Webhook_SdkV2
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in WebhookNotifications_SdkV2.
func (m *WebhookNotifications_SdkV2) SetOnFailure(ctx context.Context, v []Webhook_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnStart returns the value of the OnStart field in WebhookNotifications_SdkV2 as
// a slice of Webhook_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications_SdkV2) GetOnStart(ctx context.Context) ([]Webhook_SdkV2, bool) {
	if m.OnStart.IsNull() || m.OnStart.IsUnknown() {
		return nil, false
	}
	var v []Webhook_SdkV2
	d := m.OnStart.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStart sets the value of the OnStart field in WebhookNotifications_SdkV2.
func (m *WebhookNotifications_SdkV2) SetOnStart(ctx context.Context, v []Webhook_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_start"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStart = types.ListValueMust(t, vs)
}

// GetOnStreamingBacklogExceeded returns the value of the OnStreamingBacklogExceeded field in WebhookNotifications_SdkV2 as
// a slice of Webhook_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications_SdkV2) GetOnStreamingBacklogExceeded(ctx context.Context) ([]Webhook_SdkV2, bool) {
	if m.OnStreamingBacklogExceeded.IsNull() || m.OnStreamingBacklogExceeded.IsUnknown() {
		return nil, false
	}
	var v []Webhook_SdkV2
	d := m.OnStreamingBacklogExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStreamingBacklogExceeded sets the value of the OnStreamingBacklogExceeded field in WebhookNotifications_SdkV2.
func (m *WebhookNotifications_SdkV2) SetOnStreamingBacklogExceeded(ctx context.Context, v []Webhook_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_streaming_backlog_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStreamingBacklogExceeded = types.ListValueMust(t, vs)
}

// GetOnSuccess returns the value of the OnSuccess field in WebhookNotifications_SdkV2 as
// a slice of Webhook_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications_SdkV2) GetOnSuccess(ctx context.Context) ([]Webhook_SdkV2, bool) {
	if m.OnSuccess.IsNull() || m.OnSuccess.IsUnknown() {
		return nil, false
	}
	var v []Webhook_SdkV2
	d := m.OnSuccess.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnSuccess sets the value of the OnSuccess field in WebhookNotifications_SdkV2.
func (m *WebhookNotifications_SdkV2) SetOnSuccess(ctx context.Context, v []Webhook_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_success"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnSuccess = types.ListValueMust(t, vs)
}

type WidgetErrorDetail_SdkV2 struct {
	Message types.String `tfsdk:"message"`
}

func (to *WidgetErrorDetail_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from WidgetErrorDetail_SdkV2) {
}

func (to *WidgetErrorDetail_SdkV2) SyncFieldsDuringRead(ctx context.Context, from WidgetErrorDetail_SdkV2) {
}

func (m WidgetErrorDetail_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WidgetErrorDetail.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m WidgetErrorDetail_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WidgetErrorDetail_SdkV2
// only implements ToObjectValue() and Type().
func (m WidgetErrorDetail_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message": m.Message,
		})
}

// Type implements basetypes.ObjectValuable.
func (m WidgetErrorDetail_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message": types.StringType,
		},
	}
}
