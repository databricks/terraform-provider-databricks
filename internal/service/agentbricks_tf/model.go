// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package agentbricks_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type CancelCustomLlmOptimizationRunRequest struct {
	Id types.String `tfsdk:"-"`
}

func (to *CancelCustomLlmOptimizationRunRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelCustomLlmOptimizationRunRequest) {
}

func (to *CancelCustomLlmOptimizationRunRequest) SyncFieldsDuringRead(ctx context.Context, from CancelCustomLlmOptimizationRunRequest) {
}

func (m CancelCustomLlmOptimizationRunRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelCustomLlmOptimizationRunRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelCustomLlmOptimizationRunRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelCustomLlmOptimizationRunRequest
// only implements ToObjectValue() and Type().
func (m CancelCustomLlmOptimizationRunRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CancelCustomLlmOptimizationRunRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type CreateCustomLlmRequest struct {
	// This will soon be deprecated!! Optional: UC path for agent artifacts. If
	// you are using a dataset that you only have read permissions, please
	// provide a destination path where you have write permissions. Please
	// provide this in catalog.schema format.
	AgentArtifactPath types.String `tfsdk:"agent_artifact_path"`
	// Datasets used for training and evaluating the model, not for inference.
	// Currently, only 1 dataset is accepted.
	Datasets types.List `tfsdk:"datasets"`
	// Guidelines for the custom LLM to adhere to
	Guidelines types.List `tfsdk:"guidelines"`
	// Instructions for the custom LLM to follow
	Instructions types.String `tfsdk:"instructions"`
	// Name of the custom LLM. Only alphanumeric characters and dashes allowed.
	Name types.String `tfsdk:"name"`
}

func (to *CreateCustomLlmRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateCustomLlmRequest) {
	if !from.Datasets.IsNull() && !from.Datasets.IsUnknown() && to.Datasets.IsNull() && len(from.Datasets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Datasets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Datasets = from.Datasets
	}
	if !from.Guidelines.IsNull() && !from.Guidelines.IsUnknown() && to.Guidelines.IsNull() && len(from.Guidelines.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Guidelines, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Guidelines = from.Guidelines
	}
}

func (to *CreateCustomLlmRequest) SyncFieldsDuringRead(ctx context.Context, from CreateCustomLlmRequest) {
	if !from.Datasets.IsNull() && !from.Datasets.IsUnknown() && to.Datasets.IsNull() && len(from.Datasets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Datasets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Datasets = from.Datasets
	}
	if !from.Guidelines.IsNull() && !from.Guidelines.IsUnknown() && to.Guidelines.IsNull() && len(from.Guidelines.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Guidelines, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Guidelines = from.Guidelines
	}
}

func (m CreateCustomLlmRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["agent_artifact_path"] = attrs["agent_artifact_path"].SetOptional()
	attrs["datasets"] = attrs["datasets"].SetOptional()
	attrs["guidelines"] = attrs["guidelines"].SetOptional()
	attrs["instructions"] = attrs["instructions"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateCustomLlmRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateCustomLlmRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"datasets":   reflect.TypeOf(Dataset{}),
		"guidelines": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateCustomLlmRequest
// only implements ToObjectValue() and Type().
func (m CreateCustomLlmRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"agent_artifact_path": m.AgentArtifactPath,
			"datasets":            m.Datasets,
			"guidelines":          m.Guidelines,
			"instructions":        m.Instructions,
			"name":                m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateCustomLlmRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"agent_artifact_path": types.StringType,
			"datasets": basetypes.ListType{
				ElemType: Dataset{}.Type(ctx),
			},
			"guidelines": basetypes.ListType{
				ElemType: types.StringType,
			},
			"instructions": types.StringType,
			"name":         types.StringType,
		},
	}
}

// GetDatasets returns the value of the Datasets field in CreateCustomLlmRequest as
// a slice of Dataset values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCustomLlmRequest) GetDatasets(ctx context.Context) ([]Dataset, bool) {
	if m.Datasets.IsNull() || m.Datasets.IsUnknown() {
		return nil, false
	}
	var v []Dataset
	d := m.Datasets.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatasets sets the value of the Datasets field in CreateCustomLlmRequest.
func (m *CreateCustomLlmRequest) SetDatasets(ctx context.Context, v []Dataset) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["datasets"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Datasets = types.ListValueMust(t, vs)
}

// GetGuidelines returns the value of the Guidelines field in CreateCustomLlmRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateCustomLlmRequest) GetGuidelines(ctx context.Context) ([]types.String, bool) {
	if m.Guidelines.IsNull() || m.Guidelines.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Guidelines.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGuidelines sets the value of the Guidelines field in CreateCustomLlmRequest.
func (m *CreateCustomLlmRequest) SetGuidelines(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["guidelines"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Guidelines = types.ListValueMust(t, vs)
}

type CustomLlm struct {
	AgentArtifactPath types.String `tfsdk:"agent_artifact_path"`
	// Creation timestamp of the custom LLM
	CreationTime types.String `tfsdk:"creation_time"`
	// Creator of the custom LLM
	Creator types.String `tfsdk:"creator"`
	// Datasets used for training and evaluating the model, not for inference
	Datasets types.List `tfsdk:"datasets"`
	// Name of the endpoint that will be used to serve the custom LLM
	EndpointName types.String `tfsdk:"endpoint_name"`
	// Guidelines for the custom LLM to adhere to
	Guidelines types.List `tfsdk:"guidelines"`

	Id types.String `tfsdk:"id"`
	// Instructions for the custom LLM to follow
	Instructions types.String `tfsdk:"instructions"`
	// Name of the custom LLM
	Name types.String `tfsdk:"name"`
	// If optimization is kicked off, tracks the state of the custom LLM
	OptimizationState types.String `tfsdk:"optimization_state"`
}

func (to *CustomLlm) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CustomLlm) {
	if !from.Datasets.IsNull() && !from.Datasets.IsUnknown() && to.Datasets.IsNull() && len(from.Datasets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Datasets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Datasets = from.Datasets
	}
	if !from.Guidelines.IsNull() && !from.Guidelines.IsUnknown() && to.Guidelines.IsNull() && len(from.Guidelines.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Guidelines, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Guidelines = from.Guidelines
	}
}

func (to *CustomLlm) SyncFieldsDuringRead(ctx context.Context, from CustomLlm) {
	if !from.Datasets.IsNull() && !from.Datasets.IsUnknown() && to.Datasets.IsNull() && len(from.Datasets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Datasets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Datasets = from.Datasets
	}
	if !from.Guidelines.IsNull() && !from.Guidelines.IsUnknown() && to.Guidelines.IsNull() && len(from.Guidelines.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Guidelines, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Guidelines = from.Guidelines
	}
}

func (m CustomLlm) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["agent_artifact_path"] = attrs["agent_artifact_path"].SetOptional()
	attrs["creation_time"] = attrs["creation_time"].SetComputed()
	attrs["creation_time"] = attrs["creation_time"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["creator"] = attrs["creator"].SetComputed()
	attrs["creator"] = attrs["creator"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["datasets"] = attrs["datasets"].SetOptional()
	attrs["endpoint_name"] = attrs["endpoint_name"].SetComputed()
	attrs["guidelines"] = attrs["guidelines"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["instructions"] = attrs["instructions"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["optimization_state"] = attrs["optimization_state"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CustomLlm.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CustomLlm) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"datasets":   reflect.TypeOf(Dataset{}),
		"guidelines": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CustomLlm
// only implements ToObjectValue() and Type().
func (m CustomLlm) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"agent_artifact_path": m.AgentArtifactPath,
			"creation_time":       m.CreationTime,
			"creator":             m.Creator,
			"datasets":            m.Datasets,
			"endpoint_name":       m.EndpointName,
			"guidelines":          m.Guidelines,
			"id":                  m.Id,
			"instructions":        m.Instructions,
			"name":                m.Name,
			"optimization_state":  m.OptimizationState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CustomLlm) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"agent_artifact_path": types.StringType,
			"creation_time":       types.StringType,
			"creator":             types.StringType,
			"datasets": basetypes.ListType{
				ElemType: Dataset{}.Type(ctx),
			},
			"endpoint_name": types.StringType,
			"guidelines": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id":                 types.StringType,
			"instructions":       types.StringType,
			"name":               types.StringType,
			"optimization_state": types.StringType,
		},
	}
}

// GetDatasets returns the value of the Datasets field in CustomLlm as
// a slice of Dataset values.
// If the field is unknown or null, the boolean return value is false.
func (m *CustomLlm) GetDatasets(ctx context.Context) ([]Dataset, bool) {
	if m.Datasets.IsNull() || m.Datasets.IsUnknown() {
		return nil, false
	}
	var v []Dataset
	d := m.Datasets.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatasets sets the value of the Datasets field in CustomLlm.
func (m *CustomLlm) SetDatasets(ctx context.Context, v []Dataset) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["datasets"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Datasets = types.ListValueMust(t, vs)
}

// GetGuidelines returns the value of the Guidelines field in CustomLlm as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CustomLlm) GetGuidelines(ctx context.Context) ([]types.String, bool) {
	if m.Guidelines.IsNull() || m.Guidelines.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Guidelines.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGuidelines sets the value of the Guidelines field in CustomLlm.
func (m *CustomLlm) SetGuidelines(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["guidelines"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Guidelines = types.ListValueMust(t, vs)
}

type Dataset struct {
	Table types.Object `tfsdk:"table"`
}

func (to *Dataset) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Dataset) {
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (to *Dataset) SyncFieldsDuringRead(ctx context.Context, from Dataset) {
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (m Dataset) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table"] = attrs["table"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Dataset.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Dataset) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"table": reflect.TypeOf(Table{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Dataset
// only implements ToObjectValue() and Type().
func (m Dataset) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table": m.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Dataset) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table": Table{}.Type(ctx),
		},
	}
}

// GetTable returns the value of the Table field in Dataset as
// a Table value.
// If the field is unknown or null, the boolean return value is false.
func (m *Dataset) GetTable(ctx context.Context) (Table, bool) {
	var e Table
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v Table
	d := m.Table.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTable sets the value of the Table field in Dataset.
func (m *Dataset) SetTable(ctx context.Context, v Table) {
	vs := v.ToObjectValue(ctx)
	m.Table = vs
}

type DeleteCustomLlmRequest struct {
	// The id of the custom llm
	Id types.String `tfsdk:"-"`
}

func (to *DeleteCustomLlmRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteCustomLlmRequest) {
}

func (to *DeleteCustomLlmRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteCustomLlmRequest) {
}

func (m DeleteCustomLlmRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCustomLlmRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteCustomLlmRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCustomLlmRequest
// only implements ToObjectValue() and Type().
func (m DeleteCustomLlmRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteCustomLlmRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetCustomLlmRequest struct {
	// The id of the custom llm
	Id types.String `tfsdk:"-"`
}

func (to *GetCustomLlmRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetCustomLlmRequest) {
}

func (to *GetCustomLlmRequest) SyncFieldsDuringRead(ctx context.Context, from GetCustomLlmRequest) {
}

func (m GetCustomLlmRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCustomLlmRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetCustomLlmRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCustomLlmRequest
// only implements ToObjectValue() and Type().
func (m GetCustomLlmRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetCustomLlmRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type StartCustomLlmOptimizationRunRequest struct {
	// The Id of the tile.
	Id types.String `tfsdk:"-"`
}

func (to *StartCustomLlmOptimizationRunRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from StartCustomLlmOptimizationRunRequest) {
}

func (to *StartCustomLlmOptimizationRunRequest) SyncFieldsDuringRead(ctx context.Context, from StartCustomLlmOptimizationRunRequest) {
}

func (m StartCustomLlmOptimizationRunRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in StartCustomLlmOptimizationRunRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m StartCustomLlmOptimizationRunRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, StartCustomLlmOptimizationRunRequest
// only implements ToObjectValue() and Type().
func (m StartCustomLlmOptimizationRunRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m StartCustomLlmOptimizationRunRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type Table struct {
	// Name of the request column
	RequestCol types.String `tfsdk:"request_col"`
	// Optional: Name of the response column if the data is labeled
	ResponseCol types.String `tfsdk:"response_col"`
	// Full UC table path in catalog.schema.table_name format
	TablePath types.String `tfsdk:"table_path"`
}

func (to *Table) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Table) {
}

func (to *Table) SyncFieldsDuringRead(ctx context.Context, from Table) {
}

func (m Table) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["request_col"] = attrs["request_col"].SetRequired()
	attrs["response_col"] = attrs["response_col"].SetOptional()
	attrs["table_path"] = attrs["table_path"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Table.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Table) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Table
// only implements ToObjectValue() and Type().
func (m Table) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"request_col":  m.RequestCol,
			"response_col": m.ResponseCol,
			"table_path":   m.TablePath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Table) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"request_col":  types.StringType,
			"response_col": types.StringType,
			"table_path":   types.StringType,
		},
	}
}

type UpdateCustomLlmRequest struct {
	// The CustomLlm containing the fields which should be updated.
	CustomLlm types.Object `tfsdk:"custom_llm"`
	// The id of the custom llm
	Id types.String `tfsdk:"-"`
	// The list of the CustomLlm fields to update. These should correspond to
	// the values (or lack thereof) present in `custom_llm`.
	//
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. It’s recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"update_mask"`
}

func (to *UpdateCustomLlmRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateCustomLlmRequest) {
	if !from.CustomLlm.IsNull() && !from.CustomLlm.IsUnknown() {
		if toCustomLlm, ok := to.GetCustomLlm(ctx); ok {
			if fromCustomLlm, ok := from.GetCustomLlm(ctx); ok {
				// Recursively sync the fields of CustomLlm
				toCustomLlm.SyncFieldsDuringCreateOrUpdate(ctx, fromCustomLlm)
				to.SetCustomLlm(ctx, toCustomLlm)
			}
		}
	}
}

func (to *UpdateCustomLlmRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateCustomLlmRequest) {
	if !from.CustomLlm.IsNull() && !from.CustomLlm.IsUnknown() {
		if toCustomLlm, ok := to.GetCustomLlm(ctx); ok {
			if fromCustomLlm, ok := from.GetCustomLlm(ctx); ok {
				toCustomLlm.SyncFieldsDuringRead(ctx, fromCustomLlm)
				to.SetCustomLlm(ctx, toCustomLlm)
			}
		}
	}
}

func (m UpdateCustomLlmRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["custom_llm"] = attrs["custom_llm"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCustomLlmRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateCustomLlmRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_llm": reflect.TypeOf(CustomLlm{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCustomLlmRequest
// only implements ToObjectValue() and Type().
func (m UpdateCustomLlmRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"custom_llm":  m.CustomLlm,
			"id":          m.Id,
			"update_mask": m.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateCustomLlmRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"custom_llm":  CustomLlm{}.Type(ctx),
			"id":          types.StringType,
			"update_mask": types.StringType,
		},
	}
}

// GetCustomLlm returns the value of the CustomLlm field in UpdateCustomLlmRequest as
// a CustomLlm value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateCustomLlmRequest) GetCustomLlm(ctx context.Context) (CustomLlm, bool) {
	var e CustomLlm
	if m.CustomLlm.IsNull() || m.CustomLlm.IsUnknown() {
		return e, false
	}
	var v CustomLlm
	d := m.CustomLlm.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomLlm sets the value of the CustomLlm field in UpdateCustomLlmRequest.
func (m *UpdateCustomLlmRequest) SetCustomLlm(ctx context.Context, v CustomLlm) {
	vs := v.ToObjectValue(ctx)
	m.CustomLlm = vs
}
