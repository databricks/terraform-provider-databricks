// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package catalog_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type AccessRequestDestinations struct {
	// Indicates whether any destinations are hidden from the caller due to a
	// lack of permissions. This value is true if the caller does not have
	// permission to see all destinations.
	AreAnyDestinationsHidden types.Bool `tfsdk:"are_any_destinations_hidden"`
	// The access request destinations for the securable.
	Destinations types.List `tfsdk:"destinations"`
	// The securable for which the access request destinations are being
	// retrieved.
	Securable types.Object `tfsdk:"securable"`
}

func (toState *AccessRequestDestinations) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccessRequestDestinations) {
	if !fromPlan.Securable.IsNull() && !fromPlan.Securable.IsUnknown() {
		if toStateSecurable, ok := toState.GetSecurable(ctx); ok {
			if fromPlanSecurable, ok := fromPlan.GetSecurable(ctx); ok {
				toStateSecurable.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSecurable)
				toState.SetSecurable(ctx, toStateSecurable)
			}
		}
	}
}

func (toState *AccessRequestDestinations) SyncFieldsDuringRead(ctx context.Context, fromState AccessRequestDestinations) {
	if !fromState.Securable.IsNull() && !fromState.Securable.IsUnknown() {
		if toStateSecurable, ok := toState.GetSecurable(ctx); ok {
			if fromStateSecurable, ok := fromState.GetSecurable(ctx); ok {
				toStateSecurable.SyncFieldsDuringRead(ctx, fromStateSecurable)
				toState.SetSecurable(ctx, toStateSecurable)
			}
		}
	}
}

func (c AccessRequestDestinations) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["are_any_destinations_hidden"] = attrs["are_any_destinations_hidden"].SetComputed()
	attrs["destinations"] = attrs["destinations"].SetRequired()
	attrs["securable"] = attrs["securable"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccessRequestDestinations.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccessRequestDestinations) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"destinations": reflect.TypeOf(NotificationDestination{}),
		"securable":    reflect.TypeOf(Securable{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccessRequestDestinations
// only implements ToObjectValue() and Type().
func (o AccessRequestDestinations) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"are_any_destinations_hidden": o.AreAnyDestinationsHidden,
			"destinations":                o.Destinations,
			"securable":                   o.Securable,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccessRequestDestinations) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"are_any_destinations_hidden": types.BoolType,
			"destinations": basetypes.ListType{
				ElemType: NotificationDestination{}.Type(ctx),
			},
			"securable": Securable{}.Type(ctx),
		},
	}
}

// GetDestinations returns the value of the Destinations field in AccessRequestDestinations as
// a slice of NotificationDestination values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccessRequestDestinations) GetDestinations(ctx context.Context) ([]NotificationDestination, bool) {
	if o.Destinations.IsNull() || o.Destinations.IsUnknown() {
		return nil, false
	}
	var v []NotificationDestination
	d := o.Destinations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDestinations sets the value of the Destinations field in AccessRequestDestinations.
func (o *AccessRequestDestinations) SetDestinations(ctx context.Context, v []NotificationDestination) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["destinations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Destinations = types.ListValueMust(t, vs)
}

// GetSecurable returns the value of the Securable field in AccessRequestDestinations as
// a Securable value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccessRequestDestinations) GetSecurable(ctx context.Context) (Securable, bool) {
	var e Securable
	if o.Securable.IsNull() || o.Securable.IsUnknown() {
		return e, false
	}
	var v Securable
	d := o.Securable.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSecurable sets the value of the Securable field in AccessRequestDestinations.
func (o *AccessRequestDestinations) SetSecurable(ctx context.Context, v Securable) {
	vs := v.ToObjectValue(ctx)
	o.Securable = vs
}

type AccountsCreateMetastore struct {
	MetastoreInfo types.Object `tfsdk:"metastore_info"`
}

func (toState *AccountsCreateMetastore) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsCreateMetastore) {
	if !fromPlan.MetastoreInfo.IsNull() && !fromPlan.MetastoreInfo.IsUnknown() {
		if toStateMetastoreInfo, ok := toState.GetMetastoreInfo(ctx); ok {
			if fromPlanMetastoreInfo, ok := fromPlan.GetMetastoreInfo(ctx); ok {
				toStateMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMetastoreInfo)
				toState.SetMetastoreInfo(ctx, toStateMetastoreInfo)
			}
		}
	}
}

func (toState *AccountsCreateMetastore) SyncFieldsDuringRead(ctx context.Context, fromState AccountsCreateMetastore) {
	if !fromState.MetastoreInfo.IsNull() && !fromState.MetastoreInfo.IsUnknown() {
		if toStateMetastoreInfo, ok := toState.GetMetastoreInfo(ctx); ok {
			if fromStateMetastoreInfo, ok := fromState.GetMetastoreInfo(ctx); ok {
				toStateMetastoreInfo.SyncFieldsDuringRead(ctx, fromStateMetastoreInfo)
				toState.SetMetastoreInfo(ctx, toStateMetastoreInfo)
			}
		}
	}
}

func (c AccountsCreateMetastore) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsCreateMetastore) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(CreateMetastore{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateMetastore
// only implements ToObjectValue() and Type().
func (o AccountsCreateMetastore) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_info": o.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsCreateMetastore) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_info": CreateMetastore{}.Type(ctx),
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsCreateMetastore as
// a CreateMetastore value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsCreateMetastore) GetMetastoreInfo(ctx context.Context) (CreateMetastore, bool) {
	var e CreateMetastore
	if o.MetastoreInfo.IsNull() || o.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v CreateMetastore
	d := o.MetastoreInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsCreateMetastore.
func (o *AccountsCreateMetastore) SetMetastoreInfo(ctx context.Context, v CreateMetastore) {
	vs := v.ToObjectValue(ctx)
	o.MetastoreInfo = vs
}

type AccountsCreateMetastoreAssignment struct {
	MetastoreAssignment types.Object `tfsdk:"metastore_assignment"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *AccountsCreateMetastoreAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsCreateMetastoreAssignment) {
	if !fromPlan.MetastoreAssignment.IsNull() && !fromPlan.MetastoreAssignment.IsUnknown() {
		if toStateMetastoreAssignment, ok := toState.GetMetastoreAssignment(ctx); ok {
			if fromPlanMetastoreAssignment, ok := fromPlan.GetMetastoreAssignment(ctx); ok {
				toStateMetastoreAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMetastoreAssignment)
				toState.SetMetastoreAssignment(ctx, toStateMetastoreAssignment)
			}
		}
	}
}

func (toState *AccountsCreateMetastoreAssignment) SyncFieldsDuringRead(ctx context.Context, fromState AccountsCreateMetastoreAssignment) {
	if !fromState.MetastoreAssignment.IsNull() && !fromState.MetastoreAssignment.IsUnknown() {
		if toStateMetastoreAssignment, ok := toState.GetMetastoreAssignment(ctx); ok {
			if fromStateMetastoreAssignment, ok := fromState.GetMetastoreAssignment(ctx); ok {
				toStateMetastoreAssignment.SyncFieldsDuringRead(ctx, fromStateMetastoreAssignment)
				toState.SetMetastoreAssignment(ctx, toStateMetastoreAssignment)
			}
		}
	}
}

func (c AccountsCreateMetastoreAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_assignment"] = attrs["metastore_assignment"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsCreateMetastoreAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_assignment": reflect.TypeOf(CreateMetastoreAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateMetastoreAssignment
// only implements ToObjectValue() and Type().
func (o AccountsCreateMetastoreAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_assignment": o.MetastoreAssignment,
			"metastore_id":         o.MetastoreId,
			"workspace_id":         o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsCreateMetastoreAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_assignment": CreateMetastoreAssignment{}.Type(ctx),
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

// GetMetastoreAssignment returns the value of the MetastoreAssignment field in AccountsCreateMetastoreAssignment as
// a CreateMetastoreAssignment value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsCreateMetastoreAssignment) GetMetastoreAssignment(ctx context.Context) (CreateMetastoreAssignment, bool) {
	var e CreateMetastoreAssignment
	if o.MetastoreAssignment.IsNull() || o.MetastoreAssignment.IsUnknown() {
		return e, false
	}
	var v CreateMetastoreAssignment
	d := o.MetastoreAssignment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastoreAssignment sets the value of the MetastoreAssignment field in AccountsCreateMetastoreAssignment.
func (o *AccountsCreateMetastoreAssignment) SetMetastoreAssignment(ctx context.Context, v CreateMetastoreAssignment) {
	vs := v.ToObjectValue(ctx)
	o.MetastoreAssignment = vs
}

type AccountsCreateStorageCredential struct {
	CredentialInfo types.Object `tfsdk:"credential_info"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (toState *AccountsCreateStorageCredential) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsCreateStorageCredential) {
	if !fromPlan.CredentialInfo.IsNull() && !fromPlan.CredentialInfo.IsUnknown() {
		if toStateCredentialInfo, ok := toState.GetCredentialInfo(ctx); ok {
			if fromPlanCredentialInfo, ok := fromPlan.GetCredentialInfo(ctx); ok {
				toStateCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCredentialInfo)
				toState.SetCredentialInfo(ctx, toStateCredentialInfo)
			}
		}
	}
}

func (toState *AccountsCreateStorageCredential) SyncFieldsDuringRead(ctx context.Context, fromState AccountsCreateStorageCredential) {
	if !fromState.CredentialInfo.IsNull() && !fromState.CredentialInfo.IsUnknown() {
		if toStateCredentialInfo, ok := toState.GetCredentialInfo(ctx); ok {
			if fromStateCredentialInfo, ok := fromState.GetCredentialInfo(ctx); ok {
				toStateCredentialInfo.SyncFieldsDuringRead(ctx, fromStateCredentialInfo)
				toState.SetCredentialInfo(ctx, toStateCredentialInfo)
			}
		}
	}
}

func (c AccountsCreateStorageCredential) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsCreateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsCreateStorageCredential) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(CreateStorageCredential{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsCreateStorageCredential
// only implements ToObjectValue() and Type().
func (o AccountsCreateStorageCredential) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info": o.CredentialInfo,
			"metastore_id":    o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsCreateStorageCredential) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": CreateStorageCredential{}.Type(ctx),
			"metastore_id":    types.StringType,
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsCreateStorageCredential as
// a CreateStorageCredential value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsCreateStorageCredential) GetCredentialInfo(ctx context.Context) (CreateStorageCredential, bool) {
	var e CreateStorageCredential
	if o.CredentialInfo.IsNull() || o.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v CreateStorageCredential
	d := o.CredentialInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsCreateStorageCredential.
func (o *AccountsCreateStorageCredential) SetCredentialInfo(ctx context.Context, v CreateStorageCredential) {
	vs := v.ToObjectValue(ctx)
	o.CredentialInfo = vs
}

type AccountsMetastoreAssignment struct {
	MetastoreAssignment types.Object `tfsdk:"metastore_assignment"`
}

func (toState *AccountsMetastoreAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsMetastoreAssignment) {
	if !fromPlan.MetastoreAssignment.IsNull() && !fromPlan.MetastoreAssignment.IsUnknown() {
		if toStateMetastoreAssignment, ok := toState.GetMetastoreAssignment(ctx); ok {
			if fromPlanMetastoreAssignment, ok := fromPlan.GetMetastoreAssignment(ctx); ok {
				toStateMetastoreAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMetastoreAssignment)
				toState.SetMetastoreAssignment(ctx, toStateMetastoreAssignment)
			}
		}
	}
}

func (toState *AccountsMetastoreAssignment) SyncFieldsDuringRead(ctx context.Context, fromState AccountsMetastoreAssignment) {
	if !fromState.MetastoreAssignment.IsNull() && !fromState.MetastoreAssignment.IsUnknown() {
		if toStateMetastoreAssignment, ok := toState.GetMetastoreAssignment(ctx); ok {
			if fromStateMetastoreAssignment, ok := fromState.GetMetastoreAssignment(ctx); ok {
				toStateMetastoreAssignment.SyncFieldsDuringRead(ctx, fromStateMetastoreAssignment)
				toState.SetMetastoreAssignment(ctx, toStateMetastoreAssignment)
			}
		}
	}
}

func (c AccountsMetastoreAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_assignment"] = attrs["metastore_assignment"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsMetastoreAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_assignment": reflect.TypeOf(MetastoreAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsMetastoreAssignment
// only implements ToObjectValue() and Type().
func (o AccountsMetastoreAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_assignment": o.MetastoreAssignment,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsMetastoreAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_assignment": MetastoreAssignment{}.Type(ctx),
		},
	}
}

// GetMetastoreAssignment returns the value of the MetastoreAssignment field in AccountsMetastoreAssignment as
// a MetastoreAssignment value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsMetastoreAssignment) GetMetastoreAssignment(ctx context.Context) (MetastoreAssignment, bool) {
	var e MetastoreAssignment
	if o.MetastoreAssignment.IsNull() || o.MetastoreAssignment.IsUnknown() {
		return e, false
	}
	var v MetastoreAssignment
	d := o.MetastoreAssignment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastoreAssignment sets the value of the MetastoreAssignment field in AccountsMetastoreAssignment.
func (o *AccountsMetastoreAssignment) SetMetastoreAssignment(ctx context.Context, v MetastoreAssignment) {
	vs := v.ToObjectValue(ctx)
	o.MetastoreAssignment = vs
}

type AccountsMetastoreInfo struct {
	MetastoreInfo types.Object `tfsdk:"metastore_info"`
}

func (toState *AccountsMetastoreInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsMetastoreInfo) {
	if !fromPlan.MetastoreInfo.IsNull() && !fromPlan.MetastoreInfo.IsUnknown() {
		if toStateMetastoreInfo, ok := toState.GetMetastoreInfo(ctx); ok {
			if fromPlanMetastoreInfo, ok := fromPlan.GetMetastoreInfo(ctx); ok {
				toStateMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMetastoreInfo)
				toState.SetMetastoreInfo(ctx, toStateMetastoreInfo)
			}
		}
	}
}

func (toState *AccountsMetastoreInfo) SyncFieldsDuringRead(ctx context.Context, fromState AccountsMetastoreInfo) {
	if !fromState.MetastoreInfo.IsNull() && !fromState.MetastoreInfo.IsUnknown() {
		if toStateMetastoreInfo, ok := toState.GetMetastoreInfo(ctx); ok {
			if fromStateMetastoreInfo, ok := fromState.GetMetastoreInfo(ctx); ok {
				toStateMetastoreInfo.SyncFieldsDuringRead(ctx, fromStateMetastoreInfo)
				toState.SetMetastoreInfo(ctx, toStateMetastoreInfo)
			}
		}
	}
}

func (c AccountsMetastoreInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsMetastoreInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsMetastoreInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(MetastoreInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsMetastoreInfo
// only implements ToObjectValue() and Type().
func (o AccountsMetastoreInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_info": o.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsMetastoreInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_info": MetastoreInfo{}.Type(ctx),
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsMetastoreInfo as
// a MetastoreInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsMetastoreInfo) GetMetastoreInfo(ctx context.Context) (MetastoreInfo, bool) {
	var e MetastoreInfo
	if o.MetastoreInfo.IsNull() || o.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v MetastoreInfo
	d := o.MetastoreInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsMetastoreInfo.
func (o *AccountsMetastoreInfo) SetMetastoreInfo(ctx context.Context, v MetastoreInfo) {
	vs := v.ToObjectValue(ctx)
	o.MetastoreInfo = vs
}

type AccountsStorageCredentialInfo struct {
	CredentialInfo types.Object `tfsdk:"credential_info"`
}

func (toState *AccountsStorageCredentialInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsStorageCredentialInfo) {
	if !fromPlan.CredentialInfo.IsNull() && !fromPlan.CredentialInfo.IsUnknown() {
		if toStateCredentialInfo, ok := toState.GetCredentialInfo(ctx); ok {
			if fromPlanCredentialInfo, ok := fromPlan.GetCredentialInfo(ctx); ok {
				toStateCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCredentialInfo)
				toState.SetCredentialInfo(ctx, toStateCredentialInfo)
			}
		}
	}
}

func (toState *AccountsStorageCredentialInfo) SyncFieldsDuringRead(ctx context.Context, fromState AccountsStorageCredentialInfo) {
	if !fromState.CredentialInfo.IsNull() && !fromState.CredentialInfo.IsUnknown() {
		if toStateCredentialInfo, ok := toState.GetCredentialInfo(ctx); ok {
			if fromStateCredentialInfo, ok := fromState.GetCredentialInfo(ctx); ok {
				toStateCredentialInfo.SyncFieldsDuringRead(ctx, fromStateCredentialInfo)
				toState.SetCredentialInfo(ctx, toStateCredentialInfo)
			}
		}
	}
}

func (c AccountsStorageCredentialInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsStorageCredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsStorageCredentialInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(StorageCredentialInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsStorageCredentialInfo
// only implements ToObjectValue() and Type().
func (o AccountsStorageCredentialInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info": o.CredentialInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsStorageCredentialInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info": StorageCredentialInfo{}.Type(ctx),
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsStorageCredentialInfo as
// a StorageCredentialInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsStorageCredentialInfo) GetCredentialInfo(ctx context.Context) (StorageCredentialInfo, bool) {
	var e StorageCredentialInfo
	if o.CredentialInfo.IsNull() || o.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v StorageCredentialInfo
	d := o.CredentialInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsStorageCredentialInfo.
func (o *AccountsStorageCredentialInfo) SetCredentialInfo(ctx context.Context, v StorageCredentialInfo) {
	vs := v.ToObjectValue(ctx)
	o.CredentialInfo = vs
}

type AccountsUpdateMetastore struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`

	MetastoreInfo types.Object `tfsdk:"metastore_info"`
}

func (toState *AccountsUpdateMetastore) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsUpdateMetastore) {
	if !fromPlan.MetastoreInfo.IsNull() && !fromPlan.MetastoreInfo.IsUnknown() {
		if toStateMetastoreInfo, ok := toState.GetMetastoreInfo(ctx); ok {
			if fromPlanMetastoreInfo, ok := fromPlan.GetMetastoreInfo(ctx); ok {
				toStateMetastoreInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMetastoreInfo)
				toState.SetMetastoreInfo(ctx, toStateMetastoreInfo)
			}
		}
	}
}

func (toState *AccountsUpdateMetastore) SyncFieldsDuringRead(ctx context.Context, fromState AccountsUpdateMetastore) {
	if !fromState.MetastoreInfo.IsNull() && !fromState.MetastoreInfo.IsUnknown() {
		if toStateMetastoreInfo, ok := toState.GetMetastoreInfo(ctx); ok {
			if fromStateMetastoreInfo, ok := fromState.GetMetastoreInfo(ctx); ok {
				toStateMetastoreInfo.SyncFieldsDuringRead(ctx, fromStateMetastoreInfo)
				toState.SetMetastoreInfo(ctx, toStateMetastoreInfo)
			}
		}
	}
}

func (c AccountsUpdateMetastore) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_info"] = attrs["metastore_info"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsUpdateMetastore) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_info": reflect.TypeOf(UpdateMetastore{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateMetastore
// only implements ToObjectValue() and Type().
func (o AccountsUpdateMetastore) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id":   o.MetastoreId,
			"metastore_info": o.MetastoreInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsUpdateMetastore) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id":   types.StringType,
			"metastore_info": UpdateMetastore{}.Type(ctx),
		},
	}
}

// GetMetastoreInfo returns the value of the MetastoreInfo field in AccountsUpdateMetastore as
// a UpdateMetastore value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsUpdateMetastore) GetMetastoreInfo(ctx context.Context) (UpdateMetastore, bool) {
	var e UpdateMetastore
	if o.MetastoreInfo.IsNull() || o.MetastoreInfo.IsUnknown() {
		return e, false
	}
	var v UpdateMetastore
	d := o.MetastoreInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastoreInfo sets the value of the MetastoreInfo field in AccountsUpdateMetastore.
func (o *AccountsUpdateMetastore) SetMetastoreInfo(ctx context.Context, v UpdateMetastore) {
	vs := v.ToObjectValue(ctx)
	o.MetastoreInfo = vs
}

type AccountsUpdateMetastoreAssignment struct {
	MetastoreAssignment types.Object `tfsdk:"metastore_assignment"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *AccountsUpdateMetastoreAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsUpdateMetastoreAssignment) {
	if !fromPlan.MetastoreAssignment.IsNull() && !fromPlan.MetastoreAssignment.IsUnknown() {
		if toStateMetastoreAssignment, ok := toState.GetMetastoreAssignment(ctx); ok {
			if fromPlanMetastoreAssignment, ok := fromPlan.GetMetastoreAssignment(ctx); ok {
				toStateMetastoreAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMetastoreAssignment)
				toState.SetMetastoreAssignment(ctx, toStateMetastoreAssignment)
			}
		}
	}
}

func (toState *AccountsUpdateMetastoreAssignment) SyncFieldsDuringRead(ctx context.Context, fromState AccountsUpdateMetastoreAssignment) {
	if !fromState.MetastoreAssignment.IsNull() && !fromState.MetastoreAssignment.IsUnknown() {
		if toStateMetastoreAssignment, ok := toState.GetMetastoreAssignment(ctx); ok {
			if fromStateMetastoreAssignment, ok := fromState.GetMetastoreAssignment(ctx); ok {
				toStateMetastoreAssignment.SyncFieldsDuringRead(ctx, fromStateMetastoreAssignment)
				toState.SetMetastoreAssignment(ctx, toStateMetastoreAssignment)
			}
		}
	}
}

func (c AccountsUpdateMetastoreAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_assignment"] = attrs["metastore_assignment"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsUpdateMetastoreAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastore_assignment": reflect.TypeOf(UpdateMetastoreAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateMetastoreAssignment
// only implements ToObjectValue() and Type().
func (o AccountsUpdateMetastoreAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_assignment": o.MetastoreAssignment,
			"metastore_id":         o.MetastoreId,
			"workspace_id":         o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsUpdateMetastoreAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_assignment": UpdateMetastoreAssignment{}.Type(ctx),
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

// GetMetastoreAssignment returns the value of the MetastoreAssignment field in AccountsUpdateMetastoreAssignment as
// a UpdateMetastoreAssignment value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsUpdateMetastoreAssignment) GetMetastoreAssignment(ctx context.Context) (UpdateMetastoreAssignment, bool) {
	var e UpdateMetastoreAssignment
	if o.MetastoreAssignment.IsNull() || o.MetastoreAssignment.IsUnknown() {
		return e, false
	}
	var v UpdateMetastoreAssignment
	d := o.MetastoreAssignment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastoreAssignment sets the value of the MetastoreAssignment field in AccountsUpdateMetastoreAssignment.
func (o *AccountsUpdateMetastoreAssignment) SetMetastoreAssignment(ctx context.Context, v UpdateMetastoreAssignment) {
	vs := v.ToObjectValue(ctx)
	o.MetastoreAssignment = vs
}

type AccountsUpdateStorageCredential struct {
	CredentialInfo types.Object `tfsdk:"credential_info"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Name of the storage credential.
	StorageCredentialName types.String `tfsdk:"-"`
}

func (toState *AccountsUpdateStorageCredential) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AccountsUpdateStorageCredential) {
	if !fromPlan.CredentialInfo.IsNull() && !fromPlan.CredentialInfo.IsUnknown() {
		if toStateCredentialInfo, ok := toState.GetCredentialInfo(ctx); ok {
			if fromPlanCredentialInfo, ok := fromPlan.GetCredentialInfo(ctx); ok {
				toStateCredentialInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCredentialInfo)
				toState.SetCredentialInfo(ctx, toStateCredentialInfo)
			}
		}
	}
}

func (toState *AccountsUpdateStorageCredential) SyncFieldsDuringRead(ctx context.Context, fromState AccountsUpdateStorageCredential) {
	if !fromState.CredentialInfo.IsNull() && !fromState.CredentialInfo.IsUnknown() {
		if toStateCredentialInfo, ok := toState.GetCredentialInfo(ctx); ok {
			if fromStateCredentialInfo, ok := fromState.GetCredentialInfo(ctx); ok {
				toStateCredentialInfo.SyncFieldsDuringRead(ctx, fromStateCredentialInfo)
				toState.SetCredentialInfo(ctx, toStateCredentialInfo)
			}
		}
	}
}

func (c AccountsUpdateStorageCredential) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_info"] = attrs["credential_info"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountsUpdateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountsUpdateStorageCredential) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credential_info": reflect.TypeOf(UpdateStorageCredential{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountsUpdateStorageCredential
// only implements ToObjectValue() and Type().
func (o AccountsUpdateStorageCredential) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_info":         o.CredentialInfo,
			"metastore_id":            o.MetastoreId,
			"storage_credential_name": o.StorageCredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountsUpdateStorageCredential) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_info":         UpdateStorageCredential{}.Type(ctx),
			"metastore_id":            types.StringType,
			"storage_credential_name": types.StringType,
		},
	}
}

// GetCredentialInfo returns the value of the CredentialInfo field in AccountsUpdateStorageCredential as
// a UpdateStorageCredential value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountsUpdateStorageCredential) GetCredentialInfo(ctx context.Context) (UpdateStorageCredential, bool) {
	var e UpdateStorageCredential
	if o.CredentialInfo.IsNull() || o.CredentialInfo.IsUnknown() {
		return e, false
	}
	var v UpdateStorageCredential
	d := o.CredentialInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCredentialInfo sets the value of the CredentialInfo field in AccountsUpdateStorageCredential.
func (o *AccountsUpdateStorageCredential) SetCredentialInfo(ctx context.Context, v UpdateStorageCredential) {
	vs := v.ToObjectValue(ctx)
	o.CredentialInfo = vs
}

type ArtifactAllowlistInfo struct {
	// A list of allowed artifact match patterns.
	ArtifactMatchers types.List `tfsdk:"artifact_matchers"`
	// Time at which this artifact allowlist was set, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who set the artifact allowlist.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
}

func (toState *ArtifactAllowlistInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ArtifactAllowlistInfo) {
}

func (toState *ArtifactAllowlistInfo) SyncFieldsDuringRead(ctx context.Context, fromState ArtifactAllowlistInfo) {
}

func (c ArtifactAllowlistInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact_matchers"] = attrs["artifact_matchers"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ArtifactAllowlistInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ArtifactAllowlistInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"artifact_matchers": reflect.TypeOf(ArtifactMatcher{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ArtifactAllowlistInfo
// only implements ToObjectValue() and Type().
func (o ArtifactAllowlistInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact_matchers": o.ArtifactMatchers,
			"created_at":        o.CreatedAt,
			"created_by":        o.CreatedBy,
			"metastore_id":      o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ArtifactAllowlistInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact_matchers": basetypes.ListType{
				ElemType: ArtifactMatcher{}.Type(ctx),
			},
			"created_at":   types.Int64Type,
			"created_by":   types.StringType,
			"metastore_id": types.StringType,
		},
	}
}

// GetArtifactMatchers returns the value of the ArtifactMatchers field in ArtifactAllowlistInfo as
// a slice of ArtifactMatcher values.
// If the field is unknown or null, the boolean return value is false.
func (o *ArtifactAllowlistInfo) GetArtifactMatchers(ctx context.Context) ([]ArtifactMatcher, bool) {
	if o.ArtifactMatchers.IsNull() || o.ArtifactMatchers.IsUnknown() {
		return nil, false
	}
	var v []ArtifactMatcher
	d := o.ArtifactMatchers.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetArtifactMatchers sets the value of the ArtifactMatchers field in ArtifactAllowlistInfo.
func (o *ArtifactAllowlistInfo) SetArtifactMatchers(ctx context.Context, v []ArtifactMatcher) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["artifact_matchers"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ArtifactMatchers = types.ListValueMust(t, vs)
}

type ArtifactMatcher struct {
	// The artifact path or maven coordinate
	Artifact types.String `tfsdk:"artifact"`
	// The pattern matching type of the artifact
	MatchType types.String `tfsdk:"match_type"`
}

func (toState *ArtifactMatcher) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ArtifactMatcher) {
}

func (toState *ArtifactMatcher) SyncFieldsDuringRead(ctx context.Context, fromState ArtifactMatcher) {
}

func (c ArtifactMatcher) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact"] = attrs["artifact"].SetRequired()
	attrs["match_type"] = attrs["match_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ArtifactMatcher.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ArtifactMatcher) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ArtifactMatcher
// only implements ToObjectValue() and Type().
func (o ArtifactMatcher) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact":   o.Artifact,
			"match_type": o.MatchType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ArtifactMatcher) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact":   types.StringType,
			"match_type": types.StringType,
		},
	}
}

type AssignResponse struct {
}

func (toState *AssignResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AssignResponse) {
}

func (toState *AssignResponse) SyncFieldsDuringRead(ctx context.Context, fromState AssignResponse) {
}

func (c AssignResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AssignResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AssignResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AssignResponse
// only implements ToObjectValue() and Type().
func (o AssignResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o AssignResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// AWS temporary credentials for API authentication. Read more at
// https://docs.aws.amazon.com/STS/latest/APIReference/API_Credentials.html.
type AwsCredentials struct {
	// The access key ID that identifies the temporary credentials.
	AccessKeyId types.String `tfsdk:"access_key_id"`
	// The Amazon Resource Name (ARN) of the S3 access point for temporary
	// credentials related the external location.
	AccessPoint types.String `tfsdk:"access_point"`
	// The secret access key that can be used to sign AWS API requests.
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
	// The token that users must pass to AWS API to use the temporary
	// credentials.
	SessionToken types.String `tfsdk:"session_token"`
}

func (toState *AwsCredentials) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AwsCredentials) {
}

func (toState *AwsCredentials) SyncFieldsDuringRead(ctx context.Context, fromState AwsCredentials) {
}

func (c AwsCredentials) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_key_id"] = attrs["access_key_id"].SetOptional()
	attrs["access_point"] = attrs["access_point"].SetOptional()
	attrs["secret_access_key"] = attrs["secret_access_key"].SetOptional()
	attrs["session_token"] = attrs["session_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsCredentials.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AwsCredentials) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsCredentials
// only implements ToObjectValue() and Type().
func (o AwsCredentials) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_key_id":     o.AccessKeyId,
			"access_point":      o.AccessPoint,
			"secret_access_key": o.SecretAccessKey,
			"session_token":     o.SessionToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AwsCredentials) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_key_id":     types.StringType,
			"access_point":      types.StringType,
			"secret_access_key": types.StringType,
			"session_token":     types.StringType,
		},
	}
}

// The AWS IAM role configuration
type AwsIamRole struct {
	// The external ID used in role assumption to prevent the confused deputy
	// problem.
	ExternalId types.String `tfsdk:"external_id"`
	// The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary
	// credentials.
	RoleArn types.String `tfsdk:"role_arn"`
	// The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks.
	// This is the identity that is going to assume the AWS IAM role.
	UnityCatalogIamArn types.String `tfsdk:"unity_catalog_iam_arn"`
}

func (toState *AwsIamRole) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AwsIamRole) {
}

func (toState *AwsIamRole) SyncFieldsDuringRead(ctx context.Context, fromState AwsIamRole) {
}

func (c AwsIamRole) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_id"] = attrs["external_id"].SetComputed()
	attrs["role_arn"] = attrs["role_arn"].SetOptional()
	attrs["unity_catalog_iam_arn"] = attrs["unity_catalog_iam_arn"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsIamRole.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AwsIamRole) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsIamRole
// only implements ToObjectValue() and Type().
func (o AwsIamRole) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_id":           o.ExternalId,
			"role_arn":              o.RoleArn,
			"unity_catalog_iam_arn": o.UnityCatalogIamArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AwsIamRole) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_id":           types.StringType,
			"role_arn":              types.StringType,
			"unity_catalog_iam_arn": types.StringType,
		},
	}
}

// The AWS IAM role configuration
type AwsIamRoleRequest struct {
	// The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary
	// credentials.
	RoleArn types.String `tfsdk:"role_arn"`
}

func (toState *AwsIamRoleRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AwsIamRoleRequest) {
}

func (toState *AwsIamRoleRequest) SyncFieldsDuringRead(ctx context.Context, fromState AwsIamRoleRequest) {
}

func (c AwsIamRoleRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["role_arn"] = attrs["role_arn"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsIamRoleRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AwsIamRoleRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsIamRoleRequest
// only implements ToObjectValue() and Type().
func (o AwsIamRoleRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"role_arn": o.RoleArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AwsIamRoleRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"role_arn": types.StringType,
		},
	}
}

// The AWS IAM role configuration
type AwsIamRoleResponse struct {
	// The external ID used in role assumption to prevent the confused deputy
	// problem.
	ExternalId types.String `tfsdk:"external_id"`
	// The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary
	// credentials.
	RoleArn types.String `tfsdk:"role_arn"`
	// The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks.
	// This is the identity that is going to assume the AWS IAM role.
	UnityCatalogIamArn types.String `tfsdk:"unity_catalog_iam_arn"`
}

func (toState *AwsIamRoleResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AwsIamRoleResponse) {
}

func (toState *AwsIamRoleResponse) SyncFieldsDuringRead(ctx context.Context, fromState AwsIamRoleResponse) {
}

func (c AwsIamRoleResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_id"] = attrs["external_id"].SetComputed()
	attrs["role_arn"] = attrs["role_arn"].SetRequired()
	attrs["unity_catalog_iam_arn"] = attrs["unity_catalog_iam_arn"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsIamRoleResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AwsIamRoleResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsIamRoleResponse
// only implements ToObjectValue() and Type().
func (o AwsIamRoleResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_id":           o.ExternalId,
			"role_arn":              o.RoleArn,
			"unity_catalog_iam_arn": o.UnityCatalogIamArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AwsIamRoleResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_id":           types.StringType,
			"role_arn":              types.StringType,
			"unity_catalog_iam_arn": types.StringType,
		},
	}
}

type AwsSqsQueue struct {
	// Unique identifier included in the name of file events managed cloud
	// resources.
	ManagedResourceId types.String `tfsdk:"managed_resource_id"`
	// The AQS queue url in the format
	// https://sqs.{region}.amazonaws.com/{account id}/{queue name} Required for
	// provided_sqs.
	QueueUrl types.String `tfsdk:"queue_url"`
}

func (toState *AwsSqsQueue) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AwsSqsQueue) {
}

func (toState *AwsSqsQueue) SyncFieldsDuringRead(ctx context.Context, fromState AwsSqsQueue) {
}

func (c AwsSqsQueue) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_resource_id"] = attrs["managed_resource_id"].SetComputed()
	attrs["queue_url"] = attrs["queue_url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AwsSqsQueue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AwsSqsQueue) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AwsSqsQueue
// only implements ToObjectValue() and Type().
func (o AwsSqsQueue) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_resource_id": o.ManagedResourceId,
			"queue_url":           o.QueueUrl,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AwsSqsQueue) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_resource_id": types.StringType,
			"queue_url":           types.StringType,
		},
	}
}

// Azure Active Directory token, essentially the Oauth token for Azure Service
// Principal or Managed Identity. Read more at
// https://learn.microsoft.com/en-us/azure/databricks/dev-tools/api/latest/aad/service-prin-aad-token
type AzureActiveDirectoryToken struct {
	// Opaque token that contains claims that you can use in Azure Active
	// Directory to access cloud services.
	AadToken types.String `tfsdk:"aad_token"`
}

func (toState *AzureActiveDirectoryToken) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureActiveDirectoryToken) {
}

func (toState *AzureActiveDirectoryToken) SyncFieldsDuringRead(ctx context.Context, fromState AzureActiveDirectoryToken) {
}

func (c AzureActiveDirectoryToken) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aad_token"] = attrs["aad_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureActiveDirectoryToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureActiveDirectoryToken) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureActiveDirectoryToken
// only implements ToObjectValue() and Type().
func (o AzureActiveDirectoryToken) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aad_token": o.AadToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureActiveDirectoryToken) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aad_token": types.StringType,
		},
	}
}

// The Azure managed identity configuration.
type AzureManagedIdentity struct {
	// The Azure resource ID of the Azure Databricks Access Connector. Use the
	// format
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`.
	AccessConnectorId types.String `tfsdk:"access_connector_id"`
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The Azure resource ID of the managed identity. Use the format,
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}`
	// This is only available for user-assgined identities. For system-assigned
	// identities, the access_connector_id is used to identify the identity. If
	// this field is not provided, then we assume the AzureManagedIdentity is
	// using the system-assigned identity.
	ManagedIdentityId types.String `tfsdk:"managed_identity_id"`
}

func (toState *AzureManagedIdentity) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureManagedIdentity) {
}

func (toState *AzureManagedIdentity) SyncFieldsDuringRead(ctx context.Context, fromState AzureManagedIdentity) {
}

func (c AzureManagedIdentity) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_connector_id"] = attrs["access_connector_id"].SetRequired()
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["managed_identity_id"] = attrs["managed_identity_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureManagedIdentity.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureManagedIdentity) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureManagedIdentity
// only implements ToObjectValue() and Type().
func (o AzureManagedIdentity) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_connector_id": o.AccessConnectorId,
			"credential_id":       o.CredentialId,
			"managed_identity_id": o.ManagedIdentityId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureManagedIdentity) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_connector_id": types.StringType,
			"credential_id":       types.StringType,
			"managed_identity_id": types.StringType,
		},
	}
}

// The Azure managed identity configuration.
type AzureManagedIdentityRequest struct {
	// The Azure resource ID of the Azure Databricks Access Connector. Use the
	// format
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`.
	AccessConnectorId types.String `tfsdk:"access_connector_id"`
	// The Azure resource ID of the managed identity. Use the format,
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}`
	// This is only available for user-assgined identities. For system-assigned
	// identities, the access_connector_id is used to identify the identity. If
	// this field is not provided, then we assume the AzureManagedIdentity is
	// using the system-assigned identity.
	ManagedIdentityId types.String `tfsdk:"managed_identity_id"`
}

func (toState *AzureManagedIdentityRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureManagedIdentityRequest) {
}

func (toState *AzureManagedIdentityRequest) SyncFieldsDuringRead(ctx context.Context, fromState AzureManagedIdentityRequest) {
}

func (c AzureManagedIdentityRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_connector_id"] = attrs["access_connector_id"].SetRequired()
	attrs["managed_identity_id"] = attrs["managed_identity_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureManagedIdentityRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureManagedIdentityRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureManagedIdentityRequest
// only implements ToObjectValue() and Type().
func (o AzureManagedIdentityRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_connector_id": o.AccessConnectorId,
			"managed_identity_id": o.ManagedIdentityId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureManagedIdentityRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_connector_id": types.StringType,
			"managed_identity_id": types.StringType,
		},
	}
}

// The Azure managed identity configuration.
type AzureManagedIdentityResponse struct {
	// The Azure resource ID of the Azure Databricks Access Connector. Use the
	// format
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`.
	AccessConnectorId types.String `tfsdk:"access_connector_id"`
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The Azure resource ID of the managed identity. Use the format,
	// `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}`
	// This is only available for user-assgined identities. For system-assigned
	// identities, the access_connector_id is used to identify the identity. If
	// this field is not provided, then we assume the AzureManagedIdentity is
	// using the system-assigned identity.
	ManagedIdentityId types.String `tfsdk:"managed_identity_id"`
}

func (toState *AzureManagedIdentityResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureManagedIdentityResponse) {
}

func (toState *AzureManagedIdentityResponse) SyncFieldsDuringRead(ctx context.Context, fromState AzureManagedIdentityResponse) {
}

func (c AzureManagedIdentityResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_connector_id"] = attrs["access_connector_id"].SetRequired()
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["managed_identity_id"] = attrs["managed_identity_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureManagedIdentityResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureManagedIdentityResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureManagedIdentityResponse
// only implements ToObjectValue() and Type().
func (o AzureManagedIdentityResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_connector_id": o.AccessConnectorId,
			"credential_id":       o.CredentialId,
			"managed_identity_id": o.ManagedIdentityId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureManagedIdentityResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_connector_id": types.StringType,
			"credential_id":       types.StringType,
			"managed_identity_id": types.StringType,
		},
	}
}

type AzureQueueStorage struct {
	// Unique identifier included in the name of file events managed cloud
	// resources.
	ManagedResourceId types.String `tfsdk:"managed_resource_id"`
	// The AQS queue url in the format https://{storage
	// account}.queue.core.windows.net/{queue name} Required for provided_aqs.
	QueueUrl types.String `tfsdk:"queue_url"`
	// The resource group for the queue, event grid subscription, and external
	// location storage account. Only required for locations with a service
	// principal storage credential
	ResourceGroup types.String `tfsdk:"resource_group"`
	// Optional subscription id for the queue, event grid subscription, and
	// external location storage account. Required for locations with a service
	// principal storage credential
	SubscriptionId types.String `tfsdk:"subscription_id"`
}

func (toState *AzureQueueStorage) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureQueueStorage) {
}

func (toState *AzureQueueStorage) SyncFieldsDuringRead(ctx context.Context, fromState AzureQueueStorage) {
}

func (c AzureQueueStorage) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_resource_id"] = attrs["managed_resource_id"].SetComputed()
	attrs["queue_url"] = attrs["queue_url"].SetOptional()
	attrs["resource_group"] = attrs["resource_group"].SetOptional()
	attrs["subscription_id"] = attrs["subscription_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureQueueStorage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureQueueStorage) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureQueueStorage
// only implements ToObjectValue() and Type().
func (o AzureQueueStorage) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_resource_id": o.ManagedResourceId,
			"queue_url":           o.QueueUrl,
			"resource_group":      o.ResourceGroup,
			"subscription_id":     o.SubscriptionId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureQueueStorage) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_resource_id": types.StringType,
			"queue_url":           types.StringType,
			"resource_group":      types.StringType,
			"subscription_id":     types.StringType,
		},
	}
}

// The Azure service principal configuration. Only applicable when purpose is
// **STORAGE**.
type AzureServicePrincipal struct {
	// The application ID of the application registration within the referenced
	// AAD tenant.
	ApplicationId types.String `tfsdk:"application_id"`
	// The client secret generated for the above app ID in AAD.
	ClientSecret types.String `tfsdk:"client_secret"`
	// The directory ID corresponding to the Azure Active Directory (AAD) tenant
	// of the application.
	DirectoryId types.String `tfsdk:"directory_id"`
}

func (toState *AzureServicePrincipal) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureServicePrincipal) {
}

func (toState *AzureServicePrincipal) SyncFieldsDuringRead(ctx context.Context, fromState AzureServicePrincipal) {
}

func (c AzureServicePrincipal) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["application_id"] = attrs["application_id"].SetRequired()
	attrs["client_secret"] = attrs["client_secret"].SetRequired()
	attrs["directory_id"] = attrs["directory_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureServicePrincipal.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureServicePrincipal) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureServicePrincipal
// only implements ToObjectValue() and Type().
func (o AzureServicePrincipal) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"application_id": o.ApplicationId,
			"client_secret":  o.ClientSecret,
			"directory_id":   o.DirectoryId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureServicePrincipal) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"application_id": types.StringType,
			"client_secret":  types.StringType,
			"directory_id":   types.StringType,
		},
	}
}

// Azure temporary credentials for API authentication. Read more at
// https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas
type AzureUserDelegationSas struct {
	// The signed URI (SAS Token) used to access blob services for a given path
	SasToken types.String `tfsdk:"sas_token"`
}

func (toState *AzureUserDelegationSas) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan AzureUserDelegationSas) {
}

func (toState *AzureUserDelegationSas) SyncFieldsDuringRead(ctx context.Context, fromState AzureUserDelegationSas) {
}

func (c AzureUserDelegationSas) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["sas_token"] = attrs["sas_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AzureUserDelegationSas.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AzureUserDelegationSas) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AzureUserDelegationSas
// only implements ToObjectValue() and Type().
func (o AzureUserDelegationSas) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"sas_token": o.SasToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AzureUserDelegationSas) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"sas_token": types.StringType,
		},
	}
}

type BatchCreateAccessRequestsRequest struct {
	// A list of individual access requests, where each request corresponds to a
	// set of permissions being requested on a list of securables for a
	// specified principal.
	//
	// At most 30 requests per API call.
	Requests types.List `tfsdk:"requests"`
}

func (toState *BatchCreateAccessRequestsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan BatchCreateAccessRequestsRequest) {
}

func (toState *BatchCreateAccessRequestsRequest) SyncFieldsDuringRead(ctx context.Context, fromState BatchCreateAccessRequestsRequest) {
}

func (c BatchCreateAccessRequestsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["requests"] = attrs["requests"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BatchCreateAccessRequestsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a BatchCreateAccessRequestsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"requests": reflect.TypeOf(CreateAccessRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BatchCreateAccessRequestsRequest
// only implements ToObjectValue() and Type().
func (o BatchCreateAccessRequestsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"requests": o.Requests,
		})
}

// Type implements basetypes.ObjectValuable.
func (o BatchCreateAccessRequestsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"requests": basetypes.ListType{
				ElemType: CreateAccessRequest{}.Type(ctx),
			},
		},
	}
}

// GetRequests returns the value of the Requests field in BatchCreateAccessRequestsRequest as
// a slice of CreateAccessRequest values.
// If the field is unknown or null, the boolean return value is false.
func (o *BatchCreateAccessRequestsRequest) GetRequests(ctx context.Context) ([]CreateAccessRequest, bool) {
	if o.Requests.IsNull() || o.Requests.IsUnknown() {
		return nil, false
	}
	var v []CreateAccessRequest
	d := o.Requests.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRequests sets the value of the Requests field in BatchCreateAccessRequestsRequest.
func (o *BatchCreateAccessRequestsRequest) SetRequests(ctx context.Context, v []CreateAccessRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["requests"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Requests = types.ListValueMust(t, vs)
}

type BatchCreateAccessRequestsResponse struct {
	// The access request destinations for each securable object the principal
	// requested.
	Responses types.List `tfsdk:"responses"`
}

func (toState *BatchCreateAccessRequestsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan BatchCreateAccessRequestsResponse) {
}

func (toState *BatchCreateAccessRequestsResponse) SyncFieldsDuringRead(ctx context.Context, fromState BatchCreateAccessRequestsResponse) {
}

func (c BatchCreateAccessRequestsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["responses"] = attrs["responses"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BatchCreateAccessRequestsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a BatchCreateAccessRequestsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"responses": reflect.TypeOf(CreateAccessRequestResponse{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BatchCreateAccessRequestsResponse
// only implements ToObjectValue() and Type().
func (o BatchCreateAccessRequestsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"responses": o.Responses,
		})
}

// Type implements basetypes.ObjectValuable.
func (o BatchCreateAccessRequestsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"responses": basetypes.ListType{
				ElemType: CreateAccessRequestResponse{}.Type(ctx),
			},
		},
	}
}

// GetResponses returns the value of the Responses field in BatchCreateAccessRequestsResponse as
// a slice of CreateAccessRequestResponse values.
// If the field is unknown or null, the boolean return value is false.
func (o *BatchCreateAccessRequestsResponse) GetResponses(ctx context.Context) ([]CreateAccessRequestResponse, bool) {
	if o.Responses.IsNull() || o.Responses.IsUnknown() {
		return nil, false
	}
	var v []CreateAccessRequestResponse
	d := o.Responses.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResponses sets the value of the Responses field in BatchCreateAccessRequestsResponse.
func (o *BatchCreateAccessRequestsResponse) SetResponses(ctx context.Context, v []CreateAccessRequestResponse) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["responses"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Responses = types.ListValueMust(t, vs)
}

type CancelRefreshRequest struct {
	RefreshId types.Int64 `tfsdk:"-"`
	// UC table name in format `catalog.schema.table_name`. table_name is case
	// insensitive and spaces are disallowed.
	TableName types.String `tfsdk:"-"`
}

func (toState *CancelRefreshRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CancelRefreshRequest) {
}

func (toState *CancelRefreshRequest) SyncFieldsDuringRead(ctx context.Context, fromState CancelRefreshRequest) {
}

func (c CancelRefreshRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()
	attrs["refresh_id"] = attrs["refresh_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelRefreshRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CancelRefreshRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelRefreshRequest
// only implements ToObjectValue() and Type().
func (o CancelRefreshRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"refresh_id": o.RefreshId,
			"table_name": o.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CancelRefreshRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"refresh_id": types.Int64Type,
			"table_name": types.StringType,
		},
	}
}

type CancelRefreshResponse struct {
}

func (toState *CancelRefreshResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CancelRefreshResponse) {
}

func (toState *CancelRefreshResponse) SyncFieldsDuringRead(ctx context.Context, fromState CancelRefreshResponse) {
}

func (c CancelRefreshResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelRefreshResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CancelRefreshResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelRefreshResponse
// only implements ToObjectValue() and Type().
func (o CancelRefreshResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o CancelRefreshResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type CatalogInfo struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`

	CatalogType types.String `tfsdk:"catalog_type"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// The name of the connection to an external data source.
	ConnectionName types.String `tfsdk:"connection_name"`
	// Time at which this catalog was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of catalog creator.
	CreatedBy types.String `tfsdk:"created_by"`

	EffectivePredictiveOptimizationFlag types.Object `tfsdk:"effective_predictive_optimization_flag"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// The full name of the catalog. Corresponds with the name field.
	FullName types.String `tfsdk:"full_name"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of catalog.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of catalog.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// The name of delta sharing provider.
	//
	// A Delta Sharing catalog is a catalog that is based on a Delta share on a
	// remote sharing server.
	ProviderName types.String `tfsdk:"provider_name"`

	ProvisioningInfo types.Object `tfsdk:"provisioning_info"`

	SecurableType types.String `tfsdk:"securable_type"`
	// The name of the share under the share provider.
	ShareName types.String `tfsdk:"share_name"`
	// Storage Location URL (full path) for managed tables within catalog.
	StorageLocation types.String `tfsdk:"storage_location"`
	// Storage root URL for managed tables within catalog.
	StorageRoot types.String `tfsdk:"storage_root"`
	// Time at which this catalog was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified catalog.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (toState *CatalogInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CatalogInfo) {
	if !fromPlan.EffectivePredictiveOptimizationFlag.IsNull() && !fromPlan.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toStateEffectivePredictiveOptimizationFlag, ok := toState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromPlanEffectivePredictiveOptimizationFlag, ok := fromPlan.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toStateEffectivePredictiveOptimizationFlag.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEffectivePredictiveOptimizationFlag)
				toState.SetEffectivePredictiveOptimizationFlag(ctx, toStateEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !fromPlan.ProvisioningInfo.IsNull() && !fromPlan.ProvisioningInfo.IsUnknown() {
		if toStateProvisioningInfo, ok := toState.GetProvisioningInfo(ctx); ok {
			if fromPlanProvisioningInfo, ok := fromPlan.GetProvisioningInfo(ctx); ok {
				toStateProvisioningInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanProvisioningInfo)
				toState.SetProvisioningInfo(ctx, toStateProvisioningInfo)
			}
		}
	}
}

func (toState *CatalogInfo) SyncFieldsDuringRead(ctx context.Context, fromState CatalogInfo) {
	if !fromState.EffectivePredictiveOptimizationFlag.IsNull() && !fromState.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toStateEffectivePredictiveOptimizationFlag, ok := toState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromStateEffectivePredictiveOptimizationFlag, ok := fromState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toStateEffectivePredictiveOptimizationFlag.SyncFieldsDuringRead(ctx, fromStateEffectivePredictiveOptimizationFlag)
				toState.SetEffectivePredictiveOptimizationFlag(ctx, toStateEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !fromState.ProvisioningInfo.IsNull() && !fromState.ProvisioningInfo.IsUnknown() {
		if toStateProvisioningInfo, ok := toState.GetProvisioningInfo(ctx); ok {
			if fromStateProvisioningInfo, ok := fromState.GetProvisioningInfo(ctx); ok {
				toStateProvisioningInfo.SyncFieldsDuringRead(ctx, fromStateProvisioningInfo)
				toState.SetProvisioningInfo(ctx, toStateProvisioningInfo)
			}
		}
	}
}

func (c CatalogInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_type"] = attrs["catalog_type"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_name"] = attrs["connection_name"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["provider_name"] = attrs["provider_name"].SetOptional()
	attrs["provisioning_info"] = attrs["provisioning_info"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()
	attrs["share_name"] = attrs["share_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CatalogInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CatalogInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"effective_predictive_optimization_flag": reflect.TypeOf(EffectivePredictiveOptimizationFlag{}),
		"options":                                reflect.TypeOf(types.String{}),
		"properties":                             reflect.TypeOf(types.String{}),
		"provisioning_info":                      reflect.TypeOf(ProvisioningInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CatalogInfo
// only implements ToObjectValue() and Type().
func (o CatalogInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":                            o.BrowseOnly,
			"catalog_type":                           o.CatalogType,
			"comment":                                o.Comment,
			"connection_name":                        o.ConnectionName,
			"created_at":                             o.CreatedAt,
			"created_by":                             o.CreatedBy,
			"effective_predictive_optimization_flag": o.EffectivePredictiveOptimizationFlag,
			"enable_predictive_optimization":         o.EnablePredictiveOptimization,
			"full_name":                              o.FullName,
			"isolation_mode":                         o.IsolationMode,
			"metastore_id":                           o.MetastoreId,
			"name":                                   o.Name,
			"options":                                o.Options,
			"owner":                                  o.Owner,
			"properties":                             o.Properties,
			"provider_name":                          o.ProviderName,
			"provisioning_info":                      o.ProvisioningInfo,
			"securable_type":                         o.SecurableType,
			"share_name":                             o.ShareName,
			"storage_location":                       o.StorageLocation,
			"storage_root":                           o.StorageRoot,
			"updated_at":                             o.UpdatedAt,
			"updated_by":                             o.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CatalogInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":                            types.BoolType,
			"catalog_type":                           types.StringType,
			"comment":                                types.StringType,
			"connection_name":                        types.StringType,
			"created_at":                             types.Int64Type,
			"created_by":                             types.StringType,
			"effective_predictive_optimization_flag": EffectivePredictiveOptimizationFlag{}.Type(ctx),
			"enable_predictive_optimization":         types.StringType,
			"full_name":                              types.StringType,
			"isolation_mode":                         types.StringType,
			"metastore_id":                           types.StringType,
			"name":                                   types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"provider_name":     types.StringType,
			"provisioning_info": ProvisioningInfo{}.Type(ctx),
			"securable_type":    types.StringType,
			"share_name":        types.StringType,
			"storage_location":  types.StringType,
			"storage_root":      types.StringType,
			"updated_at":        types.Int64Type,
			"updated_by":        types.StringType,
		},
	}
}

// GetEffectivePredictiveOptimizationFlag returns the value of the EffectivePredictiveOptimizationFlag field in CatalogInfo as
// a EffectivePredictiveOptimizationFlag value.
// If the field is unknown or null, the boolean return value is false.
func (o *CatalogInfo) GetEffectivePredictiveOptimizationFlag(ctx context.Context) (EffectivePredictiveOptimizationFlag, bool) {
	var e EffectivePredictiveOptimizationFlag
	if o.EffectivePredictiveOptimizationFlag.IsNull() || o.EffectivePredictiveOptimizationFlag.IsUnknown() {
		return e, false
	}
	var v EffectivePredictiveOptimizationFlag
	d := o.EffectivePredictiveOptimizationFlag.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEffectivePredictiveOptimizationFlag sets the value of the EffectivePredictiveOptimizationFlag field in CatalogInfo.
func (o *CatalogInfo) SetEffectivePredictiveOptimizationFlag(ctx context.Context, v EffectivePredictiveOptimizationFlag) {
	vs := v.ToObjectValue(ctx)
	o.EffectivePredictiveOptimizationFlag = vs
}

// GetOptions returns the value of the Options field in CatalogInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CatalogInfo) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in CatalogInfo.
func (o *CatalogInfo) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CatalogInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CatalogInfo) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CatalogInfo.
func (o *CatalogInfo) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetProvisioningInfo returns the value of the ProvisioningInfo field in CatalogInfo as
// a ProvisioningInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *CatalogInfo) GetProvisioningInfo(ctx context.Context) (ProvisioningInfo, bool) {
	var e ProvisioningInfo
	if o.ProvisioningInfo.IsNull() || o.ProvisioningInfo.IsUnknown() {
		return e, false
	}
	var v ProvisioningInfo
	d := o.ProvisioningInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProvisioningInfo sets the value of the ProvisioningInfo field in CatalogInfo.
func (o *CatalogInfo) SetProvisioningInfo(ctx context.Context, v ProvisioningInfo) {
	vs := v.ToObjectValue(ctx)
	o.ProvisioningInfo = vs
}

// The Cloudflare API token configuration. Read more at
// https://developers.cloudflare.com/r2/api/s3/tokens/
type CloudflareApiToken struct {
	// The access key ID associated with the API token.
	AccessKeyId types.String `tfsdk:"access_key_id"`
	// The ID of the account associated with the API token.
	AccountId types.String `tfsdk:"account_id"`
	// The secret access token generated for the above access key ID.
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
}

func (toState *CloudflareApiToken) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CloudflareApiToken) {
}

func (toState *CloudflareApiToken) SyncFieldsDuringRead(ctx context.Context, fromState CloudflareApiToken) {
}

func (c CloudflareApiToken) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_key_id"] = attrs["access_key_id"].SetRequired()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["secret_access_key"] = attrs["secret_access_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CloudflareApiToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CloudflareApiToken) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CloudflareApiToken
// only implements ToObjectValue() and Type().
func (o CloudflareApiToken) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_key_id":     o.AccessKeyId,
			"account_id":        o.AccountId,
			"secret_access_key": o.SecretAccessKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CloudflareApiToken) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_key_id":     types.StringType,
			"account_id":        types.StringType,
			"secret_access_key": types.StringType,
		},
	}
}

type ColumnInfo struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`

	Mask types.Object `tfsdk:"mask"`
	// Name of Column.
	Name types.String `tfsdk:"name"`
	// Whether field may be Null (default: true).
	Nullable types.Bool `tfsdk:"nullable"`
	// Partition index for column.
	PartitionIndex types.Int64 `tfsdk:"partition_index"`
	// Ordinal position of column (starting at position 0).
	Position types.Int64 `tfsdk:"position"`
	// Format of IntervalType.
	TypeIntervalType types.String `tfsdk:"type_interval_type"`
	// Full data type specification, JSON-serialized.
	TypeJson types.String `tfsdk:"type_json"`

	TypeName types.String `tfsdk:"type_name"`
	// Digits of precision; required for DecimalTypes.
	TypePrecision types.Int64 `tfsdk:"type_precision"`
	// Digits to right of decimal; Required for DecimalTypes.
	TypeScale types.Int64 `tfsdk:"type_scale"`
	// Full data type specification as SQL/catalogString text.
	TypeText types.String `tfsdk:"type_text"`
}

func (toState *ColumnInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ColumnInfo) {
	if !fromPlan.Mask.IsNull() && !fromPlan.Mask.IsUnknown() {
		if toStateMask, ok := toState.GetMask(ctx); ok {
			if fromPlanMask, ok := fromPlan.GetMask(ctx); ok {
				toStateMask.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanMask)
				toState.SetMask(ctx, toStateMask)
			}
		}
	}
}

func (toState *ColumnInfo) SyncFieldsDuringRead(ctx context.Context, fromState ColumnInfo) {
	if !fromState.Mask.IsNull() && !fromState.Mask.IsUnknown() {
		if toStateMask, ok := toState.GetMask(ctx); ok {
			if fromStateMask, ok := fromState.GetMask(ctx); ok {
				toStateMask.SyncFieldsDuringRead(ctx, fromStateMask)
				toState.SetMask(ctx, toStateMask)
			}
		}
	}
}

func (c ColumnInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["mask"] = attrs["mask"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["nullable"] = attrs["nullable"].SetOptional()
	attrs["partition_index"] = attrs["partition_index"].SetOptional()
	attrs["position"] = attrs["position"].SetOptional()
	attrs["type_interval_type"] = attrs["type_interval_type"].SetOptional()
	attrs["type_json"] = attrs["type_json"].SetOptional()
	attrs["type_name"] = attrs["type_name"].SetOptional()
	attrs["type_precision"] = attrs["type_precision"].SetOptional()
	attrs["type_scale"] = attrs["type_scale"].SetOptional()
	attrs["type_text"] = attrs["type_text"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ColumnInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"mask": reflect.TypeOf(ColumnMask{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnInfo
// only implements ToObjectValue() and Type().
func (o ColumnInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            o.Comment,
			"mask":               o.Mask,
			"name":               o.Name,
			"nullable":           o.Nullable,
			"partition_index":    o.PartitionIndex,
			"position":           o.Position,
			"type_interval_type": o.TypeIntervalType,
			"type_json":          o.TypeJson,
			"type_name":          o.TypeName,
			"type_precision":     o.TypePrecision,
			"type_scale":         o.TypeScale,
			"type_text":          o.TypeText,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ColumnInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"mask":               ColumnMask{}.Type(ctx),
			"name":               types.StringType,
			"nullable":           types.BoolType,
			"partition_index":    types.Int64Type,
			"position":           types.Int64Type,
			"type_interval_type": types.StringType,
			"type_json":          types.StringType,
			"type_name":          types.StringType,
			"type_precision":     types.Int64Type,
			"type_scale":         types.Int64Type,
			"type_text":          types.StringType,
		},
	}
}

// GetMask returns the value of the Mask field in ColumnInfo as
// a ColumnMask value.
// If the field is unknown or null, the boolean return value is false.
func (o *ColumnInfo) GetMask(ctx context.Context) (ColumnMask, bool) {
	var e ColumnMask
	if o.Mask.IsNull() || o.Mask.IsUnknown() {
		return e, false
	}
	var v ColumnMask
	d := o.Mask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMask sets the value of the Mask field in ColumnInfo.
func (o *ColumnInfo) SetMask(ctx context.Context, v ColumnMask) {
	vs := v.ToObjectValue(ctx)
	o.Mask = vs
}

type ColumnMask struct {
	// The full name of the column mask SQL UDF.
	FunctionName types.String `tfsdk:"function_name"`
	// The list of additional table columns to be passed as input to the column
	// mask function. The first arg of the mask function should be of the type
	// of the column being masked and the types of the rest of the args should
	// match the types of columns in 'using_column_names'.
	UsingColumnNames types.List `tfsdk:"using_column_names"`
}

func (toState *ColumnMask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ColumnMask) {
}

func (toState *ColumnMask) SyncFieldsDuringRead(ctx context.Context, fromState ColumnMask) {
}

func (c ColumnMask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetOptional()
	attrs["using_column_names"] = attrs["using_column_names"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnMask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ColumnMask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"using_column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnMask
// only implements ToObjectValue() and Type().
func (o ColumnMask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name":      o.FunctionName,
			"using_column_names": o.UsingColumnNames,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ColumnMask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"using_column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetUsingColumnNames returns the value of the UsingColumnNames field in ColumnMask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ColumnMask) GetUsingColumnNames(ctx context.Context) ([]types.String, bool) {
	if o.UsingColumnNames.IsNull() || o.UsingColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.UsingColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUsingColumnNames sets the value of the UsingColumnNames field in ColumnMask.
func (o *ColumnMask) SetUsingColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["using_column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.UsingColumnNames = types.ListValueMust(t, vs)
}

type ColumnMaskOptions struct {
	// The fully qualified name of the column mask function. The function is
	// called on each row of the target table. The function's first argument and
	// its return type should match the type of the masked column. Required on
	// create and update.
	FunctionName types.String `tfsdk:"function_name"`
	// The alias of the column to be masked. The alias must refer to one of
	// matched columns. The values of the column is passed to the column mask
	// function as the first argument. Required on create and update.
	OnColumn types.String `tfsdk:"on_column"`
	// Optional list of column aliases or constant literals to be passed as
	// additional arguments to the column mask function. The type of each column
	// should match the positional argument of the column mask function.
	Using types.List `tfsdk:"using"`
}

func (toState *ColumnMaskOptions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ColumnMaskOptions) {
}

func (toState *ColumnMaskOptions) SyncFieldsDuringRead(ctx context.Context, fromState ColumnMaskOptions) {
}

func (c ColumnMaskOptions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetRequired()
	attrs["on_column"] = attrs["on_column"].SetRequired()
	attrs["using"] = attrs["using"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnMaskOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ColumnMaskOptions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"using": reflect.TypeOf(FunctionArgument{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnMaskOptions
// only implements ToObjectValue() and Type().
func (o ColumnMaskOptions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name": o.FunctionName,
			"on_column":     o.OnColumn,
			"using":         o.Using,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ColumnMaskOptions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"on_column":     types.StringType,
			"using": basetypes.ListType{
				ElemType: FunctionArgument{}.Type(ctx),
			},
		},
	}
}

// GetUsing returns the value of the Using field in ColumnMaskOptions as
// a slice of FunctionArgument values.
// If the field is unknown or null, the boolean return value is false.
func (o *ColumnMaskOptions) GetUsing(ctx context.Context) ([]FunctionArgument, bool) {
	if o.Using.IsNull() || o.Using.IsUnknown() {
		return nil, false
	}
	var v []FunctionArgument
	d := o.Using.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUsing sets the value of the Using field in ColumnMaskOptions.
func (o *ColumnMaskOptions) SetUsing(ctx context.Context, v []FunctionArgument) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["using"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Using = types.ListValueMust(t, vs)
}

type ColumnRelationship struct {
	Source types.String `tfsdk:"source"`

	Target types.String `tfsdk:"target"`
}

func (toState *ColumnRelationship) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ColumnRelationship) {
}

func (toState *ColumnRelationship) SyncFieldsDuringRead(ctx context.Context, fromState ColumnRelationship) {
}

func (c ColumnRelationship) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["source"] = attrs["source"].SetOptional()
	attrs["target"] = attrs["target"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ColumnRelationship.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ColumnRelationship) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ColumnRelationship
// only implements ToObjectValue() and Type().
func (o ColumnRelationship) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"source": o.Source,
			"target": o.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ColumnRelationship) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"source": types.StringType,
			"target": types.StringType,
		},
	}
}

// A connection that is dependent on a SQL object.
type ConnectionDependency struct {
	// Full name of the dependent connection, in the form of
	// __connection_name__.
	ConnectionName types.String `tfsdk:"connection_name"`
}

func (toState *ConnectionDependency) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ConnectionDependency) {
}

func (toState *ConnectionDependency) SyncFieldsDuringRead(ctx context.Context, fromState ConnectionDependency) {
}

func (c ConnectionDependency) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_name"] = attrs["connection_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConnectionDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ConnectionDependency) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConnectionDependency
// only implements ToObjectValue() and Type().
func (o ConnectionDependency) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_name": o.ConnectionName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ConnectionDependency) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_name": types.StringType,
		},
	}
}

// Next ID: 23
type ConnectionInfo struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Unique identifier of the Connection.
	ConnectionId types.String `tfsdk:"connection_id"`
	// The type of connection.
	ConnectionType types.String `tfsdk:"connection_type"`
	// Time at which this connection was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of connection creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// The type of credential.
	CredentialType types.String `tfsdk:"credential_type"`
	// Full name of connection.
	FullName types.String `tfsdk:"full_name"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of the connection.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of the connection.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`

	ProvisioningInfo types.Object `tfsdk:"provisioning_info"`
	// If the connection is read only.
	ReadOnly types.Bool `tfsdk:"read_only"`

	SecurableType types.String `tfsdk:"securable_type"`
	// Time at which this connection was updated, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified connection.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// URL of the remote data source, extracted from options.
	Url types.String `tfsdk:"url"`
}

func (toState *ConnectionInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ConnectionInfo) {
	if !fromPlan.ProvisioningInfo.IsNull() && !fromPlan.ProvisioningInfo.IsUnknown() {
		if toStateProvisioningInfo, ok := toState.GetProvisioningInfo(ctx); ok {
			if fromPlanProvisioningInfo, ok := fromPlan.GetProvisioningInfo(ctx); ok {
				toStateProvisioningInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanProvisioningInfo)
				toState.SetProvisioningInfo(ctx, toStateProvisioningInfo)
			}
		}
	}
}

func (toState *ConnectionInfo) SyncFieldsDuringRead(ctx context.Context, fromState ConnectionInfo) {
	if !fromState.ProvisioningInfo.IsNull() && !fromState.ProvisioningInfo.IsUnknown() {
		if toStateProvisioningInfo, ok := toState.GetProvisioningInfo(ctx); ok {
			if fromStateProvisioningInfo, ok := fromState.GetProvisioningInfo(ctx); ok {
				toStateProvisioningInfo.SyncFieldsDuringRead(ctx, fromStateProvisioningInfo)
				toState.SetProvisioningInfo(ctx, toStateProvisioningInfo)
			}
		}
	}
}

func (c ConnectionInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_id"] = attrs["connection_id"].SetOptional()
	attrs["connection_type"] = attrs["connection_type"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["credential_type"] = attrs["credential_type"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["provisioning_info"] = attrs["provisioning_info"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConnectionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ConnectionInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":           reflect.TypeOf(types.String{}),
		"properties":        reflect.TypeOf(types.String{}),
		"provisioning_info": reflect.TypeOf(ProvisioningInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConnectionInfo
// only implements ToObjectValue() and Type().
func (o ConnectionInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":           o.Comment,
			"connection_id":     o.ConnectionId,
			"connection_type":   o.ConnectionType,
			"created_at":        o.CreatedAt,
			"created_by":        o.CreatedBy,
			"credential_type":   o.CredentialType,
			"full_name":         o.FullName,
			"metastore_id":      o.MetastoreId,
			"name":              o.Name,
			"options":           o.Options,
			"owner":             o.Owner,
			"properties":        o.Properties,
			"provisioning_info": o.ProvisioningInfo,
			"read_only":         o.ReadOnly,
			"securable_type":    o.SecurableType,
			"updated_at":        o.UpdatedAt,
			"updated_by":        o.UpdatedBy,
			"url":               o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ConnectionInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":         types.StringType,
			"connection_id":   types.StringType,
			"connection_type": types.StringType,
			"created_at":      types.Int64Type,
			"created_by":      types.StringType,
			"credential_type": types.StringType,
			"full_name":       types.StringType,
			"metastore_id":    types.StringType,
			"name":            types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"provisioning_info": ProvisioningInfo{}.Type(ctx),
			"read_only":         types.BoolType,
			"securable_type":    types.StringType,
			"updated_at":        types.Int64Type,
			"updated_by":        types.StringType,
			"url":               types.StringType,
		},
	}
}

// GetOptions returns the value of the Options field in ConnectionInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ConnectionInfo) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in ConnectionInfo.
func (o *ConnectionInfo) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ConnectionInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ConnectionInfo) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ConnectionInfo.
func (o *ConnectionInfo) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetProvisioningInfo returns the value of the ProvisioningInfo field in ConnectionInfo as
// a ProvisioningInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *ConnectionInfo) GetProvisioningInfo(ctx context.Context) (ProvisioningInfo, bool) {
	var e ProvisioningInfo
	if o.ProvisioningInfo.IsNull() || o.ProvisioningInfo.IsUnknown() {
		return e, false
	}
	var v ProvisioningInfo
	d := o.ProvisioningInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProvisioningInfo sets the value of the ProvisioningInfo field in ConnectionInfo.
func (o *ConnectionInfo) SetProvisioningInfo(ctx context.Context, v ProvisioningInfo) {
	vs := v.ToObjectValue(ctx)
	o.ProvisioningInfo = vs
}

// Detailed status of an online table. Shown if the online table is in the
// ONLINE_CONTINUOUS_UPDATE or the ONLINE_UPDATING_PIPELINE_RESOURCES state.
type ContinuousUpdateStatus struct {
	// Progress of the initial data synchronization.
	InitialPipelineSyncProgress types.Object `tfsdk:"initial_pipeline_sync_progress"`
	// The last source table Delta version that was synced to the online table.
	// Note that this Delta version may not be completely synced to the online
	// table yet.
	LastProcessedCommitVersion types.Int64 `tfsdk:"last_processed_commit_version"`
	// The timestamp of the last time any data was synchronized from the source
	// table to the online table.
	Timestamp types.String `tfsdk:"timestamp"`
}

func (toState *ContinuousUpdateStatus) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ContinuousUpdateStatus) {
	if !fromPlan.InitialPipelineSyncProgress.IsNull() && !fromPlan.InitialPipelineSyncProgress.IsUnknown() {
		if toStateInitialPipelineSyncProgress, ok := toState.GetInitialPipelineSyncProgress(ctx); ok {
			if fromPlanInitialPipelineSyncProgress, ok := fromPlan.GetInitialPipelineSyncProgress(ctx); ok {
				toStateInitialPipelineSyncProgress.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInitialPipelineSyncProgress)
				toState.SetInitialPipelineSyncProgress(ctx, toStateInitialPipelineSyncProgress)
			}
		}
	}
}

func (toState *ContinuousUpdateStatus) SyncFieldsDuringRead(ctx context.Context, fromState ContinuousUpdateStatus) {
	if !fromState.InitialPipelineSyncProgress.IsNull() && !fromState.InitialPipelineSyncProgress.IsUnknown() {
		if toStateInitialPipelineSyncProgress, ok := toState.GetInitialPipelineSyncProgress(ctx); ok {
			if fromStateInitialPipelineSyncProgress, ok := fromState.GetInitialPipelineSyncProgress(ctx); ok {
				toStateInitialPipelineSyncProgress.SyncFieldsDuringRead(ctx, fromStateInitialPipelineSyncProgress)
				toState.SetInitialPipelineSyncProgress(ctx, toStateInitialPipelineSyncProgress)
			}
		}
	}
}

func (c ContinuousUpdateStatus) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["initial_pipeline_sync_progress"] = attrs["initial_pipeline_sync_progress"].SetOptional()
	attrs["last_processed_commit_version"] = attrs["last_processed_commit_version"].SetOptional()
	attrs["timestamp"] = attrs["timestamp"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ContinuousUpdateStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ContinuousUpdateStatus) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"initial_pipeline_sync_progress": reflect.TypeOf(PipelineProgress{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ContinuousUpdateStatus
// only implements ToObjectValue() and Type().
func (o ContinuousUpdateStatus) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"initial_pipeline_sync_progress": o.InitialPipelineSyncProgress,
			"last_processed_commit_version":  o.LastProcessedCommitVersion,
			"timestamp":                      o.Timestamp,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ContinuousUpdateStatus) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"initial_pipeline_sync_progress": PipelineProgress{}.Type(ctx),
			"last_processed_commit_version":  types.Int64Type,
			"timestamp":                      types.StringType,
		},
	}
}

// GetInitialPipelineSyncProgress returns the value of the InitialPipelineSyncProgress field in ContinuousUpdateStatus as
// a PipelineProgress value.
// If the field is unknown or null, the boolean return value is false.
func (o *ContinuousUpdateStatus) GetInitialPipelineSyncProgress(ctx context.Context) (PipelineProgress, bool) {
	var e PipelineProgress
	if o.InitialPipelineSyncProgress.IsNull() || o.InitialPipelineSyncProgress.IsUnknown() {
		return e, false
	}
	var v PipelineProgress
	d := o.InitialPipelineSyncProgress.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInitialPipelineSyncProgress sets the value of the InitialPipelineSyncProgress field in ContinuousUpdateStatus.
func (o *ContinuousUpdateStatus) SetInitialPipelineSyncProgress(ctx context.Context, v PipelineProgress) {
	vs := v.ToObjectValue(ctx)
	o.InitialPipelineSyncProgress = vs
}

type CreateAccessRequest struct {
	// Optional. The principal this request is for. Empty `behalf_of` defaults
	// to the requester's identity.
	//
	// Principals must be unique across the API call.
	BehalfOf types.Object `tfsdk:"behalf_of"`
	// Optional. Comment associated with the request.
	//
	// At most 200 characters, can only contain lowercase/uppercase letters
	// (a-z, A-Z), numbers (0-9), punctuation, and spaces.
	Comment types.String `tfsdk:"comment"`
	// List of securables and their corresponding requested UC privileges.
	//
	// At most 30 securables can be requested for a principal per batched call.
	// Each securable can only be requested once per principal.
	SecurablePermissions types.List `tfsdk:"securable_permissions"`
}

func (toState *CreateAccessRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateAccessRequest) {
	if !fromPlan.BehalfOf.IsNull() && !fromPlan.BehalfOf.IsUnknown() {
		if toStateBehalfOf, ok := toState.GetBehalfOf(ctx); ok {
			if fromPlanBehalfOf, ok := fromPlan.GetBehalfOf(ctx); ok {
				toStateBehalfOf.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanBehalfOf)
				toState.SetBehalfOf(ctx, toStateBehalfOf)
			}
		}
	}
}

func (toState *CreateAccessRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateAccessRequest) {
	if !fromState.BehalfOf.IsNull() && !fromState.BehalfOf.IsUnknown() {
		if toStateBehalfOf, ok := toState.GetBehalfOf(ctx); ok {
			if fromStateBehalfOf, ok := fromState.GetBehalfOf(ctx); ok {
				toStateBehalfOf.SyncFieldsDuringRead(ctx, fromStateBehalfOf)
				toState.SetBehalfOf(ctx, toStateBehalfOf)
			}
		}
	}
}

func (c CreateAccessRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["behalf_of"] = attrs["behalf_of"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["securable_permissions"] = attrs["securable_permissions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccessRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateAccessRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"behalf_of":             reflect.TypeOf(Principal{}),
		"securable_permissions": reflect.TypeOf(SecurablePermissions{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccessRequest
// only implements ToObjectValue() and Type().
func (o CreateAccessRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"behalf_of":             o.BehalfOf,
			"comment":               o.Comment,
			"securable_permissions": o.SecurablePermissions,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateAccessRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"behalf_of": Principal{}.Type(ctx),
			"comment":   types.StringType,
			"securable_permissions": basetypes.ListType{
				ElemType: SecurablePermissions{}.Type(ctx),
			},
		},
	}
}

// GetBehalfOf returns the value of the BehalfOf field in CreateAccessRequest as
// a Principal value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccessRequest) GetBehalfOf(ctx context.Context) (Principal, bool) {
	var e Principal
	if o.BehalfOf.IsNull() || o.BehalfOf.IsUnknown() {
		return e, false
	}
	var v Principal
	d := o.BehalfOf.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBehalfOf sets the value of the BehalfOf field in CreateAccessRequest.
func (o *CreateAccessRequest) SetBehalfOf(ctx context.Context, v Principal) {
	vs := v.ToObjectValue(ctx)
	o.BehalfOf = vs
}

// GetSecurablePermissions returns the value of the SecurablePermissions field in CreateAccessRequest as
// a slice of SecurablePermissions values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccessRequest) GetSecurablePermissions(ctx context.Context) ([]SecurablePermissions, bool) {
	if o.SecurablePermissions.IsNull() || o.SecurablePermissions.IsUnknown() {
		return nil, false
	}
	var v []SecurablePermissions
	d := o.SecurablePermissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSecurablePermissions sets the value of the SecurablePermissions field in CreateAccessRequest.
func (o *CreateAccessRequest) SetSecurablePermissions(ctx context.Context, v []SecurablePermissions) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["securable_permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.SecurablePermissions = types.ListValueMust(t, vs)
}

type CreateAccessRequestResponse struct {
	// The principal the request was made on behalf of.
	BehalfOf types.Object `tfsdk:"behalf_of"`
	// The access request destinations for all the securables the principal
	// requested.
	RequestDestinations types.List `tfsdk:"request_destinations"`
}

func (toState *CreateAccessRequestResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateAccessRequestResponse) {
	if !fromPlan.BehalfOf.IsNull() && !fromPlan.BehalfOf.IsUnknown() {
		if toStateBehalfOf, ok := toState.GetBehalfOf(ctx); ok {
			if fromPlanBehalfOf, ok := fromPlan.GetBehalfOf(ctx); ok {
				toStateBehalfOf.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanBehalfOf)
				toState.SetBehalfOf(ctx, toStateBehalfOf)
			}
		}
	}
}

func (toState *CreateAccessRequestResponse) SyncFieldsDuringRead(ctx context.Context, fromState CreateAccessRequestResponse) {
	if !fromState.BehalfOf.IsNull() && !fromState.BehalfOf.IsUnknown() {
		if toStateBehalfOf, ok := toState.GetBehalfOf(ctx); ok {
			if fromStateBehalfOf, ok := fromState.GetBehalfOf(ctx); ok {
				toStateBehalfOf.SyncFieldsDuringRead(ctx, fromStateBehalfOf)
				toState.SetBehalfOf(ctx, toStateBehalfOf)
			}
		}
	}
}

func (c CreateAccessRequestResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["behalf_of"] = attrs["behalf_of"].SetOptional()
	attrs["request_destinations"] = attrs["request_destinations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccessRequestResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateAccessRequestResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"behalf_of":            reflect.TypeOf(Principal{}),
		"request_destinations": reflect.TypeOf(AccessRequestDestinations{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccessRequestResponse
// only implements ToObjectValue() and Type().
func (o CreateAccessRequestResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"behalf_of":            o.BehalfOf,
			"request_destinations": o.RequestDestinations,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateAccessRequestResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"behalf_of": Principal{}.Type(ctx),
			"request_destinations": basetypes.ListType{
				ElemType: AccessRequestDestinations{}.Type(ctx),
			},
		},
	}
}

// GetBehalfOf returns the value of the BehalfOf field in CreateAccessRequestResponse as
// a Principal value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccessRequestResponse) GetBehalfOf(ctx context.Context) (Principal, bool) {
	var e Principal
	if o.BehalfOf.IsNull() || o.BehalfOf.IsUnknown() {
		return e, false
	}
	var v Principal
	d := o.BehalfOf.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBehalfOf sets the value of the BehalfOf field in CreateAccessRequestResponse.
func (o *CreateAccessRequestResponse) SetBehalfOf(ctx context.Context, v Principal) {
	vs := v.ToObjectValue(ctx)
	o.BehalfOf = vs
}

// GetRequestDestinations returns the value of the RequestDestinations field in CreateAccessRequestResponse as
// a slice of AccessRequestDestinations values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccessRequestResponse) GetRequestDestinations(ctx context.Context) ([]AccessRequestDestinations, bool) {
	if o.RequestDestinations.IsNull() || o.RequestDestinations.IsUnknown() {
		return nil, false
	}
	var v []AccessRequestDestinations
	d := o.RequestDestinations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRequestDestinations sets the value of the RequestDestinations field in CreateAccessRequestResponse.
func (o *CreateAccessRequestResponse) SetRequestDestinations(ctx context.Context, v []AccessRequestDestinations) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["request_destinations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.RequestDestinations = types.ListValueMust(t, vs)
}

type CreateCatalog struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// The name of the connection to an external data source.
	ConnectionName types.String `tfsdk:"connection_name"`
	// Name of catalog.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// The name of delta sharing provider.
	//
	// A Delta Sharing catalog is a catalog that is based on a Delta share on a
	// remote sharing server.
	ProviderName types.String `tfsdk:"provider_name"`
	// The name of the share under the share provider.
	ShareName types.String `tfsdk:"share_name"`
	// Storage root URL for managed tables within catalog.
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (toState *CreateCatalog) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateCatalog) {
}

func (toState *CreateCatalog) SyncFieldsDuringRead(ctx context.Context, fromState CreateCatalog) {
}

func (c CreateCatalog) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_name"] = attrs["connection_name"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["provider_name"] = attrs["provider_name"].SetOptional()
	attrs["share_name"] = attrs["share_name"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateCatalog.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateCatalog) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateCatalog
// only implements ToObjectValue() and Type().
func (o CreateCatalog) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":         o.Comment,
			"connection_name": o.ConnectionName,
			"name":            o.Name,
			"options":         o.Options,
			"properties":      o.Properties,
			"provider_name":   o.ProviderName,
			"share_name":      o.ShareName,
			"storage_root":    o.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateCatalog) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":         types.StringType,
			"connection_name": types.StringType,
			"name":            types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"provider_name": types.StringType,
			"share_name":    types.StringType,
			"storage_root":  types.StringType,
		},
	}
}

// GetOptions returns the value of the Options field in CreateCatalog as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateCatalog) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in CreateCatalog.
func (o *CreateCatalog) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateCatalog as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateCatalog) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateCatalog.
func (o *CreateCatalog) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

type CreateConnection struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// The type of connection.
	ConnectionType types.String `tfsdk:"connection_type"`
	// Name of the connection.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// If the connection is read only.
	ReadOnly types.Bool `tfsdk:"read_only"`
}

func (toState *CreateConnection) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateConnection) {
}

func (toState *CreateConnection) SyncFieldsDuringRead(ctx context.Context, fromState CreateConnection) {
}

func (c CreateConnection) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["connection_type"] = attrs["connection_type"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["options"] = attrs["options"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateConnection.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateConnection) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateConnection
// only implements ToObjectValue() and Type().
func (o CreateConnection) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":         o.Comment,
			"connection_type": o.ConnectionType,
			"name":            o.Name,
			"options":         o.Options,
			"properties":      o.Properties,
			"read_only":       o.ReadOnly,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateConnection) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":         types.StringType,
			"connection_type": types.StringType,
			"name":            types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"read_only": types.BoolType,
		},
	}
}

// GetOptions returns the value of the Options field in CreateConnection as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateConnection) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in CreateConnection.
func (o *CreateConnection) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateConnection as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateConnection) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateConnection.
func (o *CreateConnection) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

type CreateCredentialRequest struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Indicates the purpose of the credential.
	Purpose types.String `tfsdk:"purpose"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Optional. Supplying true to this argument skips validation of the created
	// set of credentials.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (toState *CreateCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateCredentialRequest) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *CreateCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateCredentialRequest) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c CreateCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["purpose"] = attrs["purpose"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateCredentialRequest
// only implements ToObjectValue() and Type().
func (o CreateCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"comment":                        o.Comment,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"name":                           o.Name,
			"purpose":                        o.Purpose,
			"read_only":                      o.ReadOnly,
			"skip_validation":                o.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRole{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentity{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"comment":                        types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccount{}.Type(ctx),
			"name":                           types.StringType,
			"purpose":                        types.StringType,
			"read_only":                      types.BoolType,
			"skip_validation":                types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CreateCredentialRequest as
// a AwsIamRole value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateCredentialRequest) GetAwsIamRole(ctx context.Context) (AwsIamRole, bool) {
	var e AwsIamRole
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRole
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CreateCredentialRequest.
func (o *CreateCredentialRequest) SetAwsIamRole(ctx context.Context, v AwsIamRole) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CreateCredentialRequest as
// a AzureManagedIdentity value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateCredentialRequest) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity, bool) {
	var e AzureManagedIdentity
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentity
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CreateCredentialRequest.
func (o *CreateCredentialRequest) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CreateCredentialRequest as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateCredentialRequest) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CreateCredentialRequest.
func (o *CreateCredentialRequest) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CreateCredentialRequest as
// a DatabricksGcpServiceAccount value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateCredentialRequest) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount, bool) {
	var e DatabricksGcpServiceAccount
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccount
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CreateCredentialRequest.
func (o *CreateCredentialRequest) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type CreateEntityTagAssignmentRequest struct {
	TagAssignment types.Object `tfsdk:"tag_assignment"`
}

func (toState *CreateEntityTagAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateEntityTagAssignmentRequest) {
	if !fromPlan.TagAssignment.IsNull() && !fromPlan.TagAssignment.IsUnknown() {
		if toStateTagAssignment, ok := toState.GetTagAssignment(ctx); ok {
			if fromPlanTagAssignment, ok := fromPlan.GetTagAssignment(ctx); ok {
				toStateTagAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTagAssignment)
				toState.SetTagAssignment(ctx, toStateTagAssignment)
			}
		}
	}
}

func (toState *CreateEntityTagAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateEntityTagAssignmentRequest) {
	if !fromState.TagAssignment.IsNull() && !fromState.TagAssignment.IsUnknown() {
		if toStateTagAssignment, ok := toState.GetTagAssignment(ctx); ok {
			if fromStateTagAssignment, ok := fromState.GetTagAssignment(ctx); ok {
				toStateTagAssignment.SyncFieldsDuringRead(ctx, fromStateTagAssignment)
				toState.SetTagAssignment(ctx, toStateTagAssignment)
			}
		}
	}
}

func (c CreateEntityTagAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["tag_assignment"] = attrs["tag_assignment"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateEntityTagAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tag_assignment": reflect.TypeOf(EntityTagAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateEntityTagAssignmentRequest
// only implements ToObjectValue() and Type().
func (o CreateEntityTagAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"tag_assignment": o.TagAssignment,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateEntityTagAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"tag_assignment": EntityTagAssignment{}.Type(ctx),
		},
	}
}

// GetTagAssignment returns the value of the TagAssignment field in CreateEntityTagAssignmentRequest as
// a EntityTagAssignment value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateEntityTagAssignmentRequest) GetTagAssignment(ctx context.Context) (EntityTagAssignment, bool) {
	var e EntityTagAssignment
	if o.TagAssignment.IsNull() || o.TagAssignment.IsUnknown() {
		return e, false
	}
	var v EntityTagAssignment
	d := o.TagAssignment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTagAssignment sets the value of the TagAssignment field in CreateEntityTagAssignmentRequest.
func (o *CreateEntityTagAssignmentRequest) SetTagAssignment(ctx context.Context, v EntityTagAssignment) {
	vs := v.ToObjectValue(ctx)
	o.TagAssignment = vs
}

type CreateExternalLineageRelationshipRequest struct {
	ExternalLineageRelationship types.Object `tfsdk:"external_lineage_relationship"`
}

func (toState *CreateExternalLineageRelationshipRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateExternalLineageRelationshipRequest) {
	if !fromPlan.ExternalLineageRelationship.IsNull() && !fromPlan.ExternalLineageRelationship.IsUnknown() {
		if toStateExternalLineageRelationship, ok := toState.GetExternalLineageRelationship(ctx); ok {
			if fromPlanExternalLineageRelationship, ok := fromPlan.GetExternalLineageRelationship(ctx); ok {
				toStateExternalLineageRelationship.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalLineageRelationship)
				toState.SetExternalLineageRelationship(ctx, toStateExternalLineageRelationship)
			}
		}
	}
}

func (toState *CreateExternalLineageRelationshipRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateExternalLineageRelationshipRequest) {
	if !fromState.ExternalLineageRelationship.IsNull() && !fromState.ExternalLineageRelationship.IsUnknown() {
		if toStateExternalLineageRelationship, ok := toState.GetExternalLineageRelationship(ctx); ok {
			if fromStateExternalLineageRelationship, ok := fromState.GetExternalLineageRelationship(ctx); ok {
				toStateExternalLineageRelationship.SyncFieldsDuringRead(ctx, fromStateExternalLineageRelationship)
				toState.SetExternalLineageRelationship(ctx, toStateExternalLineageRelationship)
			}
		}
	}
}

func (c CreateExternalLineageRelationshipRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateExternalLineageRelationshipRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateExternalLineageRelationshipRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationship": reflect.TypeOf(CreateRequestExternalLineage{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateExternalLineageRelationshipRequest
// only implements ToObjectValue() and Type().
func (o CreateExternalLineageRelationshipRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationship": o.ExternalLineageRelationship,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateExternalLineageRelationshipRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationship": CreateRequestExternalLineage{}.Type(ctx),
		},
	}
}

// GetExternalLineageRelationship returns the value of the ExternalLineageRelationship field in CreateExternalLineageRelationshipRequest as
// a CreateRequestExternalLineage value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateExternalLineageRelationshipRequest) GetExternalLineageRelationship(ctx context.Context) (CreateRequestExternalLineage, bool) {
	var e CreateRequestExternalLineage
	if o.ExternalLineageRelationship.IsNull() || o.ExternalLineageRelationship.IsUnknown() {
		return e, false
	}
	var v CreateRequestExternalLineage
	d := o.ExternalLineageRelationship.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLineageRelationship sets the value of the ExternalLineageRelationship field in CreateExternalLineageRelationshipRequest.
func (o *CreateExternalLineageRelationshipRequest) SetExternalLineageRelationship(ctx context.Context, v CreateRequestExternalLineage) {
	vs := v.ToObjectValue(ctx)
	o.ExternalLineageRelationship = vs
}

type CreateExternalLocation struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of the storage credential used with this location.
	CredentialName types.String `tfsdk:"credential_name"`
	// Whether to enable file events on this external location.
	EnableFileEvents types.Bool `tfsdk:"enable_file_events"`

	EncryptionDetails types.Object `tfsdk:"encryption_details"`
	// Indicates whether fallback mode is enabled for this external location.
	// When fallback mode is enabled, the access to the location falls back to
	// cluster credentials if UC credentials are not sufficient.
	Fallback types.Bool `tfsdk:"fallback"`
	// File event queue settings. If `enable_file_events` is `true`, must be
	// defined and have exactly one of the documented properties.
	FileEventQueue types.Object `tfsdk:"file_event_queue"`
	// Name of the external location.
	Name types.String `tfsdk:"name"`
	// Indicates whether the external location is read-only.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Skips validation of the storage credential associated with the external
	// location.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
	// Path URL of the external location.
	Url types.String `tfsdk:"url"`
}

func (toState *CreateExternalLocation) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateExternalLocation) {
	if !fromPlan.EncryptionDetails.IsNull() && !fromPlan.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromPlanEncryptionDetails, ok := fromPlan.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromPlan.FileEventQueue.IsNull() && !fromPlan.FileEventQueue.IsUnknown() {
		if toStateFileEventQueue, ok := toState.GetFileEventQueue(ctx); ok {
			if fromPlanFileEventQueue, ok := fromPlan.GetFileEventQueue(ctx); ok {
				toStateFileEventQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFileEventQueue)
				toState.SetFileEventQueue(ctx, toStateFileEventQueue)
			}
		}
	}
}

func (toState *CreateExternalLocation) SyncFieldsDuringRead(ctx context.Context, fromState CreateExternalLocation) {
	if !fromState.EncryptionDetails.IsNull() && !fromState.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromStateEncryptionDetails, ok := fromState.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringRead(ctx, fromStateEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromState.FileEventQueue.IsNull() && !fromState.FileEventQueue.IsUnknown() {
		if toStateFileEventQueue, ok := toState.GetFileEventQueue(ctx); ok {
			if fromStateFileEventQueue, ok := fromState.GetFileEventQueue(ctx); ok {
				toStateFileEventQueue.SyncFieldsDuringRead(ctx, fromStateFileEventQueue)
				toState.SetFileEventQueue(ctx, toStateFileEventQueue)
			}
		}
	}
}

func (c CreateExternalLocation) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetRequired()
	attrs["enable_file_events"] = attrs["enable_file_events"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["fallback"] = attrs["fallback"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["url"] = attrs["url"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateExternalLocation.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateExternalLocation) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails{}),
		"file_event_queue":   reflect.TypeOf(FileEventQueue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateExternalLocation
// only implements ToObjectValue() and Type().
func (o CreateExternalLocation) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            o.Comment,
			"credential_name":    o.CredentialName,
			"enable_file_events": o.EnableFileEvents,
			"encryption_details": o.EncryptionDetails,
			"fallback":           o.Fallback,
			"file_event_queue":   o.FileEventQueue,
			"name":               o.Name,
			"read_only":          o.ReadOnly,
			"skip_validation":    o.SkipValidation,
			"url":                o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateExternalLocation) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"credential_name":    types.StringType,
			"enable_file_events": types.BoolType,
			"encryption_details": EncryptionDetails{}.Type(ctx),
			"fallback":           types.BoolType,
			"file_event_queue":   FileEventQueue{}.Type(ctx),
			"name":               types.StringType,
			"read_only":          types.BoolType,
			"skip_validation":    types.BoolType,
			"url":                types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in CreateExternalLocation as
// a EncryptionDetails value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateExternalLocation) GetEncryptionDetails(ctx context.Context) (EncryptionDetails, bool) {
	var e EncryptionDetails
	if o.EncryptionDetails.IsNull() || o.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v EncryptionDetails
	d := o.EncryptionDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in CreateExternalLocation.
func (o *CreateExternalLocation) SetEncryptionDetails(ctx context.Context, v EncryptionDetails) {
	vs := v.ToObjectValue(ctx)
	o.EncryptionDetails = vs
}

// GetFileEventQueue returns the value of the FileEventQueue field in CreateExternalLocation as
// a FileEventQueue value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateExternalLocation) GetFileEventQueue(ctx context.Context) (FileEventQueue, bool) {
	var e FileEventQueue
	if o.FileEventQueue.IsNull() || o.FileEventQueue.IsUnknown() {
		return e, false
	}
	var v FileEventQueue
	d := o.FileEventQueue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFileEventQueue sets the value of the FileEventQueue field in CreateExternalLocation.
func (o *CreateExternalLocation) SetFileEventQueue(ctx context.Context, v FileEventQueue) {
	vs := v.ToObjectValue(ctx)
	o.FileEventQueue = vs
}

type CreateExternalMetadataRequest struct {
	ExternalMetadata types.Object `tfsdk:"external_metadata"`
}

func (toState *CreateExternalMetadataRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateExternalMetadataRequest) {
	if !fromPlan.ExternalMetadata.IsNull() && !fromPlan.ExternalMetadata.IsUnknown() {
		if toStateExternalMetadata, ok := toState.GetExternalMetadata(ctx); ok {
			if fromPlanExternalMetadata, ok := fromPlan.GetExternalMetadata(ctx); ok {
				toStateExternalMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalMetadata)
				toState.SetExternalMetadata(ctx, toStateExternalMetadata)
			}
		}
	}
}

func (toState *CreateExternalMetadataRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateExternalMetadataRequest) {
	if !fromState.ExternalMetadata.IsNull() && !fromState.ExternalMetadata.IsUnknown() {
		if toStateExternalMetadata, ok := toState.GetExternalMetadata(ctx); ok {
			if fromStateExternalMetadata, ok := fromState.GetExternalMetadata(ctx); ok {
				toStateExternalMetadata.SyncFieldsDuringRead(ctx, fromStateExternalMetadata)
				toState.SetExternalMetadata(ctx, toStateExternalMetadata)
			}
		}
	}
}

func (c CreateExternalMetadataRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateExternalMetadataRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalMetadata{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateExternalMetadataRequest
// only implements ToObjectValue() and Type().
func (o CreateExternalMetadataRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": o.ExternalMetadata,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateExternalMetadataRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": ExternalMetadata{}.Type(ctx),
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in CreateExternalMetadataRequest as
// a ExternalMetadata value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateExternalMetadataRequest) GetExternalMetadata(ctx context.Context) (ExternalMetadata, bool) {
	var e ExternalMetadata
	if o.ExternalMetadata.IsNull() || o.ExternalMetadata.IsUnknown() {
		return e, false
	}
	var v ExternalMetadata
	d := o.ExternalMetadata.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in CreateExternalMetadataRequest.
func (o *CreateExternalMetadataRequest) SetExternalMetadata(ctx context.Context, v ExternalMetadata) {
	vs := v.ToObjectValue(ctx)
	o.ExternalMetadata = vs
}

type CreateFunction struct {
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Scalar function return data type.
	DataType types.String `tfsdk:"data_type"`
	// External function language.
	ExternalLanguage types.String `tfsdk:"external_language"`
	// External function name.
	ExternalName types.String `tfsdk:"external_name"`
	// Pretty printed function data type.
	FullDataType types.String `tfsdk:"full_data_type"`

	InputParams types.Object `tfsdk:"input_params"`
	// Whether the function is deterministic.
	IsDeterministic types.Bool `tfsdk:"is_deterministic"`
	// Function null call.
	IsNullCall types.Bool `tfsdk:"is_null_call"`
	// Name of function, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// Function parameter style. **S** is the value for SQL.
	ParameterStyle types.String `tfsdk:"parameter_style"`
	// JSON-serialized key-value pair map, encoded (escaped) as a string.
	Properties types.String `tfsdk:"properties"`
	// Table function return parameters.
	ReturnParams types.Object `tfsdk:"return_params"`
	// Function language. When **EXTERNAL** is used, the language of the routine
	// function should be specified in the __external_language__ field, and the
	// __return_params__ of the function cannot be used (as **TABLE** return
	// type is not supported), and the __sql_data_access__ field must be
	// **NO_SQL**.
	RoutineBody types.String `tfsdk:"routine_body"`
	// Function body.
	RoutineDefinition types.String `tfsdk:"routine_definition"`
	// Function dependencies.
	RoutineDependencies types.Object `tfsdk:"routine_dependencies"`
	// Name of parent schema relative to its parent catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// Function security type.
	SecurityType types.String `tfsdk:"security_type"`
	// Specific name of the function; Reserved for future use.
	SpecificName types.String `tfsdk:"specific_name"`
	// Function SQL data access.
	SqlDataAccess types.String `tfsdk:"sql_data_access"`
	// List of schemes whose objects can be referenced without qualification.
	SqlPath types.String `tfsdk:"sql_path"`
}

func (toState *CreateFunction) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateFunction) {
	if !fromPlan.InputParams.IsNull() && !fromPlan.InputParams.IsUnknown() {
		if toStateInputParams, ok := toState.GetInputParams(ctx); ok {
			if fromPlanInputParams, ok := fromPlan.GetInputParams(ctx); ok {
				toStateInputParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInputParams)
				toState.SetInputParams(ctx, toStateInputParams)
			}
		}
	}
	if !fromPlan.ReturnParams.IsNull() && !fromPlan.ReturnParams.IsUnknown() {
		if toStateReturnParams, ok := toState.GetReturnParams(ctx); ok {
			if fromPlanReturnParams, ok := fromPlan.GetReturnParams(ctx); ok {
				toStateReturnParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanReturnParams)
				toState.SetReturnParams(ctx, toStateReturnParams)
			}
		}
	}
	if !fromPlan.RoutineDependencies.IsNull() && !fromPlan.RoutineDependencies.IsUnknown() {
		if toStateRoutineDependencies, ok := toState.GetRoutineDependencies(ctx); ok {
			if fromPlanRoutineDependencies, ok := fromPlan.GetRoutineDependencies(ctx); ok {
				toStateRoutineDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanRoutineDependencies)
				toState.SetRoutineDependencies(ctx, toStateRoutineDependencies)
			}
		}
	}
}

func (toState *CreateFunction) SyncFieldsDuringRead(ctx context.Context, fromState CreateFunction) {
	if !fromState.InputParams.IsNull() && !fromState.InputParams.IsUnknown() {
		if toStateInputParams, ok := toState.GetInputParams(ctx); ok {
			if fromStateInputParams, ok := fromState.GetInputParams(ctx); ok {
				toStateInputParams.SyncFieldsDuringRead(ctx, fromStateInputParams)
				toState.SetInputParams(ctx, toStateInputParams)
			}
		}
	}
	if !fromState.ReturnParams.IsNull() && !fromState.ReturnParams.IsUnknown() {
		if toStateReturnParams, ok := toState.GetReturnParams(ctx); ok {
			if fromStateReturnParams, ok := fromState.GetReturnParams(ctx); ok {
				toStateReturnParams.SyncFieldsDuringRead(ctx, fromStateReturnParams)
				toState.SetReturnParams(ctx, toStateReturnParams)
			}
		}
	}
	if !fromState.RoutineDependencies.IsNull() && !fromState.RoutineDependencies.IsUnknown() {
		if toStateRoutineDependencies, ok := toState.GetRoutineDependencies(ctx); ok {
			if fromStateRoutineDependencies, ok := fromState.GetRoutineDependencies(ctx); ok {
				toStateRoutineDependencies.SyncFieldsDuringRead(ctx, fromStateRoutineDependencies)
				toState.SetRoutineDependencies(ctx, toStateRoutineDependencies)
			}
		}
	}
}

func (c CreateFunction) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["data_type"] = attrs["data_type"].SetRequired()
	attrs["external_language"] = attrs["external_language"].SetOptional()
	attrs["external_name"] = attrs["external_name"].SetOptional()
	attrs["full_data_type"] = attrs["full_data_type"].SetRequired()
	attrs["input_params"] = attrs["input_params"].SetRequired()
	attrs["is_deterministic"] = attrs["is_deterministic"].SetRequired()
	attrs["is_null_call"] = attrs["is_null_call"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["parameter_style"] = attrs["parameter_style"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["return_params"] = attrs["return_params"].SetOptional()
	attrs["routine_body"] = attrs["routine_body"].SetRequired()
	attrs["routine_definition"] = attrs["routine_definition"].SetRequired()
	attrs["routine_dependencies"] = attrs["routine_dependencies"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["security_type"] = attrs["security_type"].SetRequired()
	attrs["specific_name"] = attrs["specific_name"].SetRequired()
	attrs["sql_data_access"] = attrs["sql_data_access"].SetRequired()
	attrs["sql_path"] = attrs["sql_path"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateFunction.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateFunction) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_params":         reflect.TypeOf(FunctionParameterInfos{}),
		"return_params":        reflect.TypeOf(FunctionParameterInfos{}),
		"routine_dependencies": reflect.TypeOf(DependencyList{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateFunction
// only implements ToObjectValue() and Type().
func (o CreateFunction) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":         o.CatalogName,
			"comment":              o.Comment,
			"data_type":            o.DataType,
			"external_language":    o.ExternalLanguage,
			"external_name":        o.ExternalName,
			"full_data_type":       o.FullDataType,
			"input_params":         o.InputParams,
			"is_deterministic":     o.IsDeterministic,
			"is_null_call":         o.IsNullCall,
			"name":                 o.Name,
			"parameter_style":      o.ParameterStyle,
			"properties":           o.Properties,
			"return_params":        o.ReturnParams,
			"routine_body":         o.RoutineBody,
			"routine_definition":   o.RoutineDefinition,
			"routine_dependencies": o.RoutineDependencies,
			"schema_name":          o.SchemaName,
			"security_type":        o.SecurityType,
			"specific_name":        o.SpecificName,
			"sql_data_access":      o.SqlDataAccess,
			"sql_path":             o.SqlPath,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateFunction) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":         types.StringType,
			"comment":              types.StringType,
			"data_type":            types.StringType,
			"external_language":    types.StringType,
			"external_name":        types.StringType,
			"full_data_type":       types.StringType,
			"input_params":         FunctionParameterInfos{}.Type(ctx),
			"is_deterministic":     types.BoolType,
			"is_null_call":         types.BoolType,
			"name":                 types.StringType,
			"parameter_style":      types.StringType,
			"properties":           types.StringType,
			"return_params":        FunctionParameterInfos{}.Type(ctx),
			"routine_body":         types.StringType,
			"routine_definition":   types.StringType,
			"routine_dependencies": DependencyList{}.Type(ctx),
			"schema_name":          types.StringType,
			"security_type":        types.StringType,
			"specific_name":        types.StringType,
			"sql_data_access":      types.StringType,
			"sql_path":             types.StringType,
		},
	}
}

// GetInputParams returns the value of the InputParams field in CreateFunction as
// a FunctionParameterInfos value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateFunction) GetInputParams(ctx context.Context) (FunctionParameterInfos, bool) {
	var e FunctionParameterInfos
	if o.InputParams.IsNull() || o.InputParams.IsUnknown() {
		return e, false
	}
	var v FunctionParameterInfos
	d := o.InputParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInputParams sets the value of the InputParams field in CreateFunction.
func (o *CreateFunction) SetInputParams(ctx context.Context, v FunctionParameterInfos) {
	vs := v.ToObjectValue(ctx)
	o.InputParams = vs
}

// GetReturnParams returns the value of the ReturnParams field in CreateFunction as
// a FunctionParameterInfos value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateFunction) GetReturnParams(ctx context.Context) (FunctionParameterInfos, bool) {
	var e FunctionParameterInfos
	if o.ReturnParams.IsNull() || o.ReturnParams.IsUnknown() {
		return e, false
	}
	var v FunctionParameterInfos
	d := o.ReturnParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetReturnParams sets the value of the ReturnParams field in CreateFunction.
func (o *CreateFunction) SetReturnParams(ctx context.Context, v FunctionParameterInfos) {
	vs := v.ToObjectValue(ctx)
	o.ReturnParams = vs
}

// GetRoutineDependencies returns the value of the RoutineDependencies field in CreateFunction as
// a DependencyList value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateFunction) GetRoutineDependencies(ctx context.Context) (DependencyList, bool) {
	var e DependencyList
	if o.RoutineDependencies.IsNull() || o.RoutineDependencies.IsUnknown() {
		return e, false
	}
	var v DependencyList
	d := o.RoutineDependencies.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoutineDependencies sets the value of the RoutineDependencies field in CreateFunction.
func (o *CreateFunction) SetRoutineDependencies(ctx context.Context, v DependencyList) {
	vs := v.ToObjectValue(ctx)
	o.RoutineDependencies = vs
}

type CreateFunctionRequest struct {
	// Partial __FunctionInfo__ specifying the function to be created.
	FunctionInfo types.Object `tfsdk:"function_info"`
}

func (toState *CreateFunctionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateFunctionRequest) {
	if !fromPlan.FunctionInfo.IsNull() && !fromPlan.FunctionInfo.IsUnknown() {
		if toStateFunctionInfo, ok := toState.GetFunctionInfo(ctx); ok {
			if fromPlanFunctionInfo, ok := fromPlan.GetFunctionInfo(ctx); ok {
				toStateFunctionInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFunctionInfo)
				toState.SetFunctionInfo(ctx, toStateFunctionInfo)
			}
		}
	}
}

func (toState *CreateFunctionRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateFunctionRequest) {
	if !fromState.FunctionInfo.IsNull() && !fromState.FunctionInfo.IsUnknown() {
		if toStateFunctionInfo, ok := toState.GetFunctionInfo(ctx); ok {
			if fromStateFunctionInfo, ok := fromState.GetFunctionInfo(ctx); ok {
				toStateFunctionInfo.SyncFieldsDuringRead(ctx, fromStateFunctionInfo)
				toState.SetFunctionInfo(ctx, toStateFunctionInfo)
			}
		}
	}
}

func (c CreateFunctionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_info"] = attrs["function_info"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateFunctionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateFunctionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"function_info": reflect.TypeOf(CreateFunction{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateFunctionRequest
// only implements ToObjectValue() and Type().
func (o CreateFunctionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_info": o.FunctionInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateFunctionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_info": CreateFunction{}.Type(ctx),
		},
	}
}

// GetFunctionInfo returns the value of the FunctionInfo field in CreateFunctionRequest as
// a CreateFunction value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateFunctionRequest) GetFunctionInfo(ctx context.Context) (CreateFunction, bool) {
	var e CreateFunction
	if o.FunctionInfo.IsNull() || o.FunctionInfo.IsUnknown() {
		return e, false
	}
	var v CreateFunction
	d := o.FunctionInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFunctionInfo sets the value of the FunctionInfo field in CreateFunctionRequest.
func (o *CreateFunctionRequest) SetFunctionInfo(ctx context.Context, v CreateFunction) {
	vs := v.ToObjectValue(ctx)
	o.FunctionInfo = vs
}

type CreateMetastore struct {
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (toState *CreateMetastore) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateMetastore) {
}

func (toState *CreateMetastore) SyncFieldsDuringRead(ctx context.Context, fromState CreateMetastore) {
}

func (c CreateMetastore) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateMetastore) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateMetastore
// only implements ToObjectValue() and Type().
func (o CreateMetastore) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":         o.Name,
			"region":       o.Region,
			"storage_root": o.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateMetastore) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":         types.StringType,
			"region":       types.StringType,
			"storage_root": types.StringType,
		},
	}
}

type CreateMetastoreAssignment struct {
	// The name of the default catalog in the metastore. This field is
	// deprecated. Please use "Default Namespace API" to configure the default
	// catalog for a Databricks workspace.
	DefaultCatalogName types.String `tfsdk:"default_catalog_name"`
	// The unique ID of the metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// A workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *CreateMetastoreAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateMetastoreAssignment) {
}

func (toState *CreateMetastoreAssignment) SyncFieldsDuringRead(ctx context.Context, fromState CreateMetastoreAssignment) {
}

func (c CreateMetastoreAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default_catalog_name"] = attrs["default_catalog_name"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateMetastoreAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateMetastoreAssignment
// only implements ToObjectValue() and Type().
func (o CreateMetastoreAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default_catalog_name": o.DefaultCatalogName,
			"metastore_id":         o.MetastoreId,
			"workspace_id":         o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateMetastoreAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default_catalog_name": types.StringType,
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

type CreateMonitor struct {
	// [Create:REQ Update:IGN] Field for specifying the absolute path to a
	// custom directory to store data-monitoring assets. Normally prepopulated
	// to a default user location via UI and Python APIs.
	AssetsDir types.String `tfsdk:"assets_dir"`
	// [Create:OPT Update:OPT] Baseline table name. Baseline data is used to
	// compute drift from the data in the monitored `table_name`. The baseline
	// table and the monitored table shall have the same schema.
	BaselineTableName types.String `tfsdk:"baseline_table_name"`
	// [Create:OPT Update:OPT] Custom metrics.
	CustomMetrics types.List `tfsdk:"custom_metrics"`
	// [Create:OPT Update:OPT] Data classification related config.
	DataClassificationConfig types.Object `tfsdk:"data_classification_config"`

	InferenceLog types.Object `tfsdk:"inference_log"`
	// [Create:ERR Update:IGN] The latest error message for a monitor failure.
	LatestMonitorFailureMsg types.String `tfsdk:"latest_monitor_failure_msg"`
	// [Create:OPT Update:OPT] Field for specifying notification settings.
	Notifications types.Object `tfsdk:"notifications"`
	// [Create:REQ Update:REQ] Schema where output tables are created. Needs to
	// be in 2-level format {catalog}.{schema}
	OutputSchemaName types.String `tfsdk:"output_schema_name"`
	// [Create:OPT Update:OPT] The monitor schedule.
	Schedule types.Object `tfsdk:"schedule"`
	// Whether to skip creating a default dashboard summarizing data quality
	// metrics.
	SkipBuiltinDashboard types.Bool `tfsdk:"skip_builtin_dashboard"`
	// [Create:OPT Update:OPT] List of column expressions to slice data with for
	// targeted analysis. The data is grouped by each expression independently,
	// resulting in a separate slice for each predicate and its complements. For
	// example `slicing_exprs=[col_1, col_2 > 10]` will generate the
	// following slices: two slices for `col_2 > 10` (True and False), and one
	// slice per unique value in `col1`. For high-cardinality columns, only the
	// top 100 unique values by frequency will generate slices.
	SlicingExprs types.List `tfsdk:"slicing_exprs"`
	// Configuration for monitoring snapshot tables.
	Snapshot types.Object `tfsdk:"snapshot"`
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
	// Configuration for monitoring time series tables.
	TimeSeries types.Object `tfsdk:"time_series"`
	// Optional argument to specify the warehouse for dashboard creation. If not
	// specified, the first running warehouse will be used.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (toState *CreateMonitor) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateMonitor) {
	if !fromPlan.DataClassificationConfig.IsNull() && !fromPlan.DataClassificationConfig.IsUnknown() {
		if toStateDataClassificationConfig, ok := toState.GetDataClassificationConfig(ctx); ok {
			if fromPlanDataClassificationConfig, ok := fromPlan.GetDataClassificationConfig(ctx); ok {
				toStateDataClassificationConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDataClassificationConfig)
				toState.SetDataClassificationConfig(ctx, toStateDataClassificationConfig)
			}
		}
	}
	if !fromPlan.InferenceLog.IsNull() && !fromPlan.InferenceLog.IsUnknown() {
		if toStateInferenceLog, ok := toState.GetInferenceLog(ctx); ok {
			if fromPlanInferenceLog, ok := fromPlan.GetInferenceLog(ctx); ok {
				toStateInferenceLog.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInferenceLog)
				toState.SetInferenceLog(ctx, toStateInferenceLog)
			}
		}
	}
	if !fromPlan.Notifications.IsNull() && !fromPlan.Notifications.IsUnknown() {
		if toStateNotifications, ok := toState.GetNotifications(ctx); ok {
			if fromPlanNotifications, ok := fromPlan.GetNotifications(ctx); ok {
				toStateNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanNotifications)
				toState.SetNotifications(ctx, toStateNotifications)
			}
		}
	}
	if !fromPlan.Schedule.IsNull() && !fromPlan.Schedule.IsUnknown() {
		if toStateSchedule, ok := toState.GetSchedule(ctx); ok {
			if fromPlanSchedule, ok := fromPlan.GetSchedule(ctx); ok {
				toStateSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSchedule)
				toState.SetSchedule(ctx, toStateSchedule)
			}
		}
	}
	if !fromPlan.Snapshot.IsNull() && !fromPlan.Snapshot.IsUnknown() {
		if toStateSnapshot, ok := toState.GetSnapshot(ctx); ok {
			if fromPlanSnapshot, ok := fromPlan.GetSnapshot(ctx); ok {
				toStateSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSnapshot)
				toState.SetSnapshot(ctx, toStateSnapshot)
			}
		}
	}
	if !fromPlan.TimeSeries.IsNull() && !fromPlan.TimeSeries.IsUnknown() {
		if toStateTimeSeries, ok := toState.GetTimeSeries(ctx); ok {
			if fromPlanTimeSeries, ok := fromPlan.GetTimeSeries(ctx); ok {
				toStateTimeSeries.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTimeSeries)
				toState.SetTimeSeries(ctx, toStateTimeSeries)
			}
		}
	}
}

func (toState *CreateMonitor) SyncFieldsDuringRead(ctx context.Context, fromState CreateMonitor) {
	if !fromState.DataClassificationConfig.IsNull() && !fromState.DataClassificationConfig.IsUnknown() {
		if toStateDataClassificationConfig, ok := toState.GetDataClassificationConfig(ctx); ok {
			if fromStateDataClassificationConfig, ok := fromState.GetDataClassificationConfig(ctx); ok {
				toStateDataClassificationConfig.SyncFieldsDuringRead(ctx, fromStateDataClassificationConfig)
				toState.SetDataClassificationConfig(ctx, toStateDataClassificationConfig)
			}
		}
	}
	if !fromState.InferenceLog.IsNull() && !fromState.InferenceLog.IsUnknown() {
		if toStateInferenceLog, ok := toState.GetInferenceLog(ctx); ok {
			if fromStateInferenceLog, ok := fromState.GetInferenceLog(ctx); ok {
				toStateInferenceLog.SyncFieldsDuringRead(ctx, fromStateInferenceLog)
				toState.SetInferenceLog(ctx, toStateInferenceLog)
			}
		}
	}
	if !fromState.Notifications.IsNull() && !fromState.Notifications.IsUnknown() {
		if toStateNotifications, ok := toState.GetNotifications(ctx); ok {
			if fromStateNotifications, ok := fromState.GetNotifications(ctx); ok {
				toStateNotifications.SyncFieldsDuringRead(ctx, fromStateNotifications)
				toState.SetNotifications(ctx, toStateNotifications)
			}
		}
	}
	if !fromState.Schedule.IsNull() && !fromState.Schedule.IsUnknown() {
		if toStateSchedule, ok := toState.GetSchedule(ctx); ok {
			if fromStateSchedule, ok := fromState.GetSchedule(ctx); ok {
				toStateSchedule.SyncFieldsDuringRead(ctx, fromStateSchedule)
				toState.SetSchedule(ctx, toStateSchedule)
			}
		}
	}
	if !fromState.Snapshot.IsNull() && !fromState.Snapshot.IsUnknown() {
		if toStateSnapshot, ok := toState.GetSnapshot(ctx); ok {
			if fromStateSnapshot, ok := fromState.GetSnapshot(ctx); ok {
				toStateSnapshot.SyncFieldsDuringRead(ctx, fromStateSnapshot)
				toState.SetSnapshot(ctx, toStateSnapshot)
			}
		}
	}
	if !fromState.TimeSeries.IsNull() && !fromState.TimeSeries.IsUnknown() {
		if toStateTimeSeries, ok := toState.GetTimeSeries(ctx); ok {
			if fromStateTimeSeries, ok := fromState.GetTimeSeries(ctx); ok {
				toStateTimeSeries.SyncFieldsDuringRead(ctx, fromStateTimeSeries)
				toState.SetTimeSeries(ctx, toStateTimeSeries)
			}
		}
	}
}

func (c CreateMonitor) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assets_dir"] = attrs["assets_dir"].SetRequired()
	attrs["baseline_table_name"] = attrs["baseline_table_name"].SetOptional()
	attrs["custom_metrics"] = attrs["custom_metrics"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].SetOptional()
	attrs["inference_log"] = attrs["inference_log"].SetOptional()
	attrs["latest_monitor_failure_msg"] = attrs["latest_monitor_failure_msg"].SetOptional()
	attrs["notifications"] = attrs["notifications"].SetOptional()
	attrs["output_schema_name"] = attrs["output_schema_name"].SetRequired()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["skip_builtin_dashboard"] = attrs["skip_builtin_dashboard"].SetOptional()
	attrs["slicing_exprs"] = attrs["slicing_exprs"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].SetOptional()
	attrs["time_series"] = attrs["time_series"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateMonitor.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateMonitor) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_metrics":             reflect.TypeOf(MonitorMetric{}),
		"data_classification_config": reflect.TypeOf(MonitorDataClassificationConfig{}),
		"inference_log":              reflect.TypeOf(MonitorInferenceLog{}),
		"notifications":              reflect.TypeOf(MonitorNotifications{}),
		"schedule":                   reflect.TypeOf(MonitorCronSchedule{}),
		"slicing_exprs":              reflect.TypeOf(types.String{}),
		"snapshot":                   reflect.TypeOf(MonitorSnapshot{}),
		"time_series":                reflect.TypeOf(MonitorTimeSeries{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateMonitor
// only implements ToObjectValue() and Type().
func (o CreateMonitor) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assets_dir":                 o.AssetsDir,
			"baseline_table_name":        o.BaselineTableName,
			"custom_metrics":             o.CustomMetrics,
			"data_classification_config": o.DataClassificationConfig,
			"inference_log":              o.InferenceLog,
			"latest_monitor_failure_msg": o.LatestMonitorFailureMsg,
			"notifications":              o.Notifications,
			"output_schema_name":         o.OutputSchemaName,
			"schedule":                   o.Schedule,
			"skip_builtin_dashboard":     o.SkipBuiltinDashboard,
			"slicing_exprs":              o.SlicingExprs,
			"snapshot":                   o.Snapshot,
			"table_name":                 o.TableName,
			"time_series":                o.TimeSeries,
			"warehouse_id":               o.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateMonitor) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assets_dir":          types.StringType,
			"baseline_table_name": types.StringType,
			"custom_metrics": basetypes.ListType{
				ElemType: MonitorMetric{}.Type(ctx),
			},
			"data_classification_config": MonitorDataClassificationConfig{}.Type(ctx),
			"inference_log":              MonitorInferenceLog{}.Type(ctx),
			"latest_monitor_failure_msg": types.StringType,
			"notifications":              MonitorNotifications{}.Type(ctx),
			"output_schema_name":         types.StringType,
			"schedule":                   MonitorCronSchedule{}.Type(ctx),
			"skip_builtin_dashboard":     types.BoolType,
			"slicing_exprs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"snapshot":     MonitorSnapshot{}.Type(ctx),
			"table_name":   types.StringType,
			"time_series":  MonitorTimeSeries{}.Type(ctx),
			"warehouse_id": types.StringType,
		},
	}
}

// GetCustomMetrics returns the value of the CustomMetrics field in CreateMonitor as
// a slice of MonitorMetric values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetCustomMetrics(ctx context.Context) ([]MonitorMetric, bool) {
	if o.CustomMetrics.IsNull() || o.CustomMetrics.IsUnknown() {
		return nil, false
	}
	var v []MonitorMetric
	d := o.CustomMetrics.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomMetrics sets the value of the CustomMetrics field in CreateMonitor.
func (o *CreateMonitor) SetCustomMetrics(ctx context.Context, v []MonitorMetric) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["custom_metrics"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.CustomMetrics = types.ListValueMust(t, vs)
}

// GetDataClassificationConfig returns the value of the DataClassificationConfig field in CreateMonitor as
// a MonitorDataClassificationConfig value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetDataClassificationConfig(ctx context.Context) (MonitorDataClassificationConfig, bool) {
	var e MonitorDataClassificationConfig
	if o.DataClassificationConfig.IsNull() || o.DataClassificationConfig.IsUnknown() {
		return e, false
	}
	var v MonitorDataClassificationConfig
	d := o.DataClassificationConfig.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDataClassificationConfig sets the value of the DataClassificationConfig field in CreateMonitor.
func (o *CreateMonitor) SetDataClassificationConfig(ctx context.Context, v MonitorDataClassificationConfig) {
	vs := v.ToObjectValue(ctx)
	o.DataClassificationConfig = vs
}

// GetInferenceLog returns the value of the InferenceLog field in CreateMonitor as
// a MonitorInferenceLog value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetInferenceLog(ctx context.Context) (MonitorInferenceLog, bool) {
	var e MonitorInferenceLog
	if o.InferenceLog.IsNull() || o.InferenceLog.IsUnknown() {
		return e, false
	}
	var v MonitorInferenceLog
	d := o.InferenceLog.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInferenceLog sets the value of the InferenceLog field in CreateMonitor.
func (o *CreateMonitor) SetInferenceLog(ctx context.Context, v MonitorInferenceLog) {
	vs := v.ToObjectValue(ctx)
	o.InferenceLog = vs
}

// GetNotifications returns the value of the Notifications field in CreateMonitor as
// a MonitorNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetNotifications(ctx context.Context) (MonitorNotifications, bool) {
	var e MonitorNotifications
	if o.Notifications.IsNull() || o.Notifications.IsUnknown() {
		return e, false
	}
	var v MonitorNotifications
	d := o.Notifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotifications sets the value of the Notifications field in CreateMonitor.
func (o *CreateMonitor) SetNotifications(ctx context.Context, v MonitorNotifications) {
	vs := v.ToObjectValue(ctx)
	o.Notifications = vs
}

// GetSchedule returns the value of the Schedule field in CreateMonitor as
// a MonitorCronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetSchedule(ctx context.Context) (MonitorCronSchedule, bool) {
	var e MonitorCronSchedule
	if o.Schedule.IsNull() || o.Schedule.IsUnknown() {
		return e, false
	}
	var v MonitorCronSchedule
	d := o.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in CreateMonitor.
func (o *CreateMonitor) SetSchedule(ctx context.Context, v MonitorCronSchedule) {
	vs := v.ToObjectValue(ctx)
	o.Schedule = vs
}

// GetSlicingExprs returns the value of the SlicingExprs field in CreateMonitor as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetSlicingExprs(ctx context.Context) ([]types.String, bool) {
	if o.SlicingExprs.IsNull() || o.SlicingExprs.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.SlicingExprs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSlicingExprs sets the value of the SlicingExprs field in CreateMonitor.
func (o *CreateMonitor) SetSlicingExprs(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["slicing_exprs"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.SlicingExprs = types.ListValueMust(t, vs)
}

// GetSnapshot returns the value of the Snapshot field in CreateMonitor as
// a MonitorSnapshot value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetSnapshot(ctx context.Context) (MonitorSnapshot, bool) {
	var e MonitorSnapshot
	if o.Snapshot.IsNull() || o.Snapshot.IsUnknown() {
		return e, false
	}
	var v MonitorSnapshot
	d := o.Snapshot.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSnapshot sets the value of the Snapshot field in CreateMonitor.
func (o *CreateMonitor) SetSnapshot(ctx context.Context, v MonitorSnapshot) {
	vs := v.ToObjectValue(ctx)
	o.Snapshot = vs
}

// GetTimeSeries returns the value of the TimeSeries field in CreateMonitor as
// a MonitorTimeSeries value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateMonitor) GetTimeSeries(ctx context.Context) (MonitorTimeSeries, bool) {
	var e MonitorTimeSeries
	if o.TimeSeries.IsNull() || o.TimeSeries.IsUnknown() {
		return e, false
	}
	var v MonitorTimeSeries
	d := o.TimeSeries.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTimeSeries sets the value of the TimeSeries field in CreateMonitor.
func (o *CreateMonitor) SetTimeSeries(ctx context.Context, v MonitorTimeSeries) {
	vs := v.ToObjectValue(ctx)
	o.TimeSeries = vs
}

type CreateOnlineTableRequest struct {
	// Specification of the online table to be created.
	Table types.Object `tfsdk:"table"`
}

func (toState *CreateOnlineTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateOnlineTableRequest) {
	if !fromPlan.Table.IsNull() && !fromPlan.Table.IsUnknown() {
		if toStateTable, ok := toState.GetTable(ctx); ok {
			if fromPlanTable, ok := fromPlan.GetTable(ctx); ok {
				toStateTable.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTable)
				toState.SetTable(ctx, toStateTable)
			}
		}
	}
}

func (toState *CreateOnlineTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateOnlineTableRequest) {
	if !fromState.Table.IsNull() && !fromState.Table.IsUnknown() {
		if toStateTable, ok := toState.GetTable(ctx); ok {
			if fromStateTable, ok := fromState.GetTable(ctx); ok {
				toStateTable.SyncFieldsDuringRead(ctx, fromStateTable)
				toState.SetTable(ctx, toStateTable)
			}
		}
	}
}

func (c CreateOnlineTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table"] = attrs["table"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateOnlineTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateOnlineTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"table": reflect.TypeOf(OnlineTable{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateOnlineTableRequest
// only implements ToObjectValue() and Type().
func (o CreateOnlineTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table": o.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateOnlineTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table": OnlineTable{}.Type(ctx),
		},
	}
}

// GetTable returns the value of the Table field in CreateOnlineTableRequest as
// a OnlineTable value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateOnlineTableRequest) GetTable(ctx context.Context) (OnlineTable, bool) {
	var e OnlineTable
	if o.Table.IsNull() || o.Table.IsUnknown() {
		return e, false
	}
	var v OnlineTable
	d := o.Table.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTable sets the value of the Table field in CreateOnlineTableRequest.
func (o *CreateOnlineTableRequest) SetTable(ctx context.Context, v OnlineTable) {
	vs := v.ToObjectValue(ctx)
	o.Table = vs
}

type CreatePolicyRequest struct {
	// Required. The policy to create.
	PolicyInfo types.Object `tfsdk:"policy_info"`
}

func (toState *CreatePolicyRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreatePolicyRequest) {
	if !fromPlan.PolicyInfo.IsNull() && !fromPlan.PolicyInfo.IsUnknown() {
		if toStatePolicyInfo, ok := toState.GetPolicyInfo(ctx); ok {
			if fromPlanPolicyInfo, ok := fromPlan.GetPolicyInfo(ctx); ok {
				toStatePolicyInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanPolicyInfo)
				toState.SetPolicyInfo(ctx, toStatePolicyInfo)
			}
		}
	}
}

func (toState *CreatePolicyRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreatePolicyRequest) {
	if !fromState.PolicyInfo.IsNull() && !fromState.PolicyInfo.IsUnknown() {
		if toStatePolicyInfo, ok := toState.GetPolicyInfo(ctx); ok {
			if fromStatePolicyInfo, ok := fromState.GetPolicyInfo(ctx); ok {
				toStatePolicyInfo.SyncFieldsDuringRead(ctx, fromStatePolicyInfo)
				toState.SetPolicyInfo(ctx, toStatePolicyInfo)
			}
		}
	}
}

func (c CreatePolicyRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["policy_info"] = attrs["policy_info"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreatePolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreatePolicyRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"policy_info": reflect.TypeOf(PolicyInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreatePolicyRequest
// only implements ToObjectValue() and Type().
func (o CreatePolicyRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"policy_info": o.PolicyInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreatePolicyRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"policy_info": PolicyInfo{}.Type(ctx),
		},
	}
}

// GetPolicyInfo returns the value of the PolicyInfo field in CreatePolicyRequest as
// a PolicyInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreatePolicyRequest) GetPolicyInfo(ctx context.Context) (PolicyInfo, bool) {
	var e PolicyInfo
	if o.PolicyInfo.IsNull() || o.PolicyInfo.IsUnknown() {
		return e, false
	}
	var v PolicyInfo
	d := o.PolicyInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPolicyInfo sets the value of the PolicyInfo field in CreatePolicyRequest.
func (o *CreatePolicyRequest) SetPolicyInfo(ctx context.Context, v PolicyInfo) {
	vs := v.ToObjectValue(ctx)
	o.PolicyInfo = vs
}

type CreateRegisteredModelRequest struct {
	// The name of the catalog where the schema and the registered model reside
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the registered model
	Comment types.String `tfsdk:"comment"`
	// The name of the registered model
	Name types.String `tfsdk:"name"`
	// The name of the schema where the registered model resides
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`
}

func (toState *CreateRegisteredModelRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateRegisteredModelRequest) {
}

func (toState *CreateRegisteredModelRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateRegisteredModelRequest) {
}

func (c CreateRegisteredModelRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateRegisteredModelRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateRegisteredModelRequest
// only implements ToObjectValue() and Type().
func (o CreateRegisteredModelRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":     o.CatalogName,
			"comment":          o.Comment,
			"name":             o.Name,
			"schema_name":      o.SchemaName,
			"storage_location": o.StorageLocation,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateRegisteredModelRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"name":             types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
		},
	}
}

type CreateRequestExternalLineage struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.Object `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.Object `tfsdk:"target"`
}

func (toState *CreateRequestExternalLineage) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateRequestExternalLineage) {
	if !fromPlan.Source.IsNull() && !fromPlan.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromPlanSource, ok := fromPlan.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromPlan.Target.IsNull() && !fromPlan.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromPlanTarget, ok := fromPlan.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (toState *CreateRequestExternalLineage) SyncFieldsDuringRead(ctx context.Context, fromState CreateRequestExternalLineage) {
	if !fromState.Source.IsNull() && !fromState.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromStateSource, ok := fromState.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringRead(ctx, fromStateSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromState.Target.IsNull() && !fromState.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromStateTarget, ok := fromState.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringRead(ctx, fromStateTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (c CreateRequestExternalLineage) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["target"] = attrs["target"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateRequestExternalLineage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateRequestExternalLineage) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject{}),
		"target":     reflect.TypeOf(ExternalLineageObject{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateRequestExternalLineage
// only implements ToObjectValue() and Type().
func (o CreateRequestExternalLineage) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    o.Columns,
			"id":         o.Id,
			"properties": o.Properties,
			"source":     o.Source,
			"target":     o.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateRequestExternalLineage) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": ExternalLineageObject{}.Type(ctx),
			"target": ExternalLineageObject{}.Type(ctx),
		},
	}
}

// GetColumns returns the value of the Columns field in CreateRequestExternalLineage as
// a slice of ColumnRelationship values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateRequestExternalLineage) GetColumns(ctx context.Context) ([]ColumnRelationship, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in CreateRequestExternalLineage.
func (o *CreateRequestExternalLineage) SetColumns(ctx context.Context, v []ColumnRelationship) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateRequestExternalLineage as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateRequestExternalLineage) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateRequestExternalLineage.
func (o *CreateRequestExternalLineage) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in CreateRequestExternalLineage as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateRequestExternalLineage) GetSource(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Source.IsNull() || o.Source.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Source.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSource sets the value of the Source field in CreateRequestExternalLineage.
func (o *CreateRequestExternalLineage) SetSource(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Source = vs
}

// GetTarget returns the value of the Target field in CreateRequestExternalLineage as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateRequestExternalLineage) GetTarget(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Target.IsNull() || o.Target.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Target.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTarget sets the value of the Target field in CreateRequestExternalLineage.
func (o *CreateRequestExternalLineage) SetTarget(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Target = vs
}

type CreateSchema struct {
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of schema, relative to parent catalog.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// Storage root URL for managed tables within schema.
	StorageRoot types.String `tfsdk:"storage_root"`
}

func (toState *CreateSchema) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateSchema) {
}

func (toState *CreateSchema) SyncFieldsDuringRead(ctx context.Context, fromState CreateSchema) {
}

func (c CreateSchema) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateSchema.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateSchema) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateSchema
// only implements ToObjectValue() and Type().
func (o CreateSchema) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name": o.CatalogName,
			"comment":      o.Comment,
			"name":         o.Name,
			"properties":   o.Properties,
			"storage_root": o.StorageRoot,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateSchema) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"comment":      types.StringType,
			"name":         types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"storage_root": types.StringType,
		},
	}
}

// GetProperties returns the value of the Properties field in CreateSchema as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateSchema) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateSchema.
func (o *CreateSchema) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

type CreateStorageCredential struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.Object `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Supplying true to this argument skips validation of the created
	// credential.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (toState *CreateStorageCredential) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateStorageCredential) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.CloudflareApiToken.IsNull() && !fromPlan.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromPlanCloudflareApiToken, ok := fromPlan.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *CreateStorageCredential) SyncFieldsDuringRead(ctx context.Context, fromState CreateStorageCredential) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.CloudflareApiToken.IsNull() && !fromState.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromStateCloudflareApiToken, ok := fromState.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringRead(ctx, fromStateCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c CreateStorageCredential) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateStorageCredential) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityRequest{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateStorageCredential
// only implements ToObjectValue() and Type().
func (o CreateStorageCredential) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"cloudflare_api_token":           o.CloudflareApiToken,
			"comment":                        o.Comment,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"name":                           o.Name,
			"read_only":                      o.ReadOnly,
			"skip_validation":                o.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateStorageCredential) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRoleRequest{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentityRequest{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"cloudflare_api_token":           CloudflareApiToken{}.Type(ctx),
			"comment":                        types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccountRequest{}.Type(ctx),
			"name":                           types.StringType,
			"read_only":                      types.BoolType,
			"skip_validation":                types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CreateStorageCredential as
// a AwsIamRoleRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateStorageCredential) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest, bool) {
	var e AwsIamRoleRequest
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRoleRequest
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CreateStorageCredential.
func (o *CreateStorageCredential) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CreateStorageCredential as
// a AzureManagedIdentityRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateStorageCredential) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityRequest, bool) {
	var e AzureManagedIdentityRequest
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentityRequest
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CreateStorageCredential.
func (o *CreateStorageCredential) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityRequest) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CreateStorageCredential as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateStorageCredential) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CreateStorageCredential.
func (o *CreateStorageCredential) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in CreateStorageCredential as
// a CloudflareApiToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateStorageCredential) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken, bool) {
	var e CloudflareApiToken
	if o.CloudflareApiToken.IsNull() || o.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v CloudflareApiToken
	d := o.CloudflareApiToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in CreateStorageCredential.
func (o *CreateStorageCredential) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken) {
	vs := v.ToObjectValue(ctx)
	o.CloudflareApiToken = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CreateStorageCredential as
// a DatabricksGcpServiceAccountRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateStorageCredential) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest, bool) {
	var e DatabricksGcpServiceAccountRequest
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccountRequest
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CreateStorageCredential.
func (o *CreateStorageCredential) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type CreateTableConstraint struct {
	Constraint types.Object `tfsdk:"constraint"`
	// The full name of the table referenced by the constraint.
	FullNameArg types.String `tfsdk:"full_name_arg"`
}

func (toState *CreateTableConstraint) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateTableConstraint) {
	if !fromPlan.Constraint.IsNull() && !fromPlan.Constraint.IsUnknown() {
		if toStateConstraint, ok := toState.GetConstraint(ctx); ok {
			if fromPlanConstraint, ok := fromPlan.GetConstraint(ctx); ok {
				toStateConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanConstraint)
				toState.SetConstraint(ctx, toStateConstraint)
			}
		}
	}
}

func (toState *CreateTableConstraint) SyncFieldsDuringRead(ctx context.Context, fromState CreateTableConstraint) {
	if !fromState.Constraint.IsNull() && !fromState.Constraint.IsUnknown() {
		if toStateConstraint, ok := toState.GetConstraint(ctx); ok {
			if fromStateConstraint, ok := fromState.GetConstraint(ctx); ok {
				toStateConstraint.SyncFieldsDuringRead(ctx, fromStateConstraint)
				toState.SetConstraint(ctx, toStateConstraint)
			}
		}
	}
}

func (c CreateTableConstraint) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["constraint"] = attrs["constraint"].SetRequired()
	attrs["full_name_arg"] = attrs["full_name_arg"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateTableConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateTableConstraint) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"constraint": reflect.TypeOf(TableConstraint{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateTableConstraint
// only implements ToObjectValue() and Type().
func (o CreateTableConstraint) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"constraint":    o.Constraint,
			"full_name_arg": o.FullNameArg,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateTableConstraint) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"constraint":    TableConstraint{}.Type(ctx),
			"full_name_arg": types.StringType,
		},
	}
}

// GetConstraint returns the value of the Constraint field in CreateTableConstraint as
// a TableConstraint value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateTableConstraint) GetConstraint(ctx context.Context) (TableConstraint, bool) {
	var e TableConstraint
	if o.Constraint.IsNull() || o.Constraint.IsUnknown() {
		return e, false
	}
	var v TableConstraint
	d := o.Constraint.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConstraint sets the value of the Constraint field in CreateTableConstraint.
func (o *CreateTableConstraint) SetConstraint(ctx context.Context, v TableConstraint) {
	vs := v.ToObjectValue(ctx)
	o.Constraint = vs
}

type CreateTableRequest struct {
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// The array of __ColumnInfo__ definitions of the table's columns.
	Columns types.List `tfsdk:"columns"`

	DataSourceFormat types.String `tfsdk:"data_source_format"`
	// Name of table, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// Name of parent schema relative to its parent catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// Storage root URL for table (for **MANAGED**, **EXTERNAL** tables).
	StorageLocation types.String `tfsdk:"storage_location"`

	TableType types.String `tfsdk:"table_type"`
}

func (toState *CreateTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateTableRequest) {
}

func (toState *CreateTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState CreateTableRequest) {
}

func (c CreateTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["data_source_format"] = attrs["data_source_format"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["storage_location"] = attrs["storage_location"].SetRequired()
	attrs["table_type"] = attrs["table_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnInfo{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateTableRequest
// only implements ToObjectValue() and Type().
func (o CreateTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":       o.CatalogName,
			"columns":            o.Columns,
			"data_source_format": o.DataSourceFormat,
			"name":               o.Name,
			"properties":         o.Properties,
			"schema_name":        o.SchemaName,
			"storage_location":   o.StorageLocation,
			"table_type":         o.TableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"columns": basetypes.ListType{
				ElemType: ColumnInfo{}.Type(ctx),
			},
			"data_source_format": types.StringType,
			"name":               types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"table_type":       types.StringType,
		},
	}
}

// GetColumns returns the value of the Columns field in CreateTableRequest as
// a slice of ColumnInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateTableRequest) GetColumns(ctx context.Context) ([]ColumnInfo, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnInfo
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in CreateTableRequest.
func (o *CreateTableRequest) SetColumns(ctx context.Context, v []ColumnInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in CreateTableRequest as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateTableRequest) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in CreateTableRequest.
func (o *CreateTableRequest) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

type CreateVolumeRequestContent struct {
	// The name of the catalog where the schema and the volume are
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the volume
	Comment types.String `tfsdk:"comment"`
	// The name of the volume
	Name types.String `tfsdk:"name"`
	// The name of the schema where the volume is
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud
	StorageLocation types.String `tfsdk:"storage_location"`

	VolumeType types.String `tfsdk:"volume_type"`
}

func (toState *CreateVolumeRequestContent) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CreateVolumeRequestContent) {
}

func (toState *CreateVolumeRequestContent) SyncFieldsDuringRead(ctx context.Context, fromState CreateVolumeRequestContent) {
}

func (c CreateVolumeRequestContent) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["volume_type"] = attrs["volume_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateVolumeRequestContent.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateVolumeRequestContent) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateVolumeRequestContent
// only implements ToObjectValue() and Type().
func (o CreateVolumeRequestContent) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":     o.CatalogName,
			"comment":          o.Comment,
			"name":             o.Name,
			"schema_name":      o.SchemaName,
			"storage_location": o.StorageLocation,
			"volume_type":      o.VolumeType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateVolumeRequestContent) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"name":             types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"volume_type":      types.StringType,
		},
	}
}

// A credential that is dependent on a SQL object.
type CredentialDependency struct {
	// Full name of the dependent credential, in the form of
	// __credential_name__.
	CredentialName types.String `tfsdk:"credential_name"`
}

func (toState *CredentialDependency) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CredentialDependency) {
}

func (toState *CredentialDependency) SyncFieldsDuringRead(ctx context.Context, fromState CredentialDependency) {
}

func (c CredentialDependency) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_name"] = attrs["credential_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CredentialDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CredentialDependency) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CredentialDependency
// only implements ToObjectValue() and Type().
func (o CredentialDependency) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_name": o.CredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CredentialDependency) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_name": types.StringType,
		},
	}
}

type CredentialInfo struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// Time at which this credential was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of credential creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// The full name of the credential.
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the credential.
	Id types.String `tfsdk:"id"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of the parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Indicates the purpose of the credential.
	Purpose types.String `tfsdk:"purpose"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Time at which this credential was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the credential.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Whether this credential is the current metastore's root storage
	// credential. Only applicable when purpose is **STORAGE**.
	UsedForManagedStorage types.Bool `tfsdk:"used_for_managed_storage"`
}

func (toState *CredentialInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CredentialInfo) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *CredentialInfo) SyncFieldsDuringRead(ctx context.Context, fromState CredentialInfo) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c CredentialInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["purpose"] = attrs["purpose"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["used_for_managed_storage"] = attrs["used_for_managed_storage"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CredentialInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CredentialInfo
// only implements ToObjectValue() and Type().
func (o CredentialInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"comment":                        o.Comment,
			"created_at":                     o.CreatedAt,
			"created_by":                     o.CreatedBy,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"full_name":                      o.FullName,
			"id":                             o.Id,
			"isolation_mode":                 o.IsolationMode,
			"metastore_id":                   o.MetastoreId,
			"name":                           o.Name,
			"owner":                          o.Owner,
			"purpose":                        o.Purpose,
			"read_only":                      o.ReadOnly,
			"updated_at":                     o.UpdatedAt,
			"updated_by":                     o.UpdatedBy,
			"used_for_managed_storage":       o.UsedForManagedStorage,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CredentialInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRole{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentity{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"comment":                        types.StringType,
			"created_at":                     types.Int64Type,
			"created_by":                     types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccount{}.Type(ctx),
			"full_name":                      types.StringType,
			"id":                             types.StringType,
			"isolation_mode":                 types.StringType,
			"metastore_id":                   types.StringType,
			"name":                           types.StringType,
			"owner":                          types.StringType,
			"purpose":                        types.StringType,
			"read_only":                      types.BoolType,
			"updated_at":                     types.Int64Type,
			"updated_by":                     types.StringType,
			"used_for_managed_storage":       types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in CredentialInfo as
// a AwsIamRole value.
// If the field is unknown or null, the boolean return value is false.
func (o *CredentialInfo) GetAwsIamRole(ctx context.Context) (AwsIamRole, bool) {
	var e AwsIamRole
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRole
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in CredentialInfo.
func (o *CredentialInfo) SetAwsIamRole(ctx context.Context, v AwsIamRole) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in CredentialInfo as
// a AzureManagedIdentity value.
// If the field is unknown or null, the boolean return value is false.
func (o *CredentialInfo) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity, bool) {
	var e AzureManagedIdentity
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentity
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in CredentialInfo.
func (o *CredentialInfo) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in CredentialInfo as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *CredentialInfo) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in CredentialInfo.
func (o *CredentialInfo) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in CredentialInfo as
// a DatabricksGcpServiceAccount value.
// If the field is unknown or null, the boolean return value is false.
func (o *CredentialInfo) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount, bool) {
	var e DatabricksGcpServiceAccount
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccount
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in CredentialInfo.
func (o *CredentialInfo) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type CredentialValidationResult struct {
	// Error message would exist when the result does not equal to **PASS**.
	Message types.String `tfsdk:"message"`
	// The results of the tested operation.
	Result types.String `tfsdk:"result"`
}

func (toState *CredentialValidationResult) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CredentialValidationResult) {
}

func (toState *CredentialValidationResult) SyncFieldsDuringRead(ctx context.Context, fromState CredentialValidationResult) {
}

func (c CredentialValidationResult) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetOptional()
	attrs["result"] = attrs["result"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CredentialValidationResult.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CredentialValidationResult) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CredentialValidationResult
// only implements ToObjectValue() and Type().
func (o CredentialValidationResult) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message": o.Message,
			"result":  o.Result,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CredentialValidationResult) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message": types.StringType,
			"result":  types.StringType,
		},
	}
}

type CurrentRequest struct {
}

func (toState *CurrentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan CurrentRequest) {
}

func (toState *CurrentRequest) SyncFieldsDuringRead(ctx context.Context, fromState CurrentRequest) {
}

func (c CurrentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CurrentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CurrentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CurrentRequest
// only implements ToObjectValue() and Type().
func (o CurrentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o CurrentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// GCP long-lived credential. Databricks-created Google Cloud Storage service
// account.
type DatabricksGcpServiceAccount struct {
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The email of the service account.
	Email types.String `tfsdk:"email"`
	// The ID that represents the private key for this Service Account
	PrivateKeyId types.String `tfsdk:"private_key_id"`
}

func (toState *DatabricksGcpServiceAccount) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DatabricksGcpServiceAccount) {
}

func (toState *DatabricksGcpServiceAccount) SyncFieldsDuringRead(ctx context.Context, fromState DatabricksGcpServiceAccount) {
}

func (c DatabricksGcpServiceAccount) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["email"] = attrs["email"].SetComputed()
	attrs["private_key_id"] = attrs["private_key_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DatabricksGcpServiceAccount.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DatabricksGcpServiceAccount) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DatabricksGcpServiceAccount
// only implements ToObjectValue() and Type().
func (o DatabricksGcpServiceAccount) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_id":  o.CredentialId,
			"email":          o.Email,
			"private_key_id": o.PrivateKeyId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DatabricksGcpServiceAccount) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_id":  types.StringType,
			"email":          types.StringType,
			"private_key_id": types.StringType,
		},
	}
}

// GCP long-lived credential. Databricks-created Google Cloud Storage service
// account.
type DatabricksGcpServiceAccountRequest struct {
}

func (toState *DatabricksGcpServiceAccountRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DatabricksGcpServiceAccountRequest) {
}

func (toState *DatabricksGcpServiceAccountRequest) SyncFieldsDuringRead(ctx context.Context, fromState DatabricksGcpServiceAccountRequest) {
}

func (c DatabricksGcpServiceAccountRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DatabricksGcpServiceAccountRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DatabricksGcpServiceAccountRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DatabricksGcpServiceAccountRequest
// only implements ToObjectValue() and Type().
func (o DatabricksGcpServiceAccountRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DatabricksGcpServiceAccountRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// GCP long-lived credential. Databricks-created Google Cloud Storage service
// account.
type DatabricksGcpServiceAccountResponse struct {
	// The Databricks internal ID that represents this managed identity.
	CredentialId types.String `tfsdk:"credential_id"`
	// The email of the service account.
	Email types.String `tfsdk:"email"`
}

func (toState *DatabricksGcpServiceAccountResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DatabricksGcpServiceAccountResponse) {
}

func (toState *DatabricksGcpServiceAccountResponse) SyncFieldsDuringRead(ctx context.Context, fromState DatabricksGcpServiceAccountResponse) {
}

func (c DatabricksGcpServiceAccountResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credential_id"] = attrs["credential_id"].SetComputed()
	attrs["email"] = attrs["email"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DatabricksGcpServiceAccountResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DatabricksGcpServiceAccountResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DatabricksGcpServiceAccountResponse
// only implements ToObjectValue() and Type().
func (o DatabricksGcpServiceAccountResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credential_id": o.CredentialId,
			"email":         o.Email,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DatabricksGcpServiceAccountResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credential_id": types.StringType,
			"email":         types.StringType,
		},
	}
}

type DeleteAccountMetastoreAssignmentRequest struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *DeleteAccountMetastoreAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteAccountMetastoreAssignmentRequest) {
}

func (toState *DeleteAccountMetastoreAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteAccountMetastoreAssignmentRequest) {
}

func (c DeleteAccountMetastoreAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountMetastoreAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAccountMetastoreAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountMetastoreAssignmentRequest
// only implements ToObjectValue() and Type().
func (o DeleteAccountMetastoreAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": o.MetastoreId,
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAccountMetastoreAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}

type DeleteAccountMetastoreRequest struct {
	// Force deletion even if the metastore is not empty. Default is false.
	Force types.Bool `tfsdk:"-"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (toState *DeleteAccountMetastoreRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteAccountMetastoreRequest) {
}

func (toState *DeleteAccountMetastoreRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteAccountMetastoreRequest) {
}

func (c DeleteAccountMetastoreRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAccountMetastoreRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountMetastoreRequest
// only implements ToObjectValue() and Type().
func (o DeleteAccountMetastoreRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":        o.Force,
			"metastore_id": o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAccountMetastoreRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":        types.BoolType,
			"metastore_id": types.StringType,
		},
	}
}

type DeleteAccountStorageCredentialRequest struct {
	// Force deletion even if the Storage Credential is not empty. Default is
	// false.
	Force types.Bool `tfsdk:"-"`
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Name of the storage credential.
	StorageCredentialName types.String `tfsdk:"-"`
}

func (toState *DeleteAccountStorageCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteAccountStorageCredentialRequest) {
}

func (toState *DeleteAccountStorageCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteAccountStorageCredentialRequest) {
}

func (c DeleteAccountStorageCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAccountStorageCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountStorageCredentialRequest
// only implements ToObjectValue() and Type().
func (o DeleteAccountStorageCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":                   o.Force,
			"metastore_id":            o.MetastoreId,
			"storage_credential_name": o.StorageCredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAccountStorageCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":                   types.BoolType,
			"metastore_id":            types.StringType,
			"storage_credential_name": types.StringType,
		},
	}
}

type DeleteAliasRequest struct {
	// The name of the alias
	Alias types.String `tfsdk:"-"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
}

func (toState *DeleteAliasRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteAliasRequest) {
}

func (toState *DeleteAliasRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteAliasRequest) {
}

func (c DeleteAliasRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["alias"] = attrs["alias"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAliasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAliasRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAliasRequest
// only implements ToObjectValue() and Type().
func (o DeleteAliasRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":     o.Alias,
			"full_name": o.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAliasRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":     types.StringType,
			"full_name": types.StringType,
		},
	}
}

type DeleteCatalogRequest struct {
	// Force deletion even if the catalog is not empty.
	Force types.Bool `tfsdk:"-"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteCatalogRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteCatalogRequest) {
}

func (toState *DeleteCatalogRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteCatalogRequest) {
}

func (c DeleteCatalogRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCatalogRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteCatalogRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCatalogRequest
// only implements ToObjectValue() and Type().
func (o DeleteCatalogRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": o.Force,
			"name":  o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteCatalogRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteConnectionRequest struct {
	// The name of the connection to be deleted.
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteConnectionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteConnectionRequest) {
}

func (toState *DeleteConnectionRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteConnectionRequest) {
}

func (c DeleteConnectionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteConnectionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteConnectionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteConnectionRequest
// only implements ToObjectValue() and Type().
func (o DeleteConnectionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteConnectionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type DeleteCredentialRequest struct {
	// Force an update even if there are dependent services (when purpose is
	// **SERVICE**) or dependent external locations and external tables (when
	// purpose is **STORAGE**).
	Force types.Bool `tfsdk:"-"`
	// Name of the credential.
	NameArg types.String `tfsdk:"-"`
}

func (toState *DeleteCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteCredentialRequest) {
}

func (toState *DeleteCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteCredentialRequest) {
}

func (c DeleteCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name_arg"] = attrs["name_arg"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCredentialRequest
// only implements ToObjectValue() and Type().
func (o DeleteCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":    o.Force,
			"name_arg": o.NameArg,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":    types.BoolType,
			"name_arg": types.StringType,
		},
	}
}

type DeleteCredentialResponse struct {
}

func (toState *DeleteCredentialResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteCredentialResponse) {
}

func (toState *DeleteCredentialResponse) SyncFieldsDuringRead(ctx context.Context, fromState DeleteCredentialResponse) {
}

func (c DeleteCredentialResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteCredentialResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteCredentialResponse
// only implements ToObjectValue() and Type().
func (o DeleteCredentialResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteCredentialResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteEntityTagAssignmentRequest struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`
	// Required. The key of the tag to delete
	TagKey types.String `tfsdk:"-"`
}

func (toState *DeleteEntityTagAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteEntityTagAssignmentRequest) {
}

func (toState *DeleteEntityTagAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteEntityTagAssignmentRequest) {
}

func (c DeleteEntityTagAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteEntityTagAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteEntityTagAssignmentRequest
// only implements ToObjectValue() and Type().
func (o DeleteEntityTagAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": o.EntityName,
			"entity_type": o.EntityType,
			"tag_key":     o.TagKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteEntityTagAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_key":     types.StringType,
		},
	}
}

type DeleteExternalLineageRelationshipRequest struct {
	ExternalLineageRelationship types.Object `tfsdk:"-"`
}

func (toState *DeleteExternalLineageRelationshipRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteExternalLineageRelationshipRequest) {
	if !fromPlan.ExternalLineageRelationship.IsNull() && !fromPlan.ExternalLineageRelationship.IsUnknown() {
		if toStateExternalLineageRelationship, ok := toState.GetExternalLineageRelationship(ctx); ok {
			if fromPlanExternalLineageRelationship, ok := fromPlan.GetExternalLineageRelationship(ctx); ok {
				toStateExternalLineageRelationship.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalLineageRelationship)
				toState.SetExternalLineageRelationship(ctx, toStateExternalLineageRelationship)
			}
		}
	}
}

func (toState *DeleteExternalLineageRelationshipRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteExternalLineageRelationshipRequest) {
	if !fromState.ExternalLineageRelationship.IsNull() && !fromState.ExternalLineageRelationship.IsUnknown() {
		if toStateExternalLineageRelationship, ok := toState.GetExternalLineageRelationship(ctx); ok {
			if fromStateExternalLineageRelationship, ok := fromState.GetExternalLineageRelationship(ctx); ok {
				toStateExternalLineageRelationship.SyncFieldsDuringRead(ctx, fromStateExternalLineageRelationship)
				toState.SetExternalLineageRelationship(ctx, toStateExternalLineageRelationship)
			}
		}
	}
}

func (c DeleteExternalLineageRelationshipRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteExternalLineageRelationshipRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteExternalLineageRelationshipRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationship": reflect.TypeOf(DeleteRequestExternalLineage{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteExternalLineageRelationshipRequest
// only implements ToObjectValue() and Type().
func (o DeleteExternalLineageRelationshipRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationship": o.ExternalLineageRelationship,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteExternalLineageRelationshipRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationship": DeleteRequestExternalLineage{}.Type(ctx),
		},
	}
}

// GetExternalLineageRelationship returns the value of the ExternalLineageRelationship field in DeleteExternalLineageRelationshipRequest as
// a DeleteRequestExternalLineage value.
// If the field is unknown or null, the boolean return value is false.
func (o *DeleteExternalLineageRelationshipRequest) GetExternalLineageRelationship(ctx context.Context) (DeleteRequestExternalLineage, bool) {
	var e DeleteRequestExternalLineage
	if o.ExternalLineageRelationship.IsNull() || o.ExternalLineageRelationship.IsUnknown() {
		return e, false
	}
	var v DeleteRequestExternalLineage
	d := o.ExternalLineageRelationship.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLineageRelationship sets the value of the ExternalLineageRelationship field in DeleteExternalLineageRelationshipRequest.
func (o *DeleteExternalLineageRelationshipRequest) SetExternalLineageRelationship(ctx context.Context, v DeleteRequestExternalLineage) {
	vs := v.ToObjectValue(ctx)
	o.ExternalLineageRelationship = vs
}

type DeleteExternalLocationRequest struct {
	// Force deletion even if there are dependent external tables or mounts.
	Force types.Bool `tfsdk:"-"`
	// Name of the external location.
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteExternalLocationRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteExternalLocationRequest) {
}

func (toState *DeleteExternalLocationRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteExternalLocationRequest) {
}

func (c DeleteExternalLocationRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteExternalLocationRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteExternalLocationRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteExternalLocationRequest
// only implements ToObjectValue() and Type().
func (o DeleteExternalLocationRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": o.Force,
			"name":  o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteExternalLocationRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteExternalMetadataRequest struct {
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteExternalMetadataRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteExternalMetadataRequest) {
}

func (toState *DeleteExternalMetadataRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteExternalMetadataRequest) {
}

func (c DeleteExternalMetadataRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteExternalMetadataRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteExternalMetadataRequest
// only implements ToObjectValue() and Type().
func (o DeleteExternalMetadataRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteExternalMetadataRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type DeleteFunctionRequest struct {
	// Force deletion even if the function is notempty.
	Force types.Bool `tfsdk:"-"`
	// The fully-qualified name of the function (of the form
	// __catalog_name__.__schema_name__.__function__name__).
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteFunctionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteFunctionRequest) {
}

func (toState *DeleteFunctionRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteFunctionRequest) {
}

func (c DeleteFunctionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteFunctionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteFunctionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteFunctionRequest
// only implements ToObjectValue() and Type().
func (o DeleteFunctionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": o.Force,
			"name":  o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteFunctionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteMetastoreRequest struct {
	// Force deletion even if the metastore is not empty. Default is false.
	Force types.Bool `tfsdk:"-"`
	// Unique ID of the metastore.
	Id types.String `tfsdk:"-"`
}

func (toState *DeleteMetastoreRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteMetastoreRequest) {
}

func (toState *DeleteMetastoreRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteMetastoreRequest) {
}

func (c DeleteMetastoreRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteMetastoreRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteMetastoreRequest
// only implements ToObjectValue() and Type().
func (o DeleteMetastoreRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": o.Force,
			"id":    o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteMetastoreRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"id":    types.StringType,
		},
	}
}

type DeleteModelVersionRequest struct {
	// The three-level (fully qualified) name of the model version
	FullName types.String `tfsdk:"-"`
	// The integer version number of the model version
	Version types.Int64 `tfsdk:"-"`
}

func (toState *DeleteModelVersionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteModelVersionRequest) {
}

func (toState *DeleteModelVersionRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteModelVersionRequest) {
}

func (c DeleteModelVersionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version"] = attrs["version"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteModelVersionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteModelVersionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteModelVersionRequest
// only implements ToObjectValue() and Type().
func (o DeleteModelVersionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": o.FullName,
			"version":   o.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteModelVersionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
			"version":   types.Int64Type,
		},
	}
}

type DeleteMonitorResponse struct {
}

func (toState *DeleteMonitorResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteMonitorResponse) {
}

func (toState *DeleteMonitorResponse) SyncFieldsDuringRead(ctx context.Context, fromState DeleteMonitorResponse) {
}

func (c DeleteMonitorResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteMonitorResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteMonitorResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteMonitorResponse
// only implements ToObjectValue() and Type().
func (o DeleteMonitorResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteMonitorResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteOnlineTableRequest struct {
	// Full three-part (catalog, schema, table) name of the table.
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteOnlineTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteOnlineTableRequest) {
}

func (toState *DeleteOnlineTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteOnlineTableRequest) {
}

func (c DeleteOnlineTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteOnlineTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteOnlineTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteOnlineTableRequest
// only implements ToObjectValue() and Type().
func (o DeleteOnlineTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteOnlineTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type DeletePolicyRequest struct {
	// Required. The name of the policy to delete
	Name types.String `tfsdk:"-"`
	// Required. The fully qualified name of the securable to delete the policy
	// from.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to delete the policy from.
	OnSecurableType types.String `tfsdk:"-"`
}

func (toState *DeletePolicyRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeletePolicyRequest) {
}

func (toState *DeletePolicyRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeletePolicyRequest) {
}

func (c DeletePolicyRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeletePolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeletePolicyRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeletePolicyRequest
// only implements ToObjectValue() and Type().
func (o DeletePolicyRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                  o.Name,
			"on_securable_fullname": o.OnSecurableFullname,
			"on_securable_type":     o.OnSecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeletePolicyRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
		},
	}
}

type DeletePolicyResponse struct {
}

func (toState *DeletePolicyResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeletePolicyResponse) {
}

func (toState *DeletePolicyResponse) SyncFieldsDuringRead(ctx context.Context, fromState DeletePolicyResponse) {
}

func (c DeletePolicyResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeletePolicyResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeletePolicyResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeletePolicyResponse
// only implements ToObjectValue() and Type().
func (o DeletePolicyResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DeletePolicyResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteQualityMonitorRequest struct {
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
}

func (toState *DeleteQualityMonitorRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteQualityMonitorRequest) {
}

func (toState *DeleteQualityMonitorRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteQualityMonitorRequest) {
}

func (c DeleteQualityMonitorRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteQualityMonitorRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteQualityMonitorRequest
// only implements ToObjectValue() and Type().
func (o DeleteQualityMonitorRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": o.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteQualityMonitorRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

type DeleteRegisteredModelRequest struct {
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
}

func (toState *DeleteRegisteredModelRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteRegisteredModelRequest) {
}

func (toState *DeleteRegisteredModelRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteRegisteredModelRequest) {
}

func (c DeleteRegisteredModelRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteRegisteredModelRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteRegisteredModelRequest
// only implements ToObjectValue() and Type().
func (o DeleteRegisteredModelRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": o.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteRegisteredModelRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
		},
	}
}

type DeleteRequestExternalLineage struct {
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Source object of the external lineage relationship.
	Source types.Object `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.Object `tfsdk:"target"`
}

func (toState *DeleteRequestExternalLineage) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteRequestExternalLineage) {
	if !fromPlan.Source.IsNull() && !fromPlan.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromPlanSource, ok := fromPlan.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromPlan.Target.IsNull() && !fromPlan.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromPlanTarget, ok := fromPlan.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (toState *DeleteRequestExternalLineage) SyncFieldsDuringRead(ctx context.Context, fromState DeleteRequestExternalLineage) {
	if !fromState.Source.IsNull() && !fromState.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromStateSource, ok := fromState.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringRead(ctx, fromStateSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromState.Target.IsNull() && !fromState.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromStateTarget, ok := fromState.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringRead(ctx, fromStateTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (c DeleteRequestExternalLineage) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetComputed()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["target"] = attrs["target"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteRequestExternalLineage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteRequestExternalLineage) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"source": reflect.TypeOf(ExternalLineageObject{}),
		"target": reflect.TypeOf(ExternalLineageObject{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteRequestExternalLineage
// only implements ToObjectValue() and Type().
func (o DeleteRequestExternalLineage) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":     o.Id,
			"source": o.Source,
			"target": o.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteRequestExternalLineage) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id":     types.StringType,
			"source": ExternalLineageObject{}.Type(ctx),
			"target": ExternalLineageObject{}.Type(ctx),
		},
	}
}

// GetSource returns the value of the Source field in DeleteRequestExternalLineage as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *DeleteRequestExternalLineage) GetSource(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Source.IsNull() || o.Source.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Source.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSource sets the value of the Source field in DeleteRequestExternalLineage.
func (o *DeleteRequestExternalLineage) SetSource(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Source = vs
}

// GetTarget returns the value of the Target field in DeleteRequestExternalLineage as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *DeleteRequestExternalLineage) GetTarget(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Target.IsNull() || o.Target.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Target.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTarget sets the value of the Target field in DeleteRequestExternalLineage.
func (o *DeleteRequestExternalLineage) SetTarget(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Target = vs
}

type DeleteResponse struct {
}

func (toState *DeleteResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteResponse) {
}

func (toState *DeleteResponse) SyncFieldsDuringRead(ctx context.Context, fromState DeleteResponse) {
}

func (c DeleteResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteResponse
// only implements ToObjectValue() and Type().
func (o DeleteResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteSchemaRequest struct {
	// Force deletion even if the schema is not empty.
	Force types.Bool `tfsdk:"-"`
	// Full name of the schema.
	FullName types.String `tfsdk:"-"`
}

func (toState *DeleteSchemaRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteSchemaRequest) {
}

func (toState *DeleteSchemaRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteSchemaRequest) {
}

func (c DeleteSchemaRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteSchemaRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteSchemaRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteSchemaRequest
// only implements ToObjectValue() and Type().
func (o DeleteSchemaRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force":     o.Force,
			"full_name": o.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteSchemaRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force":     types.BoolType,
			"full_name": types.StringType,
		},
	}
}

type DeleteStorageCredentialRequest struct {
	// Force an update even if there are dependent external locations or
	// external tables (when purpose is **STORAGE**) or dependent services (when
	// purpose is **SERVICE**).
	Force types.Bool `tfsdk:"-"`
	// Name of the storage credential.
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteStorageCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteStorageCredentialRequest) {
}

func (toState *DeleteStorageCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteStorageCredentialRequest) {
}

func (c DeleteStorageCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["force"] = attrs["force"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteStorageCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteStorageCredentialRequest
// only implements ToObjectValue() and Type().
func (o DeleteStorageCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"force": o.Force,
			"name":  o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteStorageCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"force": types.BoolType,
			"name":  types.StringType,
		},
	}
}

type DeleteTableConstraintRequest struct {
	// If true, try deleting all child constraints of the current constraint. If
	// false, reject this operation if the current constraint has any child
	// constraints.
	Cascade types.Bool `tfsdk:"-"`
	// The name of the constraint to delete.
	ConstraintName types.String `tfsdk:"-"`
	// Full name of the table referenced by the constraint.
	FullName types.String `tfsdk:"-"`
}

func (toState *DeleteTableConstraintRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteTableConstraintRequest) {
}

func (toState *DeleteTableConstraintRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteTableConstraintRequest) {
}

func (c DeleteTableConstraintRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["constraint_name"] = attrs["constraint_name"].SetRequired()
	attrs["cascade"] = attrs["cascade"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteTableConstraintRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteTableConstraintRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteTableConstraintRequest
// only implements ToObjectValue() and Type().
func (o DeleteTableConstraintRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cascade":         o.Cascade,
			"constraint_name": o.ConstraintName,
			"full_name":       o.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteTableConstraintRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cascade":         types.BoolType,
			"constraint_name": types.StringType,
			"full_name":       types.StringType,
		},
	}
}

type DeleteTableConstraintResponse struct {
}

func (toState *DeleteTableConstraintResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteTableConstraintResponse) {
}

func (toState *DeleteTableConstraintResponse) SyncFieldsDuringRead(ctx context.Context, fromState DeleteTableConstraintResponse) {
}

func (c DeleteTableConstraintResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteTableConstraintResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteTableConstraintResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteTableConstraintResponse
// only implements ToObjectValue() and Type().
func (o DeleteTableConstraintResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteTableConstraintResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type DeleteTableRequest struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
}

func (toState *DeleteTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteTableRequest) {
}

func (toState *DeleteTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteTableRequest) {
}

func (c DeleteTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteTableRequest
// only implements ToObjectValue() and Type().
func (o DeleteTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": o.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
		},
	}
}

type DeleteVolumeRequest struct {
	// The three-level (fully qualified) name of the volume
	Name types.String `tfsdk:"-"`
}

func (toState *DeleteVolumeRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeleteVolumeRequest) {
}

func (toState *DeleteVolumeRequest) SyncFieldsDuringRead(ctx context.Context, fromState DeleteVolumeRequest) {
}

func (c DeleteVolumeRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteVolumeRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteVolumeRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteVolumeRequest
// only implements ToObjectValue() and Type().
func (o DeleteVolumeRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteVolumeRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

// Properties pertaining to the current state of the delta table as given by the
// commit server. This does not contain **delta.*** (input) properties in
// __TableInfo.properties__.
type DeltaRuntimePropertiesKvPairs struct {
	// A map of key-value properties attached to the securable.
	DeltaRuntimeProperties types.Map `tfsdk:"delta_runtime_properties"`
}

func (toState *DeltaRuntimePropertiesKvPairs) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DeltaRuntimePropertiesKvPairs) {
}

func (toState *DeltaRuntimePropertiesKvPairs) SyncFieldsDuringRead(ctx context.Context, fromState DeltaRuntimePropertiesKvPairs) {
}

func (c DeltaRuntimePropertiesKvPairs) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["delta_runtime_properties"] = attrs["delta_runtime_properties"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeltaRuntimePropertiesKvPairs.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeltaRuntimePropertiesKvPairs) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"delta_runtime_properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeltaRuntimePropertiesKvPairs
// only implements ToObjectValue() and Type().
func (o DeltaRuntimePropertiesKvPairs) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"delta_runtime_properties": o.DeltaRuntimeProperties,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeltaRuntimePropertiesKvPairs) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"delta_runtime_properties": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDeltaRuntimeProperties returns the value of the DeltaRuntimeProperties field in DeltaRuntimePropertiesKvPairs as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *DeltaRuntimePropertiesKvPairs) GetDeltaRuntimeProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.DeltaRuntimeProperties.IsNull() || o.DeltaRuntimeProperties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.DeltaRuntimeProperties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDeltaRuntimeProperties sets the value of the DeltaRuntimeProperties field in DeltaRuntimePropertiesKvPairs.
func (o *DeltaRuntimePropertiesKvPairs) SetDeltaRuntimeProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["delta_runtime_properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.DeltaRuntimeProperties = types.MapValueMust(t, vs)
}

// A dependency of a SQL object. One of the following fields must be defined:
// __table__, __function__, __connection__, or __credential__.
type Dependency struct {
	Connection types.Object `tfsdk:"connection"`

	Credential types.Object `tfsdk:"credential"`

	Function types.Object `tfsdk:"function"`

	Table types.Object `tfsdk:"table"`
}

func (toState *Dependency) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan Dependency) {
	if !fromPlan.Connection.IsNull() && !fromPlan.Connection.IsUnknown() {
		if toStateConnection, ok := toState.GetConnection(ctx); ok {
			if fromPlanConnection, ok := fromPlan.GetConnection(ctx); ok {
				toStateConnection.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanConnection)
				toState.SetConnection(ctx, toStateConnection)
			}
		}
	}
	if !fromPlan.Credential.IsNull() && !fromPlan.Credential.IsUnknown() {
		if toStateCredential, ok := toState.GetCredential(ctx); ok {
			if fromPlanCredential, ok := fromPlan.GetCredential(ctx); ok {
				toStateCredential.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCredential)
				toState.SetCredential(ctx, toStateCredential)
			}
		}
	}
	if !fromPlan.Function.IsNull() && !fromPlan.Function.IsUnknown() {
		if toStateFunction, ok := toState.GetFunction(ctx); ok {
			if fromPlanFunction, ok := fromPlan.GetFunction(ctx); ok {
				toStateFunction.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFunction)
				toState.SetFunction(ctx, toStateFunction)
			}
		}
	}
	if !fromPlan.Table.IsNull() && !fromPlan.Table.IsUnknown() {
		if toStateTable, ok := toState.GetTable(ctx); ok {
			if fromPlanTable, ok := fromPlan.GetTable(ctx); ok {
				toStateTable.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTable)
				toState.SetTable(ctx, toStateTable)
			}
		}
	}
}

func (toState *Dependency) SyncFieldsDuringRead(ctx context.Context, fromState Dependency) {
	if !fromState.Connection.IsNull() && !fromState.Connection.IsUnknown() {
		if toStateConnection, ok := toState.GetConnection(ctx); ok {
			if fromStateConnection, ok := fromState.GetConnection(ctx); ok {
				toStateConnection.SyncFieldsDuringRead(ctx, fromStateConnection)
				toState.SetConnection(ctx, toStateConnection)
			}
		}
	}
	if !fromState.Credential.IsNull() && !fromState.Credential.IsUnknown() {
		if toStateCredential, ok := toState.GetCredential(ctx); ok {
			if fromStateCredential, ok := fromState.GetCredential(ctx); ok {
				toStateCredential.SyncFieldsDuringRead(ctx, fromStateCredential)
				toState.SetCredential(ctx, toStateCredential)
			}
		}
	}
	if !fromState.Function.IsNull() && !fromState.Function.IsUnknown() {
		if toStateFunction, ok := toState.GetFunction(ctx); ok {
			if fromStateFunction, ok := fromState.GetFunction(ctx); ok {
				toStateFunction.SyncFieldsDuringRead(ctx, fromStateFunction)
				toState.SetFunction(ctx, toStateFunction)
			}
		}
	}
	if !fromState.Table.IsNull() && !fromState.Table.IsUnknown() {
		if toStateTable, ok := toState.GetTable(ctx); ok {
			if fromStateTable, ok := fromState.GetTable(ctx); ok {
				toStateTable.SyncFieldsDuringRead(ctx, fromStateTable)
				toState.SetTable(ctx, toStateTable)
			}
		}
	}
}

func (c Dependency) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection"] = attrs["connection"].SetOptional()
	attrs["credential"] = attrs["credential"].SetOptional()
	attrs["function"] = attrs["function"].SetOptional()
	attrs["table"] = attrs["table"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Dependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Dependency) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"connection": reflect.TypeOf(ConnectionDependency{}),
		"credential": reflect.TypeOf(CredentialDependency{}),
		"function":   reflect.TypeOf(FunctionDependency{}),
		"table":      reflect.TypeOf(TableDependency{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Dependency
// only implements ToObjectValue() and Type().
func (o Dependency) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection": o.Connection,
			"credential": o.Credential,
			"function":   o.Function,
			"table":      o.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Dependency) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection": ConnectionDependency{}.Type(ctx),
			"credential": CredentialDependency{}.Type(ctx),
			"function":   FunctionDependency{}.Type(ctx),
			"table":      TableDependency{}.Type(ctx),
		},
	}
}

// GetConnection returns the value of the Connection field in Dependency as
// a ConnectionDependency value.
// If the field is unknown or null, the boolean return value is false.
func (o *Dependency) GetConnection(ctx context.Context) (ConnectionDependency, bool) {
	var e ConnectionDependency
	if o.Connection.IsNull() || o.Connection.IsUnknown() {
		return e, false
	}
	var v ConnectionDependency
	d := o.Connection.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConnection sets the value of the Connection field in Dependency.
func (o *Dependency) SetConnection(ctx context.Context, v ConnectionDependency) {
	vs := v.ToObjectValue(ctx)
	o.Connection = vs
}

// GetCredential returns the value of the Credential field in Dependency as
// a CredentialDependency value.
// If the field is unknown or null, the boolean return value is false.
func (o *Dependency) GetCredential(ctx context.Context) (CredentialDependency, bool) {
	var e CredentialDependency
	if o.Credential.IsNull() || o.Credential.IsUnknown() {
		return e, false
	}
	var v CredentialDependency
	d := o.Credential.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCredential sets the value of the Credential field in Dependency.
func (o *Dependency) SetCredential(ctx context.Context, v CredentialDependency) {
	vs := v.ToObjectValue(ctx)
	o.Credential = vs
}

// GetFunction returns the value of the Function field in Dependency as
// a FunctionDependency value.
// If the field is unknown or null, the boolean return value is false.
func (o *Dependency) GetFunction(ctx context.Context) (FunctionDependency, bool) {
	var e FunctionDependency
	if o.Function.IsNull() || o.Function.IsUnknown() {
		return e, false
	}
	var v FunctionDependency
	d := o.Function.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFunction sets the value of the Function field in Dependency.
func (o *Dependency) SetFunction(ctx context.Context, v FunctionDependency) {
	vs := v.ToObjectValue(ctx)
	o.Function = vs
}

// GetTable returns the value of the Table field in Dependency as
// a TableDependency value.
// If the field is unknown or null, the boolean return value is false.
func (o *Dependency) GetTable(ctx context.Context) (TableDependency, bool) {
	var e TableDependency
	if o.Table.IsNull() || o.Table.IsUnknown() {
		return e, false
	}
	var v TableDependency
	d := o.Table.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTable sets the value of the Table field in Dependency.
func (o *Dependency) SetTable(ctx context.Context, v TableDependency) {
	vs := v.ToObjectValue(ctx)
	o.Table = vs
}

// A list of dependencies.
type DependencyList struct {
	// Array of dependencies.
	Dependencies types.List `tfsdk:"dependencies"`
}

func (toState *DependencyList) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DependencyList) {
}

func (toState *DependencyList) SyncFieldsDuringRead(ctx context.Context, fromState DependencyList) {
}

func (c DependencyList) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dependencies"] = attrs["dependencies"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DependencyList.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DependencyList) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dependencies": reflect.TypeOf(Dependency{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DependencyList
// only implements ToObjectValue() and Type().
func (o DependencyList) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dependencies": o.Dependencies,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DependencyList) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dependencies": basetypes.ListType{
				ElemType: Dependency{}.Type(ctx),
			},
		},
	}
}

// GetDependencies returns the value of the Dependencies field in DependencyList as
// a slice of Dependency values.
// If the field is unknown or null, the boolean return value is false.
func (o *DependencyList) GetDependencies(ctx context.Context) ([]Dependency, bool) {
	if o.Dependencies.IsNull() || o.Dependencies.IsUnknown() {
		return nil, false
	}
	var v []Dependency
	d := o.Dependencies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependencies sets the value of the Dependencies field in DependencyList.
func (o *DependencyList) SetDependencies(ctx context.Context, v []Dependency) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["dependencies"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Dependencies = types.ListValueMust(t, vs)
}

type DisableRequest struct {
	// The metastore ID under which the system schema lives.
	MetastoreId types.String `tfsdk:"-"`
	// Full name of the system schema.
	SchemaName types.String `tfsdk:"-"`
}

func (toState *DisableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DisableRequest) {
}

func (toState *DisableRequest) SyncFieldsDuringRead(ctx context.Context, fromState DisableRequest) {
}

func (c DisableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DisableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DisableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DisableRequest
// only implements ToObjectValue() and Type().
func (o DisableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": o.MetastoreId,
			"schema_name":  o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DisableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"schema_name":  types.StringType,
		},
	}
}

type DisableResponse struct {
}

func (toState *DisableResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan DisableResponse) {
}

func (toState *DisableResponse) SyncFieldsDuringRead(ctx context.Context, fromState DisableResponse) {
}

func (c DisableResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DisableResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DisableResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DisableResponse
// only implements ToObjectValue() and Type().
func (o DisableResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DisableResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type EffectivePermissionsList struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The privileges conveyed to each principal (either directly or via
	// inheritance)
	PrivilegeAssignments types.List `tfsdk:"privilege_assignments"`
}

func (toState *EffectivePermissionsList) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EffectivePermissionsList) {
}

func (toState *EffectivePermissionsList) SyncFieldsDuringRead(ctx context.Context, fromState EffectivePermissionsList) {
}

func (c EffectivePermissionsList) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["privilege_assignments"] = attrs["privilege_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePermissionsList.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EffectivePermissionsList) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privilege_assignments": reflect.TypeOf(EffectivePrivilegeAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePermissionsList
// only implements ToObjectValue() and Type().
func (o EffectivePermissionsList) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":       o.NextPageToken,
			"privilege_assignments": o.PrivilegeAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EffectivePermissionsList) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"privilege_assignments": basetypes.ListType{
				ElemType: EffectivePrivilegeAssignment{}.Type(ctx),
			},
		},
	}
}

// GetPrivilegeAssignments returns the value of the PrivilegeAssignments field in EffectivePermissionsList as
// a slice of EffectivePrivilegeAssignment values.
// If the field is unknown or null, the boolean return value is false.
func (o *EffectivePermissionsList) GetPrivilegeAssignments(ctx context.Context) ([]EffectivePrivilegeAssignment, bool) {
	if o.PrivilegeAssignments.IsNull() || o.PrivilegeAssignments.IsUnknown() {
		return nil, false
	}
	var v []EffectivePrivilegeAssignment
	d := o.PrivilegeAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivilegeAssignments sets the value of the PrivilegeAssignments field in EffectivePermissionsList.
func (o *EffectivePermissionsList) SetPrivilegeAssignments(ctx context.Context, v []EffectivePrivilegeAssignment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["privilege_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PrivilegeAssignments = types.ListValueMust(t, vs)
}

type EffectivePredictiveOptimizationFlag struct {
	// The name of the object from which the flag was inherited. If there was no
	// inheritance, this field is left blank.
	InheritedFromName types.String `tfsdk:"inherited_from_name"`
	// The type of the object from which the flag was inherited. If there was no
	// inheritance, this field is left blank.
	InheritedFromType types.String `tfsdk:"inherited_from_type"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	Value types.String `tfsdk:"value"`
}

func (toState *EffectivePredictiveOptimizationFlag) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EffectivePredictiveOptimizationFlag) {
}

func (toState *EffectivePredictiveOptimizationFlag) SyncFieldsDuringRead(ctx context.Context, fromState EffectivePredictiveOptimizationFlag) {
}

func (c EffectivePredictiveOptimizationFlag) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited_from_name"] = attrs["inherited_from_name"].SetOptional()
	attrs["inherited_from_type"] = attrs["inherited_from_type"].SetOptional()
	attrs["value"] = attrs["value"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePredictiveOptimizationFlag.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EffectivePredictiveOptimizationFlag) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePredictiveOptimizationFlag
// only implements ToObjectValue() and Type().
func (o EffectivePredictiveOptimizationFlag) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited_from_name": o.InheritedFromName,
			"inherited_from_type": o.InheritedFromType,
			"value":               o.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EffectivePredictiveOptimizationFlag) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited_from_name": types.StringType,
			"inherited_from_type": types.StringType,
			"value":               types.StringType,
		},
	}
}

type EffectivePrivilege struct {
	// The full name of the object that conveys this privilege via inheritance.
	// This field is omitted when privilege is not inherited (it's assigned to
	// the securable itself).
	InheritedFromName types.String `tfsdk:"inherited_from_name"`
	// The type of the object that conveys this privilege via inheritance. This
	// field is omitted when privilege is not inherited (it's assigned to the
	// securable itself).
	InheritedFromType types.String `tfsdk:"inherited_from_type"`
	// The privilege assigned to the principal.
	Privilege types.String `tfsdk:"privilege"`
}

func (toState *EffectivePrivilege) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EffectivePrivilege) {
}

func (toState *EffectivePrivilege) SyncFieldsDuringRead(ctx context.Context, fromState EffectivePrivilege) {
}

func (c EffectivePrivilege) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited_from_name"] = attrs["inherited_from_name"].SetOptional()
	attrs["inherited_from_type"] = attrs["inherited_from_type"].SetOptional()
	attrs["privilege"] = attrs["privilege"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePrivilege.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EffectivePrivilege) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePrivilege
// only implements ToObjectValue() and Type().
func (o EffectivePrivilege) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited_from_name": o.InheritedFromName,
			"inherited_from_type": o.InheritedFromType,
			"privilege":           o.Privilege,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EffectivePrivilege) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited_from_name": types.StringType,
			"inherited_from_type": types.StringType,
			"privilege":           types.StringType,
		},
	}
}

type EffectivePrivilegeAssignment struct {
	// The principal (user email address or group name).
	Principal types.String `tfsdk:"principal"`
	// The privileges conveyed to the principal (either directly or via
	// inheritance).
	Privileges types.List `tfsdk:"privileges"`
}

func (toState *EffectivePrivilegeAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EffectivePrivilegeAssignment) {
}

func (toState *EffectivePrivilegeAssignment) SyncFieldsDuringRead(ctx context.Context, fromState EffectivePrivilegeAssignment) {
}

func (c EffectivePrivilegeAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["privileges"] = attrs["privileges"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EffectivePrivilegeAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EffectivePrivilegeAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privileges": reflect.TypeOf(EffectivePrivilege{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EffectivePrivilegeAssignment
// only implements ToObjectValue() and Type().
func (o EffectivePrivilegeAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"principal":  o.Principal,
			"privileges": o.Privileges,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EffectivePrivilegeAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"principal": types.StringType,
			"privileges": basetypes.ListType{
				ElemType: EffectivePrivilege{}.Type(ctx),
			},
		},
	}
}

// GetPrivileges returns the value of the Privileges field in EffectivePrivilegeAssignment as
// a slice of EffectivePrivilege values.
// If the field is unknown or null, the boolean return value is false.
func (o *EffectivePrivilegeAssignment) GetPrivileges(ctx context.Context) ([]EffectivePrivilege, bool) {
	if o.Privileges.IsNull() || o.Privileges.IsUnknown() {
		return nil, false
	}
	var v []EffectivePrivilege
	d := o.Privileges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivileges sets the value of the Privileges field in EffectivePrivilegeAssignment.
func (o *EffectivePrivilegeAssignment) SetPrivileges(ctx context.Context, v []EffectivePrivilege) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["privileges"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Privileges = types.ListValueMust(t, vs)
}

type EnableRequest struct {
	// the catalog for which the system schema is to enabled in
	CatalogName types.String `tfsdk:"catalog_name"`
	// The metastore ID under which the system schema lives.
	MetastoreId types.String `tfsdk:"-"`
	// Full name of the system schema.
	SchemaName types.String `tfsdk:"-"`
}

func (toState *EnableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EnableRequest) {
}

func (toState *EnableRequest) SyncFieldsDuringRead(ctx context.Context, fromState EnableRequest) {
}

func (c EnableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EnableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnableRequest
// only implements ToObjectValue() and Type().
func (o EnableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name": o.CatalogName,
			"metastore_id": o.MetastoreId,
			"schema_name":  o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EnableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"metastore_id": types.StringType,
			"schema_name":  types.StringType,
		},
	}
}

type EnableResponse struct {
}

func (toState *EnableResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EnableResponse) {
}

func (toState *EnableResponse) SyncFieldsDuringRead(ctx context.Context, fromState EnableResponse) {
}

func (c EnableResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnableResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EnableResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnableResponse
// only implements ToObjectValue() and Type().
func (o EnableResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o EnableResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// Encryption options that apply to clients connecting to cloud storage.
type EncryptionDetails struct {
	// Server-Side Encryption properties for clients communicating with AWS s3.
	SseEncryptionDetails types.Object `tfsdk:"sse_encryption_details"`
}

func (toState *EncryptionDetails) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EncryptionDetails) {
	if !fromPlan.SseEncryptionDetails.IsNull() && !fromPlan.SseEncryptionDetails.IsUnknown() {
		if toStateSseEncryptionDetails, ok := toState.GetSseEncryptionDetails(ctx); ok {
			if fromPlanSseEncryptionDetails, ok := fromPlan.GetSseEncryptionDetails(ctx); ok {
				toStateSseEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSseEncryptionDetails)
				toState.SetSseEncryptionDetails(ctx, toStateSseEncryptionDetails)
			}
		}
	}
}

func (toState *EncryptionDetails) SyncFieldsDuringRead(ctx context.Context, fromState EncryptionDetails) {
	if !fromState.SseEncryptionDetails.IsNull() && !fromState.SseEncryptionDetails.IsUnknown() {
		if toStateSseEncryptionDetails, ok := toState.GetSseEncryptionDetails(ctx); ok {
			if fromStateSseEncryptionDetails, ok := fromState.GetSseEncryptionDetails(ctx); ok {
				toStateSseEncryptionDetails.SyncFieldsDuringRead(ctx, fromStateSseEncryptionDetails)
				toState.SetSseEncryptionDetails(ctx, toStateSseEncryptionDetails)
			}
		}
	}
}

func (c EncryptionDetails) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["sse_encryption_details"] = attrs["sse_encryption_details"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EncryptionDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EncryptionDetails) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"sse_encryption_details": reflect.TypeOf(SseEncryptionDetails{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EncryptionDetails
// only implements ToObjectValue() and Type().
func (o EncryptionDetails) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"sse_encryption_details": o.SseEncryptionDetails,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EncryptionDetails) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"sse_encryption_details": SseEncryptionDetails{}.Type(ctx),
		},
	}
}

// GetSseEncryptionDetails returns the value of the SseEncryptionDetails field in EncryptionDetails as
// a SseEncryptionDetails value.
// If the field is unknown or null, the boolean return value is false.
func (o *EncryptionDetails) GetSseEncryptionDetails(ctx context.Context) (SseEncryptionDetails, bool) {
	var e SseEncryptionDetails
	if o.SseEncryptionDetails.IsNull() || o.SseEncryptionDetails.IsUnknown() {
		return e, false
	}
	var v SseEncryptionDetails
	d := o.SseEncryptionDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSseEncryptionDetails sets the value of the SseEncryptionDetails field in EncryptionDetails.
func (o *EncryptionDetails) SetSseEncryptionDetails(ctx context.Context, v SseEncryptionDetails) {
	vs := v.ToObjectValue(ctx)
	o.SseEncryptionDetails = vs
}

// Represents a tag assignment to an entity
type EntityTagAssignment struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"entity_name"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"entity_type"`
	// The key of the tag
	TagKey types.String `tfsdk:"tag_key"`
	// The value of the tag
	TagValue types.String `tfsdk:"tag_value"`
}

func (toState *EntityTagAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan EntityTagAssignment) {
}

func (toState *EntityTagAssignment) SyncFieldsDuringRead(ctx context.Context, fromState EntityTagAssignment) {
}

func (c EntityTagAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_type"] = attrs["entity_type"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["tag_key"] = attrs["tag_key"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["tag_value"] = attrs["tag_value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EntityTagAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a EntityTagAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EntityTagAssignment
// only implements ToObjectValue() and Type().
func (o EntityTagAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": o.EntityName,
			"entity_type": o.EntityType,
			"tag_key":     o.TagKey,
			"tag_value":   o.TagValue,
		})
}

// Type implements basetypes.ObjectValuable.
func (o EntityTagAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_key":     types.StringType,
			"tag_value":   types.StringType,
		},
	}
}

type ExistsRequest struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
}

func (toState *ExistsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExistsRequest) {
}

func (toState *ExistsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ExistsRequest) {
}

func (c ExistsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExistsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExistsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExistsRequest
// only implements ToObjectValue() and Type().
func (o ExistsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": o.FullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExistsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
		},
	}
}

type ExternalLineageExternalMetadata struct {
	Name types.String `tfsdk:"name"`
}

func (toState *ExternalLineageExternalMetadata) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageExternalMetadata) {
}

func (toState *ExternalLineageExternalMetadata) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageExternalMetadata) {
}

func (c ExternalLineageExternalMetadata) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageExternalMetadata.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageExternalMetadata) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageExternalMetadata
// only implements ToObjectValue() and Type().
func (o ExternalLineageExternalMetadata) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageExternalMetadata) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

// Represents the external metadata object in the lineage event.
type ExternalLineageExternalMetadataInfo struct {
	// Type of entity represented by the external metadata object.
	EntityType types.String `tfsdk:"entity_type"`
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// Name of the external metadata object.
	Name types.String `tfsdk:"name"`
	// Type of external system.
	SystemType types.String `tfsdk:"system_type"`
}

func (toState *ExternalLineageExternalMetadataInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageExternalMetadataInfo) {
}

func (toState *ExternalLineageExternalMetadataInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageExternalMetadataInfo) {
}

func (c ExternalLineageExternalMetadataInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetOptional()
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["system_type"] = attrs["system_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageExternalMetadataInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageExternalMetadataInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageExternalMetadataInfo
// only implements ToObjectValue() and Type().
func (o ExternalLineageExternalMetadataInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_type": o.EntityType,
			"event_time":  o.EventTime,
			"name":        o.Name,
			"system_type": o.SystemType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageExternalMetadataInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_type": types.StringType,
			"event_time":  types.StringType,
			"name":        types.StringType,
			"system_type": types.StringType,
		},
	}
}

// Represents the path information in the lineage event.
type ExternalLineageFileInfo struct {
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// URL of the path.
	Path types.String `tfsdk:"path"`
	// The full name of the securable on the path.
	SecurableName types.String `tfsdk:"securable_name"`
	// The securable type of the securable on the path.
	SecurableType types.String `tfsdk:"securable_type"`
	// The storage location associated with securable on the path.
	StorageLocation types.String `tfsdk:"storage_location"`
}

func (toState *ExternalLineageFileInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageFileInfo) {
}

func (toState *ExternalLineageFileInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageFileInfo) {
}

func (c ExternalLineageFileInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["path"] = attrs["path"].SetOptional()
	attrs["securable_name"] = attrs["securable_name"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageFileInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageFileInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageFileInfo
// only implements ToObjectValue() and Type().
func (o ExternalLineageFileInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"event_time":       o.EventTime,
			"path":             o.Path,
			"securable_name":   o.SecurableName,
			"securable_type":   o.SecurableType,
			"storage_location": o.StorageLocation,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageFileInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"event_time":       types.StringType,
			"path":             types.StringType,
			"securable_name":   types.StringType,
			"securable_type":   types.StringType,
			"storage_location": types.StringType,
		},
	}
}

// Lineage response containing lineage information of a data asset.
type ExternalLineageInfo struct {
	// Information about the edge metadata of the external lineage relationship.
	ExternalLineageInfo types.Object `tfsdk:"external_lineage_info"`
	// Information about external metadata involved in the lineage relationship.
	ExternalMetadataInfo types.Object `tfsdk:"external_metadata_info"`
	// Information about the file involved in the lineage relationship.
	FileInfo types.Object `tfsdk:"file_info"`
	// Information about the model version involved in the lineage relationship.
	ModelInfo types.Object `tfsdk:"model_info"`
	// Information about the table involved in the lineage relationship.
	TableInfo types.Object `tfsdk:"table_info"`
}

func (toState *ExternalLineageInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageInfo) {
	if !fromPlan.ExternalLineageInfo.IsNull() && !fromPlan.ExternalLineageInfo.IsUnknown() {
		if toStateExternalLineageInfo, ok := toState.GetExternalLineageInfo(ctx); ok {
			if fromPlanExternalLineageInfo, ok := fromPlan.GetExternalLineageInfo(ctx); ok {
				toStateExternalLineageInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalLineageInfo)
				toState.SetExternalLineageInfo(ctx, toStateExternalLineageInfo)
			}
		}
	}
	if !fromPlan.ExternalMetadataInfo.IsNull() && !fromPlan.ExternalMetadataInfo.IsUnknown() {
		if toStateExternalMetadataInfo, ok := toState.GetExternalMetadataInfo(ctx); ok {
			if fromPlanExternalMetadataInfo, ok := fromPlan.GetExternalMetadataInfo(ctx); ok {
				toStateExternalMetadataInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalMetadataInfo)
				toState.SetExternalMetadataInfo(ctx, toStateExternalMetadataInfo)
			}
		}
	}
	if !fromPlan.FileInfo.IsNull() && !fromPlan.FileInfo.IsUnknown() {
		if toStateFileInfo, ok := toState.GetFileInfo(ctx); ok {
			if fromPlanFileInfo, ok := fromPlan.GetFileInfo(ctx); ok {
				toStateFileInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFileInfo)
				toState.SetFileInfo(ctx, toStateFileInfo)
			}
		}
	}
	if !fromPlan.ModelInfo.IsNull() && !fromPlan.ModelInfo.IsUnknown() {
		if toStateModelInfo, ok := toState.GetModelInfo(ctx); ok {
			if fromPlanModelInfo, ok := fromPlan.GetModelInfo(ctx); ok {
				toStateModelInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanModelInfo)
				toState.SetModelInfo(ctx, toStateModelInfo)
			}
		}
	}
	if !fromPlan.TableInfo.IsNull() && !fromPlan.TableInfo.IsUnknown() {
		if toStateTableInfo, ok := toState.GetTableInfo(ctx); ok {
			if fromPlanTableInfo, ok := fromPlan.GetTableInfo(ctx); ok {
				toStateTableInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTableInfo)
				toState.SetTableInfo(ctx, toStateTableInfo)
			}
		}
	}
}

func (toState *ExternalLineageInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageInfo) {
	if !fromState.ExternalLineageInfo.IsNull() && !fromState.ExternalLineageInfo.IsUnknown() {
		if toStateExternalLineageInfo, ok := toState.GetExternalLineageInfo(ctx); ok {
			if fromStateExternalLineageInfo, ok := fromState.GetExternalLineageInfo(ctx); ok {
				toStateExternalLineageInfo.SyncFieldsDuringRead(ctx, fromStateExternalLineageInfo)
				toState.SetExternalLineageInfo(ctx, toStateExternalLineageInfo)
			}
		}
	}
	if !fromState.ExternalMetadataInfo.IsNull() && !fromState.ExternalMetadataInfo.IsUnknown() {
		if toStateExternalMetadataInfo, ok := toState.GetExternalMetadataInfo(ctx); ok {
			if fromStateExternalMetadataInfo, ok := fromState.GetExternalMetadataInfo(ctx); ok {
				toStateExternalMetadataInfo.SyncFieldsDuringRead(ctx, fromStateExternalMetadataInfo)
				toState.SetExternalMetadataInfo(ctx, toStateExternalMetadataInfo)
			}
		}
	}
	if !fromState.FileInfo.IsNull() && !fromState.FileInfo.IsUnknown() {
		if toStateFileInfo, ok := toState.GetFileInfo(ctx); ok {
			if fromStateFileInfo, ok := fromState.GetFileInfo(ctx); ok {
				toStateFileInfo.SyncFieldsDuringRead(ctx, fromStateFileInfo)
				toState.SetFileInfo(ctx, toStateFileInfo)
			}
		}
	}
	if !fromState.ModelInfo.IsNull() && !fromState.ModelInfo.IsUnknown() {
		if toStateModelInfo, ok := toState.GetModelInfo(ctx); ok {
			if fromStateModelInfo, ok := fromState.GetModelInfo(ctx); ok {
				toStateModelInfo.SyncFieldsDuringRead(ctx, fromStateModelInfo)
				toState.SetModelInfo(ctx, toStateModelInfo)
			}
		}
	}
	if !fromState.TableInfo.IsNull() && !fromState.TableInfo.IsUnknown() {
		if toStateTableInfo, ok := toState.GetTableInfo(ctx); ok {
			if fromStateTableInfo, ok := fromState.GetTableInfo(ctx); ok {
				toStateTableInfo.SyncFieldsDuringRead(ctx, fromStateTableInfo)
				toState.SetTableInfo(ctx, toStateTableInfo)
			}
		}
	}
}

func (c ExternalLineageInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_info"] = attrs["external_lineage_info"].SetOptional()
	attrs["external_metadata_info"] = attrs["external_metadata_info"].SetOptional()
	attrs["file_info"] = attrs["file_info"].SetOptional()
	attrs["model_info"] = attrs["model_info"].SetOptional()
	attrs["table_info"] = attrs["table_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_info":  reflect.TypeOf(ExternalLineageRelationshipInfo{}),
		"external_metadata_info": reflect.TypeOf(ExternalLineageExternalMetadataInfo{}),
		"file_info":              reflect.TypeOf(ExternalLineageFileInfo{}),
		"model_info":             reflect.TypeOf(ExternalLineageModelVersionInfo{}),
		"table_info":             reflect.TypeOf(ExternalLineageTableInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageInfo
// only implements ToObjectValue() and Type().
func (o ExternalLineageInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_info":  o.ExternalLineageInfo,
			"external_metadata_info": o.ExternalMetadataInfo,
			"file_info":              o.FileInfo,
			"model_info":             o.ModelInfo,
			"table_info":             o.TableInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_info":  ExternalLineageRelationshipInfo{}.Type(ctx),
			"external_metadata_info": ExternalLineageExternalMetadataInfo{}.Type(ctx),
			"file_info":              ExternalLineageFileInfo{}.Type(ctx),
			"model_info":             ExternalLineageModelVersionInfo{}.Type(ctx),
			"table_info":             ExternalLineageTableInfo{}.Type(ctx),
		},
	}
}

// GetExternalLineageInfo returns the value of the ExternalLineageInfo field in ExternalLineageInfo as
// a ExternalLineageRelationshipInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageInfo) GetExternalLineageInfo(ctx context.Context) (ExternalLineageRelationshipInfo, bool) {
	var e ExternalLineageRelationshipInfo
	if o.ExternalLineageInfo.IsNull() || o.ExternalLineageInfo.IsUnknown() {
		return e, false
	}
	var v ExternalLineageRelationshipInfo
	d := o.ExternalLineageInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLineageInfo sets the value of the ExternalLineageInfo field in ExternalLineageInfo.
func (o *ExternalLineageInfo) SetExternalLineageInfo(ctx context.Context, v ExternalLineageRelationshipInfo) {
	vs := v.ToObjectValue(ctx)
	o.ExternalLineageInfo = vs
}

// GetExternalMetadataInfo returns the value of the ExternalMetadataInfo field in ExternalLineageInfo as
// a ExternalLineageExternalMetadataInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageInfo) GetExternalMetadataInfo(ctx context.Context) (ExternalLineageExternalMetadataInfo, bool) {
	var e ExternalLineageExternalMetadataInfo
	if o.ExternalMetadataInfo.IsNull() || o.ExternalMetadataInfo.IsUnknown() {
		return e, false
	}
	var v ExternalLineageExternalMetadataInfo
	d := o.ExternalMetadataInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalMetadataInfo sets the value of the ExternalMetadataInfo field in ExternalLineageInfo.
func (o *ExternalLineageInfo) SetExternalMetadataInfo(ctx context.Context, v ExternalLineageExternalMetadataInfo) {
	vs := v.ToObjectValue(ctx)
	o.ExternalMetadataInfo = vs
}

// GetFileInfo returns the value of the FileInfo field in ExternalLineageInfo as
// a ExternalLineageFileInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageInfo) GetFileInfo(ctx context.Context) (ExternalLineageFileInfo, bool) {
	var e ExternalLineageFileInfo
	if o.FileInfo.IsNull() || o.FileInfo.IsUnknown() {
		return e, false
	}
	var v ExternalLineageFileInfo
	d := o.FileInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFileInfo sets the value of the FileInfo field in ExternalLineageInfo.
func (o *ExternalLineageInfo) SetFileInfo(ctx context.Context, v ExternalLineageFileInfo) {
	vs := v.ToObjectValue(ctx)
	o.FileInfo = vs
}

// GetModelInfo returns the value of the ModelInfo field in ExternalLineageInfo as
// a ExternalLineageModelVersionInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageInfo) GetModelInfo(ctx context.Context) (ExternalLineageModelVersionInfo, bool) {
	var e ExternalLineageModelVersionInfo
	if o.ModelInfo.IsNull() || o.ModelInfo.IsUnknown() {
		return e, false
	}
	var v ExternalLineageModelVersionInfo
	d := o.ModelInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetModelInfo sets the value of the ModelInfo field in ExternalLineageInfo.
func (o *ExternalLineageInfo) SetModelInfo(ctx context.Context, v ExternalLineageModelVersionInfo) {
	vs := v.ToObjectValue(ctx)
	o.ModelInfo = vs
}

// GetTableInfo returns the value of the TableInfo field in ExternalLineageInfo as
// a ExternalLineageTableInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageInfo) GetTableInfo(ctx context.Context) (ExternalLineageTableInfo, bool) {
	var e ExternalLineageTableInfo
	if o.TableInfo.IsNull() || o.TableInfo.IsUnknown() {
		return e, false
	}
	var v ExternalLineageTableInfo
	d := o.TableInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTableInfo sets the value of the TableInfo field in ExternalLineageInfo.
func (o *ExternalLineageInfo) SetTableInfo(ctx context.Context, v ExternalLineageTableInfo) {
	vs := v.ToObjectValue(ctx)
	o.TableInfo = vs
}

type ExternalLineageModelVersion struct {
	Name types.String `tfsdk:"name"`

	Version types.String `tfsdk:"version"`
}

func (toState *ExternalLineageModelVersion) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageModelVersion) {
}

func (toState *ExternalLineageModelVersion) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageModelVersion) {
}

func (c ExternalLineageModelVersion) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()
	attrs["version"] = attrs["version"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageModelVersion.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageModelVersion) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageModelVersion
// only implements ToObjectValue() and Type().
func (o ExternalLineageModelVersion) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":    o.Name,
			"version": o.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageModelVersion) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":    types.StringType,
			"version": types.StringType,
		},
	}
}

// Represents the model version information in the lineage event.
type ExternalLineageModelVersionInfo struct {
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// Name of the model.
	ModelName types.String `tfsdk:"model_name"`
	// Version number of the model.
	Version types.Int64 `tfsdk:"version"`
}

func (toState *ExternalLineageModelVersionInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageModelVersionInfo) {
}

func (toState *ExternalLineageModelVersionInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageModelVersionInfo) {
}

func (c ExternalLineageModelVersionInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["version"] = attrs["version"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageModelVersionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageModelVersionInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageModelVersionInfo
// only implements ToObjectValue() and Type().
func (o ExternalLineageModelVersionInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"event_time": o.EventTime,
			"model_name": o.ModelName,
			"version":    o.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageModelVersionInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"event_time": types.StringType,
			"model_name": types.StringType,
			"version":    types.Int64Type,
		},
	}
}

type ExternalLineageObject struct {
	ExternalMetadata types.Object `tfsdk:"external_metadata"`

	ModelVersion types.Object `tfsdk:"model_version"`

	Path types.Object `tfsdk:"path"`

	Table types.Object `tfsdk:"table"`
}

func (toState *ExternalLineageObject) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageObject) {
	if !fromPlan.ExternalMetadata.IsNull() && !fromPlan.ExternalMetadata.IsUnknown() {
		if toStateExternalMetadata, ok := toState.GetExternalMetadata(ctx); ok {
			if fromPlanExternalMetadata, ok := fromPlan.GetExternalMetadata(ctx); ok {
				toStateExternalMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalMetadata)
				toState.SetExternalMetadata(ctx, toStateExternalMetadata)
			}
		}
	}
	if !fromPlan.ModelVersion.IsNull() && !fromPlan.ModelVersion.IsUnknown() {
		if toStateModelVersion, ok := toState.GetModelVersion(ctx); ok {
			if fromPlanModelVersion, ok := fromPlan.GetModelVersion(ctx); ok {
				toStateModelVersion.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanModelVersion)
				toState.SetModelVersion(ctx, toStateModelVersion)
			}
		}
	}
	if !fromPlan.Path.IsNull() && !fromPlan.Path.IsUnknown() {
		if toStatePath, ok := toState.GetPath(ctx); ok {
			if fromPlanPath, ok := fromPlan.GetPath(ctx); ok {
				toStatePath.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanPath)
				toState.SetPath(ctx, toStatePath)
			}
		}
	}
	if !fromPlan.Table.IsNull() && !fromPlan.Table.IsUnknown() {
		if toStateTable, ok := toState.GetTable(ctx); ok {
			if fromPlanTable, ok := fromPlan.GetTable(ctx); ok {
				toStateTable.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTable)
				toState.SetTable(ctx, toStateTable)
			}
		}
	}
}

func (toState *ExternalLineageObject) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageObject) {
	if !fromState.ExternalMetadata.IsNull() && !fromState.ExternalMetadata.IsUnknown() {
		if toStateExternalMetadata, ok := toState.GetExternalMetadata(ctx); ok {
			if fromStateExternalMetadata, ok := fromState.GetExternalMetadata(ctx); ok {
				toStateExternalMetadata.SyncFieldsDuringRead(ctx, fromStateExternalMetadata)
				toState.SetExternalMetadata(ctx, toStateExternalMetadata)
			}
		}
	}
	if !fromState.ModelVersion.IsNull() && !fromState.ModelVersion.IsUnknown() {
		if toStateModelVersion, ok := toState.GetModelVersion(ctx); ok {
			if fromStateModelVersion, ok := fromState.GetModelVersion(ctx); ok {
				toStateModelVersion.SyncFieldsDuringRead(ctx, fromStateModelVersion)
				toState.SetModelVersion(ctx, toStateModelVersion)
			}
		}
	}
	if !fromState.Path.IsNull() && !fromState.Path.IsUnknown() {
		if toStatePath, ok := toState.GetPath(ctx); ok {
			if fromStatePath, ok := fromState.GetPath(ctx); ok {
				toStatePath.SyncFieldsDuringRead(ctx, fromStatePath)
				toState.SetPath(ctx, toStatePath)
			}
		}
	}
	if !fromState.Table.IsNull() && !fromState.Table.IsUnknown() {
		if toStateTable, ok := toState.GetTable(ctx); ok {
			if fromStateTable, ok := fromState.GetTable(ctx); ok {
				toStateTable.SyncFieldsDuringRead(ctx, fromStateTable)
				toState.SetTable(ctx, toStateTable)
			}
		}
	}
}

func (c ExternalLineageObject) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetOptional()
	attrs["model_version"] = attrs["model_version"].SetOptional()
	attrs["path"] = attrs["path"].SetOptional()
	attrs["table"] = attrs["table"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageObject.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageObject) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalLineageExternalMetadata{}),
		"model_version":     reflect.TypeOf(ExternalLineageModelVersion{}),
		"path":              reflect.TypeOf(ExternalLineagePath{}),
		"table":             reflect.TypeOf(ExternalLineageTable{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageObject
// only implements ToObjectValue() and Type().
func (o ExternalLineageObject) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": o.ExternalMetadata,
			"model_version":     o.ModelVersion,
			"path":              o.Path,
			"table":             o.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageObject) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": ExternalLineageExternalMetadata{}.Type(ctx),
			"model_version":     ExternalLineageModelVersion{}.Type(ctx),
			"path":              ExternalLineagePath{}.Type(ctx),
			"table":             ExternalLineageTable{}.Type(ctx),
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in ExternalLineageObject as
// a ExternalLineageExternalMetadata value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageObject) GetExternalMetadata(ctx context.Context) (ExternalLineageExternalMetadata, bool) {
	var e ExternalLineageExternalMetadata
	if o.ExternalMetadata.IsNull() || o.ExternalMetadata.IsUnknown() {
		return e, false
	}
	var v ExternalLineageExternalMetadata
	d := o.ExternalMetadata.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in ExternalLineageObject.
func (o *ExternalLineageObject) SetExternalMetadata(ctx context.Context, v ExternalLineageExternalMetadata) {
	vs := v.ToObjectValue(ctx)
	o.ExternalMetadata = vs
}

// GetModelVersion returns the value of the ModelVersion field in ExternalLineageObject as
// a ExternalLineageModelVersion value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageObject) GetModelVersion(ctx context.Context) (ExternalLineageModelVersion, bool) {
	var e ExternalLineageModelVersion
	if o.ModelVersion.IsNull() || o.ModelVersion.IsUnknown() {
		return e, false
	}
	var v ExternalLineageModelVersion
	d := o.ModelVersion.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetModelVersion sets the value of the ModelVersion field in ExternalLineageObject.
func (o *ExternalLineageObject) SetModelVersion(ctx context.Context, v ExternalLineageModelVersion) {
	vs := v.ToObjectValue(ctx)
	o.ModelVersion = vs
}

// GetPath returns the value of the Path field in ExternalLineageObject as
// a ExternalLineagePath value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageObject) GetPath(ctx context.Context) (ExternalLineagePath, bool) {
	var e ExternalLineagePath
	if o.Path.IsNull() || o.Path.IsUnknown() {
		return e, false
	}
	var v ExternalLineagePath
	d := o.Path.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPath sets the value of the Path field in ExternalLineageObject.
func (o *ExternalLineageObject) SetPath(ctx context.Context, v ExternalLineagePath) {
	vs := v.ToObjectValue(ctx)
	o.Path = vs
}

// GetTable returns the value of the Table field in ExternalLineageObject as
// a ExternalLineageTable value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageObject) GetTable(ctx context.Context) (ExternalLineageTable, bool) {
	var e ExternalLineageTable
	if o.Table.IsNull() || o.Table.IsUnknown() {
		return e, false
	}
	var v ExternalLineageTable
	d := o.Table.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTable sets the value of the Table field in ExternalLineageObject.
func (o *ExternalLineageObject) SetTable(ctx context.Context, v ExternalLineageTable) {
	vs := v.ToObjectValue(ctx)
	o.Table = vs
}

type ExternalLineagePath struct {
	Url types.String `tfsdk:"url"`
}

func (toState *ExternalLineagePath) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineagePath) {
}

func (toState *ExternalLineagePath) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineagePath) {
}

func (c ExternalLineagePath) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineagePath.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineagePath) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineagePath
// only implements ToObjectValue() and Type().
func (o ExternalLineagePath) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"url": o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineagePath) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"url": types.StringType,
		},
	}
}

type ExternalLineageRelationship struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.Object `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.Object `tfsdk:"target"`
}

func (toState *ExternalLineageRelationship) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageRelationship) {
	if !fromPlan.Source.IsNull() && !fromPlan.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromPlanSource, ok := fromPlan.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromPlan.Target.IsNull() && !fromPlan.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromPlanTarget, ok := fromPlan.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (toState *ExternalLineageRelationship) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageRelationship) {
	if !fromState.Source.IsNull() && !fromState.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromStateSource, ok := fromState.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringRead(ctx, fromStateSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromState.Target.IsNull() && !fromState.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromStateTarget, ok := fromState.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringRead(ctx, fromStateTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (c ExternalLineageRelationship) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["target"] = attrs["target"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageRelationship.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageRelationship) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject{}),
		"target":     reflect.TypeOf(ExternalLineageObject{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageRelationship
// only implements ToObjectValue() and Type().
func (o ExternalLineageRelationship) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    o.Columns,
			"id":         o.Id,
			"properties": o.Properties,
			"source":     o.Source,
			"target":     o.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageRelationship) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": ExternalLineageObject{}.Type(ctx),
			"target": ExternalLineageObject{}.Type(ctx),
		},
	}
}

// GetColumns returns the value of the Columns field in ExternalLineageRelationship as
// a slice of ColumnRelationship values.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationship) GetColumns(ctx context.Context) ([]ColumnRelationship, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in ExternalLineageRelationship.
func (o *ExternalLineageRelationship) SetColumns(ctx context.Context, v []ColumnRelationship) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ExternalLineageRelationship as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationship) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ExternalLineageRelationship.
func (o *ExternalLineageRelationship) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in ExternalLineageRelationship as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationship) GetSource(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Source.IsNull() || o.Source.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Source.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSource sets the value of the Source field in ExternalLineageRelationship.
func (o *ExternalLineageRelationship) SetSource(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Source = vs
}

// GetTarget returns the value of the Target field in ExternalLineageRelationship as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationship) GetTarget(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Target.IsNull() || o.Target.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Target.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTarget sets the value of the Target field in ExternalLineageRelationship.
func (o *ExternalLineageRelationship) SetTarget(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Target = vs
}

type ExternalLineageRelationshipInfo struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.Object `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.Object `tfsdk:"target"`
}

func (toState *ExternalLineageRelationshipInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageRelationshipInfo) {
	if !fromPlan.Source.IsNull() && !fromPlan.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromPlanSource, ok := fromPlan.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromPlan.Target.IsNull() && !fromPlan.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromPlanTarget, ok := fromPlan.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (toState *ExternalLineageRelationshipInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageRelationshipInfo) {
	if !fromState.Source.IsNull() && !fromState.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromStateSource, ok := fromState.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringRead(ctx, fromStateSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromState.Target.IsNull() && !fromState.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromStateTarget, ok := fromState.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringRead(ctx, fromStateTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (c ExternalLineageRelationshipInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["target"] = attrs["target"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageRelationshipInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageRelationshipInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject{}),
		"target":     reflect.TypeOf(ExternalLineageObject{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageRelationshipInfo
// only implements ToObjectValue() and Type().
func (o ExternalLineageRelationshipInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    o.Columns,
			"id":         o.Id,
			"properties": o.Properties,
			"source":     o.Source,
			"target":     o.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageRelationshipInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": ExternalLineageObject{}.Type(ctx),
			"target": ExternalLineageObject{}.Type(ctx),
		},
	}
}

// GetColumns returns the value of the Columns field in ExternalLineageRelationshipInfo as
// a slice of ColumnRelationship values.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationshipInfo) GetColumns(ctx context.Context) ([]ColumnRelationship, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in ExternalLineageRelationshipInfo.
func (o *ExternalLineageRelationshipInfo) SetColumns(ctx context.Context, v []ColumnRelationship) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ExternalLineageRelationshipInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationshipInfo) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ExternalLineageRelationshipInfo.
func (o *ExternalLineageRelationshipInfo) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in ExternalLineageRelationshipInfo as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationshipInfo) GetSource(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Source.IsNull() || o.Source.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Source.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSource sets the value of the Source field in ExternalLineageRelationshipInfo.
func (o *ExternalLineageRelationshipInfo) SetSource(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Source = vs
}

// GetTarget returns the value of the Target field in ExternalLineageRelationshipInfo as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLineageRelationshipInfo) GetTarget(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Target.IsNull() || o.Target.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Target.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTarget sets the value of the Target field in ExternalLineageRelationshipInfo.
func (o *ExternalLineageRelationshipInfo) SetTarget(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Target = vs
}

type ExternalLineageTable struct {
	Name types.String `tfsdk:"name"`
}

func (toState *ExternalLineageTable) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageTable) {
}

func (toState *ExternalLineageTable) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageTable) {
}

func (c ExternalLineageTable) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageTable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageTable) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageTable
// only implements ToObjectValue() and Type().
func (o ExternalLineageTable) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageTable) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

// Represents the table information in the lineage event.
type ExternalLineageTableInfo struct {
	// Name of Catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// Timestamp of the lineage event.
	EventTime types.String `tfsdk:"event_time"`
	// Name of Table.
	Name types.String `tfsdk:"name"`
	// Name of Schema.
	SchemaName types.String `tfsdk:"schema_name"`
}

func (toState *ExternalLineageTableInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLineageTableInfo) {
}

func (toState *ExternalLineageTableInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLineageTableInfo) {
}

func (c ExternalLineageTableInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["event_time"] = attrs["event_time"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLineageTableInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLineageTableInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLineageTableInfo
// only implements ToObjectValue() and Type().
func (o ExternalLineageTableInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name": o.CatalogName,
			"event_time":   o.EventTime,
			"name":         o.Name,
			"schema_name":  o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLineageTableInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name": types.StringType,
			"event_time":   types.StringType,
			"name":         types.StringType,
			"schema_name":  types.StringType,
		},
	}
}

type ExternalLocationInfo struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this external location was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of external location creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique ID of the location's storage credential.
	CredentialId types.String `tfsdk:"credential_id"`
	// Name of the storage credential used with this location.
	CredentialName types.String `tfsdk:"credential_name"`
	// Whether to enable file events on this external location.
	EnableFileEvents types.Bool `tfsdk:"enable_file_events"`

	EncryptionDetails types.Object `tfsdk:"encryption_details"`
	// Indicates whether fallback mode is enabled for this external location.
	// When fallback mode is enabled, the access to the location falls back to
	// cluster credentials if UC credentials are not sufficient.
	Fallback types.Bool `tfsdk:"fallback"`
	// File event queue settings. If `enable_file_events` is `true`, must be
	// defined and have exactly one of the documented properties.
	FileEventQueue types.Object `tfsdk:"file_event_queue"`

	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of metastore hosting the external location.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of the external location.
	Name types.String `tfsdk:"name"`
	// The owner of the external location.
	Owner types.String `tfsdk:"owner"`
	// Indicates whether the external location is read-only.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Time at which external location this was last modified, in epoch
	// milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the external location.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Path URL of the external location.
	Url types.String `tfsdk:"url"`
}

func (toState *ExternalLocationInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalLocationInfo) {
	if !fromPlan.EncryptionDetails.IsNull() && !fromPlan.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromPlanEncryptionDetails, ok := fromPlan.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromPlan.FileEventQueue.IsNull() && !fromPlan.FileEventQueue.IsUnknown() {
		if toStateFileEventQueue, ok := toState.GetFileEventQueue(ctx); ok {
			if fromPlanFileEventQueue, ok := fromPlan.GetFileEventQueue(ctx); ok {
				toStateFileEventQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFileEventQueue)
				toState.SetFileEventQueue(ctx, toStateFileEventQueue)
			}
		}
	}
}

func (toState *ExternalLocationInfo) SyncFieldsDuringRead(ctx context.Context, fromState ExternalLocationInfo) {
	if !fromState.EncryptionDetails.IsNull() && !fromState.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromStateEncryptionDetails, ok := fromState.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringRead(ctx, fromStateEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromState.FileEventQueue.IsNull() && !fromState.FileEventQueue.IsUnknown() {
		if toStateFileEventQueue, ok := toState.GetFileEventQueue(ctx); ok {
			if fromStateFileEventQueue, ok := fromState.GetFileEventQueue(ctx); ok {
				toStateFileEventQueue.SyncFieldsDuringRead(ctx, fromStateFileEventQueue)
				toState.SetFileEventQueue(ctx, toStateFileEventQueue)
			}
		}
	}
}

func (c ExternalLocationInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["credential_id"] = attrs["credential_id"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetOptional()
	attrs["enable_file_events"] = attrs["enable_file_events"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["fallback"] = attrs["fallback"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalLocationInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalLocationInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails{}),
		"file_event_queue":   reflect.TypeOf(FileEventQueue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalLocationInfo
// only implements ToObjectValue() and Type().
func (o ExternalLocationInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":        o.BrowseOnly,
			"comment":            o.Comment,
			"created_at":         o.CreatedAt,
			"created_by":         o.CreatedBy,
			"credential_id":      o.CredentialId,
			"credential_name":    o.CredentialName,
			"enable_file_events": o.EnableFileEvents,
			"encryption_details": o.EncryptionDetails,
			"fallback":           o.Fallback,
			"file_event_queue":   o.FileEventQueue,
			"isolation_mode":     o.IsolationMode,
			"metastore_id":       o.MetastoreId,
			"name":               o.Name,
			"owner":              o.Owner,
			"read_only":          o.ReadOnly,
			"updated_at":         o.UpdatedAt,
			"updated_by":         o.UpdatedBy,
			"url":                o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalLocationInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":        types.BoolType,
			"comment":            types.StringType,
			"created_at":         types.Int64Type,
			"created_by":         types.StringType,
			"credential_id":      types.StringType,
			"credential_name":    types.StringType,
			"enable_file_events": types.BoolType,
			"encryption_details": EncryptionDetails{}.Type(ctx),
			"fallback":           types.BoolType,
			"file_event_queue":   FileEventQueue{}.Type(ctx),
			"isolation_mode":     types.StringType,
			"metastore_id":       types.StringType,
			"name":               types.StringType,
			"owner":              types.StringType,
			"read_only":          types.BoolType,
			"updated_at":         types.Int64Type,
			"updated_by":         types.StringType,
			"url":                types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in ExternalLocationInfo as
// a EncryptionDetails value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLocationInfo) GetEncryptionDetails(ctx context.Context) (EncryptionDetails, bool) {
	var e EncryptionDetails
	if o.EncryptionDetails.IsNull() || o.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v EncryptionDetails
	d := o.EncryptionDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in ExternalLocationInfo.
func (o *ExternalLocationInfo) SetEncryptionDetails(ctx context.Context, v EncryptionDetails) {
	vs := v.ToObjectValue(ctx)
	o.EncryptionDetails = vs
}

// GetFileEventQueue returns the value of the FileEventQueue field in ExternalLocationInfo as
// a FileEventQueue value.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalLocationInfo) GetFileEventQueue(ctx context.Context) (FileEventQueue, bool) {
	var e FileEventQueue
	if o.FileEventQueue.IsNull() || o.FileEventQueue.IsUnknown() {
		return e, false
	}
	var v FileEventQueue
	d := o.FileEventQueue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFileEventQueue sets the value of the FileEventQueue field in ExternalLocationInfo.
func (o *ExternalLocationInfo) SetFileEventQueue(ctx context.Context, v FileEventQueue) {
	vs := v.ToObjectValue(ctx)
	o.FileEventQueue = vs
}

type ExternalMetadata struct {
	// List of columns associated with the external metadata object.
	Columns types.List `tfsdk:"columns"`
	// Time at which this external metadata object was created.
	CreateTime types.String `tfsdk:"create_time"`
	// Username of external metadata object creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// User-provided free-form text description.
	Description types.String `tfsdk:"description"`
	// Type of entity within the external system.
	EntityType types.String `tfsdk:"entity_type"`
	// Unique identifier of the external metadata object.
	Id types.String `tfsdk:"id"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of the external metadata object.
	Name types.String `tfsdk:"name"`
	// Owner of the external metadata object.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the external metadata object.
	Properties types.Map `tfsdk:"properties"`
	// Type of external system.
	SystemType types.String `tfsdk:"system_type"`
	// Time at which this external metadata object was last modified.
	UpdateTime types.String `tfsdk:"update_time"`
	// Username of user who last modified external metadata object.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// URL associated with the external metadata object.
	Url types.String `tfsdk:"url"`
}

func (toState *ExternalMetadata) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ExternalMetadata) {
}

func (toState *ExternalMetadata) SyncFieldsDuringRead(ctx context.Context, fromState ExternalMetadata) {
}

func (c ExternalMetadata) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["create_time"] = attrs["create_time"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["system_type"] = attrs["system_type"].SetRequired()
	attrs["update_time"] = attrs["update_time"].SetComputed()
	attrs["updated_by"] = attrs["updated_by"].SetComputed()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExternalMetadata.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ExternalMetadata) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExternalMetadata
// only implements ToObjectValue() and Type().
func (o ExternalMetadata) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":      o.Columns,
			"create_time":  o.CreateTime,
			"created_by":   o.CreatedBy,
			"description":  o.Description,
			"entity_type":  o.EntityType,
			"id":           o.Id,
			"metastore_id": o.MetastoreId,
			"name":         o.Name,
			"owner":        o.Owner,
			"properties":   o.Properties,
			"system_type":  o.SystemType,
			"update_time":  o.UpdateTime,
			"updated_by":   o.UpdatedBy,
			"url":          o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ExternalMetadata) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"create_time":  types.StringType,
			"created_by":   types.StringType,
			"description":  types.StringType,
			"entity_type":  types.StringType,
			"id":           types.StringType,
			"metastore_id": types.StringType,
			"name":         types.StringType,
			"owner":        types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"system_type": types.StringType,
			"update_time": types.StringType,
			"updated_by":  types.StringType,
			"url":         types.StringType,
		},
	}
}

// GetColumns returns the value of the Columns field in ExternalMetadata as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalMetadata) GetColumns(ctx context.Context) ([]types.String, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in ExternalMetadata.
func (o *ExternalMetadata) SetColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in ExternalMetadata as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ExternalMetadata) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in ExternalMetadata.
func (o *ExternalMetadata) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// Detailed status of an online table. Shown if the online table is in the
// OFFLINE_FAILED or the ONLINE_PIPELINE_FAILED state.
type FailedStatus struct {
	// The last source table Delta version that was synced to the online table.
	// Note that this Delta version may only be partially synced to the online
	// table. Only populated if the table is still online and available for
	// serving.
	LastProcessedCommitVersion types.Int64 `tfsdk:"last_processed_commit_version"`
	// The timestamp of the last time any data was synchronized from the source
	// table to the online table. Only populated if the table is still online
	// and available for serving.
	Timestamp types.String `tfsdk:"timestamp"`
}

func (toState *FailedStatus) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FailedStatus) {
}

func (toState *FailedStatus) SyncFieldsDuringRead(ctx context.Context, fromState FailedStatus) {
}

func (c FailedStatus) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_processed_commit_version"] = attrs["last_processed_commit_version"].SetOptional()
	attrs["timestamp"] = attrs["timestamp"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FailedStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FailedStatus) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FailedStatus
// only implements ToObjectValue() and Type().
func (o FailedStatus) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_processed_commit_version": o.LastProcessedCommitVersion,
			"timestamp":                     o.Timestamp,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FailedStatus) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_processed_commit_version": types.Int64Type,
			"timestamp":                     types.StringType,
		},
	}
}

type FileEventQueue struct {
	ManagedAqs types.Object `tfsdk:"managed_aqs"`

	ManagedPubsub types.Object `tfsdk:"managed_pubsub"`

	ManagedSqs types.Object `tfsdk:"managed_sqs"`

	ProvidedAqs types.Object `tfsdk:"provided_aqs"`

	ProvidedPubsub types.Object `tfsdk:"provided_pubsub"`

	ProvidedSqs types.Object `tfsdk:"provided_sqs"`
}

func (toState *FileEventQueue) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FileEventQueue) {
	if !fromPlan.ManagedAqs.IsNull() && !fromPlan.ManagedAqs.IsUnknown() {
		if toStateManagedAqs, ok := toState.GetManagedAqs(ctx); ok {
			if fromPlanManagedAqs, ok := fromPlan.GetManagedAqs(ctx); ok {
				toStateManagedAqs.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanManagedAqs)
				toState.SetManagedAqs(ctx, toStateManagedAqs)
			}
		}
	}
	if !fromPlan.ManagedPubsub.IsNull() && !fromPlan.ManagedPubsub.IsUnknown() {
		if toStateManagedPubsub, ok := toState.GetManagedPubsub(ctx); ok {
			if fromPlanManagedPubsub, ok := fromPlan.GetManagedPubsub(ctx); ok {
				toStateManagedPubsub.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanManagedPubsub)
				toState.SetManagedPubsub(ctx, toStateManagedPubsub)
			}
		}
	}
	if !fromPlan.ManagedSqs.IsNull() && !fromPlan.ManagedSqs.IsUnknown() {
		if toStateManagedSqs, ok := toState.GetManagedSqs(ctx); ok {
			if fromPlanManagedSqs, ok := fromPlan.GetManagedSqs(ctx); ok {
				toStateManagedSqs.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanManagedSqs)
				toState.SetManagedSqs(ctx, toStateManagedSqs)
			}
		}
	}
	if !fromPlan.ProvidedAqs.IsNull() && !fromPlan.ProvidedAqs.IsUnknown() {
		if toStateProvidedAqs, ok := toState.GetProvidedAqs(ctx); ok {
			if fromPlanProvidedAqs, ok := fromPlan.GetProvidedAqs(ctx); ok {
				toStateProvidedAqs.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanProvidedAqs)
				toState.SetProvidedAqs(ctx, toStateProvidedAqs)
			}
		}
	}
	if !fromPlan.ProvidedPubsub.IsNull() && !fromPlan.ProvidedPubsub.IsUnknown() {
		if toStateProvidedPubsub, ok := toState.GetProvidedPubsub(ctx); ok {
			if fromPlanProvidedPubsub, ok := fromPlan.GetProvidedPubsub(ctx); ok {
				toStateProvidedPubsub.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanProvidedPubsub)
				toState.SetProvidedPubsub(ctx, toStateProvidedPubsub)
			}
		}
	}
	if !fromPlan.ProvidedSqs.IsNull() && !fromPlan.ProvidedSqs.IsUnknown() {
		if toStateProvidedSqs, ok := toState.GetProvidedSqs(ctx); ok {
			if fromPlanProvidedSqs, ok := fromPlan.GetProvidedSqs(ctx); ok {
				toStateProvidedSqs.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanProvidedSqs)
				toState.SetProvidedSqs(ctx, toStateProvidedSqs)
			}
		}
	}
}

func (toState *FileEventQueue) SyncFieldsDuringRead(ctx context.Context, fromState FileEventQueue) {
	if !fromState.ManagedAqs.IsNull() && !fromState.ManagedAqs.IsUnknown() {
		if toStateManagedAqs, ok := toState.GetManagedAqs(ctx); ok {
			if fromStateManagedAqs, ok := fromState.GetManagedAqs(ctx); ok {
				toStateManagedAqs.SyncFieldsDuringRead(ctx, fromStateManagedAqs)
				toState.SetManagedAqs(ctx, toStateManagedAqs)
			}
		}
	}
	if !fromState.ManagedPubsub.IsNull() && !fromState.ManagedPubsub.IsUnknown() {
		if toStateManagedPubsub, ok := toState.GetManagedPubsub(ctx); ok {
			if fromStateManagedPubsub, ok := fromState.GetManagedPubsub(ctx); ok {
				toStateManagedPubsub.SyncFieldsDuringRead(ctx, fromStateManagedPubsub)
				toState.SetManagedPubsub(ctx, toStateManagedPubsub)
			}
		}
	}
	if !fromState.ManagedSqs.IsNull() && !fromState.ManagedSqs.IsUnknown() {
		if toStateManagedSqs, ok := toState.GetManagedSqs(ctx); ok {
			if fromStateManagedSqs, ok := fromState.GetManagedSqs(ctx); ok {
				toStateManagedSqs.SyncFieldsDuringRead(ctx, fromStateManagedSqs)
				toState.SetManagedSqs(ctx, toStateManagedSqs)
			}
		}
	}
	if !fromState.ProvidedAqs.IsNull() && !fromState.ProvidedAqs.IsUnknown() {
		if toStateProvidedAqs, ok := toState.GetProvidedAqs(ctx); ok {
			if fromStateProvidedAqs, ok := fromState.GetProvidedAqs(ctx); ok {
				toStateProvidedAqs.SyncFieldsDuringRead(ctx, fromStateProvidedAqs)
				toState.SetProvidedAqs(ctx, toStateProvidedAqs)
			}
		}
	}
	if !fromState.ProvidedPubsub.IsNull() && !fromState.ProvidedPubsub.IsUnknown() {
		if toStateProvidedPubsub, ok := toState.GetProvidedPubsub(ctx); ok {
			if fromStateProvidedPubsub, ok := fromState.GetProvidedPubsub(ctx); ok {
				toStateProvidedPubsub.SyncFieldsDuringRead(ctx, fromStateProvidedPubsub)
				toState.SetProvidedPubsub(ctx, toStateProvidedPubsub)
			}
		}
	}
	if !fromState.ProvidedSqs.IsNull() && !fromState.ProvidedSqs.IsUnknown() {
		if toStateProvidedSqs, ok := toState.GetProvidedSqs(ctx); ok {
			if fromStateProvidedSqs, ok := fromState.GetProvidedSqs(ctx); ok {
				toStateProvidedSqs.SyncFieldsDuringRead(ctx, fromStateProvidedSqs)
				toState.SetProvidedSqs(ctx, toStateProvidedSqs)
			}
		}
	}
}

func (c FileEventQueue) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_aqs"] = attrs["managed_aqs"].SetOptional()
	attrs["managed_pubsub"] = attrs["managed_pubsub"].SetOptional()
	attrs["managed_sqs"] = attrs["managed_sqs"].SetOptional()
	attrs["provided_aqs"] = attrs["provided_aqs"].SetOptional()
	attrs["provided_pubsub"] = attrs["provided_pubsub"].SetOptional()
	attrs["provided_sqs"] = attrs["provided_sqs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FileEventQueue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FileEventQueue) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"managed_aqs":     reflect.TypeOf(AzureQueueStorage{}),
		"managed_pubsub":  reflect.TypeOf(GcpPubsub{}),
		"managed_sqs":     reflect.TypeOf(AwsSqsQueue{}),
		"provided_aqs":    reflect.TypeOf(AzureQueueStorage{}),
		"provided_pubsub": reflect.TypeOf(GcpPubsub{}),
		"provided_sqs":    reflect.TypeOf(AwsSqsQueue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FileEventQueue
// only implements ToObjectValue() and Type().
func (o FileEventQueue) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_aqs":     o.ManagedAqs,
			"managed_pubsub":  o.ManagedPubsub,
			"managed_sqs":     o.ManagedSqs,
			"provided_aqs":    o.ProvidedAqs,
			"provided_pubsub": o.ProvidedPubsub,
			"provided_sqs":    o.ProvidedSqs,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FileEventQueue) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_aqs":     AzureQueueStorage{}.Type(ctx),
			"managed_pubsub":  GcpPubsub{}.Type(ctx),
			"managed_sqs":     AwsSqsQueue{}.Type(ctx),
			"provided_aqs":    AzureQueueStorage{}.Type(ctx),
			"provided_pubsub": GcpPubsub{}.Type(ctx),
			"provided_sqs":    AwsSqsQueue{}.Type(ctx),
		},
	}
}

// GetManagedAqs returns the value of the ManagedAqs field in FileEventQueue as
// a AzureQueueStorage value.
// If the field is unknown or null, the boolean return value is false.
func (o *FileEventQueue) GetManagedAqs(ctx context.Context) (AzureQueueStorage, bool) {
	var e AzureQueueStorage
	if o.ManagedAqs.IsNull() || o.ManagedAqs.IsUnknown() {
		return e, false
	}
	var v AzureQueueStorage
	d := o.ManagedAqs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetManagedAqs sets the value of the ManagedAqs field in FileEventQueue.
func (o *FileEventQueue) SetManagedAqs(ctx context.Context, v AzureQueueStorage) {
	vs := v.ToObjectValue(ctx)
	o.ManagedAqs = vs
}

// GetManagedPubsub returns the value of the ManagedPubsub field in FileEventQueue as
// a GcpPubsub value.
// If the field is unknown or null, the boolean return value is false.
func (o *FileEventQueue) GetManagedPubsub(ctx context.Context) (GcpPubsub, bool) {
	var e GcpPubsub
	if o.ManagedPubsub.IsNull() || o.ManagedPubsub.IsUnknown() {
		return e, false
	}
	var v GcpPubsub
	d := o.ManagedPubsub.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetManagedPubsub sets the value of the ManagedPubsub field in FileEventQueue.
func (o *FileEventQueue) SetManagedPubsub(ctx context.Context, v GcpPubsub) {
	vs := v.ToObjectValue(ctx)
	o.ManagedPubsub = vs
}

// GetManagedSqs returns the value of the ManagedSqs field in FileEventQueue as
// a AwsSqsQueue value.
// If the field is unknown or null, the boolean return value is false.
func (o *FileEventQueue) GetManagedSqs(ctx context.Context) (AwsSqsQueue, bool) {
	var e AwsSqsQueue
	if o.ManagedSqs.IsNull() || o.ManagedSqs.IsUnknown() {
		return e, false
	}
	var v AwsSqsQueue
	d := o.ManagedSqs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetManagedSqs sets the value of the ManagedSqs field in FileEventQueue.
func (o *FileEventQueue) SetManagedSqs(ctx context.Context, v AwsSqsQueue) {
	vs := v.ToObjectValue(ctx)
	o.ManagedSqs = vs
}

// GetProvidedAqs returns the value of the ProvidedAqs field in FileEventQueue as
// a AzureQueueStorage value.
// If the field is unknown or null, the boolean return value is false.
func (o *FileEventQueue) GetProvidedAqs(ctx context.Context) (AzureQueueStorage, bool) {
	var e AzureQueueStorage
	if o.ProvidedAqs.IsNull() || o.ProvidedAqs.IsUnknown() {
		return e, false
	}
	var v AzureQueueStorage
	d := o.ProvidedAqs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProvidedAqs sets the value of the ProvidedAqs field in FileEventQueue.
func (o *FileEventQueue) SetProvidedAqs(ctx context.Context, v AzureQueueStorage) {
	vs := v.ToObjectValue(ctx)
	o.ProvidedAqs = vs
}

// GetProvidedPubsub returns the value of the ProvidedPubsub field in FileEventQueue as
// a GcpPubsub value.
// If the field is unknown or null, the boolean return value is false.
func (o *FileEventQueue) GetProvidedPubsub(ctx context.Context) (GcpPubsub, bool) {
	var e GcpPubsub
	if o.ProvidedPubsub.IsNull() || o.ProvidedPubsub.IsUnknown() {
		return e, false
	}
	var v GcpPubsub
	d := o.ProvidedPubsub.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProvidedPubsub sets the value of the ProvidedPubsub field in FileEventQueue.
func (o *FileEventQueue) SetProvidedPubsub(ctx context.Context, v GcpPubsub) {
	vs := v.ToObjectValue(ctx)
	o.ProvidedPubsub = vs
}

// GetProvidedSqs returns the value of the ProvidedSqs field in FileEventQueue as
// a AwsSqsQueue value.
// If the field is unknown or null, the boolean return value is false.
func (o *FileEventQueue) GetProvidedSqs(ctx context.Context) (AwsSqsQueue, bool) {
	var e AwsSqsQueue
	if o.ProvidedSqs.IsNull() || o.ProvidedSqs.IsUnknown() {
		return e, false
	}
	var v AwsSqsQueue
	d := o.ProvidedSqs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProvidedSqs sets the value of the ProvidedSqs field in FileEventQueue.
func (o *FileEventQueue) SetProvidedSqs(ctx context.Context, v AwsSqsQueue) {
	vs := v.ToObjectValue(ctx)
	o.ProvidedSqs = vs
}

type ForeignKeyConstraint struct {
	// Column names for this constraint.
	ChildColumns types.List `tfsdk:"child_columns"`
	// The name of the constraint.
	Name types.String `tfsdk:"name"`
	// Column names for this constraint.
	ParentColumns types.List `tfsdk:"parent_columns"`
	// The full name of the parent constraint.
	ParentTable types.String `tfsdk:"parent_table"`
	// True if the constraint is RELY, false or unset if NORELY.
	Rely types.Bool `tfsdk:"rely"`
}

func (toState *ForeignKeyConstraint) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ForeignKeyConstraint) {
}

func (toState *ForeignKeyConstraint) SyncFieldsDuringRead(ctx context.Context, fromState ForeignKeyConstraint) {
}

func (c ForeignKeyConstraint) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["child_columns"] = attrs["child_columns"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["parent_columns"] = attrs["parent_columns"].SetRequired()
	attrs["parent_table"] = attrs["parent_table"].SetRequired()
	attrs["rely"] = attrs["rely"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForeignKeyConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ForeignKeyConstraint) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"child_columns":  reflect.TypeOf(types.String{}),
		"parent_columns": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForeignKeyConstraint
// only implements ToObjectValue() and Type().
func (o ForeignKeyConstraint) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"child_columns":  o.ChildColumns,
			"name":           o.Name,
			"parent_columns": o.ParentColumns,
			"parent_table":   o.ParentTable,
			"rely":           o.Rely,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ForeignKeyConstraint) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"child_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": types.StringType,
			"parent_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"parent_table": types.StringType,
			"rely":         types.BoolType,
		},
	}
}

// GetChildColumns returns the value of the ChildColumns field in ForeignKeyConstraint as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ForeignKeyConstraint) GetChildColumns(ctx context.Context) ([]types.String, bool) {
	if o.ChildColumns.IsNull() || o.ChildColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.ChildColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetChildColumns sets the value of the ChildColumns field in ForeignKeyConstraint.
func (o *ForeignKeyConstraint) SetChildColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["child_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ChildColumns = types.ListValueMust(t, vs)
}

// GetParentColumns returns the value of the ParentColumns field in ForeignKeyConstraint as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ForeignKeyConstraint) GetParentColumns(ctx context.Context) ([]types.String, bool) {
	if o.ParentColumns.IsNull() || o.ParentColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.ParentColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParentColumns sets the value of the ParentColumns field in ForeignKeyConstraint.
func (o *ForeignKeyConstraint) SetParentColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["parent_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ParentColumns = types.ListValueMust(t, vs)
}

type FunctionArgument struct {
	// The alias of a matched column.
	Alias types.String `tfsdk:"alias"`
	// A constant literal.
	Constant types.String `tfsdk:"constant"`
}

func (toState *FunctionArgument) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FunctionArgument) {
}

func (toState *FunctionArgument) SyncFieldsDuringRead(ctx context.Context, fromState FunctionArgument) {
}

func (c FunctionArgument) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias"] = attrs["alias"].SetOptional()
	attrs["constant"] = attrs["constant"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionArgument.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FunctionArgument) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionArgument
// only implements ToObjectValue() and Type().
func (o FunctionArgument) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":    o.Alias,
			"constant": o.Constant,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FunctionArgument) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":    types.StringType,
			"constant": types.StringType,
		},
	}
}

// A function that is dependent on a SQL object.
type FunctionDependency struct {
	// Full name of the dependent function, in the form of
	// __catalog_name__.__schema_name__.__function_name__.
	FunctionFullName types.String `tfsdk:"function_full_name"`
}

func (toState *FunctionDependency) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FunctionDependency) {
}

func (toState *FunctionDependency) SyncFieldsDuringRead(ctx context.Context, fromState FunctionDependency) {
}

func (c FunctionDependency) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_full_name"] = attrs["function_full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FunctionDependency) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionDependency
// only implements ToObjectValue() and Type().
func (o FunctionDependency) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_full_name": o.FunctionFullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FunctionDependency) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_full_name": types.StringType,
		},
	}
}

type FunctionInfo struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this function was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of function creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Scalar function return data type.
	DataType types.String `tfsdk:"data_type"`
	// External function language.
	ExternalLanguage types.String `tfsdk:"external_language"`
	// External function name.
	ExternalName types.String `tfsdk:"external_name"`
	// Pretty printed function data type.
	FullDataType types.String `tfsdk:"full_data_type"`
	// Full name of function, in form of
	// __catalog_name__.__schema_name__.__function__name__
	FullName types.String `tfsdk:"full_name"`
	// Id of Function, relative to parent schema.
	FunctionId types.String `tfsdk:"function_id"`

	InputParams types.Object `tfsdk:"input_params"`
	// Whether the function is deterministic.
	IsDeterministic types.Bool `tfsdk:"is_deterministic"`
	// Function null call.
	IsNullCall types.Bool `tfsdk:"is_null_call"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of function, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// Username of current owner of function.
	Owner types.String `tfsdk:"owner"`
	// Function parameter style. **S** is the value for SQL.
	ParameterStyle types.String `tfsdk:"parameter_style"`
	// JSON-serialized key-value pair map, encoded (escaped) as a string.
	Properties types.String `tfsdk:"properties"`
	// Table function return parameters.
	ReturnParams types.Object `tfsdk:"return_params"`
	// Function language. When **EXTERNAL** is used, the language of the routine
	// function should be specified in the __external_language__ field, and the
	// __return_params__ of the function cannot be used (as **TABLE** return
	// type is not supported), and the __sql_data_access__ field must be
	// **NO_SQL**.
	RoutineBody types.String `tfsdk:"routine_body"`
	// Function body.
	RoutineDefinition types.String `tfsdk:"routine_definition"`
	// Function dependencies.
	RoutineDependencies types.Object `tfsdk:"routine_dependencies"`
	// Name of parent schema relative to its parent catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// Function security type.
	SecurityType types.String `tfsdk:"security_type"`
	// Specific name of the function; Reserved for future use.
	SpecificName types.String `tfsdk:"specific_name"`
	// Function SQL data access.
	SqlDataAccess types.String `tfsdk:"sql_data_access"`
	// List of schemes whose objects can be referenced without qualification.
	SqlPath types.String `tfsdk:"sql_path"`
	// Time at which this function was created, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified function.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (toState *FunctionInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FunctionInfo) {
	if !fromPlan.InputParams.IsNull() && !fromPlan.InputParams.IsUnknown() {
		if toStateInputParams, ok := toState.GetInputParams(ctx); ok {
			if fromPlanInputParams, ok := fromPlan.GetInputParams(ctx); ok {
				toStateInputParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInputParams)
				toState.SetInputParams(ctx, toStateInputParams)
			}
		}
	}
	if !fromPlan.ReturnParams.IsNull() && !fromPlan.ReturnParams.IsUnknown() {
		if toStateReturnParams, ok := toState.GetReturnParams(ctx); ok {
			if fromPlanReturnParams, ok := fromPlan.GetReturnParams(ctx); ok {
				toStateReturnParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanReturnParams)
				toState.SetReturnParams(ctx, toStateReturnParams)
			}
		}
	}
	if !fromPlan.RoutineDependencies.IsNull() && !fromPlan.RoutineDependencies.IsUnknown() {
		if toStateRoutineDependencies, ok := toState.GetRoutineDependencies(ctx); ok {
			if fromPlanRoutineDependencies, ok := fromPlan.GetRoutineDependencies(ctx); ok {
				toStateRoutineDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanRoutineDependencies)
				toState.SetRoutineDependencies(ctx, toStateRoutineDependencies)
			}
		}
	}
}

func (toState *FunctionInfo) SyncFieldsDuringRead(ctx context.Context, fromState FunctionInfo) {
	if !fromState.InputParams.IsNull() && !fromState.InputParams.IsUnknown() {
		if toStateInputParams, ok := toState.GetInputParams(ctx); ok {
			if fromStateInputParams, ok := fromState.GetInputParams(ctx); ok {
				toStateInputParams.SyncFieldsDuringRead(ctx, fromStateInputParams)
				toState.SetInputParams(ctx, toStateInputParams)
			}
		}
	}
	if !fromState.ReturnParams.IsNull() && !fromState.ReturnParams.IsUnknown() {
		if toStateReturnParams, ok := toState.GetReturnParams(ctx); ok {
			if fromStateReturnParams, ok := fromState.GetReturnParams(ctx); ok {
				toStateReturnParams.SyncFieldsDuringRead(ctx, fromStateReturnParams)
				toState.SetReturnParams(ctx, toStateReturnParams)
			}
		}
	}
	if !fromState.RoutineDependencies.IsNull() && !fromState.RoutineDependencies.IsUnknown() {
		if toStateRoutineDependencies, ok := toState.GetRoutineDependencies(ctx); ok {
			if fromStateRoutineDependencies, ok := fromState.GetRoutineDependencies(ctx); ok {
				toStateRoutineDependencies.SyncFieldsDuringRead(ctx, fromStateRoutineDependencies)
				toState.SetRoutineDependencies(ctx, toStateRoutineDependencies)
			}
		}
	}
}

func (c FunctionInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["data_type"] = attrs["data_type"].SetOptional()
	attrs["external_language"] = attrs["external_language"].SetOptional()
	attrs["external_name"] = attrs["external_name"].SetOptional()
	attrs["full_data_type"] = attrs["full_data_type"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["function_id"] = attrs["function_id"].SetOptional()
	attrs["input_params"] = attrs["input_params"].SetOptional()
	attrs["is_deterministic"] = attrs["is_deterministic"].SetOptional()
	attrs["is_null_call"] = attrs["is_null_call"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["parameter_style"] = attrs["parameter_style"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["return_params"] = attrs["return_params"].SetOptional()
	attrs["routine_body"] = attrs["routine_body"].SetOptional()
	attrs["routine_definition"] = attrs["routine_definition"].SetOptional()
	attrs["routine_dependencies"] = attrs["routine_dependencies"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["security_type"] = attrs["security_type"].SetOptional()
	attrs["specific_name"] = attrs["specific_name"].SetOptional()
	attrs["sql_data_access"] = attrs["sql_data_access"].SetOptional()
	attrs["sql_path"] = attrs["sql_path"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FunctionInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_params":         reflect.TypeOf(FunctionParameterInfos{}),
		"return_params":        reflect.TypeOf(FunctionParameterInfos{}),
		"routine_dependencies": reflect.TypeOf(DependencyList{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionInfo
// only implements ToObjectValue() and Type().
func (o FunctionInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":          o.BrowseOnly,
			"catalog_name":         o.CatalogName,
			"comment":              o.Comment,
			"created_at":           o.CreatedAt,
			"created_by":           o.CreatedBy,
			"data_type":            o.DataType,
			"external_language":    o.ExternalLanguage,
			"external_name":        o.ExternalName,
			"full_data_type":       o.FullDataType,
			"full_name":            o.FullName,
			"function_id":          o.FunctionId,
			"input_params":         o.InputParams,
			"is_deterministic":     o.IsDeterministic,
			"is_null_call":         o.IsNullCall,
			"metastore_id":         o.MetastoreId,
			"name":                 o.Name,
			"owner":                o.Owner,
			"parameter_style":      o.ParameterStyle,
			"properties":           o.Properties,
			"return_params":        o.ReturnParams,
			"routine_body":         o.RoutineBody,
			"routine_definition":   o.RoutineDefinition,
			"routine_dependencies": o.RoutineDependencies,
			"schema_name":          o.SchemaName,
			"security_type":        o.SecurityType,
			"specific_name":        o.SpecificName,
			"sql_data_access":      o.SqlDataAccess,
			"sql_path":             o.SqlPath,
			"updated_at":           o.UpdatedAt,
			"updated_by":           o.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FunctionInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":          types.BoolType,
			"catalog_name":         types.StringType,
			"comment":              types.StringType,
			"created_at":           types.Int64Type,
			"created_by":           types.StringType,
			"data_type":            types.StringType,
			"external_language":    types.StringType,
			"external_name":        types.StringType,
			"full_data_type":       types.StringType,
			"full_name":            types.StringType,
			"function_id":          types.StringType,
			"input_params":         FunctionParameterInfos{}.Type(ctx),
			"is_deterministic":     types.BoolType,
			"is_null_call":         types.BoolType,
			"metastore_id":         types.StringType,
			"name":                 types.StringType,
			"owner":                types.StringType,
			"parameter_style":      types.StringType,
			"properties":           types.StringType,
			"return_params":        FunctionParameterInfos{}.Type(ctx),
			"routine_body":         types.StringType,
			"routine_definition":   types.StringType,
			"routine_dependencies": DependencyList{}.Type(ctx),
			"schema_name":          types.StringType,
			"security_type":        types.StringType,
			"specific_name":        types.StringType,
			"sql_data_access":      types.StringType,
			"sql_path":             types.StringType,
			"updated_at":           types.Int64Type,
			"updated_by":           types.StringType,
		},
	}
}

// GetInputParams returns the value of the InputParams field in FunctionInfo as
// a FunctionParameterInfos value.
// If the field is unknown or null, the boolean return value is false.
func (o *FunctionInfo) GetInputParams(ctx context.Context) (FunctionParameterInfos, bool) {
	var e FunctionParameterInfos
	if o.InputParams.IsNull() || o.InputParams.IsUnknown() {
		return e, false
	}
	var v FunctionParameterInfos
	d := o.InputParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInputParams sets the value of the InputParams field in FunctionInfo.
func (o *FunctionInfo) SetInputParams(ctx context.Context, v FunctionParameterInfos) {
	vs := v.ToObjectValue(ctx)
	o.InputParams = vs
}

// GetReturnParams returns the value of the ReturnParams field in FunctionInfo as
// a FunctionParameterInfos value.
// If the field is unknown or null, the boolean return value is false.
func (o *FunctionInfo) GetReturnParams(ctx context.Context) (FunctionParameterInfos, bool) {
	var e FunctionParameterInfos
	if o.ReturnParams.IsNull() || o.ReturnParams.IsUnknown() {
		return e, false
	}
	var v FunctionParameterInfos
	d := o.ReturnParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetReturnParams sets the value of the ReturnParams field in FunctionInfo.
func (o *FunctionInfo) SetReturnParams(ctx context.Context, v FunctionParameterInfos) {
	vs := v.ToObjectValue(ctx)
	o.ReturnParams = vs
}

// GetRoutineDependencies returns the value of the RoutineDependencies field in FunctionInfo as
// a DependencyList value.
// If the field is unknown or null, the boolean return value is false.
func (o *FunctionInfo) GetRoutineDependencies(ctx context.Context) (DependencyList, bool) {
	var e DependencyList
	if o.RoutineDependencies.IsNull() || o.RoutineDependencies.IsUnknown() {
		return e, false
	}
	var v DependencyList
	d := o.RoutineDependencies.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoutineDependencies sets the value of the RoutineDependencies field in FunctionInfo.
func (o *FunctionInfo) SetRoutineDependencies(ctx context.Context, v DependencyList) {
	vs := v.ToObjectValue(ctx)
	o.RoutineDependencies = vs
}

type FunctionParameterInfo struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of parameter.
	Name types.String `tfsdk:"name"`
	// Default value of the parameter.
	ParameterDefault types.String `tfsdk:"parameter_default"`

	ParameterMode types.String `tfsdk:"parameter_mode"`

	ParameterType types.String `tfsdk:"parameter_type"`
	// Ordinal position of column (starting at position 0).
	Position types.Int64 `tfsdk:"position"`
	// Format of IntervalType.
	TypeIntervalType types.String `tfsdk:"type_interval_type"`
	// Full data type spec, JSON-serialized.
	TypeJson types.String `tfsdk:"type_json"`

	TypeName types.String `tfsdk:"type_name"`
	// Digits of precision; required on Create for DecimalTypes.
	TypePrecision types.Int64 `tfsdk:"type_precision"`
	// Digits to right of decimal; Required on Create for DecimalTypes.
	TypeScale types.Int64 `tfsdk:"type_scale"`
	// Full data type spec, SQL/catalogString text.
	TypeText types.String `tfsdk:"type_text"`
}

func (toState *FunctionParameterInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FunctionParameterInfo) {
}

func (toState *FunctionParameterInfo) SyncFieldsDuringRead(ctx context.Context, fromState FunctionParameterInfo) {
}

func (c FunctionParameterInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["parameter_default"] = attrs["parameter_default"].SetOptional()
	attrs["parameter_mode"] = attrs["parameter_mode"].SetOptional()
	attrs["parameter_type"] = attrs["parameter_type"].SetOptional()
	attrs["position"] = attrs["position"].SetRequired()
	attrs["type_interval_type"] = attrs["type_interval_type"].SetOptional()
	attrs["type_json"] = attrs["type_json"].SetOptional()
	attrs["type_name"] = attrs["type_name"].SetRequired()
	attrs["type_precision"] = attrs["type_precision"].SetOptional()
	attrs["type_scale"] = attrs["type_scale"].SetOptional()
	attrs["type_text"] = attrs["type_text"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionParameterInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FunctionParameterInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionParameterInfo
// only implements ToObjectValue() and Type().
func (o FunctionParameterInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            o.Comment,
			"name":               o.Name,
			"parameter_default":  o.ParameterDefault,
			"parameter_mode":     o.ParameterMode,
			"parameter_type":     o.ParameterType,
			"position":           o.Position,
			"type_interval_type": o.TypeIntervalType,
			"type_json":          o.TypeJson,
			"type_name":          o.TypeName,
			"type_precision":     o.TypePrecision,
			"type_scale":         o.TypeScale,
			"type_text":          o.TypeText,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FunctionParameterInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"name":               types.StringType,
			"parameter_default":  types.StringType,
			"parameter_mode":     types.StringType,
			"parameter_type":     types.StringType,
			"position":           types.Int64Type,
			"type_interval_type": types.StringType,
			"type_json":          types.StringType,
			"type_name":          types.StringType,
			"type_precision":     types.Int64Type,
			"type_scale":         types.Int64Type,
			"type_text":          types.StringType,
		},
	}
}

type FunctionParameterInfos struct {
	// The array of __FunctionParameterInfo__ definitions of the function's
	// parameters.
	Parameters types.List `tfsdk:"parameters"`
}

func (toState *FunctionParameterInfos) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan FunctionParameterInfos) {
}

func (toState *FunctionParameterInfos) SyncFieldsDuringRead(ctx context.Context, fromState FunctionParameterInfos) {
}

func (c FunctionParameterInfos) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FunctionParameterInfos.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a FunctionParameterInfos) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(FunctionParameterInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FunctionParameterInfos
// only implements ToObjectValue() and Type().
func (o FunctionParameterInfos) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": o.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (o FunctionParameterInfos) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: FunctionParameterInfo{}.Type(ctx),
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in FunctionParameterInfos as
// a slice of FunctionParameterInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *FunctionParameterInfos) GetParameters(ctx context.Context) ([]FunctionParameterInfo, bool) {
	if o.Parameters.IsNull() || o.Parameters.IsUnknown() {
		return nil, false
	}
	var v []FunctionParameterInfo
	d := o.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in FunctionParameterInfos.
func (o *FunctionParameterInfos) SetParameters(ctx context.Context, v []FunctionParameterInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Parameters = types.ListValueMust(t, vs)
}

// GCP temporary credentials for API authentication. Read more at
// https://developers.google.com/identity/protocols/oauth2/service-account
type GcpOauthToken struct {
	OauthToken types.String `tfsdk:"oauth_token"`
}

func (toState *GcpOauthToken) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GcpOauthToken) {
}

func (toState *GcpOauthToken) SyncFieldsDuringRead(ctx context.Context, fromState GcpOauthToken) {
}

func (c GcpOauthToken) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["oauth_token"] = attrs["oauth_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GcpOauthToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GcpOauthToken) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GcpOauthToken
// only implements ToObjectValue() and Type().
func (o GcpOauthToken) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"oauth_token": o.OauthToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GcpOauthToken) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"oauth_token": types.StringType,
		},
	}
}

type GcpPubsub struct {
	// Unique identifier included in the name of file events managed cloud
	// resources.
	ManagedResourceId types.String `tfsdk:"managed_resource_id"`
	// The Pub/Sub subscription name in the format
	// projects/{project}/subscriptions/{subscription name} Required for
	// provided_pubsub.
	SubscriptionName types.String `tfsdk:"subscription_name"`
}

func (toState *GcpPubsub) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GcpPubsub) {
}

func (toState *GcpPubsub) SyncFieldsDuringRead(ctx context.Context, fromState GcpPubsub) {
}

func (c GcpPubsub) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["managed_resource_id"] = attrs["managed_resource_id"].SetComputed()
	attrs["subscription_name"] = attrs["subscription_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GcpPubsub.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GcpPubsub) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GcpPubsub
// only implements ToObjectValue() and Type().
func (o GcpPubsub) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"managed_resource_id": o.ManagedResourceId,
			"subscription_name":   o.SubscriptionName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GcpPubsub) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"managed_resource_id": types.StringType,
			"subscription_name":   types.StringType,
		},
	}
}

type GenerateTemporaryPathCredentialRequest struct {
	// Optional. When set to true, the service will not validate that the
	// generated credentials can perform write operations, therefore no new
	// paths will be created and the response will not contain valid
	// credentials. Defaults to false.
	DryRun types.Bool `tfsdk:"dry_run"`
	// The operation being performed on the path.
	Operation types.String `tfsdk:"operation"`
	// URL for path-based access.
	Url types.String `tfsdk:"url"`
}

func (toState *GenerateTemporaryPathCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryPathCredentialRequest) {
}

func (toState *GenerateTemporaryPathCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryPathCredentialRequest) {
}

func (c GenerateTemporaryPathCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dry_run"] = attrs["dry_run"].SetOptional()
	attrs["operation"] = attrs["operation"].SetRequired()
	attrs["url"] = attrs["url"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryPathCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryPathCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryPathCredentialRequest
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryPathCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dry_run":   o.DryRun,
			"operation": o.Operation,
			"url":       o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryPathCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dry_run":   types.BoolType,
			"operation": types.StringType,
			"url":       types.StringType,
		},
	}
}

type GenerateTemporaryPathCredentialResponse struct {
	AwsTempCredentials types.Object `tfsdk:"aws_temp_credentials"`

	AzureAad types.Object `tfsdk:"azure_aad"`

	AzureUserDelegationSas types.Object `tfsdk:"azure_user_delegation_sas"`
	// Server time when the credential will expire, in epoch milliseconds. The
	// API client is advised to cache the credential given this expiration time.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	GcpOauthToken types.Object `tfsdk:"gcp_oauth_token"`

	R2TempCredentials types.Object `tfsdk:"r2_temp_credentials"`
	// The URL of the storage path accessible by the temporary credential.
	Url types.String `tfsdk:"url"`
}

func (toState *GenerateTemporaryPathCredentialResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryPathCredentialResponse) {
	if !fromPlan.AwsTempCredentials.IsNull() && !fromPlan.AwsTempCredentials.IsUnknown() {
		if toStateAwsTempCredentials, ok := toState.GetAwsTempCredentials(ctx); ok {
			if fromPlanAwsTempCredentials, ok := fromPlan.GetAwsTempCredentials(ctx); ok {
				toStateAwsTempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsTempCredentials)
				toState.SetAwsTempCredentials(ctx, toStateAwsTempCredentials)
			}
		}
	}
	if !fromPlan.AzureAad.IsNull() && !fromPlan.AzureAad.IsUnknown() {
		if toStateAzureAad, ok := toState.GetAzureAad(ctx); ok {
			if fromPlanAzureAad, ok := fromPlan.GetAzureAad(ctx); ok {
				toStateAzureAad.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureAad)
				toState.SetAzureAad(ctx, toStateAzureAad)
			}
		}
	}
	if !fromPlan.AzureUserDelegationSas.IsNull() && !fromPlan.AzureUserDelegationSas.IsUnknown() {
		if toStateAzureUserDelegationSas, ok := toState.GetAzureUserDelegationSas(ctx); ok {
			if fromPlanAzureUserDelegationSas, ok := fromPlan.GetAzureUserDelegationSas(ctx); ok {
				toStateAzureUserDelegationSas.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureUserDelegationSas)
				toState.SetAzureUserDelegationSas(ctx, toStateAzureUserDelegationSas)
			}
		}
	}
	if !fromPlan.GcpOauthToken.IsNull() && !fromPlan.GcpOauthToken.IsUnknown() {
		if toStateGcpOauthToken, ok := toState.GetGcpOauthToken(ctx); ok {
			if fromPlanGcpOauthToken, ok := fromPlan.GetGcpOauthToken(ctx); ok {
				toStateGcpOauthToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanGcpOauthToken)
				toState.SetGcpOauthToken(ctx, toStateGcpOauthToken)
			}
		}
	}
	if !fromPlan.R2TempCredentials.IsNull() && !fromPlan.R2TempCredentials.IsUnknown() {
		if toStateR2TempCredentials, ok := toState.GetR2TempCredentials(ctx); ok {
			if fromPlanR2TempCredentials, ok := fromPlan.GetR2TempCredentials(ctx); ok {
				toStateR2TempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanR2TempCredentials)
				toState.SetR2TempCredentials(ctx, toStateR2TempCredentials)
			}
		}
	}
}

func (toState *GenerateTemporaryPathCredentialResponse) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryPathCredentialResponse) {
	if !fromState.AwsTempCredentials.IsNull() && !fromState.AwsTempCredentials.IsUnknown() {
		if toStateAwsTempCredentials, ok := toState.GetAwsTempCredentials(ctx); ok {
			if fromStateAwsTempCredentials, ok := fromState.GetAwsTempCredentials(ctx); ok {
				toStateAwsTempCredentials.SyncFieldsDuringRead(ctx, fromStateAwsTempCredentials)
				toState.SetAwsTempCredentials(ctx, toStateAwsTempCredentials)
			}
		}
	}
	if !fromState.AzureAad.IsNull() && !fromState.AzureAad.IsUnknown() {
		if toStateAzureAad, ok := toState.GetAzureAad(ctx); ok {
			if fromStateAzureAad, ok := fromState.GetAzureAad(ctx); ok {
				toStateAzureAad.SyncFieldsDuringRead(ctx, fromStateAzureAad)
				toState.SetAzureAad(ctx, toStateAzureAad)
			}
		}
	}
	if !fromState.AzureUserDelegationSas.IsNull() && !fromState.AzureUserDelegationSas.IsUnknown() {
		if toStateAzureUserDelegationSas, ok := toState.GetAzureUserDelegationSas(ctx); ok {
			if fromStateAzureUserDelegationSas, ok := fromState.GetAzureUserDelegationSas(ctx); ok {
				toStateAzureUserDelegationSas.SyncFieldsDuringRead(ctx, fromStateAzureUserDelegationSas)
				toState.SetAzureUserDelegationSas(ctx, toStateAzureUserDelegationSas)
			}
		}
	}
	if !fromState.GcpOauthToken.IsNull() && !fromState.GcpOauthToken.IsUnknown() {
		if toStateGcpOauthToken, ok := toState.GetGcpOauthToken(ctx); ok {
			if fromStateGcpOauthToken, ok := fromState.GetGcpOauthToken(ctx); ok {
				toStateGcpOauthToken.SyncFieldsDuringRead(ctx, fromStateGcpOauthToken)
				toState.SetGcpOauthToken(ctx, toStateGcpOauthToken)
			}
		}
	}
	if !fromState.R2TempCredentials.IsNull() && !fromState.R2TempCredentials.IsUnknown() {
		if toStateR2TempCredentials, ok := toState.GetR2TempCredentials(ctx); ok {
			if fromStateR2TempCredentials, ok := fromState.GetR2TempCredentials(ctx); ok {
				toStateR2TempCredentials.SyncFieldsDuringRead(ctx, fromStateR2TempCredentials)
				toState.SetR2TempCredentials(ctx, toStateR2TempCredentials)
			}
		}
	}
}

func (c GenerateTemporaryPathCredentialResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].SetOptional()
	attrs["azure_aad"] = attrs["azure_aad"].SetOptional()
	attrs["azure_user_delegation_sas"] = attrs["azure_user_delegation_sas"].SetOptional()
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].SetOptional()
	attrs["r2_temp_credentials"] = attrs["r2_temp_credentials"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryPathCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryPathCredentialResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_temp_credentials":      reflect.TypeOf(AwsCredentials{}),
		"azure_aad":                 reflect.TypeOf(AzureActiveDirectoryToken{}),
		"azure_user_delegation_sas": reflect.TypeOf(AzureUserDelegationSas{}),
		"gcp_oauth_token":           reflect.TypeOf(GcpOauthToken{}),
		"r2_temp_credentials":       reflect.TypeOf(R2Credentials{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryPathCredentialResponse
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryPathCredentialResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_temp_credentials":      o.AwsTempCredentials,
			"azure_aad":                 o.AzureAad,
			"azure_user_delegation_sas": o.AzureUserDelegationSas,
			"expiration_time":           o.ExpirationTime,
			"gcp_oauth_token":           o.GcpOauthToken,
			"r2_temp_credentials":       o.R2TempCredentials,
			"url":                       o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryPathCredentialResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_temp_credentials":      AwsCredentials{}.Type(ctx),
			"azure_aad":                 AzureActiveDirectoryToken{}.Type(ctx),
			"azure_user_delegation_sas": AzureUserDelegationSas{}.Type(ctx),
			"expiration_time":           types.Int64Type,
			"gcp_oauth_token":           GcpOauthToken{}.Type(ctx),
			"r2_temp_credentials":       R2Credentials{}.Type(ctx),
			"url":                       types.StringType,
		},
	}
}

// GetAwsTempCredentials returns the value of the AwsTempCredentials field in GenerateTemporaryPathCredentialResponse as
// a AwsCredentials value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryPathCredentialResponse) GetAwsTempCredentials(ctx context.Context) (AwsCredentials, bool) {
	var e AwsCredentials
	if o.AwsTempCredentials.IsNull() || o.AwsTempCredentials.IsUnknown() {
		return e, false
	}
	var v AwsCredentials
	d := o.AwsTempCredentials.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsTempCredentials sets the value of the AwsTempCredentials field in GenerateTemporaryPathCredentialResponse.
func (o *GenerateTemporaryPathCredentialResponse) SetAwsTempCredentials(ctx context.Context, v AwsCredentials) {
	vs := v.ToObjectValue(ctx)
	o.AwsTempCredentials = vs
}

// GetAzureAad returns the value of the AzureAad field in GenerateTemporaryPathCredentialResponse as
// a AzureActiveDirectoryToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryPathCredentialResponse) GetAzureAad(ctx context.Context) (AzureActiveDirectoryToken, bool) {
	var e AzureActiveDirectoryToken
	if o.AzureAad.IsNull() || o.AzureAad.IsUnknown() {
		return e, false
	}
	var v AzureActiveDirectoryToken
	d := o.AzureAad.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureAad sets the value of the AzureAad field in GenerateTemporaryPathCredentialResponse.
func (o *GenerateTemporaryPathCredentialResponse) SetAzureAad(ctx context.Context, v AzureActiveDirectoryToken) {
	vs := v.ToObjectValue(ctx)
	o.AzureAad = vs
}

// GetAzureUserDelegationSas returns the value of the AzureUserDelegationSas field in GenerateTemporaryPathCredentialResponse as
// a AzureUserDelegationSas value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryPathCredentialResponse) GetAzureUserDelegationSas(ctx context.Context) (AzureUserDelegationSas, bool) {
	var e AzureUserDelegationSas
	if o.AzureUserDelegationSas.IsNull() || o.AzureUserDelegationSas.IsUnknown() {
		return e, false
	}
	var v AzureUserDelegationSas
	d := o.AzureUserDelegationSas.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureUserDelegationSas sets the value of the AzureUserDelegationSas field in GenerateTemporaryPathCredentialResponse.
func (o *GenerateTemporaryPathCredentialResponse) SetAzureUserDelegationSas(ctx context.Context, v AzureUserDelegationSas) {
	vs := v.ToObjectValue(ctx)
	o.AzureUserDelegationSas = vs
}

// GetGcpOauthToken returns the value of the GcpOauthToken field in GenerateTemporaryPathCredentialResponse as
// a GcpOauthToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryPathCredentialResponse) GetGcpOauthToken(ctx context.Context) (GcpOauthToken, bool) {
	var e GcpOauthToken
	if o.GcpOauthToken.IsNull() || o.GcpOauthToken.IsUnknown() {
		return e, false
	}
	var v GcpOauthToken
	d := o.GcpOauthToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGcpOauthToken sets the value of the GcpOauthToken field in GenerateTemporaryPathCredentialResponse.
func (o *GenerateTemporaryPathCredentialResponse) SetGcpOauthToken(ctx context.Context, v GcpOauthToken) {
	vs := v.ToObjectValue(ctx)
	o.GcpOauthToken = vs
}

// GetR2TempCredentials returns the value of the R2TempCredentials field in GenerateTemporaryPathCredentialResponse as
// a R2Credentials value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryPathCredentialResponse) GetR2TempCredentials(ctx context.Context) (R2Credentials, bool) {
	var e R2Credentials
	if o.R2TempCredentials.IsNull() || o.R2TempCredentials.IsUnknown() {
		return e, false
	}
	var v R2Credentials
	d := o.R2TempCredentials.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetR2TempCredentials sets the value of the R2TempCredentials field in GenerateTemporaryPathCredentialResponse.
func (o *GenerateTemporaryPathCredentialResponse) SetR2TempCredentials(ctx context.Context, v R2Credentials) {
	vs := v.ToObjectValue(ctx)
	o.R2TempCredentials = vs
}

// The Azure cloud options to customize the requested temporary credential
type GenerateTemporaryServiceCredentialAzureOptions struct {
	// The resources to which the temporary Azure credential should apply. These
	// resources are the scopes that are passed to the token provider (see
	// https://learn.microsoft.com/python/api/azure-core/azure.core.credentials.tokencredential?view=azure-python)
	Resources types.List `tfsdk:"resources"`
}

func (toState *GenerateTemporaryServiceCredentialAzureOptions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryServiceCredentialAzureOptions) {
}

func (toState *GenerateTemporaryServiceCredentialAzureOptions) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryServiceCredentialAzureOptions) {
}

func (c GenerateTemporaryServiceCredentialAzureOptions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryServiceCredentialAzureOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryServiceCredentialAzureOptions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryServiceCredentialAzureOptions
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryServiceCredentialAzureOptions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"resources": o.Resources,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryServiceCredentialAzureOptions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"resources": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetResources returns the value of the Resources field in GenerateTemporaryServiceCredentialAzureOptions as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryServiceCredentialAzureOptions) GetResources(ctx context.Context) ([]types.String, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in GenerateTemporaryServiceCredentialAzureOptions.
func (o *GenerateTemporaryServiceCredentialAzureOptions) SetResources(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

// The GCP cloud options to customize the requested temporary credential
type GenerateTemporaryServiceCredentialGcpOptions struct {
	// The scopes to which the temporary GCP credential should apply. These
	// resources are the scopes that are passed to the token provider (see
	// https://google-auth.readthedocs.io/en/latest/reference/google.auth.html#google.auth.credentials.Credentials)
	Scopes types.List `tfsdk:"scopes"`
}

func (toState *GenerateTemporaryServiceCredentialGcpOptions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryServiceCredentialGcpOptions) {
}

func (toState *GenerateTemporaryServiceCredentialGcpOptions) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryServiceCredentialGcpOptions) {
}

func (c GenerateTemporaryServiceCredentialGcpOptions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["scopes"] = attrs["scopes"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryServiceCredentialGcpOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryServiceCredentialGcpOptions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"scopes": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryServiceCredentialGcpOptions
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryServiceCredentialGcpOptions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"scopes": o.Scopes,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryServiceCredentialGcpOptions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"scopes": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetScopes returns the value of the Scopes field in GenerateTemporaryServiceCredentialGcpOptions as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryServiceCredentialGcpOptions) GetScopes(ctx context.Context) ([]types.String, bool) {
	if o.Scopes.IsNull() || o.Scopes.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Scopes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetScopes sets the value of the Scopes field in GenerateTemporaryServiceCredentialGcpOptions.
func (o *GenerateTemporaryServiceCredentialGcpOptions) SetScopes(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["scopes"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Scopes = types.ListValueMust(t, vs)
}

type GenerateTemporaryServiceCredentialRequest struct {
	AzureOptions types.Object `tfsdk:"azure_options"`
	// The name of the service credential used to generate a temporary
	// credential
	CredentialName types.String `tfsdk:"credential_name"`

	GcpOptions types.Object `tfsdk:"gcp_options"`
}

func (toState *GenerateTemporaryServiceCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryServiceCredentialRequest) {
	if !fromPlan.AzureOptions.IsNull() && !fromPlan.AzureOptions.IsUnknown() {
		if toStateAzureOptions, ok := toState.GetAzureOptions(ctx); ok {
			if fromPlanAzureOptions, ok := fromPlan.GetAzureOptions(ctx); ok {
				toStateAzureOptions.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureOptions)
				toState.SetAzureOptions(ctx, toStateAzureOptions)
			}
		}
	}
	if !fromPlan.GcpOptions.IsNull() && !fromPlan.GcpOptions.IsUnknown() {
		if toStateGcpOptions, ok := toState.GetGcpOptions(ctx); ok {
			if fromPlanGcpOptions, ok := fromPlan.GetGcpOptions(ctx); ok {
				toStateGcpOptions.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanGcpOptions)
				toState.SetGcpOptions(ctx, toStateGcpOptions)
			}
		}
	}
}

func (toState *GenerateTemporaryServiceCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryServiceCredentialRequest) {
	if !fromState.AzureOptions.IsNull() && !fromState.AzureOptions.IsUnknown() {
		if toStateAzureOptions, ok := toState.GetAzureOptions(ctx); ok {
			if fromStateAzureOptions, ok := fromState.GetAzureOptions(ctx); ok {
				toStateAzureOptions.SyncFieldsDuringRead(ctx, fromStateAzureOptions)
				toState.SetAzureOptions(ctx, toStateAzureOptions)
			}
		}
	}
	if !fromState.GcpOptions.IsNull() && !fromState.GcpOptions.IsUnknown() {
		if toStateGcpOptions, ok := toState.GetGcpOptions(ctx); ok {
			if fromStateGcpOptions, ok := fromState.GetGcpOptions(ctx); ok {
				toStateGcpOptions.SyncFieldsDuringRead(ctx, fromStateGcpOptions)
				toState.SetGcpOptions(ctx, toStateGcpOptions)
			}
		}
	}
}

func (c GenerateTemporaryServiceCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["azure_options"] = attrs["azure_options"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetRequired()
	attrs["gcp_options"] = attrs["gcp_options"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryServiceCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryServiceCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"azure_options": reflect.TypeOf(GenerateTemporaryServiceCredentialAzureOptions{}),
		"gcp_options":   reflect.TypeOf(GenerateTemporaryServiceCredentialGcpOptions{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryServiceCredentialRequest
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryServiceCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"azure_options":   o.AzureOptions,
			"credential_name": o.CredentialName,
			"gcp_options":     o.GcpOptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryServiceCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"azure_options":   GenerateTemporaryServiceCredentialAzureOptions{}.Type(ctx),
			"credential_name": types.StringType,
			"gcp_options":     GenerateTemporaryServiceCredentialGcpOptions{}.Type(ctx),
		},
	}
}

// GetAzureOptions returns the value of the AzureOptions field in GenerateTemporaryServiceCredentialRequest as
// a GenerateTemporaryServiceCredentialAzureOptions value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryServiceCredentialRequest) GetAzureOptions(ctx context.Context) (GenerateTemporaryServiceCredentialAzureOptions, bool) {
	var e GenerateTemporaryServiceCredentialAzureOptions
	if o.AzureOptions.IsNull() || o.AzureOptions.IsUnknown() {
		return e, false
	}
	var v GenerateTemporaryServiceCredentialAzureOptions
	d := o.AzureOptions.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureOptions sets the value of the AzureOptions field in GenerateTemporaryServiceCredentialRequest.
func (o *GenerateTemporaryServiceCredentialRequest) SetAzureOptions(ctx context.Context, v GenerateTemporaryServiceCredentialAzureOptions) {
	vs := v.ToObjectValue(ctx)
	o.AzureOptions = vs
}

// GetGcpOptions returns the value of the GcpOptions field in GenerateTemporaryServiceCredentialRequest as
// a GenerateTemporaryServiceCredentialGcpOptions value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryServiceCredentialRequest) GetGcpOptions(ctx context.Context) (GenerateTemporaryServiceCredentialGcpOptions, bool) {
	var e GenerateTemporaryServiceCredentialGcpOptions
	if o.GcpOptions.IsNull() || o.GcpOptions.IsUnknown() {
		return e, false
	}
	var v GenerateTemporaryServiceCredentialGcpOptions
	d := o.GcpOptions.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGcpOptions sets the value of the GcpOptions field in GenerateTemporaryServiceCredentialRequest.
func (o *GenerateTemporaryServiceCredentialRequest) SetGcpOptions(ctx context.Context, v GenerateTemporaryServiceCredentialGcpOptions) {
	vs := v.ToObjectValue(ctx)
	o.GcpOptions = vs
}

type GenerateTemporaryTableCredentialRequest struct {
	// The operation performed against the table data, either READ or
	// READ_WRITE. If READ_WRITE is specified, the credentials returned will
	// have write permissions, otherwise, it will be read only.
	Operation types.String `tfsdk:"operation"`
	// UUID of the table to read or write.
	TableId types.String `tfsdk:"table_id"`
}

func (toState *GenerateTemporaryTableCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryTableCredentialRequest) {
}

func (toState *GenerateTemporaryTableCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryTableCredentialRequest) {
}

func (c GenerateTemporaryTableCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operation"] = attrs["operation"].SetOptional()
	attrs["table_id"] = attrs["table_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryTableCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryTableCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryTableCredentialRequest
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryTableCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"operation": o.Operation,
			"table_id":  o.TableId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryTableCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"operation": types.StringType,
			"table_id":  types.StringType,
		},
	}
}

type GenerateTemporaryTableCredentialResponse struct {
	AwsTempCredentials types.Object `tfsdk:"aws_temp_credentials"`

	AzureAad types.Object `tfsdk:"azure_aad"`

	AzureUserDelegationSas types.Object `tfsdk:"azure_user_delegation_sas"`
	// Server time when the credential will expire, in epoch milliseconds. The
	// API client is advised to cache the credential given this expiration time.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	GcpOauthToken types.Object `tfsdk:"gcp_oauth_token"`

	R2TempCredentials types.Object `tfsdk:"r2_temp_credentials"`
	// The URL of the storage path accessible by the temporary credential.
	Url types.String `tfsdk:"url"`
}

func (toState *GenerateTemporaryTableCredentialResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GenerateTemporaryTableCredentialResponse) {
	if !fromPlan.AwsTempCredentials.IsNull() && !fromPlan.AwsTempCredentials.IsUnknown() {
		if toStateAwsTempCredentials, ok := toState.GetAwsTempCredentials(ctx); ok {
			if fromPlanAwsTempCredentials, ok := fromPlan.GetAwsTempCredentials(ctx); ok {
				toStateAwsTempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsTempCredentials)
				toState.SetAwsTempCredentials(ctx, toStateAwsTempCredentials)
			}
		}
	}
	if !fromPlan.AzureAad.IsNull() && !fromPlan.AzureAad.IsUnknown() {
		if toStateAzureAad, ok := toState.GetAzureAad(ctx); ok {
			if fromPlanAzureAad, ok := fromPlan.GetAzureAad(ctx); ok {
				toStateAzureAad.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureAad)
				toState.SetAzureAad(ctx, toStateAzureAad)
			}
		}
	}
	if !fromPlan.AzureUserDelegationSas.IsNull() && !fromPlan.AzureUserDelegationSas.IsUnknown() {
		if toStateAzureUserDelegationSas, ok := toState.GetAzureUserDelegationSas(ctx); ok {
			if fromPlanAzureUserDelegationSas, ok := fromPlan.GetAzureUserDelegationSas(ctx); ok {
				toStateAzureUserDelegationSas.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureUserDelegationSas)
				toState.SetAzureUserDelegationSas(ctx, toStateAzureUserDelegationSas)
			}
		}
	}
	if !fromPlan.GcpOauthToken.IsNull() && !fromPlan.GcpOauthToken.IsUnknown() {
		if toStateGcpOauthToken, ok := toState.GetGcpOauthToken(ctx); ok {
			if fromPlanGcpOauthToken, ok := fromPlan.GetGcpOauthToken(ctx); ok {
				toStateGcpOauthToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanGcpOauthToken)
				toState.SetGcpOauthToken(ctx, toStateGcpOauthToken)
			}
		}
	}
	if !fromPlan.R2TempCredentials.IsNull() && !fromPlan.R2TempCredentials.IsUnknown() {
		if toStateR2TempCredentials, ok := toState.GetR2TempCredentials(ctx); ok {
			if fromPlanR2TempCredentials, ok := fromPlan.GetR2TempCredentials(ctx); ok {
				toStateR2TempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanR2TempCredentials)
				toState.SetR2TempCredentials(ctx, toStateR2TempCredentials)
			}
		}
	}
}

func (toState *GenerateTemporaryTableCredentialResponse) SyncFieldsDuringRead(ctx context.Context, fromState GenerateTemporaryTableCredentialResponse) {
	if !fromState.AwsTempCredentials.IsNull() && !fromState.AwsTempCredentials.IsUnknown() {
		if toStateAwsTempCredentials, ok := toState.GetAwsTempCredentials(ctx); ok {
			if fromStateAwsTempCredentials, ok := fromState.GetAwsTempCredentials(ctx); ok {
				toStateAwsTempCredentials.SyncFieldsDuringRead(ctx, fromStateAwsTempCredentials)
				toState.SetAwsTempCredentials(ctx, toStateAwsTempCredentials)
			}
		}
	}
	if !fromState.AzureAad.IsNull() && !fromState.AzureAad.IsUnknown() {
		if toStateAzureAad, ok := toState.GetAzureAad(ctx); ok {
			if fromStateAzureAad, ok := fromState.GetAzureAad(ctx); ok {
				toStateAzureAad.SyncFieldsDuringRead(ctx, fromStateAzureAad)
				toState.SetAzureAad(ctx, toStateAzureAad)
			}
		}
	}
	if !fromState.AzureUserDelegationSas.IsNull() && !fromState.AzureUserDelegationSas.IsUnknown() {
		if toStateAzureUserDelegationSas, ok := toState.GetAzureUserDelegationSas(ctx); ok {
			if fromStateAzureUserDelegationSas, ok := fromState.GetAzureUserDelegationSas(ctx); ok {
				toStateAzureUserDelegationSas.SyncFieldsDuringRead(ctx, fromStateAzureUserDelegationSas)
				toState.SetAzureUserDelegationSas(ctx, toStateAzureUserDelegationSas)
			}
		}
	}
	if !fromState.GcpOauthToken.IsNull() && !fromState.GcpOauthToken.IsUnknown() {
		if toStateGcpOauthToken, ok := toState.GetGcpOauthToken(ctx); ok {
			if fromStateGcpOauthToken, ok := fromState.GetGcpOauthToken(ctx); ok {
				toStateGcpOauthToken.SyncFieldsDuringRead(ctx, fromStateGcpOauthToken)
				toState.SetGcpOauthToken(ctx, toStateGcpOauthToken)
			}
		}
	}
	if !fromState.R2TempCredentials.IsNull() && !fromState.R2TempCredentials.IsUnknown() {
		if toStateR2TempCredentials, ok := toState.GetR2TempCredentials(ctx); ok {
			if fromStateR2TempCredentials, ok := fromState.GetR2TempCredentials(ctx); ok {
				toStateR2TempCredentials.SyncFieldsDuringRead(ctx, fromStateR2TempCredentials)
				toState.SetR2TempCredentials(ctx, toStateR2TempCredentials)
			}
		}
	}
}

func (c GenerateTemporaryTableCredentialResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].SetOptional()
	attrs["azure_aad"] = attrs["azure_aad"].SetOptional()
	attrs["azure_user_delegation_sas"] = attrs["azure_user_delegation_sas"].SetOptional()
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].SetOptional()
	attrs["r2_temp_credentials"] = attrs["r2_temp_credentials"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenerateTemporaryTableCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GenerateTemporaryTableCredentialResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_temp_credentials":      reflect.TypeOf(AwsCredentials{}),
		"azure_aad":                 reflect.TypeOf(AzureActiveDirectoryToken{}),
		"azure_user_delegation_sas": reflect.TypeOf(AzureUserDelegationSas{}),
		"gcp_oauth_token":           reflect.TypeOf(GcpOauthToken{}),
		"r2_temp_credentials":       reflect.TypeOf(R2Credentials{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenerateTemporaryTableCredentialResponse
// only implements ToObjectValue() and Type().
func (o GenerateTemporaryTableCredentialResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_temp_credentials":      o.AwsTempCredentials,
			"azure_aad":                 o.AzureAad,
			"azure_user_delegation_sas": o.AzureUserDelegationSas,
			"expiration_time":           o.ExpirationTime,
			"gcp_oauth_token":           o.GcpOauthToken,
			"r2_temp_credentials":       o.R2TempCredentials,
			"url":                       o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GenerateTemporaryTableCredentialResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_temp_credentials":      AwsCredentials{}.Type(ctx),
			"azure_aad":                 AzureActiveDirectoryToken{}.Type(ctx),
			"azure_user_delegation_sas": AzureUserDelegationSas{}.Type(ctx),
			"expiration_time":           types.Int64Type,
			"gcp_oauth_token":           GcpOauthToken{}.Type(ctx),
			"r2_temp_credentials":       R2Credentials{}.Type(ctx),
			"url":                       types.StringType,
		},
	}
}

// GetAwsTempCredentials returns the value of the AwsTempCredentials field in GenerateTemporaryTableCredentialResponse as
// a AwsCredentials value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryTableCredentialResponse) GetAwsTempCredentials(ctx context.Context) (AwsCredentials, bool) {
	var e AwsCredentials
	if o.AwsTempCredentials.IsNull() || o.AwsTempCredentials.IsUnknown() {
		return e, false
	}
	var v AwsCredentials
	d := o.AwsTempCredentials.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsTempCredentials sets the value of the AwsTempCredentials field in GenerateTemporaryTableCredentialResponse.
func (o *GenerateTemporaryTableCredentialResponse) SetAwsTempCredentials(ctx context.Context, v AwsCredentials) {
	vs := v.ToObjectValue(ctx)
	o.AwsTempCredentials = vs
}

// GetAzureAad returns the value of the AzureAad field in GenerateTemporaryTableCredentialResponse as
// a AzureActiveDirectoryToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryTableCredentialResponse) GetAzureAad(ctx context.Context) (AzureActiveDirectoryToken, bool) {
	var e AzureActiveDirectoryToken
	if o.AzureAad.IsNull() || o.AzureAad.IsUnknown() {
		return e, false
	}
	var v AzureActiveDirectoryToken
	d := o.AzureAad.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureAad sets the value of the AzureAad field in GenerateTemporaryTableCredentialResponse.
func (o *GenerateTemporaryTableCredentialResponse) SetAzureAad(ctx context.Context, v AzureActiveDirectoryToken) {
	vs := v.ToObjectValue(ctx)
	o.AzureAad = vs
}

// GetAzureUserDelegationSas returns the value of the AzureUserDelegationSas field in GenerateTemporaryTableCredentialResponse as
// a AzureUserDelegationSas value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryTableCredentialResponse) GetAzureUserDelegationSas(ctx context.Context) (AzureUserDelegationSas, bool) {
	var e AzureUserDelegationSas
	if o.AzureUserDelegationSas.IsNull() || o.AzureUserDelegationSas.IsUnknown() {
		return e, false
	}
	var v AzureUserDelegationSas
	d := o.AzureUserDelegationSas.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureUserDelegationSas sets the value of the AzureUserDelegationSas field in GenerateTemporaryTableCredentialResponse.
func (o *GenerateTemporaryTableCredentialResponse) SetAzureUserDelegationSas(ctx context.Context, v AzureUserDelegationSas) {
	vs := v.ToObjectValue(ctx)
	o.AzureUserDelegationSas = vs
}

// GetGcpOauthToken returns the value of the GcpOauthToken field in GenerateTemporaryTableCredentialResponse as
// a GcpOauthToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryTableCredentialResponse) GetGcpOauthToken(ctx context.Context) (GcpOauthToken, bool) {
	var e GcpOauthToken
	if o.GcpOauthToken.IsNull() || o.GcpOauthToken.IsUnknown() {
		return e, false
	}
	var v GcpOauthToken
	d := o.GcpOauthToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGcpOauthToken sets the value of the GcpOauthToken field in GenerateTemporaryTableCredentialResponse.
func (o *GenerateTemporaryTableCredentialResponse) SetGcpOauthToken(ctx context.Context, v GcpOauthToken) {
	vs := v.ToObjectValue(ctx)
	o.GcpOauthToken = vs
}

// GetR2TempCredentials returns the value of the R2TempCredentials field in GenerateTemporaryTableCredentialResponse as
// a R2Credentials value.
// If the field is unknown or null, the boolean return value is false.
func (o *GenerateTemporaryTableCredentialResponse) GetR2TempCredentials(ctx context.Context) (R2Credentials, bool) {
	var e R2Credentials
	if o.R2TempCredentials.IsNull() || o.R2TempCredentials.IsUnknown() {
		return e, false
	}
	var v R2Credentials
	d := o.R2TempCredentials.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetR2TempCredentials sets the value of the R2TempCredentials field in GenerateTemporaryTableCredentialResponse.
func (o *GenerateTemporaryTableCredentialResponse) SetR2TempCredentials(ctx context.Context, v R2Credentials) {
	vs := v.ToObjectValue(ctx)
	o.R2TempCredentials = vs
}

type GetAccessRequestDestinationsRequest struct {
	// The full name of the securable.
	FullName types.String `tfsdk:"-"`
	// The type of the securable.
	SecurableType types.String `tfsdk:"-"`
}

func (toState *GetAccessRequestDestinationsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetAccessRequestDestinationsRequest) {
}

func (toState *GetAccessRequestDestinationsRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetAccessRequestDestinationsRequest) {
}

func (c GetAccessRequestDestinationsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccessRequestDestinationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccessRequestDestinationsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccessRequestDestinationsRequest
// only implements ToObjectValue() and Type().
func (o GetAccessRequestDestinationsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      o.FullName,
			"securable_type": o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccessRequestDestinationsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetAccountMetastoreAssignmentRequest struct {
	// Workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *GetAccountMetastoreAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetAccountMetastoreAssignmentRequest) {
}

func (toState *GetAccountMetastoreAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetAccountMetastoreAssignmentRequest) {
}

func (c GetAccountMetastoreAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountMetastoreAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccountMetastoreAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountMetastoreAssignmentRequest
// only implements ToObjectValue() and Type().
func (o GetAccountMetastoreAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccountMetastoreAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspace_id": types.Int64Type,
		},
	}
}

type GetAccountMetastoreRequest struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (toState *GetAccountMetastoreRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetAccountMetastoreRequest) {
}

func (toState *GetAccountMetastoreRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetAccountMetastoreRequest) {
}

func (c GetAccountMetastoreRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccountMetastoreRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountMetastoreRequest
// only implements ToObjectValue() and Type().
func (o GetAccountMetastoreRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccountMetastoreRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
		},
	}
}

type GetAccountStorageCredentialRequest struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
	// Name of the storage credential.
	StorageCredentialName types.String `tfsdk:"-"`
}

func (toState *GetAccountStorageCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetAccountStorageCredentialRequest) {
}

func (toState *GetAccountStorageCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetAccountStorageCredentialRequest) {
}

func (c GetAccountStorageCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccountStorageCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountStorageCredentialRequest
// only implements ToObjectValue() and Type().
func (o GetAccountStorageCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id":            o.MetastoreId,
			"storage_credential_name": o.StorageCredentialName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccountStorageCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id":            types.StringType,
			"storage_credential_name": types.StringType,
		},
	}
}

type GetArtifactAllowlistRequest struct {
	// The artifact type of the allowlist.
	ArtifactType types.String `tfsdk:"-"`
}

func (toState *GetArtifactAllowlistRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetArtifactAllowlistRequest) {
}

func (toState *GetArtifactAllowlistRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetArtifactAllowlistRequest) {
}

func (c GetArtifactAllowlistRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact_type"] = attrs["artifact_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetArtifactAllowlistRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetArtifactAllowlistRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetArtifactAllowlistRequest
// only implements ToObjectValue() and Type().
func (o GetArtifactAllowlistRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact_type": o.ArtifactType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetArtifactAllowlistRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact_type": types.StringType,
		},
	}
}

type GetBindingsRequest struct {
	// Maximum number of workspace bindings to return. - When set to 0, the page
	// length is set to a server configured value (recommended); - When set to a
	// value greater than 0, the page length is the minimum of this value and a
	// server configured value; - When set to a value less than 0, an invalid
	// parameter error is returned; - If not set, all the workspace bindings are
	// returned (not recommended).
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// The name of the securable.
	SecurableName types.String `tfsdk:"-"`
	// The type of the securable to bind to a workspace (catalog,
	// storage_credential, credential, or external_location).
	SecurableType types.String `tfsdk:"-"`
}

func (toState *GetBindingsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetBindingsRequest) {
}

func (toState *GetBindingsRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetBindingsRequest) {
}

func (c GetBindingsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["securable_name"] = attrs["securable_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetBindingsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetBindingsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetBindingsRequest
// only implements ToObjectValue() and Type().
func (o GetBindingsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
			"securable_name": o.SecurableName,
			"securable_type": o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetBindingsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"securable_name": types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetByAliasRequest struct {
	// The name of the alias
	Alias types.String `tfsdk:"-"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// Whether to include aliases associated with the model version in the
	// response
	IncludeAliases types.Bool `tfsdk:"-"`
}

func (toState *GetByAliasRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetByAliasRequest) {
}

func (toState *GetByAliasRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetByAliasRequest) {
}

func (c GetByAliasRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["alias"] = attrs["alias"].SetRequired()
	attrs["include_aliases"] = attrs["include_aliases"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetByAliasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetByAliasRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetByAliasRequest
// only implements ToObjectValue() and Type().
func (o GetByAliasRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":           o.Alias,
			"full_name":       o.FullName,
			"include_aliases": o.IncludeAliases,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetByAliasRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":           types.StringType,
			"full_name":       types.StringType,
			"include_aliases": types.BoolType,
		},
	}
}

type GetCatalogRequest struct {
	// Whether to include catalogs in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
}

func (toState *GetCatalogRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetCatalogRequest) {
}

func (toState *GetCatalogRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetCatalogRequest) {
}

func (c GetCatalogRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCatalogRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetCatalogRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCatalogRequest
// only implements ToObjectValue() and Type().
func (o GetCatalogRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": o.IncludeBrowse,
			"name":           o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetCatalogRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type GetCatalogWorkspaceBindingsResponse struct {
	// A list of workspace IDs
	Workspaces types.List `tfsdk:"workspaces"`
}

func (toState *GetCatalogWorkspaceBindingsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetCatalogWorkspaceBindingsResponse) {
}

func (toState *GetCatalogWorkspaceBindingsResponse) SyncFieldsDuringRead(ctx context.Context, fromState GetCatalogWorkspaceBindingsResponse) {
}

func (c GetCatalogWorkspaceBindingsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspaces"] = attrs["workspaces"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCatalogWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetCatalogWorkspaceBindingsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"workspaces": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCatalogWorkspaceBindingsResponse
// only implements ToObjectValue() and Type().
func (o GetCatalogWorkspaceBindingsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspaces": o.Workspaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetCatalogWorkspaceBindingsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetWorkspaces returns the value of the Workspaces field in GetCatalogWorkspaceBindingsResponse as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (o *GetCatalogWorkspaceBindingsResponse) GetWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if o.Workspaces.IsNull() || o.Workspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := o.Workspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWorkspaces sets the value of the Workspaces field in GetCatalogWorkspaceBindingsResponse.
func (o *GetCatalogWorkspaceBindingsResponse) SetWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Workspaces = types.ListValueMust(t, vs)
}

type GetConnectionRequest struct {
	// Name of the connection.
	Name types.String `tfsdk:"-"`
}

func (toState *GetConnectionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetConnectionRequest) {
}

func (toState *GetConnectionRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetConnectionRequest) {
}

func (c GetConnectionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetConnectionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetConnectionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetConnectionRequest
// only implements ToObjectValue() and Type().
func (o GetConnectionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetConnectionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetCredentialRequest struct {
	// Name of the credential.
	NameArg types.String `tfsdk:"-"`
}

func (toState *GetCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetCredentialRequest) {
}

func (toState *GetCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetCredentialRequest) {
}

func (c GetCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name_arg"] = attrs["name_arg"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetCredentialRequest
// only implements ToObjectValue() and Type().
func (o GetCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name_arg": o.NameArg,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name_arg": types.StringType,
		},
	}
}

type GetEffectiveRequest struct {
	// Full name of securable.
	FullName types.String `tfsdk:"-"`
	// Specifies the maximum number of privileges to return (page length). Every
	// EffectivePrivilegeAssignment present in a single page response is
	// guaranteed to contain all the effective privileges granted on (or
	// inherited by) the requested Securable for the respective principal.
	//
	// If not set, all the effective permissions are returned. If set to -
	// lesser than 0: invalid parameter error - 0: page length is set to a
	// server configured value - lesser than 150 but greater than 0: invalid
	// parameter error (this is to ensure that server is able to return at least
	// one complete EffectivePrivilegeAssignment in a single page response) -
	// greater than (or equal to) 150: page length is the minimum of this value
	// and a server configured value
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token for the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// If provided, only the effective permissions for the specified principal
	// (user or group) are returned.
	Principal types.String `tfsdk:"-"`
	// Type of securable.
	SecurableType types.String `tfsdk:"-"`
}

func (toState *GetEffectiveRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetEffectiveRequest) {
}

func (toState *GetEffectiveRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetEffectiveRequest) {
}

func (c GetEffectiveRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetEffectiveRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetEffectiveRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetEffectiveRequest
// only implements ToObjectValue() and Type().
func (o GetEffectiveRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      o.FullName,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
			"principal":      o.Principal,
			"securable_type": o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetEffectiveRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"principal":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetEntityTagAssignmentRequest struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`
	// Required. The key of the tag
	TagKey types.String `tfsdk:"-"`
}

func (toState *GetEntityTagAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetEntityTagAssignmentRequest) {
}

func (toState *GetEntityTagAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetEntityTagAssignmentRequest) {
}

func (c GetEntityTagAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetEntityTagAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetEntityTagAssignmentRequest
// only implements ToObjectValue() and Type().
func (o GetEntityTagAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": o.EntityName,
			"entity_type": o.EntityType,
			"tag_key":     o.TagKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetEntityTagAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"tag_key":     types.StringType,
		},
	}
}

type GetExternalLocationRequest struct {
	// Whether to include external locations in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Name of the external location.
	Name types.String `tfsdk:"-"`
}

func (toState *GetExternalLocationRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetExternalLocationRequest) {
}

func (toState *GetExternalLocationRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetExternalLocationRequest) {
}

func (c GetExternalLocationRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetExternalLocationRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetExternalLocationRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetExternalLocationRequest
// only implements ToObjectValue() and Type().
func (o GetExternalLocationRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": o.IncludeBrowse,
			"name":           o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetExternalLocationRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type GetExternalMetadataRequest struct {
	Name types.String `tfsdk:"-"`
}

func (toState *GetExternalMetadataRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetExternalMetadataRequest) {
}

func (toState *GetExternalMetadataRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetExternalMetadataRequest) {
}

func (c GetExternalMetadataRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetExternalMetadataRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetExternalMetadataRequest
// only implements ToObjectValue() and Type().
func (o GetExternalMetadataRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetExternalMetadataRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetFunctionRequest struct {
	// Whether to include functions in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The fully-qualified name of the function (of the form
	// __catalog_name__.__schema_name__.__function__name__).
	Name types.String `tfsdk:"-"`
}

func (toState *GetFunctionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetFunctionRequest) {
}

func (toState *GetFunctionRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetFunctionRequest) {
}

func (c GetFunctionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetFunctionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetFunctionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetFunctionRequest
// only implements ToObjectValue() and Type().
func (o GetFunctionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": o.IncludeBrowse,
			"name":           o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetFunctionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type GetGrantRequest struct {
	// Full name of securable.
	FullName types.String `tfsdk:"-"`
	// Specifies the maximum number of privileges to return (page length). Every
	// PrivilegeAssignment present in a single page response is guaranteed to
	// contain all the privileges granted on the requested Securable for the
	// respective principal.
	//
	// If not set, all the permissions are returned. If set to - lesser than 0:
	// invalid parameter error - 0: page length is set to a server configured
	// value - lesser than 150 but greater than 0: invalid parameter error (this
	// is to ensure that server is able to return at least one complete
	// PrivilegeAssignment in a single page response) - greater than (or equal
	// to) 150: page length is the minimum of this value and a server configured
	// value
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// If provided, only the permissions for the specified principal (user or
	// group) are returned.
	Principal types.String `tfsdk:"-"`
	// Type of securable.
	SecurableType types.String `tfsdk:"-"`
}

func (toState *GetGrantRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetGrantRequest) {
}

func (toState *GetGrantRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetGrantRequest) {
}

func (c GetGrantRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetGrantRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetGrantRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetGrantRequest
// only implements ToObjectValue() and Type().
func (o GetGrantRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      o.FullName,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
			"principal":      o.Principal,
			"securable_type": o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetGrantRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"principal":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

type GetMetastoreRequest struct {
	// Unique ID of the metastore.
	Id types.String `tfsdk:"-"`
}

func (toState *GetMetastoreRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetMetastoreRequest) {
}

func (toState *GetMetastoreRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetMetastoreRequest) {
}

func (c GetMetastoreRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetMetastoreRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetMetastoreRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetMetastoreRequest
// only implements ToObjectValue() and Type().
func (o GetMetastoreRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetMetastoreRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetMetastoreSummaryResponse struct {
	// Cloud vendor of the metastore home shard (e.g., `aws`, `azure`, `gcp`).
	Cloud types.String `tfsdk:"cloud"`
	// Time at which this metastore was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of metastore creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of the metastore's (Default) Data Access Configuration.
	DefaultDataAccessConfigId types.String `tfsdk:"default_data_access_config_id"`
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// Whether to allow non-DBR clients to directly access entities under the
	// metastore.
	ExternalAccessEnabled types.Bool `tfsdk:"external_access_enabled"`
	// Globally unique metastore ID across clouds and regions, of the form
	// `cloud:region:metastore_id`.
	GlobalMetastoreId types.String `tfsdk:"global_metastore_id"`
	// Unique identifier of metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
	// Name of the storage credential to access the metastore storage_root.
	StorageRootCredentialName types.String `tfsdk:"storage_root_credential_name"`
	// Time at which the metastore was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the metastore.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (toState *GetMetastoreSummaryResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetMetastoreSummaryResponse) {
}

func (toState *GetMetastoreSummaryResponse) SyncFieldsDuringRead(ctx context.Context, fromState GetMetastoreSummaryResponse) {
}

func (c GetMetastoreSummaryResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["cloud"] = attrs["cloud"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["default_data_access_config_id"] = attrs["default_data_access_config_id"].SetOptional()
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["external_access_enabled"] = attrs["external_access_enabled"].SetOptional()
	attrs["global_metastore_id"] = attrs["global_metastore_id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()
	attrs["storage_root_credential_name"] = attrs["storage_root_credential_name"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetMetastoreSummaryResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetMetastoreSummaryResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetMetastoreSummaryResponse
// only implements ToObjectValue() and Type().
func (o GetMetastoreSummaryResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cloud":                           o.Cloud,
			"created_at":                      o.CreatedAt,
			"created_by":                      o.CreatedBy,
			"default_data_access_config_id":   o.DefaultDataAccessConfigId,
			"delta_sharing_organization_name": o.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": o.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               o.DeltaSharingScope,
			"external_access_enabled":                           o.ExternalAccessEnabled,
			"global_metastore_id":                               o.GlobalMetastoreId,
			"metastore_id":                                      o.MetastoreId,
			"name":                                              o.Name,
			"owner":                                             o.Owner,
			"privilege_model_version":                           o.PrivilegeModelVersion,
			"region":                                            o.Region,
			"storage_root":                                      o.StorageRoot,
			"storage_root_credential_id":                        o.StorageRootCredentialId,
			"storage_root_credential_name":                      o.StorageRootCredentialName,
			"updated_at":                                        o.UpdatedAt,
			"updated_by":                                        o.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetMetastoreSummaryResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cloud":                           types.StringType,
			"created_at":                      types.Int64Type,
			"created_by":                      types.StringType,
			"default_data_access_config_id":   types.StringType,
			"delta_sharing_organization_name": types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"external_access_enabled":                           types.BoolType,
			"global_metastore_id":                               types.StringType,
			"metastore_id":                                      types.StringType,
			"name":                                              types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"region":                                            types.StringType,
			"storage_root":                                      types.StringType,
			"storage_root_credential_id":                        types.StringType,
			"storage_root_credential_name":                      types.StringType,
			"updated_at":                                        types.Int64Type,
			"updated_by":                                        types.StringType,
		},
	}
}

type GetModelVersionRequest struct {
	// The three-level (fully qualified) name of the model version
	FullName types.String `tfsdk:"-"`
	// Whether to include aliases associated with the model version in the
	// response
	IncludeAliases types.Bool `tfsdk:"-"`
	// Whether to include model versions in the response for which the principal
	// can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The integer version number of the model version
	Version types.Int64 `tfsdk:"-"`
}

func (toState *GetModelVersionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetModelVersionRequest) {
}

func (toState *GetModelVersionRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetModelVersionRequest) {
}

func (c GetModelVersionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version"] = attrs["version"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["include_aliases"] = attrs["include_aliases"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetModelVersionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetModelVersionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetModelVersionRequest
// only implements ToObjectValue() and Type().
func (o GetModelVersionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":       o.FullName,
			"include_aliases": o.IncludeAliases,
			"include_browse":  o.IncludeBrowse,
			"version":         o.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetModelVersionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":       types.StringType,
			"include_aliases": types.BoolType,
			"include_browse":  types.BoolType,
			"version":         types.Int64Type,
		},
	}
}

type GetOnlineTableRequest struct {
	// Full three-part (catalog, schema, table) name of the table.
	Name types.String `tfsdk:"-"`
}

func (toState *GetOnlineTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetOnlineTableRequest) {
}

func (toState *GetOnlineTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetOnlineTableRequest) {
}

func (c GetOnlineTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetOnlineTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetOnlineTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetOnlineTableRequest
// only implements ToObjectValue() and Type().
func (o GetOnlineTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetOnlineTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetPermissionsResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The privileges assigned to each principal
	PrivilegeAssignments types.List `tfsdk:"privilege_assignments"`
}

func (toState *GetPermissionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetPermissionsResponse) {
}

func (toState *GetPermissionsResponse) SyncFieldsDuringRead(ctx context.Context, fromState GetPermissionsResponse) {
}

func (c GetPermissionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["privilege_assignments"] = attrs["privilege_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPermissionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPermissionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privilege_assignments": reflect.TypeOf(PrivilegeAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPermissionsResponse
// only implements ToObjectValue() and Type().
func (o GetPermissionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":       o.NextPageToken,
			"privilege_assignments": o.PrivilegeAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetPermissionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"privilege_assignments": basetypes.ListType{
				ElemType: PrivilegeAssignment{}.Type(ctx),
			},
		},
	}
}

// GetPrivilegeAssignments returns the value of the PrivilegeAssignments field in GetPermissionsResponse as
// a slice of PrivilegeAssignment values.
// If the field is unknown or null, the boolean return value is false.
func (o *GetPermissionsResponse) GetPrivilegeAssignments(ctx context.Context) ([]PrivilegeAssignment, bool) {
	if o.PrivilegeAssignments.IsNull() || o.PrivilegeAssignments.IsUnknown() {
		return nil, false
	}
	var v []PrivilegeAssignment
	d := o.PrivilegeAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivilegeAssignments sets the value of the PrivilegeAssignments field in GetPermissionsResponse.
func (o *GetPermissionsResponse) SetPrivilegeAssignments(ctx context.Context, v []PrivilegeAssignment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["privilege_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PrivilegeAssignments = types.ListValueMust(t, vs)
}

type GetPolicyRequest struct {
	// Required. The name of the policy to retrieve.
	Name types.String `tfsdk:"-"`
	// Required. The fully qualified name of securable to retrieve policy for.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to retrieve the policy for.
	OnSecurableType types.String `tfsdk:"-"`
}

func (toState *GetPolicyRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetPolicyRequest) {
}

func (toState *GetPolicyRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetPolicyRequest) {
}

func (c GetPolicyRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPolicyRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPolicyRequest
// only implements ToObjectValue() and Type().
func (o GetPolicyRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                  o.Name,
			"on_securable_fullname": o.OnSecurableFullname,
			"on_securable_type":     o.OnSecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetPolicyRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
		},
	}
}

type GetQualityMonitorRequest struct {
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
}

func (toState *GetQualityMonitorRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetQualityMonitorRequest) {
}

func (toState *GetQualityMonitorRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetQualityMonitorRequest) {
}

func (c GetQualityMonitorRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetQualityMonitorRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQualityMonitorRequest
// only implements ToObjectValue() and Type().
func (o GetQualityMonitorRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": o.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetQualityMonitorRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

type GetQuotaRequest struct {
	// Full name of the parent resource. Provide the metastore ID if the parent
	// is a metastore.
	ParentFullName types.String `tfsdk:"-"`
	// Securable type of the quota parent.
	ParentSecurableType types.String `tfsdk:"-"`
	// Name of the quota. Follows the pattern of the quota type, with "-quota"
	// added as a suffix.
	QuotaName types.String `tfsdk:"-"`
}

func (toState *GetQuotaRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetQuotaRequest) {
}

func (toState *GetQuotaRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetQuotaRequest) {
}

func (c GetQuotaRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parent_securable_type"] = attrs["parent_securable_type"].SetRequired()
	attrs["parent_full_name"] = attrs["parent_full_name"].SetRequired()
	attrs["quota_name"] = attrs["quota_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQuotaRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetQuotaRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQuotaRequest
// only implements ToObjectValue() and Type().
func (o GetQuotaRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parent_full_name":      o.ParentFullName,
			"parent_securable_type": o.ParentSecurableType,
			"quota_name":            o.QuotaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetQuotaRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parent_full_name":      types.StringType,
			"parent_securable_type": types.StringType,
			"quota_name":            types.StringType,
		},
	}
}

type GetQuotaResponse struct {
	// The returned QuotaInfo.
	QuotaInfo types.Object `tfsdk:"quota_info"`
}

func (toState *GetQuotaResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetQuotaResponse) {
	if !fromPlan.QuotaInfo.IsNull() && !fromPlan.QuotaInfo.IsUnknown() {
		if toStateQuotaInfo, ok := toState.GetQuotaInfo(ctx); ok {
			if fromPlanQuotaInfo, ok := fromPlan.GetQuotaInfo(ctx); ok {
				toStateQuotaInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanQuotaInfo)
				toState.SetQuotaInfo(ctx, toStateQuotaInfo)
			}
		}
	}
}

func (toState *GetQuotaResponse) SyncFieldsDuringRead(ctx context.Context, fromState GetQuotaResponse) {
	if !fromState.QuotaInfo.IsNull() && !fromState.QuotaInfo.IsUnknown() {
		if toStateQuotaInfo, ok := toState.GetQuotaInfo(ctx); ok {
			if fromStateQuotaInfo, ok := fromState.GetQuotaInfo(ctx); ok {
				toStateQuotaInfo.SyncFieldsDuringRead(ctx, fromStateQuotaInfo)
				toState.SetQuotaInfo(ctx, toStateQuotaInfo)
			}
		}
	}
}

func (c GetQuotaResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["quota_info"] = attrs["quota_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQuotaResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetQuotaResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quota_info": reflect.TypeOf(QuotaInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQuotaResponse
// only implements ToObjectValue() and Type().
func (o GetQuotaResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"quota_info": o.QuotaInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetQuotaResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"quota_info": QuotaInfo{}.Type(ctx),
		},
	}
}

// GetQuotaInfo returns the value of the QuotaInfo field in GetQuotaResponse as
// a QuotaInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *GetQuotaResponse) GetQuotaInfo(ctx context.Context) (QuotaInfo, bool) {
	var e QuotaInfo
	if o.QuotaInfo.IsNull() || o.QuotaInfo.IsUnknown() {
		return e, false
	}
	var v QuotaInfo
	d := o.QuotaInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQuotaInfo sets the value of the QuotaInfo field in GetQuotaResponse.
func (o *GetQuotaResponse) SetQuotaInfo(ctx context.Context, v QuotaInfo) {
	vs := v.ToObjectValue(ctx)
	o.QuotaInfo = vs
}

type GetRefreshRequest struct {
	// ID of the refresh.
	RefreshId types.Int64 `tfsdk:"-"`
	// Full name of the table.
	TableName types.String `tfsdk:"-"`
}

func (toState *GetRefreshRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetRefreshRequest) {
}

func (toState *GetRefreshRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetRefreshRequest) {
}

func (c GetRefreshRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()
	attrs["refresh_id"] = attrs["refresh_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRefreshRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetRefreshRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRefreshRequest
// only implements ToObjectValue() and Type().
func (o GetRefreshRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"refresh_id": o.RefreshId,
			"table_name": o.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetRefreshRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"refresh_id": types.Int64Type,
			"table_name": types.StringType,
		},
	}
}

type GetRegisteredModelRequest struct {
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// Whether to include registered model aliases in the response
	IncludeAliases types.Bool `tfsdk:"-"`
	// Whether to include registered models in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
}

func (toState *GetRegisteredModelRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetRegisteredModelRequest) {
}

func (toState *GetRegisteredModelRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetRegisteredModelRequest) {
}

func (c GetRegisteredModelRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["include_aliases"] = attrs["include_aliases"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetRegisteredModelRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRegisteredModelRequest
// only implements ToObjectValue() and Type().
func (o GetRegisteredModelRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":       o.FullName,
			"include_aliases": o.IncludeAliases,
			"include_browse":  o.IncludeBrowse,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetRegisteredModelRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":       types.StringType,
			"include_aliases": types.BoolType,
			"include_browse":  types.BoolType,
		},
	}
}

type GetSchemaRequest struct {
	// Full name of the schema.
	FullName types.String `tfsdk:"-"`
	// Whether to include schemas in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
}

func (toState *GetSchemaRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetSchemaRequest) {
}

func (toState *GetSchemaRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetSchemaRequest) {
}

func (c GetSchemaRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetSchemaRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetSchemaRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetSchemaRequest
// only implements ToObjectValue() and Type().
func (o GetSchemaRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      o.FullName,
			"include_browse": o.IncludeBrowse,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetSchemaRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"include_browse": types.BoolType,
		},
	}
}

type GetStorageCredentialRequest struct {
	// Name of the storage credential.
	Name types.String `tfsdk:"-"`
}

func (toState *GetStorageCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetStorageCredentialRequest) {
}

func (toState *GetStorageCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetStorageCredentialRequest) {
}

func (c GetStorageCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetStorageCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetStorageCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetStorageCredentialRequest
// only implements ToObjectValue() and Type().
func (o GetStorageCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetStorageCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetTableRequest struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
	// Whether to include tables in the response for which the principal can
	// only access selective metadata for.
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Whether delta metadata should be included in the response.
	IncludeDeltaMetadata types.Bool `tfsdk:"-"`
	// Whether to include a manifest containing table capabilities in the
	// response.
	IncludeManifestCapabilities types.Bool `tfsdk:"-"`
}

func (toState *GetTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetTableRequest) {
}

func (toState *GetTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetTableRequest) {
}

func (c GetTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["include_delta_metadata"] = attrs["include_delta_metadata"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["include_manifest_capabilities"] = attrs["include_manifest_capabilities"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetTableRequest
// only implements ToObjectValue() and Type().
func (o GetTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":                     o.FullName,
			"include_browse":                o.IncludeBrowse,
			"include_delta_metadata":        o.IncludeDeltaMetadata,
			"include_manifest_capabilities": o.IncludeManifestCapabilities,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":                     types.StringType,
			"include_browse":                types.BoolType,
			"include_delta_metadata":        types.BoolType,
			"include_manifest_capabilities": types.BoolType,
		},
	}
}

type GetWorkspaceBindingRequest struct {
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
}

func (toState *GetWorkspaceBindingRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetWorkspaceBindingRequest) {
}

func (toState *GetWorkspaceBindingRequest) SyncFieldsDuringRead(ctx context.Context, fromState GetWorkspaceBindingRequest) {
}

func (c GetWorkspaceBindingRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetWorkspaceBindingRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetWorkspaceBindingRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetWorkspaceBindingRequest
// only implements ToObjectValue() and Type().
func (o GetWorkspaceBindingRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetWorkspaceBindingRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type GetWorkspaceBindingsResponse struct {
	// List of workspace bindings
	Bindings types.List `tfsdk:"bindings"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *GetWorkspaceBindingsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan GetWorkspaceBindingsResponse) {
}

func (toState *GetWorkspaceBindingsResponse) SyncFieldsDuringRead(ctx context.Context, fromState GetWorkspaceBindingsResponse) {
}

func (c GetWorkspaceBindingsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["bindings"] = attrs["bindings"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetWorkspaceBindingsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"bindings": reflect.TypeOf(WorkspaceBinding{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetWorkspaceBindingsResponse
// only implements ToObjectValue() and Type().
func (o GetWorkspaceBindingsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"bindings":        o.Bindings,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetWorkspaceBindingsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"bindings": basetypes.ListType{
				ElemType: WorkspaceBinding{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetBindings returns the value of the Bindings field in GetWorkspaceBindingsResponse as
// a slice of WorkspaceBinding values.
// If the field is unknown or null, the boolean return value is false.
func (o *GetWorkspaceBindingsResponse) GetBindings(ctx context.Context) ([]WorkspaceBinding, bool) {
	if o.Bindings.IsNull() || o.Bindings.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding
	d := o.Bindings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBindings sets the value of the Bindings field in GetWorkspaceBindingsResponse.
func (o *GetWorkspaceBindingsResponse) SetBindings(ctx context.Context, v []WorkspaceBinding) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["bindings"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Bindings = types.ListValueMust(t, vs)
}

type ListAccountMetastoreAssignmentsRequest struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (toState *ListAccountMetastoreAssignmentsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListAccountMetastoreAssignmentsRequest) {
}

func (toState *ListAccountMetastoreAssignmentsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListAccountMetastoreAssignmentsRequest) {
}

func (c ListAccountMetastoreAssignmentsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountMetastoreAssignmentsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountMetastoreAssignmentsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountMetastoreAssignmentsRequest
// only implements ToObjectValue() and Type().
func (o ListAccountMetastoreAssignmentsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountMetastoreAssignmentsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
		},
	}
}

// The list of workspaces to which the given metastore is assigned.
type ListAccountMetastoreAssignmentsResponse struct {
	WorkspaceIds types.List `tfsdk:"workspace_ids"`
}

func (toState *ListAccountMetastoreAssignmentsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListAccountMetastoreAssignmentsResponse) {
}

func (toState *ListAccountMetastoreAssignmentsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListAccountMetastoreAssignmentsResponse) {
}

func (c ListAccountMetastoreAssignmentsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspace_ids"] = attrs["workspace_ids"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountMetastoreAssignmentsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountMetastoreAssignmentsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"workspace_ids": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountMetastoreAssignmentsResponse
// only implements ToObjectValue() and Type().
func (o ListAccountMetastoreAssignmentsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspace_ids": o.WorkspaceIds,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountMetastoreAssignmentsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspace_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetWorkspaceIds returns the value of the WorkspaceIds field in ListAccountMetastoreAssignmentsResponse as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListAccountMetastoreAssignmentsResponse) GetWorkspaceIds(ctx context.Context) ([]types.Int64, bool) {
	if o.WorkspaceIds.IsNull() || o.WorkspaceIds.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := o.WorkspaceIds.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWorkspaceIds sets the value of the WorkspaceIds field in ListAccountMetastoreAssignmentsResponse.
func (o *ListAccountMetastoreAssignmentsResponse) SetWorkspaceIds(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["workspace_ids"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.WorkspaceIds = types.ListValueMust(t, vs)
}

type ListAccountMetastoresRequest struct {
}

func (toState *ListAccountMetastoresRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListAccountMetastoresRequest) {
}

func (toState *ListAccountMetastoresRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListAccountMetastoresRequest) {
}

func (c ListAccountMetastoresRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountMetastoresRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountMetastoresRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountMetastoresRequest
// only implements ToObjectValue() and Type().
func (o ListAccountMetastoresRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountMetastoresRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type ListAccountStorageCredentialsRequest struct {
	// Unity Catalog metastore ID
	MetastoreId types.String `tfsdk:"-"`
}

func (toState *ListAccountStorageCredentialsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListAccountStorageCredentialsRequest) {
}

func (toState *ListAccountStorageCredentialsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListAccountStorageCredentialsRequest) {
}

func (c ListAccountStorageCredentialsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountStorageCredentialsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountStorageCredentialsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountStorageCredentialsRequest
// only implements ToObjectValue() and Type().
func (o ListAccountStorageCredentialsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountStorageCredentialsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
		},
	}
}

type ListAccountStorageCredentialsResponse struct {
	// An array of metastore storage credentials.
	StorageCredentials types.List `tfsdk:"storage_credentials"`
}

func (toState *ListAccountStorageCredentialsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListAccountStorageCredentialsResponse) {
}

func (toState *ListAccountStorageCredentialsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListAccountStorageCredentialsResponse) {
}

func (c ListAccountStorageCredentialsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["storage_credentials"] = attrs["storage_credentials"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountStorageCredentialsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountStorageCredentialsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"storage_credentials": reflect.TypeOf(StorageCredentialInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountStorageCredentialsResponse
// only implements ToObjectValue() and Type().
func (o ListAccountStorageCredentialsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"storage_credentials": o.StorageCredentials,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountStorageCredentialsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"storage_credentials": basetypes.ListType{
				ElemType: StorageCredentialInfo{}.Type(ctx),
			},
		},
	}
}

// GetStorageCredentials returns the value of the StorageCredentials field in ListAccountStorageCredentialsResponse as
// a slice of StorageCredentialInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListAccountStorageCredentialsResponse) GetStorageCredentials(ctx context.Context) ([]StorageCredentialInfo, bool) {
	if o.StorageCredentials.IsNull() || o.StorageCredentials.IsUnknown() {
		return nil, false
	}
	var v []StorageCredentialInfo
	d := o.StorageCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStorageCredentials sets the value of the StorageCredentials field in ListAccountStorageCredentialsResponse.
func (o *ListAccountStorageCredentialsResponse) SetStorageCredentials(ctx context.Context, v []StorageCredentialInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["storage_credentials"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.StorageCredentials = types.ListValueMust(t, vs)
}

type ListCatalogsRequest struct {
	// Whether to include catalogs in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of catalogs to return. - when set to 0, the page length is
	// set to a server configured value (recommended); - when set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - when set to a value less than 0, an invalid parameter
	// error is returned; - If not set, all valid catalogs are returned (not
	// recommended). - Note: The number of returned catalogs might be less than
	// the specified max_results size, even zero. The only definitive indication
	// that no further catalogs can be fetched is when the next_page_token is
	// unset from the response.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListCatalogsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListCatalogsRequest) {
}

func (toState *ListCatalogsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListCatalogsRequest) {
}

func (c ListCatalogsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCatalogsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListCatalogsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCatalogsRequest
// only implements ToObjectValue() and Type().
func (o ListCatalogsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListCatalogsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
		},
	}
}

type ListCatalogsResponse struct {
	// An array of catalog information objects.
	Catalogs types.List `tfsdk:"catalogs"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListCatalogsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListCatalogsResponse) {
}

func (toState *ListCatalogsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListCatalogsResponse) {
}

func (c ListCatalogsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalogs"] = attrs["catalogs"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCatalogsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListCatalogsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"catalogs": reflect.TypeOf(CatalogInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCatalogsResponse
// only implements ToObjectValue() and Type().
func (o ListCatalogsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalogs":        o.Catalogs,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListCatalogsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalogs": basetypes.ListType{
				ElemType: CatalogInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetCatalogs returns the value of the Catalogs field in ListCatalogsResponse as
// a slice of CatalogInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListCatalogsResponse) GetCatalogs(ctx context.Context) ([]CatalogInfo, bool) {
	if o.Catalogs.IsNull() || o.Catalogs.IsUnknown() {
		return nil, false
	}
	var v []CatalogInfo
	d := o.Catalogs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCatalogs sets the value of the Catalogs field in ListCatalogsResponse.
func (o *ListCatalogsResponse) SetCatalogs(ctx context.Context, v []CatalogInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["catalogs"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Catalogs = types.ListValueMust(t, vs)
}

type ListConnectionsRequest struct {
	// Maximum number of connections to return. - If not set, all connections
	// are returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListConnectionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListConnectionsRequest) {
}

func (toState *ListConnectionsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListConnectionsRequest) {
}

func (c ListConnectionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListConnectionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListConnectionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListConnectionsRequest
// only implements ToObjectValue() and Type().
func (o ListConnectionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": o.MaxResults,
			"page_token":  o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListConnectionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListConnectionsResponse struct {
	// An array of connection information objects.
	Connections types.List `tfsdk:"connections"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListConnectionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListConnectionsResponse) {
}

func (toState *ListConnectionsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListConnectionsResponse) {
}

func (c ListConnectionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connections"] = attrs["connections"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListConnectionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListConnectionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"connections": reflect.TypeOf(ConnectionInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListConnectionsResponse
// only implements ToObjectValue() and Type().
func (o ListConnectionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connections":     o.Connections,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListConnectionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connections": basetypes.ListType{
				ElemType: ConnectionInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetConnections returns the value of the Connections field in ListConnectionsResponse as
// a slice of ConnectionInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListConnectionsResponse) GetConnections(ctx context.Context) ([]ConnectionInfo, bool) {
	if o.Connections.IsNull() || o.Connections.IsUnknown() {
		return nil, false
	}
	var v []ConnectionInfo
	d := o.Connections.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConnections sets the value of the Connections field in ListConnectionsResponse.
func (o *ListConnectionsResponse) SetConnections(ctx context.Context, v []ConnectionInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["connections"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Connections = types.ListValueMust(t, vs)
}

type ListCredentialsRequest struct {
	// Maximum number of credentials to return. - If not set, the default max
	// page size is used. - When set to a value greater than 0, the page length
	// is the minimum of this value and a server-configured value. - When set to
	// 0, the page length is set to a server-configured value (recommended). -
	// When set to a value less than 0, an invalid parameter error is returned.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token to retrieve the next page of results.
	PageToken types.String `tfsdk:"-"`
	// Return only credentials for the specified purpose.
	Purpose types.String `tfsdk:"-"`
}

func (toState *ListCredentialsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListCredentialsRequest) {
}

func (toState *ListCredentialsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListCredentialsRequest) {
}

func (c ListCredentialsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["purpose"] = attrs["purpose"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCredentialsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListCredentialsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCredentialsRequest
// only implements ToObjectValue() and Type().
func (o ListCredentialsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": o.MaxResults,
			"page_token":  o.PageToken,
			"purpose":     o.Purpose,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListCredentialsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
			"purpose":     types.StringType,
		},
	}
}

type ListCredentialsResponse struct {
	Credentials types.List `tfsdk:"credentials"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListCredentialsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListCredentialsResponse) {
}

func (toState *ListCredentialsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListCredentialsResponse) {
}

func (c ListCredentialsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["credentials"] = attrs["credentials"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListCredentialsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListCredentialsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"credentials": reflect.TypeOf(CredentialInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListCredentialsResponse
// only implements ToObjectValue() and Type().
func (o ListCredentialsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"credentials":     o.Credentials,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListCredentialsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"credentials": basetypes.ListType{
				ElemType: CredentialInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetCredentials returns the value of the Credentials field in ListCredentialsResponse as
// a slice of CredentialInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListCredentialsResponse) GetCredentials(ctx context.Context) ([]CredentialInfo, bool) {
	if o.Credentials.IsNull() || o.Credentials.IsUnknown() {
		return nil, false
	}
	var v []CredentialInfo
	d := o.Credentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCredentials sets the value of the Credentials field in ListCredentialsResponse.
func (o *ListCredentialsResponse) SetCredentials(ctx context.Context, v []CredentialInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["credentials"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Credentials = types.ListValueMust(t, vs)
}

type ListEntityTagAssignmentsRequest struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`
	// Optional. Maximum number of tag assignments to return in a single page
	MaxResults types.Int64 `tfsdk:"-"`
	// Optional. Pagination token to retrieve the next page of results
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListEntityTagAssignmentsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListEntityTagAssignmentsRequest) {
}

func (toState *ListEntityTagAssignmentsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListEntityTagAssignmentsRequest) {
}

func (c ListEntityTagAssignmentsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListEntityTagAssignmentsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListEntityTagAssignmentsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListEntityTagAssignmentsRequest
// only implements ToObjectValue() and Type().
func (o ListEntityTagAssignmentsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name": o.EntityName,
			"entity_type": o.EntityType,
			"max_results": o.MaxResults,
			"page_token":  o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListEntityTagAssignmentsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name": types.StringType,
			"entity_type": types.StringType,
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListEntityTagAssignmentsResponse struct {
	// Optional. Pagination token for retrieving the next page of results
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The list of tag assignments
	TagAssignments types.List `tfsdk:"tag_assignments"`
}

func (toState *ListEntityTagAssignmentsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListEntityTagAssignmentsResponse) {
}

func (toState *ListEntityTagAssignmentsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListEntityTagAssignmentsResponse) {
}

func (c ListEntityTagAssignmentsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["tag_assignments"] = attrs["tag_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListEntityTagAssignmentsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListEntityTagAssignmentsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tag_assignments": reflect.TypeOf(EntityTagAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListEntityTagAssignmentsResponse
// only implements ToObjectValue() and Type().
func (o ListEntityTagAssignmentsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"tag_assignments": o.TagAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListEntityTagAssignmentsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"tag_assignments": basetypes.ListType{
				ElemType: EntityTagAssignment{}.Type(ctx),
			},
		},
	}
}

// GetTagAssignments returns the value of the TagAssignments field in ListEntityTagAssignmentsResponse as
// a slice of EntityTagAssignment values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListEntityTagAssignmentsResponse) GetTagAssignments(ctx context.Context) ([]EntityTagAssignment, bool) {
	if o.TagAssignments.IsNull() || o.TagAssignments.IsUnknown() {
		return nil, false
	}
	var v []EntityTagAssignment
	d := o.TagAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTagAssignments sets the value of the TagAssignments field in ListEntityTagAssignmentsResponse.
func (o *ListEntityTagAssignmentsResponse) SetTagAssignments(ctx context.Context, v []EntityTagAssignment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["tag_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.TagAssignments = types.ListValueMust(t, vs)
}

type ListExternalLineageRelationshipsRequest struct {
	// The lineage direction to filter on.
	LineageDirection types.String `tfsdk:"-"`
	// The object to query external lineage relationships for. Since this field
	// is a query parameter, please flatten the nested fields. For example, if
	// the object is a table, the query parameter should look like:
	// `object_info.table.name=main.sales.customers`
	ObjectInfo types.Object `tfsdk:"-"`
	// Specifies the maximum number of external lineage relationships to return
	// in a single response. The value must be less than or equal to 1000.
	PageSize types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListExternalLineageRelationshipsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListExternalLineageRelationshipsRequest) {
	if !fromPlan.ObjectInfo.IsNull() && !fromPlan.ObjectInfo.IsUnknown() {
		if toStateObjectInfo, ok := toState.GetObjectInfo(ctx); ok {
			if fromPlanObjectInfo, ok := fromPlan.GetObjectInfo(ctx); ok {
				toStateObjectInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanObjectInfo)
				toState.SetObjectInfo(ctx, toStateObjectInfo)
			}
		}
	}
}

func (toState *ListExternalLineageRelationshipsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListExternalLineageRelationshipsRequest) {
	if !fromState.ObjectInfo.IsNull() && !fromState.ObjectInfo.IsUnknown() {
		if toStateObjectInfo, ok := toState.GetObjectInfo(ctx); ok {
			if fromStateObjectInfo, ok := fromState.GetObjectInfo(ctx); ok {
				toStateObjectInfo.SyncFieldsDuringRead(ctx, fromStateObjectInfo)
				toState.SetObjectInfo(ctx, toStateObjectInfo)
			}
		}
	}
}

func (c ListExternalLineageRelationshipsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["object_info"] = attrs["object_info"].SetRequired()
	attrs["lineage_direction"] = attrs["lineage_direction"].SetRequired()
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLineageRelationshipsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListExternalLineageRelationshipsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"object_info": reflect.TypeOf(ExternalLineageObject{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLineageRelationshipsRequest
// only implements ToObjectValue() and Type().
func (o ListExternalLineageRelationshipsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"lineage_direction": o.LineageDirection,
			"object_info":       o.ObjectInfo,
			"page_size":         o.PageSize,
			"page_token":        o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListExternalLineageRelationshipsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"lineage_direction": types.StringType,
			"object_info":       ExternalLineageObject{}.Type(ctx),
			"page_size":         types.Int64Type,
			"page_token":        types.StringType,
		},
	}
}

// GetObjectInfo returns the value of the ObjectInfo field in ListExternalLineageRelationshipsRequest as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *ListExternalLineageRelationshipsRequest) GetObjectInfo(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.ObjectInfo.IsNull() || o.ObjectInfo.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.ObjectInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetObjectInfo sets the value of the ObjectInfo field in ListExternalLineageRelationshipsRequest.
func (o *ListExternalLineageRelationshipsRequest) SetObjectInfo(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.ObjectInfo = vs
}

type ListExternalLineageRelationshipsResponse struct {
	ExternalLineageRelationships types.List `tfsdk:"external_lineage_relationships"`

	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListExternalLineageRelationshipsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListExternalLineageRelationshipsResponse) {
}

func (toState *ListExternalLineageRelationshipsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListExternalLineageRelationshipsResponse) {
}

func (c ListExternalLineageRelationshipsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationships"] = attrs["external_lineage_relationships"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLineageRelationshipsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListExternalLineageRelationshipsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationships": reflect.TypeOf(ExternalLineageInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLineageRelationshipsResponse
// only implements ToObjectValue() and Type().
func (o ListExternalLineageRelationshipsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationships": o.ExternalLineageRelationships,
			"next_page_token":                o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListExternalLineageRelationshipsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationships": basetypes.ListType{
				ElemType: ExternalLineageInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetExternalLineageRelationships returns the value of the ExternalLineageRelationships field in ListExternalLineageRelationshipsResponse as
// a slice of ExternalLineageInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListExternalLineageRelationshipsResponse) GetExternalLineageRelationships(ctx context.Context) ([]ExternalLineageInfo, bool) {
	if o.ExternalLineageRelationships.IsNull() || o.ExternalLineageRelationships.IsUnknown() {
		return nil, false
	}
	var v []ExternalLineageInfo
	d := o.ExternalLineageRelationships.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLineageRelationships sets the value of the ExternalLineageRelationships field in ListExternalLineageRelationshipsResponse.
func (o *ListExternalLineageRelationshipsResponse) SetExternalLineageRelationships(ctx context.Context, v []ExternalLineageInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["external_lineage_relationships"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ExternalLineageRelationships = types.ListValueMust(t, vs)
}

type ListExternalLocationsRequest struct {
	// Whether to include external locations in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of external locations to return. If not set, all the
	// external locations are returned (not recommended). - when set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - when set to 0, the page length is set to a server
	// configured value (recommended); - when set to a value less than 0, an
	// invalid parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListExternalLocationsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListExternalLocationsRequest) {
}

func (toState *ListExternalLocationsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListExternalLocationsRequest) {
}

func (c ListExternalLocationsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLocationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListExternalLocationsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLocationsRequest
// only implements ToObjectValue() and Type().
func (o ListExternalLocationsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListExternalLocationsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
		},
	}
}

type ListExternalLocationsResponse struct {
	// An array of external locations.
	ExternalLocations types.List `tfsdk:"external_locations"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListExternalLocationsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListExternalLocationsResponse) {
}

func (toState *ListExternalLocationsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListExternalLocationsResponse) {
}

func (c ListExternalLocationsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_locations"] = attrs["external_locations"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalLocationsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListExternalLocationsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_locations": reflect.TypeOf(ExternalLocationInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalLocationsResponse
// only implements ToObjectValue() and Type().
func (o ListExternalLocationsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_locations": o.ExternalLocations,
			"next_page_token":    o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListExternalLocationsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_locations": basetypes.ListType{
				ElemType: ExternalLocationInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetExternalLocations returns the value of the ExternalLocations field in ListExternalLocationsResponse as
// a slice of ExternalLocationInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListExternalLocationsResponse) GetExternalLocations(ctx context.Context) ([]ExternalLocationInfo, bool) {
	if o.ExternalLocations.IsNull() || o.ExternalLocations.IsUnknown() {
		return nil, false
	}
	var v []ExternalLocationInfo
	d := o.ExternalLocations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLocations sets the value of the ExternalLocations field in ListExternalLocationsResponse.
func (o *ListExternalLocationsResponse) SetExternalLocations(ctx context.Context, v []ExternalLocationInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["external_locations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ExternalLocations = types.ListValueMust(t, vs)
}

type ListExternalMetadataRequest struct {
	// Specifies the maximum number of external metadata objects to return in a
	// single response. The value must be less than or equal to 1000.
	PageSize types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListExternalMetadataRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListExternalMetadataRequest) {
}

func (toState *ListExternalMetadataRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListExternalMetadataRequest) {
}

func (c ListExternalMetadataRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListExternalMetadataRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalMetadataRequest
// only implements ToObjectValue() and Type().
func (o ListExternalMetadataRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":  o.PageSize,
			"page_token": o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListExternalMetadataRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

type ListExternalMetadataResponse struct {
	ExternalMetadata types.List `tfsdk:"external_metadata"`

	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListExternalMetadataResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListExternalMetadataResponse) {
}

func (toState *ListExternalMetadataResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListExternalMetadataResponse) {
}

func (c ListExternalMetadataResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListExternalMetadataResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListExternalMetadataResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalMetadata{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListExternalMetadataResponse
// only implements ToObjectValue() and Type().
func (o ListExternalMetadataResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": o.ExternalMetadata,
			"next_page_token":   o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListExternalMetadataResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": basetypes.ListType{
				ElemType: ExternalMetadata{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in ListExternalMetadataResponse as
// a slice of ExternalMetadata values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListExternalMetadataResponse) GetExternalMetadata(ctx context.Context) ([]ExternalMetadata, bool) {
	if o.ExternalMetadata.IsNull() || o.ExternalMetadata.IsUnknown() {
		return nil, false
	}
	var v []ExternalMetadata
	d := o.ExternalMetadata.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in ListExternalMetadataResponse.
func (o *ListExternalMetadataResponse) SetExternalMetadata(ctx context.Context, v []ExternalMetadata) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["external_metadata"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ExternalMetadata = types.ListValueMust(t, vs)
}

type ListFunctionsRequest struct {
	// Name of parent catalog for functions of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include functions in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of functions to return. If not set, all the functions are
	// returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// Parent schema of functions.
	SchemaName types.String `tfsdk:"-"`
}

func (toState *ListFunctionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListFunctionsRequest) {
}

func (toState *ListFunctionsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListFunctionsRequest) {
}

func (c ListFunctionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListFunctionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListFunctionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListFunctionsRequest
// only implements ToObjectValue() and Type().
func (o ListFunctionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   o.CatalogName,
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
			"schema_name":    o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListFunctionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"schema_name":    types.StringType,
		},
	}
}

type ListFunctionsResponse struct {
	// An array of function information objects.
	Functions types.List `tfsdk:"functions"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListFunctionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListFunctionsResponse) {
}

func (toState *ListFunctionsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListFunctionsResponse) {
}

func (c ListFunctionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["functions"] = attrs["functions"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListFunctionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListFunctionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"functions": reflect.TypeOf(FunctionInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListFunctionsResponse
// only implements ToObjectValue() and Type().
func (o ListFunctionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"functions":       o.Functions,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListFunctionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"functions": basetypes.ListType{
				ElemType: FunctionInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetFunctions returns the value of the Functions field in ListFunctionsResponse as
// a slice of FunctionInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListFunctionsResponse) GetFunctions(ctx context.Context) ([]FunctionInfo, bool) {
	if o.Functions.IsNull() || o.Functions.IsUnknown() {
		return nil, false
	}
	var v []FunctionInfo
	d := o.Functions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFunctions sets the value of the Functions field in ListFunctionsResponse.
func (o *ListFunctionsResponse) SetFunctions(ctx context.Context, v []FunctionInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["functions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Functions = types.ListValueMust(t, vs)
}

type ListMetastoresRequest struct {
	// Maximum number of metastores to return. - when set to a value greater
	// than 0, the page length is the minimum of this value and a server
	// configured value; - when set to 0, the page length is set to a server
	// configured value (recommended); - when set to a value less than 0, an
	// invalid parameter error is returned; - If not set, all the metastores are
	// returned (not recommended). - Note: The number of returned metastores
	// might be less than the specified max_results size, even zero. The only
	// definitive indication that no further metastores can be fetched is when
	// the next_page_token is unset from the response.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListMetastoresRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListMetastoresRequest) {
}

func (toState *ListMetastoresRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListMetastoresRequest) {
}

func (c ListMetastoresRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListMetastoresRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListMetastoresRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListMetastoresRequest
// only implements ToObjectValue() and Type().
func (o ListMetastoresRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": o.MaxResults,
			"page_token":  o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListMetastoresRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListMetastoresResponse struct {
	// An array of metastore information objects.
	Metastores types.List `tfsdk:"metastores"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListMetastoresResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListMetastoresResponse) {
}

func (toState *ListMetastoresResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListMetastoresResponse) {
}

func (c ListMetastoresResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastores"] = attrs["metastores"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListMetastoresResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListMetastoresResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"metastores": reflect.TypeOf(MetastoreInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListMetastoresResponse
// only implements ToObjectValue() and Type().
func (o ListMetastoresResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastores":      o.Metastores,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListMetastoresResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastores": basetypes.ListType{
				ElemType: MetastoreInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetMetastores returns the value of the Metastores field in ListMetastoresResponse as
// a slice of MetastoreInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListMetastoresResponse) GetMetastores(ctx context.Context) ([]MetastoreInfo, bool) {
	if o.Metastores.IsNull() || o.Metastores.IsUnknown() {
		return nil, false
	}
	var v []MetastoreInfo
	d := o.Metastores.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetastores sets the value of the Metastores field in ListMetastoresResponse.
func (o *ListMetastoresResponse) SetMetastores(ctx context.Context, v []MetastoreInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["metastores"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Metastores = types.ListValueMust(t, vs)
}

type ListModelVersionsRequest struct {
	// The full three-level name of the registered model under which to list
	// model versions
	FullName types.String `tfsdk:"-"`
	// Whether to include model versions in the response for which the principal
	// can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of model versions to return. If not set, the page length
	// is set to a server configured value (100, as of 1/3/2024). - when set to
	// a value greater than 0, the page length is the minimum of this value and
	// a server configured value(1000, as of 1/3/2024); - when set to 0, the
	// page length is set to a server configured value (100, as of 1/3/2024)
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListModelVersionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListModelVersionsRequest) {
}

func (toState *ListModelVersionsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListModelVersionsRequest) {
}

func (c ListModelVersionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListModelVersionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListModelVersionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListModelVersionsRequest
// only implements ToObjectValue() and Type().
func (o ListModelVersionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      o.FullName,
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListModelVersionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
		},
	}
}

type ListModelVersionsResponse struct {
	ModelVersions types.List `tfsdk:"model_versions"`
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (toState *ListModelVersionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListModelVersionsResponse) {
}

func (toState *ListModelVersionsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListModelVersionsResponse) {
}

func (c ListModelVersionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["model_versions"] = attrs["model_versions"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListModelVersionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListModelVersionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"model_versions": reflect.TypeOf(ModelVersionInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListModelVersionsResponse
// only implements ToObjectValue() and Type().
func (o ListModelVersionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"model_versions":  o.ModelVersions,
			"next_page_token": o.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListModelVersionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"model_versions": basetypes.ListType{
				ElemType: ModelVersionInfo{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetModelVersions returns the value of the ModelVersions field in ListModelVersionsResponse as
// a slice of ModelVersionInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListModelVersionsResponse) GetModelVersions(ctx context.Context) ([]ModelVersionInfo, bool) {
	if o.ModelVersions.IsNull() || o.ModelVersions.IsUnknown() {
		return nil, false
	}
	var v []ModelVersionInfo
	d := o.ModelVersions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetModelVersions sets the value of the ModelVersions field in ListModelVersionsResponse.
func (o *ListModelVersionsResponse) SetModelVersions(ctx context.Context, v []ModelVersionInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["model_versions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ModelVersions = types.ListValueMust(t, vs)
}

type ListPoliciesRequest struct {
	// Optional. Whether to include policies defined on parent securables. By
	// default, the inherited policies are not included.
	IncludeInherited types.Bool `tfsdk:"-"`
	// Optional. Maximum number of policies to return on a single page (page
	// length). - When not set or set to 0, the page length is set to a server
	// configured value (recommended); - When set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value;
	MaxResults types.Int64 `tfsdk:"-"`
	// Required. The fully qualified name of securable to list policies for.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to list policies for.
	OnSecurableType types.String `tfsdk:"-"`
	// Optional. Opaque pagination token to go to next page based on previous
	// query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListPoliciesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListPoliciesRequest) {
}

func (toState *ListPoliciesRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListPoliciesRequest) {
}

func (c ListPoliciesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["include_inherited"] = attrs["include_inherited"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListPoliciesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListPoliciesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListPoliciesRequest
// only implements ToObjectValue() and Type().
func (o ListPoliciesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_inherited":     o.IncludeInherited,
			"max_results":           o.MaxResults,
			"on_securable_fullname": o.OnSecurableFullname,
			"on_securable_type":     o.OnSecurableType,
			"page_token":            o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListPoliciesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_inherited":     types.BoolType,
			"max_results":           types.Int64Type,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"page_token":            types.StringType,
		},
	}
}

type ListPoliciesResponse struct {
	// Optional opaque token for continuing pagination. `page_token` should be
	// set to this value for the next request to retrieve the next page of
	// results.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The list of retrieved policies.
	Policies types.List `tfsdk:"policies"`
}

func (toState *ListPoliciesResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListPoliciesResponse) {
}

func (toState *ListPoliciesResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListPoliciesResponse) {
}

func (c ListPoliciesResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetComputed()
	attrs["policies"] = attrs["policies"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListPoliciesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListPoliciesResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"policies": reflect.TypeOf(PolicyInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListPoliciesResponse
// only implements ToObjectValue() and Type().
func (o ListPoliciesResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"policies":        o.Policies,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListPoliciesResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"policies": basetypes.ListType{
				ElemType: PolicyInfo{}.Type(ctx),
			},
		},
	}
}

// GetPolicies returns the value of the Policies field in ListPoliciesResponse as
// a slice of PolicyInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListPoliciesResponse) GetPolicies(ctx context.Context) ([]PolicyInfo, bool) {
	if o.Policies.IsNull() || o.Policies.IsUnknown() {
		return nil, false
	}
	var v []PolicyInfo
	d := o.Policies.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPolicies sets the value of the Policies field in ListPoliciesResponse.
func (o *ListPoliciesResponse) SetPolicies(ctx context.Context, v []PolicyInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["policies"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Policies = types.ListValueMust(t, vs)
}

type ListQuotasRequest struct {
	// The number of quotas to return.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token for the next page of results.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListQuotasRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListQuotasRequest) {
}

func (toState *ListQuotasRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListQuotasRequest) {
}

func (c ListQuotasRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListQuotasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListQuotasRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListQuotasRequest
// only implements ToObjectValue() and Type().
func (o ListQuotasRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": o.MaxResults,
			"page_token":  o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListQuotasRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListQuotasResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of returned QuotaInfos.
	Quotas types.List `tfsdk:"quotas"`
}

func (toState *ListQuotasResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListQuotasResponse) {
}

func (toState *ListQuotasResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListQuotasResponse) {
}

func (c ListQuotasResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["quotas"] = attrs["quotas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListQuotasResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListQuotasResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quotas": reflect.TypeOf(QuotaInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListQuotasResponse
// only implements ToObjectValue() and Type().
func (o ListQuotasResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"quotas":          o.Quotas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListQuotasResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"quotas": basetypes.ListType{
				ElemType: QuotaInfo{}.Type(ctx),
			},
		},
	}
}

// GetQuotas returns the value of the Quotas field in ListQuotasResponse as
// a slice of QuotaInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListQuotasResponse) GetQuotas(ctx context.Context) ([]QuotaInfo, bool) {
	if o.Quotas.IsNull() || o.Quotas.IsUnknown() {
		return nil, false
	}
	var v []QuotaInfo
	d := o.Quotas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQuotas sets the value of the Quotas field in ListQuotasResponse.
func (o *ListQuotasResponse) SetQuotas(ctx context.Context, v []QuotaInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["quotas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Quotas = types.ListValueMust(t, vs)
}

type ListRefreshesRequest struct {
	// UC table name in format `catalog.schema.table_name`. table_name is case
	// insensitive and spaces are disallowed.
	TableName types.String `tfsdk:"-"`
}

func (toState *ListRefreshesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListRefreshesRequest) {
}

func (toState *ListRefreshesRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListRefreshesRequest) {
}

func (c ListRefreshesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRefreshesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListRefreshesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRefreshesRequest
// only implements ToObjectValue() and Type().
func (o ListRefreshesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": o.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListRefreshesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

type ListRegisteredModelsRequest struct {
	// The identifier of the catalog under which to list registered models. If
	// specified, schema_name must be specified.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include registered models in the response for which the
	// principal can only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Max number of registered models to return.
	//
	// If both catalog and schema are specified: - when max_results is not
	// specified, the page length is set to a server configured value (10000, as
	// of 4/2/2024). - when set to a value greater than 0, the page length is
	// the minimum of this value and a server configured value (10000, as of
	// 4/2/2024); - when set to 0, the page length is set to a server configured
	// value (10000, as of 4/2/2024); - when set to a value less than 0, an
	// invalid parameter error is returned;
	//
	// If neither schema nor catalog is specified: - when max_results is not
	// specified, the page length is set to a server configured value (100, as
	// of 4/2/2024). - when set to a value greater than 0, the page length is
	// the minimum of this value and a server configured value (1000, as of
	// 4/2/2024); - when set to 0, the page length is set to a server configured
	// value (100, as of 4/2/2024); - when set to a value less than 0, an
	// invalid parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token to send for the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// The identifier of the schema under which to list registered models. If
	// specified, catalog_name must be specified.
	SchemaName types.String `tfsdk:"-"`
}

func (toState *ListRegisteredModelsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListRegisteredModelsRequest) {
}

func (toState *ListRegisteredModelsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListRegisteredModelsRequest) {
}

func (c ListRegisteredModelsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRegisteredModelsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListRegisteredModelsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRegisteredModelsRequest
// only implements ToObjectValue() and Type().
func (o ListRegisteredModelsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   o.CatalogName,
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
			"schema_name":    o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListRegisteredModelsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"schema_name":    types.StringType,
		},
	}
}

type ListRegisteredModelsResponse struct {
	// Opaque token for pagination. Omitted if there are no more results.
	// page_token should be set to this value for fetching the next page.
	NextPageToken types.String `tfsdk:"next_page_token"`

	RegisteredModels types.List `tfsdk:"registered_models"`
}

func (toState *ListRegisteredModelsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListRegisteredModelsResponse) {
}

func (toState *ListRegisteredModelsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListRegisteredModelsResponse) {
}

func (c ListRegisteredModelsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["registered_models"] = attrs["registered_models"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRegisteredModelsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListRegisteredModelsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"registered_models": reflect.TypeOf(RegisteredModelInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRegisteredModelsResponse
// only implements ToObjectValue() and Type().
func (o ListRegisteredModelsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":   o.NextPageToken,
			"registered_models": o.RegisteredModels,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListRegisteredModelsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"registered_models": basetypes.ListType{
				ElemType: RegisteredModelInfo{}.Type(ctx),
			},
		},
	}
}

// GetRegisteredModels returns the value of the RegisteredModels field in ListRegisteredModelsResponse as
// a slice of RegisteredModelInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListRegisteredModelsResponse) GetRegisteredModels(ctx context.Context) ([]RegisteredModelInfo, bool) {
	if o.RegisteredModels.IsNull() || o.RegisteredModels.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelInfo
	d := o.RegisteredModels.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRegisteredModels sets the value of the RegisteredModels field in ListRegisteredModelsResponse.
func (o *ListRegisteredModelsResponse) SetRegisteredModels(ctx context.Context, v []RegisteredModelInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["registered_models"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.RegisteredModels = types.ListValueMust(t, vs)
}

type ListSchemasRequest struct {
	// Parent catalog for schemas of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include schemas in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of schemas to return. If not set, all the schemas are
	// returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListSchemasRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListSchemasRequest) {
}

func (toState *ListSchemasRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListSchemasRequest) {
}

func (c ListSchemasRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSchemasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListSchemasRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSchemasRequest
// only implements ToObjectValue() and Type().
func (o ListSchemasRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   o.CatalogName,
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListSchemasRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
		},
	}
}

type ListSchemasResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of schema information objects.
	Schemas types.List `tfsdk:"schemas"`
}

func (toState *ListSchemasResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListSchemasResponse) {
}

func (toState *ListSchemasResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListSchemasResponse) {
}

func (c ListSchemasResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSchemasResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListSchemasResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schemas": reflect.TypeOf(SchemaInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSchemasResponse
// only implements ToObjectValue() and Type().
func (o ListSchemasResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"schemas":         o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListSchemasResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"schemas": basetypes.ListType{
				ElemType: SchemaInfo{}.Type(ctx),
			},
		},
	}
}

// GetSchemas returns the value of the Schemas field in ListSchemasResponse as
// a slice of SchemaInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListSchemasResponse) GetSchemas(ctx context.Context) ([]SchemaInfo, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []SchemaInfo
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListSchemasResponse.
func (o *ListSchemasResponse) SetSchemas(ctx context.Context, v []SchemaInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type ListStorageCredentialsRequest struct {
	// Maximum number of storage credentials to return. If not set, all the
	// storage credentials are returned (not recommended). - when set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - when set to 0, the page length is set to a server
	// configured value (recommended); - when set to a value less than 0, an
	// invalid parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListStorageCredentialsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListStorageCredentialsRequest) {
}

func (toState *ListStorageCredentialsRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListStorageCredentialsRequest) {
}

func (c ListStorageCredentialsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListStorageCredentialsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListStorageCredentialsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListStorageCredentialsRequest
// only implements ToObjectValue() and Type().
func (o ListStorageCredentialsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results": o.MaxResults,
			"page_token":  o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListStorageCredentialsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results": types.Int64Type,
			"page_token":  types.StringType,
		},
	}
}

type ListStorageCredentialsResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`

	StorageCredentials types.List `tfsdk:"storage_credentials"`
}

func (toState *ListStorageCredentialsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListStorageCredentialsResponse) {
}

func (toState *ListStorageCredentialsResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListStorageCredentialsResponse) {
}

func (c ListStorageCredentialsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["storage_credentials"] = attrs["storage_credentials"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListStorageCredentialsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListStorageCredentialsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"storage_credentials": reflect.TypeOf(StorageCredentialInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListStorageCredentialsResponse
// only implements ToObjectValue() and Type().
func (o ListStorageCredentialsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":     o.NextPageToken,
			"storage_credentials": o.StorageCredentials,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListStorageCredentialsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"storage_credentials": basetypes.ListType{
				ElemType: StorageCredentialInfo{}.Type(ctx),
			},
		},
	}
}

// GetStorageCredentials returns the value of the StorageCredentials field in ListStorageCredentialsResponse as
// a slice of StorageCredentialInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListStorageCredentialsResponse) GetStorageCredentials(ctx context.Context) ([]StorageCredentialInfo, bool) {
	if o.StorageCredentials.IsNull() || o.StorageCredentials.IsUnknown() {
		return nil, false
	}
	var v []StorageCredentialInfo
	d := o.StorageCredentials.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStorageCredentials sets the value of the StorageCredentials field in ListStorageCredentialsResponse.
func (o *ListStorageCredentialsResponse) SetStorageCredentials(ctx context.Context, v []StorageCredentialInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["storage_credentials"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.StorageCredentials = types.ListValueMust(t, vs)
}

type ListSummariesRequest struct {
	// Name of parent catalog for tables of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include a manifest containing table capabilities in the
	// response.
	IncludeManifestCapabilities types.Bool `tfsdk:"-"`
	// Maximum number of summaries for tables to return. If not set, the page
	// length is set to a server configured value (10000, as of 1/5/2024). -
	// when set to a value greater than 0, the page length is the minimum of
	// this value and a server configured value (10000, as of 1/5/2024); - when
	// set to 0, the page length is set to a server configured value (10000, as
	// of 1/5/2024) (recommended); - when set to a value less than 0, an invalid
	// parameter error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
	// A sql LIKE pattern (% and _) for schema names. All schemas will be
	// returned if not set or empty.
	SchemaNamePattern types.String `tfsdk:"-"`
	// A sql LIKE pattern (% and _) for table names. All tables will be returned
	// if not set or empty.
	TableNamePattern types.String `tfsdk:"-"`
}

func (toState *ListSummariesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListSummariesRequest) {
}

func (toState *ListSummariesRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListSummariesRequest) {
}

func (c ListSummariesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name_pattern"] = attrs["schema_name_pattern"].SetOptional()
	attrs["table_name_pattern"] = attrs["table_name_pattern"].SetOptional()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_manifest_capabilities"] = attrs["include_manifest_capabilities"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSummariesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListSummariesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSummariesRequest
// only implements ToObjectValue() and Type().
func (o ListSummariesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":                  o.CatalogName,
			"include_manifest_capabilities": o.IncludeManifestCapabilities,
			"max_results":                   o.MaxResults,
			"page_token":                    o.PageToken,
			"schema_name_pattern":           o.SchemaNamePattern,
			"table_name_pattern":            o.TableNamePattern,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListSummariesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":                  types.StringType,
			"include_manifest_capabilities": types.BoolType,
			"max_results":                   types.Int64Type,
			"page_token":                    types.StringType,
			"schema_name_pattern":           types.StringType,
			"table_name_pattern":            types.StringType,
		},
	}
}

type ListSystemSchemasRequest struct {
	// Maximum number of schemas to return. - When set to 0, the page length is
	// set to a server configured value (recommended); - When set to a value
	// greater than 0, the page length is the minimum of this value and a server
	// configured value; - When set to a value less than 0, an invalid parameter
	// error is returned; - If not set, all the schemas are returned (not
	// recommended).
	MaxResults types.Int64 `tfsdk:"-"`
	// The ID for the metastore in which the system schema resides.
	MetastoreId types.String `tfsdk:"-"`
	// Opaque pagination token to go to next page based on previous query.
	PageToken types.String `tfsdk:"-"`
}

func (toState *ListSystemSchemasRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListSystemSchemasRequest) {
}

func (toState *ListSystemSchemasRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListSystemSchemasRequest) {
}

func (c ListSystemSchemasRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSystemSchemasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListSystemSchemasRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSystemSchemasRequest
// only implements ToObjectValue() and Type().
func (o ListSystemSchemasRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"max_results":  o.MaxResults,
			"metastore_id": o.MetastoreId,
			"page_token":   o.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListSystemSchemasRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"max_results":  types.Int64Type,
			"metastore_id": types.StringType,
			"page_token":   types.StringType,
		},
	}
}

type ListSystemSchemasResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of system schema information objects.
	Schemas types.List `tfsdk:"schemas"`
}

func (toState *ListSystemSchemasResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListSystemSchemasResponse) {
}

func (toState *ListSystemSchemasResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListSystemSchemasResponse) {
}

func (c ListSystemSchemasResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSystemSchemasResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListSystemSchemasResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schemas": reflect.TypeOf(SystemSchemaInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSystemSchemasResponse
// only implements ToObjectValue() and Type().
func (o ListSystemSchemasResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"schemas":         o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListSystemSchemasResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"schemas": basetypes.ListType{
				ElemType: SystemSchemaInfo{}.Type(ctx),
			},
		},
	}
}

// GetSchemas returns the value of the Schemas field in ListSystemSchemasResponse as
// a slice of SystemSchemaInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListSystemSchemasResponse) GetSchemas(ctx context.Context) ([]SystemSchemaInfo, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []SystemSchemaInfo
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListSystemSchemasResponse.
func (o *ListSystemSchemasResponse) SetSchemas(ctx context.Context, v []SystemSchemaInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type ListTableSummariesResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// List of table summaries.
	Tables types.List `tfsdk:"tables"`
}

func (toState *ListTableSummariesResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListTableSummariesResponse) {
}

func (toState *ListTableSummariesResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListTableSummariesResponse) {
}

func (c ListTableSummariesResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["tables"] = attrs["tables"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListTableSummariesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListTableSummariesResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tables": reflect.TypeOf(TableSummary{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListTableSummariesResponse
// only implements ToObjectValue() and Type().
func (o ListTableSummariesResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"tables":          o.Tables,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListTableSummariesResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"tables": basetypes.ListType{
				ElemType: TableSummary{}.Type(ctx),
			},
		},
	}
}

// GetTables returns the value of the Tables field in ListTableSummariesResponse as
// a slice of TableSummary values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListTableSummariesResponse) GetTables(ctx context.Context) ([]TableSummary, bool) {
	if o.Tables.IsNull() || o.Tables.IsUnknown() {
		return nil, false
	}
	var v []TableSummary
	d := o.Tables.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTables sets the value of the Tables field in ListTableSummariesResponse.
func (o *ListTableSummariesResponse) SetTables(ctx context.Context, v []TableSummary) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["tables"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Tables = types.ListValueMust(t, vs)
}

type ListTablesRequest struct {
	// Name of parent catalog for tables of interest.
	CatalogName types.String `tfsdk:"-"`
	// Whether to include tables in the response for which the principal can
	// only access selective metadata for.
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Whether to include a manifest containing table capabilities in the
	// response.
	IncludeManifestCapabilities types.Bool `tfsdk:"-"`
	// Maximum number of tables to return. If not set, all the tables are
	// returned (not recommended). - when set to a value greater than 0, the
	// page length is the minimum of this value and a server configured value; -
	// when set to 0, the page length is set to a server configured value
	// (recommended); - when set to a value less than 0, an invalid parameter
	// error is returned;
	MaxResults types.Int64 `tfsdk:"-"`
	// Whether to omit the columns of the table from the response or not.
	OmitColumns types.Bool `tfsdk:"-"`
	// Whether to omit the properties of the table from the response or not.
	OmitProperties types.Bool `tfsdk:"-"`
	// Whether to omit the username of the table (e.g. owner, updated_by,
	// created_by) from the response or not.
	OmitUsername types.Bool `tfsdk:"-"`
	// Opaque token to send for the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// Parent schema of tables.
	SchemaName types.String `tfsdk:"-"`
}

func (toState *ListTablesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListTablesRequest) {
}

func (toState *ListTablesRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListTablesRequest) {
}

func (c ListTablesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["omit_columns"] = attrs["omit_columns"].SetOptional()
	attrs["omit_properties"] = attrs["omit_properties"].SetOptional()
	attrs["omit_username"] = attrs["omit_username"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()
	attrs["include_manifest_capabilities"] = attrs["include_manifest_capabilities"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListTablesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListTablesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListTablesRequest
// only implements ToObjectValue() and Type().
func (o ListTablesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":                  o.CatalogName,
			"include_browse":                o.IncludeBrowse,
			"include_manifest_capabilities": o.IncludeManifestCapabilities,
			"max_results":                   o.MaxResults,
			"omit_columns":                  o.OmitColumns,
			"omit_properties":               o.OmitProperties,
			"omit_username":                 o.OmitUsername,
			"page_token":                    o.PageToken,
			"schema_name":                   o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListTablesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":                  types.StringType,
			"include_browse":                types.BoolType,
			"include_manifest_capabilities": types.BoolType,
			"max_results":                   types.Int64Type,
			"omit_columns":                  types.BoolType,
			"omit_properties":               types.BoolType,
			"omit_username":                 types.BoolType,
			"page_token":                    types.StringType,
			"schema_name":                   types.StringType,
		},
	}
}

type ListTablesResponse struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request (for the next page of results).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// An array of table information objects.
	Tables types.List `tfsdk:"tables"`
}

func (toState *ListTablesResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListTablesResponse) {
}

func (toState *ListTablesResponse) SyncFieldsDuringRead(ctx context.Context, fromState ListTablesResponse) {
}

func (c ListTablesResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["tables"] = attrs["tables"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListTablesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListTablesResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tables": reflect.TypeOf(TableInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListTablesResponse
// only implements ToObjectValue() and Type().
func (o ListTablesResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"tables":          o.Tables,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListTablesResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"tables": basetypes.ListType{
				ElemType: TableInfo{}.Type(ctx),
			},
		},
	}
}

// GetTables returns the value of the Tables field in ListTablesResponse as
// a slice of TableInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListTablesResponse) GetTables(ctx context.Context) ([]TableInfo, bool) {
	if o.Tables.IsNull() || o.Tables.IsUnknown() {
		return nil, false
	}
	var v []TableInfo
	d := o.Tables.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTables sets the value of the Tables field in ListTablesResponse.
func (o *ListTablesResponse) SetTables(ctx context.Context, v []TableInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["tables"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Tables = types.ListValueMust(t, vs)
}

type ListVolumesRequest struct {
	// The identifier of the catalog
	CatalogName types.String `tfsdk:"-"`
	// Whether to include volumes in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// Maximum number of volumes to return (page length).
	//
	// If not set, the page length is set to a server configured value (10000,
	// as of 1/29/2024). - when set to a value greater than 0, the page length
	// is the minimum of this value and a server configured value (10000, as of
	// 1/29/2024); - when set to 0, the page length is set to a server
	// configured value (10000, as of 1/29/2024) (recommended); - when set to a
	// value less than 0, an invalid parameter error is returned;
	//
	// Note: this parameter controls only the maximum number of volumes to
	// return. The actual number of volumes returned in a page may be smaller
	// than this value, including 0, even if there are more pages.
	MaxResults types.Int64 `tfsdk:"-"`
	// Opaque token returned by a previous request. It must be included in the
	// request to retrieve the next page of results (pagination).
	PageToken types.String `tfsdk:"-"`
	// The identifier of the schema
	SchemaName types.String `tfsdk:"-"`
}

func (toState *ListVolumesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListVolumesRequest) {
}

func (toState *ListVolumesRequest) SyncFieldsDuringRead(ctx context.Context, fromState ListVolumesRequest) {
}

func (c ListVolumesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetRequired()
	attrs["schema_name"] = attrs["schema_name"].SetRequired()
	attrs["max_results"] = attrs["max_results"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListVolumesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListVolumesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListVolumesRequest
// only implements ToObjectValue() and Type().
func (o ListVolumesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":   o.CatalogName,
			"include_browse": o.IncludeBrowse,
			"max_results":    o.MaxResults,
			"page_token":     o.PageToken,
			"schema_name":    o.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListVolumesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":   types.StringType,
			"include_browse": types.BoolType,
			"max_results":    types.Int64Type,
			"page_token":     types.StringType,
			"schema_name":    types.StringType,
		},
	}
}

type ListVolumesResponseContent struct {
	// Opaque token to retrieve the next page of results. Absent if there are no
	// more pages. __page_token__ should be set to this value for the next
	// request to retrieve the next page of results.
	NextPageToken types.String `tfsdk:"next_page_token"`

	Volumes types.List `tfsdk:"volumes"`
}

func (toState *ListVolumesResponseContent) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ListVolumesResponseContent) {
}

func (toState *ListVolumesResponseContent) SyncFieldsDuringRead(ctx context.Context, fromState ListVolumesResponseContent) {
}

func (c ListVolumesResponseContent) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["volumes"] = attrs["volumes"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListVolumesResponseContent.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListVolumesResponseContent) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"volumes": reflect.TypeOf(VolumeInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListVolumesResponseContent
// only implements ToObjectValue() and Type().
func (o ListVolumesResponseContent) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": o.NextPageToken,
			"volumes":         o.Volumes,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListVolumesResponseContent) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"volumes": basetypes.ListType{
				ElemType: VolumeInfo{}.Type(ctx),
			},
		},
	}
}

// GetVolumes returns the value of the Volumes field in ListVolumesResponseContent as
// a slice of VolumeInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListVolumesResponseContent) GetVolumes(ctx context.Context) ([]VolumeInfo, bool) {
	if o.Volumes.IsNull() || o.Volumes.IsUnknown() {
		return nil, false
	}
	var v []VolumeInfo
	d := o.Volumes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetVolumes sets the value of the Volumes field in ListVolumesResponseContent.
func (o *ListVolumesResponseContent) SetVolumes(ctx context.Context, v []VolumeInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["volumes"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Volumes = types.ListValueMust(t, vs)
}

type MatchColumn struct {
	// Optional alias of the matched column.
	Alias types.String `tfsdk:"alias"`
	// The condition expression used to match a table column.
	Condition types.String `tfsdk:"condition"`
}

func (toState *MatchColumn) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MatchColumn) {
}

func (toState *MatchColumn) SyncFieldsDuringRead(ctx context.Context, fromState MatchColumn) {
}

func (c MatchColumn) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias"] = attrs["alias"].SetOptional()
	attrs["condition"] = attrs["condition"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MatchColumn.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MatchColumn) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MatchColumn
// only implements ToObjectValue() and Type().
func (o MatchColumn) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":     o.Alias,
			"condition": o.Condition,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MatchColumn) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":     types.StringType,
			"condition": types.StringType,
		},
	}
}

type MetastoreAssignment struct {
	// The name of the default catalog in the metastore.
	DefaultCatalogName types.String `tfsdk:"default_catalog_name"`
	// The unique ID of the metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The unique ID of the Databricks workspace.
	WorkspaceId types.Int64 `tfsdk:"workspace_id"`
}

func (toState *MetastoreAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MetastoreAssignment) {
}

func (toState *MetastoreAssignment) SyncFieldsDuringRead(ctx context.Context, fromState MetastoreAssignment) {
}

func (c MetastoreAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default_catalog_name"] = attrs["default_catalog_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MetastoreAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MetastoreAssignment
// only implements ToObjectValue() and Type().
func (o MetastoreAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default_catalog_name": o.DefaultCatalogName,
			"metastore_id":         o.MetastoreId,
			"workspace_id":         o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MetastoreAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default_catalog_name": types.StringType,
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

type MetastoreInfo struct {
	// Cloud vendor of the metastore home shard (e.g., `aws`, `azure`, `gcp`).
	Cloud types.String `tfsdk:"cloud"`
	// Time at which this metastore was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of metastore creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of the metastore's (Default) Data Access Configuration.
	DefaultDataAccessConfigId types.String `tfsdk:"default_data_access_config_id"`
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// Whether to allow non-DBR clients to directly access entities under the
	// metastore.
	ExternalAccessEnabled types.Bool `tfsdk:"external_access_enabled"`
	// Globally unique metastore ID across clouds and regions, of the form
	// `cloud:region:metastore_id`.
	GlobalMetastoreId types.String `tfsdk:"global_metastore_id"`
	// Unique identifier of metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The user-specified name of the metastore.
	Name types.String `tfsdk:"name"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).
	Region types.String `tfsdk:"region"`
	// The storage root URL for metastore
	StorageRoot types.String `tfsdk:"storage_root"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
	// Name of the storage credential to access the metastore storage_root.
	StorageRootCredentialName types.String `tfsdk:"storage_root_credential_name"`
	// Time at which the metastore was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the metastore.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (toState *MetastoreInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MetastoreInfo) {
}

func (toState *MetastoreInfo) SyncFieldsDuringRead(ctx context.Context, fromState MetastoreInfo) {
}

func (c MetastoreInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["cloud"] = attrs["cloud"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["default_data_access_config_id"] = attrs["default_data_access_config_id"].SetOptional()
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["external_access_enabled"] = attrs["external_access_enabled"].SetOptional()
	attrs["global_metastore_id"] = attrs["global_metastore_id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["region"] = attrs["region"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()
	attrs["storage_root_credential_name"] = attrs["storage_root_credential_name"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MetastoreInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MetastoreInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MetastoreInfo
// only implements ToObjectValue() and Type().
func (o MetastoreInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cloud":                           o.Cloud,
			"created_at":                      o.CreatedAt,
			"created_by":                      o.CreatedBy,
			"default_data_access_config_id":   o.DefaultDataAccessConfigId,
			"delta_sharing_organization_name": o.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": o.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               o.DeltaSharingScope,
			"external_access_enabled":                           o.ExternalAccessEnabled,
			"global_metastore_id":                               o.GlobalMetastoreId,
			"metastore_id":                                      o.MetastoreId,
			"name":                                              o.Name,
			"owner":                                             o.Owner,
			"privilege_model_version":                           o.PrivilegeModelVersion,
			"region":                                            o.Region,
			"storage_root":                                      o.StorageRoot,
			"storage_root_credential_id":                        o.StorageRootCredentialId,
			"storage_root_credential_name":                      o.StorageRootCredentialName,
			"updated_at":                                        o.UpdatedAt,
			"updated_by":                                        o.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MetastoreInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cloud":                           types.StringType,
			"created_at":                      types.Int64Type,
			"created_by":                      types.StringType,
			"default_data_access_config_id":   types.StringType,
			"delta_sharing_organization_name": types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"external_access_enabled":                           types.BoolType,
			"global_metastore_id":                               types.StringType,
			"metastore_id":                                      types.StringType,
			"name":                                              types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"region":                                            types.StringType,
			"storage_root":                                      types.StringType,
			"storage_root_credential_id":                        types.StringType,
			"storage_root_credential_name":                      types.StringType,
			"updated_at":                                        types.Int64Type,
			"updated_by":                                        types.StringType,
		},
	}
}

type ModelVersionInfo struct {
	// List of aliases associated with the model version
	Aliases types.List `tfsdk:"aliases"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog containing the model version
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the model version
	Comment types.String `tfsdk:"comment"`

	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the model version
	CreatedBy types.String `tfsdk:"created_by"`
	// The unique identifier of the model version
	Id types.String `tfsdk:"id"`
	// The unique identifier of the metastore containing the model version
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the parent registered model of the model version, relative to
	// parent schema
	ModelName types.String `tfsdk:"model_name"`
	// Model version dependencies, for feature-store packaged models
	ModelVersionDependencies types.Object `tfsdk:"model_version_dependencies"`
	// MLflow run ID used when creating the model version, if ``source`` was
	// generated by an experiment run stored in an MLflow tracking server
	RunId types.String `tfsdk:"run_id"`
	// ID of the Databricks workspace containing the MLflow run that generated
	// this model version, if applicable
	RunWorkspaceId types.Int64 `tfsdk:"run_workspace_id"`
	// The name of the schema containing the model version, relative to parent
	// catalog
	SchemaName types.String `tfsdk:"schema_name"`
	// URI indicating the location of the source artifacts (files) for the model
	// version
	Source types.String `tfsdk:"source"`
	// Current status of the model version. Newly created model versions start
	// in PENDING_REGISTRATION status, then move to READY status once the model
	// version files are uploaded and the model version is finalized. Only model
	// versions in READY status can be loaded for inference or served.
	Status types.String `tfsdk:"status"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`

	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the model version last time
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Integer model version number, used to reference the model version in API
	// requests.
	Version types.Int64 `tfsdk:"version"`
}

func (toState *ModelVersionInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ModelVersionInfo) {
	if !fromPlan.ModelVersionDependencies.IsNull() && !fromPlan.ModelVersionDependencies.IsUnknown() {
		if toStateModelVersionDependencies, ok := toState.GetModelVersionDependencies(ctx); ok {
			if fromPlanModelVersionDependencies, ok := fromPlan.GetModelVersionDependencies(ctx); ok {
				toStateModelVersionDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanModelVersionDependencies)
				toState.SetModelVersionDependencies(ctx, toStateModelVersionDependencies)
			}
		}
	}
}

func (toState *ModelVersionInfo) SyncFieldsDuringRead(ctx context.Context, fromState ModelVersionInfo) {
	if !fromState.ModelVersionDependencies.IsNull() && !fromState.ModelVersionDependencies.IsUnknown() {
		if toStateModelVersionDependencies, ok := toState.GetModelVersionDependencies(ctx); ok {
			if fromStateModelVersionDependencies, ok := fromState.GetModelVersionDependencies(ctx); ok {
				toStateModelVersionDependencies.SyncFieldsDuringRead(ctx, fromStateModelVersionDependencies)
				toState.SetModelVersionDependencies(ctx, toStateModelVersionDependencies)
			}
		}
	}
}

func (c ModelVersionInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["model_version_dependencies"] = attrs["model_version_dependencies"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_workspace_id"] = attrs["run_workspace_id"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["version"] = attrs["version"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ModelVersionInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ModelVersionInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases":                    reflect.TypeOf(RegisteredModelAlias{}),
		"model_version_dependencies": reflect.TypeOf(DependencyList{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ModelVersionInfo
// only implements ToObjectValue() and Type().
func (o ModelVersionInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":                    o.Aliases,
			"browse_only":                o.BrowseOnly,
			"catalog_name":               o.CatalogName,
			"comment":                    o.Comment,
			"created_at":                 o.CreatedAt,
			"created_by":                 o.CreatedBy,
			"id":                         o.Id,
			"metastore_id":               o.MetastoreId,
			"model_name":                 o.ModelName,
			"model_version_dependencies": o.ModelVersionDependencies,
			"run_id":                     o.RunId,
			"run_workspace_id":           o.RunWorkspaceId,
			"schema_name":                o.SchemaName,
			"source":                     o.Source,
			"status":                     o.Status,
			"storage_location":           o.StorageLocation,
			"updated_at":                 o.UpdatedAt,
			"updated_by":                 o.UpdatedBy,
			"version":                    o.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ModelVersionInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias{}.Type(ctx),
			},
			"browse_only":                types.BoolType,
			"catalog_name":               types.StringType,
			"comment":                    types.StringType,
			"created_at":                 types.Int64Type,
			"created_by":                 types.StringType,
			"id":                         types.StringType,
			"metastore_id":               types.StringType,
			"model_name":                 types.StringType,
			"model_version_dependencies": DependencyList{}.Type(ctx),
			"run_id":                     types.StringType,
			"run_workspace_id":           types.Int64Type,
			"schema_name":                types.StringType,
			"source":                     types.StringType,
			"status":                     types.StringType,
			"storage_location":           types.StringType,
			"updated_at":                 types.Int64Type,
			"updated_by":                 types.StringType,
			"version":                    types.Int64Type,
		},
	}
}

// GetAliases returns the value of the Aliases field in ModelVersionInfo as
// a slice of RegisteredModelAlias values.
// If the field is unknown or null, the boolean return value is false.
func (o *ModelVersionInfo) GetAliases(ctx context.Context) ([]RegisteredModelAlias, bool) {
	if o.Aliases.IsNull() || o.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias
	d := o.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in ModelVersionInfo.
func (o *ModelVersionInfo) SetAliases(ctx context.Context, v []RegisteredModelAlias) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Aliases = types.ListValueMust(t, vs)
}

// GetModelVersionDependencies returns the value of the ModelVersionDependencies field in ModelVersionInfo as
// a DependencyList value.
// If the field is unknown or null, the boolean return value is false.
func (o *ModelVersionInfo) GetModelVersionDependencies(ctx context.Context) (DependencyList, bool) {
	var e DependencyList
	if o.ModelVersionDependencies.IsNull() || o.ModelVersionDependencies.IsUnknown() {
		return e, false
	}
	var v DependencyList
	d := o.ModelVersionDependencies.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetModelVersionDependencies sets the value of the ModelVersionDependencies field in ModelVersionInfo.
func (o *ModelVersionInfo) SetModelVersionDependencies(ctx context.Context, v DependencyList) {
	vs := v.ToObjectValue(ctx)
	o.ModelVersionDependencies = vs
}

type MonitorCronSchedule struct {
	// Read only field that indicates whether a schedule is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// The expression that determines when to run the monitor. See [examples].
	//
	// [examples]: https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html
	QuartzCronExpression types.String `tfsdk:"quartz_cron_expression"`
	// The timezone id (e.g., ``PST``) in which to evaluate the quartz
	// expression.
	TimezoneId types.String `tfsdk:"timezone_id"`
}

func (toState *MonitorCronSchedule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorCronSchedule) {
}

func (toState *MonitorCronSchedule) SyncFieldsDuringRead(ctx context.Context, fromState MonitorCronSchedule) {
}

func (c MonitorCronSchedule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["quartz_cron_expression"] = attrs["quartz_cron_expression"].SetRequired()
	attrs["timezone_id"] = attrs["timezone_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorCronSchedule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorCronSchedule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorCronSchedule
// only implements ToObjectValue() and Type().
func (o MonitorCronSchedule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"pause_status":           o.PauseStatus,
			"quartz_cron_expression": o.QuartzCronExpression,
			"timezone_id":            o.TimezoneId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorCronSchedule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"pause_status":           types.StringType,
			"quartz_cron_expression": types.StringType,
			"timezone_id":            types.StringType,
		},
	}
}

// Data classification related configuration.
type MonitorDataClassificationConfig struct {
	// Whether to enable data classification.
	Enabled types.Bool `tfsdk:"enabled"`
}

func (toState *MonitorDataClassificationConfig) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorDataClassificationConfig) {
}

func (toState *MonitorDataClassificationConfig) SyncFieldsDuringRead(ctx context.Context, fromState MonitorDataClassificationConfig) {
}

func (c MonitorDataClassificationConfig) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["enabled"] = attrs["enabled"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorDataClassificationConfig.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorDataClassificationConfig) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorDataClassificationConfig
// only implements ToObjectValue() and Type().
func (o MonitorDataClassificationConfig) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"enabled": o.Enabled,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorDataClassificationConfig) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"enabled": types.BoolType,
		},
	}
}

type MonitorDestination struct {
	// The list of email addresses to send the notification to. A maximum of 5
	// email addresses is supported.
	EmailAddresses types.List `tfsdk:"email_addresses"`
}

func (toState *MonitorDestination) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorDestination) {
}

func (toState *MonitorDestination) SyncFieldsDuringRead(ctx context.Context, fromState MonitorDestination) {
}

func (c MonitorDestination) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["email_addresses"] = attrs["email_addresses"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorDestination.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorDestination) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"email_addresses": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorDestination
// only implements ToObjectValue() and Type().
func (o MonitorDestination) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"email_addresses": o.EmailAddresses,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorDestination) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"email_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEmailAddresses returns the value of the EmailAddresses field in MonitorDestination as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorDestination) GetEmailAddresses(ctx context.Context) ([]types.String, bool) {
	if o.EmailAddresses.IsNull() || o.EmailAddresses.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.EmailAddresses.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailAddresses sets the value of the EmailAddresses field in MonitorDestination.
func (o *MonitorDestination) SetEmailAddresses(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["email_addresses"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.EmailAddresses = types.ListValueMust(t, vs)
}

type MonitorInferenceLog struct {
	// List of granularities to use when aggregating data into time windows
	// based on their timestamp.
	Granularities types.List `tfsdk:"granularities"`
	// Column for the label.
	LabelCol types.String `tfsdk:"label_col"`
	// Column for the model identifier.
	ModelIdCol types.String `tfsdk:"model_id_col"`
	// Column for the prediction.
	PredictionCol types.String `tfsdk:"prediction_col"`
	// Column for prediction probabilities
	PredictionProbaCol types.String `tfsdk:"prediction_proba_col"`
	// Problem type the model aims to solve.
	ProblemType types.String `tfsdk:"problem_type"`
	// Column for the timestamp.
	TimestampCol types.String `tfsdk:"timestamp_col"`
}

func (toState *MonitorInferenceLog) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorInferenceLog) {
}

func (toState *MonitorInferenceLog) SyncFieldsDuringRead(ctx context.Context, fromState MonitorInferenceLog) {
}

func (c MonitorInferenceLog) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["granularities"] = attrs["granularities"].SetRequired()
	attrs["label_col"] = attrs["label_col"].SetOptional()
	attrs["model_id_col"] = attrs["model_id_col"].SetRequired()
	attrs["prediction_col"] = attrs["prediction_col"].SetRequired()
	attrs["prediction_proba_col"] = attrs["prediction_proba_col"].SetOptional()
	attrs["problem_type"] = attrs["problem_type"].SetRequired()
	attrs["timestamp_col"] = attrs["timestamp_col"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorInferenceLog.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorInferenceLog) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"granularities": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorInferenceLog
// only implements ToObjectValue() and Type().
func (o MonitorInferenceLog) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"granularities":        o.Granularities,
			"label_col":            o.LabelCol,
			"model_id_col":         o.ModelIdCol,
			"prediction_col":       o.PredictionCol,
			"prediction_proba_col": o.PredictionProbaCol,
			"problem_type":         o.ProblemType,
			"timestamp_col":        o.TimestampCol,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorInferenceLog) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"granularities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"label_col":            types.StringType,
			"model_id_col":         types.StringType,
			"prediction_col":       types.StringType,
			"prediction_proba_col": types.StringType,
			"problem_type":         types.StringType,
			"timestamp_col":        types.StringType,
		},
	}
}

// GetGranularities returns the value of the Granularities field in MonitorInferenceLog as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInferenceLog) GetGranularities(ctx context.Context) ([]types.String, bool) {
	if o.Granularities.IsNull() || o.Granularities.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Granularities.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGranularities sets the value of the Granularities field in MonitorInferenceLog.
func (o *MonitorInferenceLog) SetGranularities(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["granularities"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Granularities = types.ListValueMust(t, vs)
}

type MonitorInfo struct {
	// [Create:REQ Update:IGN] Field for specifying the absolute path to a
	// custom directory to store data-monitoring assets. Normally prepopulated
	// to a default user location via UI and Python APIs.
	AssetsDir types.String `tfsdk:"assets_dir"`
	// [Create:OPT Update:OPT] Baseline table name. Baseline data is used to
	// compute drift from the data in the monitored `table_name`. The baseline
	// table and the monitored table shall have the same schema.
	BaselineTableName types.String `tfsdk:"baseline_table_name"`
	// [Create:OPT Update:OPT] Custom metrics.
	CustomMetrics types.List `tfsdk:"custom_metrics"`
	// [Create:ERR Update:OPT] Id of dashboard that visualizes the computed
	// metrics. This can be empty if the monitor is in PENDING state.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// [Create:OPT Update:OPT] Data classification related config.
	DataClassificationConfig types.Object `tfsdk:"data_classification_config"`
	// [Create:ERR Update:IGN] Table that stores drift metrics data. Format:
	// `catalog.schema.table_name`.
	DriftMetricsTableName types.String `tfsdk:"drift_metrics_table_name"`

	InferenceLog types.Object `tfsdk:"inference_log"`
	// [Create:ERR Update:IGN] The latest error message for a monitor failure.
	LatestMonitorFailureMsg types.String `tfsdk:"latest_monitor_failure_msg"`
	// [Create:ERR Update:IGN] Represents the current monitor configuration
	// version in use. The version will be represented in a numeric fashion
	// (1,2,3...). The field has flexibility to take on negative values, which
	// can indicate corrupted monitor_version numbers.
	MonitorVersion types.Int64 `tfsdk:"monitor_version"`
	// [Create:OPT Update:OPT] Field for specifying notification settings.
	Notifications types.Object `tfsdk:"notifications"`
	// [Create:REQ Update:REQ] Schema where output tables are created. Needs to
	// be in 2-level format {catalog}.{schema}
	OutputSchemaName types.String `tfsdk:"output_schema_name"`
	// [Create:ERR Update:IGN] Table that stores profile metrics data. Format:
	// `catalog.schema.table_name`.
	ProfileMetricsTableName types.String `tfsdk:"profile_metrics_table_name"`
	// [Create:OPT Update:OPT] The monitor schedule.
	Schedule types.Object `tfsdk:"schedule"`
	// [Create:OPT Update:OPT] List of column expressions to slice data with for
	// targeted analysis. The data is grouped by each expression independently,
	// resulting in a separate slice for each predicate and its complements. For
	// example `slicing_exprs=[col_1, col_2 > 10]` will generate the
	// following slices: two slices for `col_2 > 10` (True and False), and one
	// slice per unique value in `col1`. For high-cardinality columns, only the
	// top 100 unique values by frequency will generate slices.
	SlicingExprs types.List `tfsdk:"slicing_exprs"`
	// Configuration for monitoring snapshot tables.
	Snapshot types.Object `tfsdk:"snapshot"`
	// [Create:ERR Update:IGN] The monitor status.
	Status types.String `tfsdk:"status"`
	// [Create:ERR Update:IGN] UC table to monitor. Format:
	// `catalog.schema.table_name`
	TableName types.String `tfsdk:"table_name"`
	// Configuration for monitoring time series tables.
	TimeSeries types.Object `tfsdk:"time_series"`
}

func (toState *MonitorInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorInfo) {
	if !fromPlan.DataClassificationConfig.IsNull() && !fromPlan.DataClassificationConfig.IsUnknown() {
		if toStateDataClassificationConfig, ok := toState.GetDataClassificationConfig(ctx); ok {
			if fromPlanDataClassificationConfig, ok := fromPlan.GetDataClassificationConfig(ctx); ok {
				toStateDataClassificationConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDataClassificationConfig)
				toState.SetDataClassificationConfig(ctx, toStateDataClassificationConfig)
			}
		}
	}
	if !fromPlan.InferenceLog.IsNull() && !fromPlan.InferenceLog.IsUnknown() {
		if toStateInferenceLog, ok := toState.GetInferenceLog(ctx); ok {
			if fromPlanInferenceLog, ok := fromPlan.GetInferenceLog(ctx); ok {
				toStateInferenceLog.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInferenceLog)
				toState.SetInferenceLog(ctx, toStateInferenceLog)
			}
		}
	}
	if !fromPlan.Notifications.IsNull() && !fromPlan.Notifications.IsUnknown() {
		if toStateNotifications, ok := toState.GetNotifications(ctx); ok {
			if fromPlanNotifications, ok := fromPlan.GetNotifications(ctx); ok {
				toStateNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanNotifications)
				toState.SetNotifications(ctx, toStateNotifications)
			}
		}
	}
	if !fromPlan.Schedule.IsNull() && !fromPlan.Schedule.IsUnknown() {
		if toStateSchedule, ok := toState.GetSchedule(ctx); ok {
			if fromPlanSchedule, ok := fromPlan.GetSchedule(ctx); ok {
				toStateSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSchedule)
				toState.SetSchedule(ctx, toStateSchedule)
			}
		}
	}
	if !fromPlan.Snapshot.IsNull() && !fromPlan.Snapshot.IsUnknown() {
		if toStateSnapshot, ok := toState.GetSnapshot(ctx); ok {
			if fromPlanSnapshot, ok := fromPlan.GetSnapshot(ctx); ok {
				toStateSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSnapshot)
				toState.SetSnapshot(ctx, toStateSnapshot)
			}
		}
	}
	if !fromPlan.TimeSeries.IsNull() && !fromPlan.TimeSeries.IsUnknown() {
		if toStateTimeSeries, ok := toState.GetTimeSeries(ctx); ok {
			if fromPlanTimeSeries, ok := fromPlan.GetTimeSeries(ctx); ok {
				toStateTimeSeries.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTimeSeries)
				toState.SetTimeSeries(ctx, toStateTimeSeries)
			}
		}
	}
}

func (toState *MonitorInfo) SyncFieldsDuringRead(ctx context.Context, fromState MonitorInfo) {
	if !fromState.DataClassificationConfig.IsNull() && !fromState.DataClassificationConfig.IsUnknown() {
		if toStateDataClassificationConfig, ok := toState.GetDataClassificationConfig(ctx); ok {
			if fromStateDataClassificationConfig, ok := fromState.GetDataClassificationConfig(ctx); ok {
				toStateDataClassificationConfig.SyncFieldsDuringRead(ctx, fromStateDataClassificationConfig)
				toState.SetDataClassificationConfig(ctx, toStateDataClassificationConfig)
			}
		}
	}
	if !fromState.InferenceLog.IsNull() && !fromState.InferenceLog.IsUnknown() {
		if toStateInferenceLog, ok := toState.GetInferenceLog(ctx); ok {
			if fromStateInferenceLog, ok := fromState.GetInferenceLog(ctx); ok {
				toStateInferenceLog.SyncFieldsDuringRead(ctx, fromStateInferenceLog)
				toState.SetInferenceLog(ctx, toStateInferenceLog)
			}
		}
	}
	if !fromState.Notifications.IsNull() && !fromState.Notifications.IsUnknown() {
		if toStateNotifications, ok := toState.GetNotifications(ctx); ok {
			if fromStateNotifications, ok := fromState.GetNotifications(ctx); ok {
				toStateNotifications.SyncFieldsDuringRead(ctx, fromStateNotifications)
				toState.SetNotifications(ctx, toStateNotifications)
			}
		}
	}
	if !fromState.Schedule.IsNull() && !fromState.Schedule.IsUnknown() {
		if toStateSchedule, ok := toState.GetSchedule(ctx); ok {
			if fromStateSchedule, ok := fromState.GetSchedule(ctx); ok {
				toStateSchedule.SyncFieldsDuringRead(ctx, fromStateSchedule)
				toState.SetSchedule(ctx, toStateSchedule)
			}
		}
	}
	if !fromState.Snapshot.IsNull() && !fromState.Snapshot.IsUnknown() {
		if toStateSnapshot, ok := toState.GetSnapshot(ctx); ok {
			if fromStateSnapshot, ok := fromState.GetSnapshot(ctx); ok {
				toStateSnapshot.SyncFieldsDuringRead(ctx, fromStateSnapshot)
				toState.SetSnapshot(ctx, toStateSnapshot)
			}
		}
	}
	if !fromState.TimeSeries.IsNull() && !fromState.TimeSeries.IsUnknown() {
		if toStateTimeSeries, ok := toState.GetTimeSeries(ctx); ok {
			if fromStateTimeSeries, ok := fromState.GetTimeSeries(ctx); ok {
				toStateTimeSeries.SyncFieldsDuringRead(ctx, fromStateTimeSeries)
				toState.SetTimeSeries(ctx, toStateTimeSeries)
			}
		}
	}
}

func (c MonitorInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assets_dir"] = attrs["assets_dir"].SetOptional()
	attrs["baseline_table_name"] = attrs["baseline_table_name"].SetOptional()
	attrs["custom_metrics"] = attrs["custom_metrics"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].SetOptional()
	attrs["drift_metrics_table_name"] = attrs["drift_metrics_table_name"].SetRequired()
	attrs["inference_log"] = attrs["inference_log"].SetOptional()
	attrs["latest_monitor_failure_msg"] = attrs["latest_monitor_failure_msg"].SetOptional()
	attrs["monitor_version"] = attrs["monitor_version"].SetRequired()
	attrs["notifications"] = attrs["notifications"].SetOptional()
	attrs["output_schema_name"] = attrs["output_schema_name"].SetRequired()
	attrs["profile_metrics_table_name"] = attrs["profile_metrics_table_name"].SetRequired()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["slicing_exprs"] = attrs["slicing_exprs"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].SetOptional()
	attrs["status"] = attrs["status"].SetRequired()
	attrs["table_name"] = attrs["table_name"].SetRequired()
	attrs["time_series"] = attrs["time_series"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_metrics":             reflect.TypeOf(MonitorMetric{}),
		"data_classification_config": reflect.TypeOf(MonitorDataClassificationConfig{}),
		"inference_log":              reflect.TypeOf(MonitorInferenceLog{}),
		"notifications":              reflect.TypeOf(MonitorNotifications{}),
		"schedule":                   reflect.TypeOf(MonitorCronSchedule{}),
		"slicing_exprs":              reflect.TypeOf(types.String{}),
		"snapshot":                   reflect.TypeOf(MonitorSnapshot{}),
		"time_series":                reflect.TypeOf(MonitorTimeSeries{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorInfo
// only implements ToObjectValue() and Type().
func (o MonitorInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assets_dir":                 o.AssetsDir,
			"baseline_table_name":        o.BaselineTableName,
			"custom_metrics":             o.CustomMetrics,
			"dashboard_id":               o.DashboardId,
			"data_classification_config": o.DataClassificationConfig,
			"drift_metrics_table_name":   o.DriftMetricsTableName,
			"inference_log":              o.InferenceLog,
			"latest_monitor_failure_msg": o.LatestMonitorFailureMsg,
			"monitor_version":            o.MonitorVersion,
			"notifications":              o.Notifications,
			"output_schema_name":         o.OutputSchemaName,
			"profile_metrics_table_name": o.ProfileMetricsTableName,
			"schedule":                   o.Schedule,
			"slicing_exprs":              o.SlicingExprs,
			"snapshot":                   o.Snapshot,
			"status":                     o.Status,
			"table_name":                 o.TableName,
			"time_series":                o.TimeSeries,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assets_dir":          types.StringType,
			"baseline_table_name": types.StringType,
			"custom_metrics": basetypes.ListType{
				ElemType: MonitorMetric{}.Type(ctx),
			},
			"dashboard_id":               types.StringType,
			"data_classification_config": MonitorDataClassificationConfig{}.Type(ctx),
			"drift_metrics_table_name":   types.StringType,
			"inference_log":              MonitorInferenceLog{}.Type(ctx),
			"latest_monitor_failure_msg": types.StringType,
			"monitor_version":            types.Int64Type,
			"notifications":              MonitorNotifications{}.Type(ctx),
			"output_schema_name":         types.StringType,
			"profile_metrics_table_name": types.StringType,
			"schedule":                   MonitorCronSchedule{}.Type(ctx),
			"slicing_exprs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"snapshot":    MonitorSnapshot{}.Type(ctx),
			"status":      types.StringType,
			"table_name":  types.StringType,
			"time_series": MonitorTimeSeries{}.Type(ctx),
		},
	}
}

// GetCustomMetrics returns the value of the CustomMetrics field in MonitorInfo as
// a slice of MonitorMetric values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetCustomMetrics(ctx context.Context) ([]MonitorMetric, bool) {
	if o.CustomMetrics.IsNull() || o.CustomMetrics.IsUnknown() {
		return nil, false
	}
	var v []MonitorMetric
	d := o.CustomMetrics.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomMetrics sets the value of the CustomMetrics field in MonitorInfo.
func (o *MonitorInfo) SetCustomMetrics(ctx context.Context, v []MonitorMetric) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["custom_metrics"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.CustomMetrics = types.ListValueMust(t, vs)
}

// GetDataClassificationConfig returns the value of the DataClassificationConfig field in MonitorInfo as
// a MonitorDataClassificationConfig value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetDataClassificationConfig(ctx context.Context) (MonitorDataClassificationConfig, bool) {
	var e MonitorDataClassificationConfig
	if o.DataClassificationConfig.IsNull() || o.DataClassificationConfig.IsUnknown() {
		return e, false
	}
	var v MonitorDataClassificationConfig
	d := o.DataClassificationConfig.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDataClassificationConfig sets the value of the DataClassificationConfig field in MonitorInfo.
func (o *MonitorInfo) SetDataClassificationConfig(ctx context.Context, v MonitorDataClassificationConfig) {
	vs := v.ToObjectValue(ctx)
	o.DataClassificationConfig = vs
}

// GetInferenceLog returns the value of the InferenceLog field in MonitorInfo as
// a MonitorInferenceLog value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetInferenceLog(ctx context.Context) (MonitorInferenceLog, bool) {
	var e MonitorInferenceLog
	if o.InferenceLog.IsNull() || o.InferenceLog.IsUnknown() {
		return e, false
	}
	var v MonitorInferenceLog
	d := o.InferenceLog.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInferenceLog sets the value of the InferenceLog field in MonitorInfo.
func (o *MonitorInfo) SetInferenceLog(ctx context.Context, v MonitorInferenceLog) {
	vs := v.ToObjectValue(ctx)
	o.InferenceLog = vs
}

// GetNotifications returns the value of the Notifications field in MonitorInfo as
// a MonitorNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetNotifications(ctx context.Context) (MonitorNotifications, bool) {
	var e MonitorNotifications
	if o.Notifications.IsNull() || o.Notifications.IsUnknown() {
		return e, false
	}
	var v MonitorNotifications
	d := o.Notifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotifications sets the value of the Notifications field in MonitorInfo.
func (o *MonitorInfo) SetNotifications(ctx context.Context, v MonitorNotifications) {
	vs := v.ToObjectValue(ctx)
	o.Notifications = vs
}

// GetSchedule returns the value of the Schedule field in MonitorInfo as
// a MonitorCronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetSchedule(ctx context.Context) (MonitorCronSchedule, bool) {
	var e MonitorCronSchedule
	if o.Schedule.IsNull() || o.Schedule.IsUnknown() {
		return e, false
	}
	var v MonitorCronSchedule
	d := o.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in MonitorInfo.
func (o *MonitorInfo) SetSchedule(ctx context.Context, v MonitorCronSchedule) {
	vs := v.ToObjectValue(ctx)
	o.Schedule = vs
}

// GetSlicingExprs returns the value of the SlicingExprs field in MonitorInfo as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetSlicingExprs(ctx context.Context) ([]types.String, bool) {
	if o.SlicingExprs.IsNull() || o.SlicingExprs.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.SlicingExprs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSlicingExprs sets the value of the SlicingExprs field in MonitorInfo.
func (o *MonitorInfo) SetSlicingExprs(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["slicing_exprs"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.SlicingExprs = types.ListValueMust(t, vs)
}

// GetSnapshot returns the value of the Snapshot field in MonitorInfo as
// a MonitorSnapshot value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetSnapshot(ctx context.Context) (MonitorSnapshot, bool) {
	var e MonitorSnapshot
	if o.Snapshot.IsNull() || o.Snapshot.IsUnknown() {
		return e, false
	}
	var v MonitorSnapshot
	d := o.Snapshot.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSnapshot sets the value of the Snapshot field in MonitorInfo.
func (o *MonitorInfo) SetSnapshot(ctx context.Context, v MonitorSnapshot) {
	vs := v.ToObjectValue(ctx)
	o.Snapshot = vs
}

// GetTimeSeries returns the value of the TimeSeries field in MonitorInfo as
// a MonitorTimeSeries value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorInfo) GetTimeSeries(ctx context.Context) (MonitorTimeSeries, bool) {
	var e MonitorTimeSeries
	if o.TimeSeries.IsNull() || o.TimeSeries.IsUnknown() {
		return e, false
	}
	var v MonitorTimeSeries
	d := o.TimeSeries.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTimeSeries sets the value of the TimeSeries field in MonitorInfo.
func (o *MonitorInfo) SetTimeSeries(ctx context.Context, v MonitorTimeSeries) {
	vs := v.ToObjectValue(ctx)
	o.TimeSeries = vs
}

// Custom metric definition.
type MonitorMetric struct {
	// Jinja template for a SQL expression that specifies how to compute the
	// metric. See [create metric definition].
	//
	// [create metric definition]: https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition
	Definition types.String `tfsdk:"definition"`
	// A list of column names in the input table the metric should be computed
	// for. Can use ``":table"`` to indicate that the metric needs information
	// from multiple columns.
	InputColumns types.List `tfsdk:"input_columns"`
	// Name of the metric in the output tables.
	Name types.String `tfsdk:"name"`
	// The output type of the custom metric.
	OutputDataType types.String `tfsdk:"output_data_type"`
	// Can only be one of ``"CUSTOM_METRIC_TYPE_AGGREGATE"``,
	// ``"CUSTOM_METRIC_TYPE_DERIVED"``, or ``"CUSTOM_METRIC_TYPE_DRIFT"``. The
	// ``"CUSTOM_METRIC_TYPE_AGGREGATE"`` and ``"CUSTOM_METRIC_TYPE_DERIVED"``
	// metrics are computed on a single table, whereas the
	// ``"CUSTOM_METRIC_TYPE_DRIFT"`` compare metrics across baseline and input
	// table, or across the two consecutive time windows. -
	// CUSTOM_METRIC_TYPE_AGGREGATE: only depend on the existing columns in your
	// table - CUSTOM_METRIC_TYPE_DERIVED: depend on previously computed
	// aggregate metrics - CUSTOM_METRIC_TYPE_DRIFT: depend on previously
	// computed aggregate or derived metrics
	Type_ types.String `tfsdk:"type"`
}

func (toState *MonitorMetric) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorMetric) {
}

func (toState *MonitorMetric) SyncFieldsDuringRead(ctx context.Context, fromState MonitorMetric) {
}

func (c MonitorMetric) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["definition"] = attrs["definition"].SetRequired()
	attrs["input_columns"] = attrs["input_columns"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["output_data_type"] = attrs["output_data_type"].SetRequired()
	attrs["type"] = attrs["type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorMetric.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorMetric) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_columns": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorMetric
// only implements ToObjectValue() and Type().
func (o MonitorMetric) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"definition":       o.Definition,
			"input_columns":    o.InputColumns,
			"name":             o.Name,
			"output_data_type": o.OutputDataType,
			"type":             o.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorMetric) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"definition": types.StringType,
			"input_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name":             types.StringType,
			"output_data_type": types.StringType,
			"type":             types.StringType,
		},
	}
}

// GetInputColumns returns the value of the InputColumns field in MonitorMetric as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorMetric) GetInputColumns(ctx context.Context) ([]types.String, bool) {
	if o.InputColumns.IsNull() || o.InputColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.InputColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInputColumns sets the value of the InputColumns field in MonitorMetric.
func (o *MonitorMetric) SetInputColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["input_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.InputColumns = types.ListValueMust(t, vs)
}

type MonitorNotifications struct {
	// Destinations to send notifications on failure/timeout.
	OnFailure types.Object `tfsdk:"on_failure"`
	// Destinations to send notifications on new classification tag detected.
	OnNewClassificationTagDetected types.Object `tfsdk:"on_new_classification_tag_detected"`
}

func (toState *MonitorNotifications) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorNotifications) {
	if !fromPlan.OnFailure.IsNull() && !fromPlan.OnFailure.IsUnknown() {
		if toStateOnFailure, ok := toState.GetOnFailure(ctx); ok {
			if fromPlanOnFailure, ok := fromPlan.GetOnFailure(ctx); ok {
				toStateOnFailure.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanOnFailure)
				toState.SetOnFailure(ctx, toStateOnFailure)
			}
		}
	}
	if !fromPlan.OnNewClassificationTagDetected.IsNull() && !fromPlan.OnNewClassificationTagDetected.IsUnknown() {
		if toStateOnNewClassificationTagDetected, ok := toState.GetOnNewClassificationTagDetected(ctx); ok {
			if fromPlanOnNewClassificationTagDetected, ok := fromPlan.GetOnNewClassificationTagDetected(ctx); ok {
				toStateOnNewClassificationTagDetected.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanOnNewClassificationTagDetected)
				toState.SetOnNewClassificationTagDetected(ctx, toStateOnNewClassificationTagDetected)
			}
		}
	}
}

func (toState *MonitorNotifications) SyncFieldsDuringRead(ctx context.Context, fromState MonitorNotifications) {
	if !fromState.OnFailure.IsNull() && !fromState.OnFailure.IsUnknown() {
		if toStateOnFailure, ok := toState.GetOnFailure(ctx); ok {
			if fromStateOnFailure, ok := fromState.GetOnFailure(ctx); ok {
				toStateOnFailure.SyncFieldsDuringRead(ctx, fromStateOnFailure)
				toState.SetOnFailure(ctx, toStateOnFailure)
			}
		}
	}
	if !fromState.OnNewClassificationTagDetected.IsNull() && !fromState.OnNewClassificationTagDetected.IsUnknown() {
		if toStateOnNewClassificationTagDetected, ok := toState.GetOnNewClassificationTagDetected(ctx); ok {
			if fromStateOnNewClassificationTagDetected, ok := fromState.GetOnNewClassificationTagDetected(ctx); ok {
				toStateOnNewClassificationTagDetected.SyncFieldsDuringRead(ctx, fromStateOnNewClassificationTagDetected)
				toState.SetOnNewClassificationTagDetected(ctx, toStateOnNewClassificationTagDetected)
			}
		}
	}
}

func (c MonitorNotifications) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_new_classification_tag_detected"] = attrs["on_new_classification_tag_detected"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorNotifications) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_failure":                         reflect.TypeOf(MonitorDestination{}),
		"on_new_classification_tag_detected": reflect.TypeOf(MonitorDestination{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorNotifications
// only implements ToObjectValue() and Type().
func (o MonitorNotifications) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"on_failure":                         o.OnFailure,
			"on_new_classification_tag_detected": o.OnNewClassificationTagDetected,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorNotifications) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"on_failure":                         MonitorDestination{}.Type(ctx),
			"on_new_classification_tag_detected": MonitorDestination{}.Type(ctx),
		},
	}
}

// GetOnFailure returns the value of the OnFailure field in MonitorNotifications as
// a MonitorDestination value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorNotifications) GetOnFailure(ctx context.Context) (MonitorDestination, bool) {
	var e MonitorDestination
	if o.OnFailure.IsNull() || o.OnFailure.IsUnknown() {
		return e, false
	}
	var v MonitorDestination
	d := o.OnFailure.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in MonitorNotifications.
func (o *MonitorNotifications) SetOnFailure(ctx context.Context, v MonitorDestination) {
	vs := v.ToObjectValue(ctx)
	o.OnFailure = vs
}

// GetOnNewClassificationTagDetected returns the value of the OnNewClassificationTagDetected field in MonitorNotifications as
// a MonitorDestination value.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorNotifications) GetOnNewClassificationTagDetected(ctx context.Context) (MonitorDestination, bool) {
	var e MonitorDestination
	if o.OnNewClassificationTagDetected.IsNull() || o.OnNewClassificationTagDetected.IsUnknown() {
		return e, false
	}
	var v MonitorDestination
	d := o.OnNewClassificationTagDetected.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnNewClassificationTagDetected sets the value of the OnNewClassificationTagDetected field in MonitorNotifications.
func (o *MonitorNotifications) SetOnNewClassificationTagDetected(ctx context.Context, v MonitorDestination) {
	vs := v.ToObjectValue(ctx)
	o.OnNewClassificationTagDetected = vs
}

type MonitorRefreshInfo struct {
	// Time at which refresh operation completed (milliseconds since 1/1/1970
	// UTC).
	EndTimeMs types.Int64 `tfsdk:"end_time_ms"`
	// An optional message to give insight into the current state of the job
	// (e.g. FAILURE messages).
	Message types.String `tfsdk:"message"`
	// Unique id of the refresh operation.
	RefreshId types.Int64 `tfsdk:"refresh_id"`
	// Time at which refresh operation was initiated (milliseconds since
	// 1/1/1970 UTC).
	StartTimeMs types.Int64 `tfsdk:"start_time_ms"`
	// The current state of the refresh.
	State types.String `tfsdk:"state"`
	// The method by which the refresh was triggered.
	Trigger types.String `tfsdk:"trigger"`
}

func (toState *MonitorRefreshInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorRefreshInfo) {
}

func (toState *MonitorRefreshInfo) SyncFieldsDuringRead(ctx context.Context, fromState MonitorRefreshInfo) {
}

func (c MonitorRefreshInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["end_time_ms"] = attrs["end_time_ms"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()
	attrs["refresh_id"] = attrs["refresh_id"].SetRequired()
	attrs["start_time_ms"] = attrs["start_time_ms"].SetRequired()
	attrs["state"] = attrs["state"].SetRequired()
	attrs["trigger"] = attrs["trigger"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorRefreshInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorRefreshInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorRefreshInfo
// only implements ToObjectValue() and Type().
func (o MonitorRefreshInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"end_time_ms":   o.EndTimeMs,
			"message":       o.Message,
			"refresh_id":    o.RefreshId,
			"start_time_ms": o.StartTimeMs,
			"state":         o.State,
			"trigger":       o.Trigger,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorRefreshInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"end_time_ms":   types.Int64Type,
			"message":       types.StringType,
			"refresh_id":    types.Int64Type,
			"start_time_ms": types.Int64Type,
			"state":         types.StringType,
			"trigger":       types.StringType,
		},
	}
}

type MonitorRefreshListResponse struct {
	// List of refreshes.
	Refreshes types.List `tfsdk:"refreshes"`
}

func (toState *MonitorRefreshListResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorRefreshListResponse) {
}

func (toState *MonitorRefreshListResponse) SyncFieldsDuringRead(ctx context.Context, fromState MonitorRefreshListResponse) {
}

func (c MonitorRefreshListResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["refreshes"] = attrs["refreshes"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorRefreshListResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorRefreshListResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"refreshes": reflect.TypeOf(MonitorRefreshInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorRefreshListResponse
// only implements ToObjectValue() and Type().
func (o MonitorRefreshListResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"refreshes": o.Refreshes,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorRefreshListResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"refreshes": basetypes.ListType{
				ElemType: MonitorRefreshInfo{}.Type(ctx),
			},
		},
	}
}

// GetRefreshes returns the value of the Refreshes field in MonitorRefreshListResponse as
// a slice of MonitorRefreshInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorRefreshListResponse) GetRefreshes(ctx context.Context) ([]MonitorRefreshInfo, bool) {
	if o.Refreshes.IsNull() || o.Refreshes.IsUnknown() {
		return nil, false
	}
	var v []MonitorRefreshInfo
	d := o.Refreshes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRefreshes sets the value of the Refreshes field in MonitorRefreshListResponse.
func (o *MonitorRefreshListResponse) SetRefreshes(ctx context.Context, v []MonitorRefreshInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["refreshes"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Refreshes = types.ListValueMust(t, vs)
}

// Snapshot analysis configuration
type MonitorSnapshot struct {
}

func (toState *MonitorSnapshot) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorSnapshot) {
}

func (toState *MonitorSnapshot) SyncFieldsDuringRead(ctx context.Context, fromState MonitorSnapshot) {
}

func (c MonitorSnapshot) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorSnapshot.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorSnapshot) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorSnapshot
// only implements ToObjectValue() and Type().
func (o MonitorSnapshot) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorSnapshot) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// Time series analysis configuration.
type MonitorTimeSeries struct {
	// Granularities for aggregating data into time windows based on their
	// timestamp. Currently the following static granularities are supported:
	// {``\"5 minutes\"``, ``\"30 minutes\"``, ``\"1 hour\"``, ``\"1 day\"``,
	// ``\"\u003cn\u003e week(s)\"``, ``\"1 month\"``, ``\"1 year\"``}.
	Granularities types.List `tfsdk:"granularities"`
	// Column for the timestamp.
	TimestampCol types.String `tfsdk:"timestamp_col"`
}

func (toState *MonitorTimeSeries) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan MonitorTimeSeries) {
}

func (toState *MonitorTimeSeries) SyncFieldsDuringRead(ctx context.Context, fromState MonitorTimeSeries) {
}

func (c MonitorTimeSeries) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["granularities"] = attrs["granularities"].SetRequired()
	attrs["timestamp_col"] = attrs["timestamp_col"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MonitorTimeSeries.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MonitorTimeSeries) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"granularities": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MonitorTimeSeries
// only implements ToObjectValue() and Type().
func (o MonitorTimeSeries) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"granularities": o.Granularities,
			"timestamp_col": o.TimestampCol,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MonitorTimeSeries) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"granularities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timestamp_col": types.StringType,
		},
	}
}

// GetGranularities returns the value of the Granularities field in MonitorTimeSeries as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *MonitorTimeSeries) GetGranularities(ctx context.Context) ([]types.String, bool) {
	if o.Granularities.IsNull() || o.Granularities.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Granularities.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGranularities sets the value of the Granularities field in MonitorTimeSeries.
func (o *MonitorTimeSeries) SetGranularities(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["granularities"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Granularities = types.ListValueMust(t, vs)
}

type NamedTableConstraint struct {
	// The name of the constraint.
	Name types.String `tfsdk:"name"`
}

func (toState *NamedTableConstraint) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan NamedTableConstraint) {
}

func (toState *NamedTableConstraint) SyncFieldsDuringRead(ctx context.Context, fromState NamedTableConstraint) {
}

func (c NamedTableConstraint) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NamedTableConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a NamedTableConstraint) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NamedTableConstraint
// only implements ToObjectValue() and Type().
func (o NamedTableConstraint) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o NamedTableConstraint) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type NotificationDestination struct {
	// The identifier for the destination. This is the email address for EMAIL
	// destinations, the URL for URL destinations, or the unique Databricks
	// notification destination ID for all other external destinations.
	DestinationId types.String `tfsdk:"destination_id"`
	// The type of the destination.
	DestinationType types.String `tfsdk:"destination_type"`
	// This field is used to denote whether the destination is the email of the
	// owner of the securable object. The special destination cannot be assigned
	// to a securable and only represents the default destination of the
	// securable. The securable types that support default special destinations
	// are: "catalog", "external_location", "connection", "credential", and
	// "metastore". The **destination_type** of a **special_destination** is
	// always EMAIL.
	SpecialDestination types.String `tfsdk:"special_destination"`
}

func (toState *NotificationDestination) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan NotificationDestination) {
}

func (toState *NotificationDestination) SyncFieldsDuringRead(ctx context.Context, fromState NotificationDestination) {
}

func (c NotificationDestination) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetOptional()
	attrs["destination_type"] = attrs["destination_type"].SetOptional()
	attrs["special_destination"] = attrs["special_destination"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NotificationDestination.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a NotificationDestination) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NotificationDestination
// only implements ToObjectValue() and Type().
func (o NotificationDestination) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id":      o.DestinationId,
			"destination_type":    o.DestinationType,
			"special_destination": o.SpecialDestination,
		})
}

// Type implements basetypes.ObjectValuable.
func (o NotificationDestination) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id":      types.StringType,
			"destination_type":    types.StringType,
			"special_destination": types.StringType,
		},
	}
}

// Online Table information.
type OnlineTable struct {
	// Full three-part (catalog, schema, table) name of the table.
	Name types.String `tfsdk:"name"`
	// Specification of the online table.
	Spec types.Object `tfsdk:"spec"`
	// Online Table data synchronization status
	Status types.Object `tfsdk:"status"`
	// Data serving REST API URL for this table
	TableServingUrl types.String `tfsdk:"table_serving_url"`
	// The provisioning state of the online table entity in Unity Catalog. This
	// is distinct from the state of the data synchronization pipeline (i.e. the
	// table may be in "ACTIVE" but the pipeline may be in "PROVISIONING" as it
	// runs asynchronously).
	UnityCatalogProvisioningState types.String `tfsdk:"unity_catalog_provisioning_state"`
}

func (toState *OnlineTable) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan OnlineTable) {
	if !fromPlan.Spec.IsNull() && !fromPlan.Spec.IsUnknown() {
		if toStateSpec, ok := toState.GetSpec(ctx); ok {
			if fromPlanSpec, ok := fromPlan.GetSpec(ctx); ok {
				toStateSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSpec)
				toState.SetSpec(ctx, toStateSpec)
			}
		}
	}
	if !fromPlan.Status.IsNull() && !fromPlan.Status.IsUnknown() {
		if toStateStatus, ok := toState.GetStatus(ctx); ok {
			if fromPlanStatus, ok := fromPlan.GetStatus(ctx); ok {
				toStateStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanStatus)
				toState.SetStatus(ctx, toStateStatus)
			}
		}
	}
}

func (toState *OnlineTable) SyncFieldsDuringRead(ctx context.Context, fromState OnlineTable) {
	if !fromState.Spec.IsNull() && !fromState.Spec.IsUnknown() {
		if toStateSpec, ok := toState.GetSpec(ctx); ok {
			if fromStateSpec, ok := fromState.GetSpec(ctx); ok {
				toStateSpec.SyncFieldsDuringRead(ctx, fromStateSpec)
				toState.SetSpec(ctx, toStateSpec)
			}
		}
	}
	if !fromState.Status.IsNull() && !fromState.Status.IsUnknown() {
		if toStateStatus, ok := toState.GetStatus(ctx); ok {
			if fromStateStatus, ok := fromState.GetStatus(ctx); ok {
				toStateStatus.SyncFieldsDuringRead(ctx, fromStateStatus)
				toState.SetStatus(ctx, toStateStatus)
			}
		}
	}
}

func (c OnlineTable) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()
	attrs["spec"] = attrs["spec"].SetOptional()
	attrs["status"] = attrs["status"].SetComputed()
	attrs["table_serving_url"] = attrs["table_serving_url"].SetComputed()
	attrs["unity_catalog_provisioning_state"] = attrs["unity_catalog_provisioning_state"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a OnlineTable) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"spec":   reflect.TypeOf(OnlineTableSpec{}),
		"status": reflect.TypeOf(OnlineTableStatus{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTable
// only implements ToObjectValue() and Type().
func (o OnlineTable) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                             o.Name,
			"spec":                             o.Spec,
			"status":                           o.Status,
			"table_serving_url":                o.TableServingUrl,
			"unity_catalog_provisioning_state": o.UnityCatalogProvisioningState,
		})
}

// Type implements basetypes.ObjectValuable.
func (o OnlineTable) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                             types.StringType,
			"spec":                             OnlineTableSpec{}.Type(ctx),
			"status":                           OnlineTableStatus{}.Type(ctx),
			"table_serving_url":                types.StringType,
			"unity_catalog_provisioning_state": types.StringType,
		},
	}
}

// GetSpec returns the value of the Spec field in OnlineTable as
// a OnlineTableSpec value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTable) GetSpec(ctx context.Context) (OnlineTableSpec, bool) {
	var e OnlineTableSpec
	if o.Spec.IsNull() || o.Spec.IsUnknown() {
		return e, false
	}
	var v OnlineTableSpec
	d := o.Spec.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSpec sets the value of the Spec field in OnlineTable.
func (o *OnlineTable) SetSpec(ctx context.Context, v OnlineTableSpec) {
	vs := v.ToObjectValue(ctx)
	o.Spec = vs
}

// GetStatus returns the value of the Status field in OnlineTable as
// a OnlineTableStatus value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTable) GetStatus(ctx context.Context) (OnlineTableStatus, bool) {
	var e OnlineTableStatus
	if o.Status.IsNull() || o.Status.IsUnknown() {
		return e, false
	}
	var v OnlineTableStatus
	d := o.Status.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStatus sets the value of the Status field in OnlineTable.
func (o *OnlineTable) SetStatus(ctx context.Context, v OnlineTableStatus) {
	vs := v.ToObjectValue(ctx)
	o.Status = vs
}

// Specification of an online table.
type OnlineTableSpec struct {
	// Whether to create a full-copy pipeline -- a pipeline that stops after
	// creates a full copy of the source table upon initialization and does not
	// process any change data feeds (CDFs) afterwards. The pipeline can still
	// be manually triggered afterwards, but it always perform a full copy of
	// the source table and there are no incremental updates. This mode is
	// useful for syncing views or tables without CDFs to online tables. Note
	// that the full-copy pipeline only supports "triggered" scheduling policy.
	PerformFullCopy types.Bool `tfsdk:"perform_full_copy"`
	// ID of the associated pipeline. Generated by the server - cannot be set by
	// the caller.
	PipelineId types.String `tfsdk:"pipeline_id"`
	// Primary Key columns to be used for data insert/update in the destination.
	PrimaryKeyColumns types.List `tfsdk:"primary_key_columns"`
	// Pipeline runs continuously after generating the initial data.
	RunContinuously types.Object `tfsdk:"run_continuously"`
	// Pipeline stops after generating the initial data and can be triggered
	// later (manually, through a cron job or through data triggers)
	RunTriggered types.Object `tfsdk:"run_triggered"`
	// Three-part (catalog, schema, table) name of the source Delta table.
	SourceTableFullName types.String `tfsdk:"source_table_full_name"`
	// Time series key to deduplicate (tie-break) rows with the same primary
	// key.
	TimeseriesKey types.String `tfsdk:"timeseries_key"`
}

func (toState *OnlineTableSpec) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan OnlineTableSpec) {
	if !fromPlan.RunContinuously.IsNull() && !fromPlan.RunContinuously.IsUnknown() {
		if toStateRunContinuously, ok := toState.GetRunContinuously(ctx); ok {
			if fromPlanRunContinuously, ok := fromPlan.GetRunContinuously(ctx); ok {
				toStateRunContinuously.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanRunContinuously)
				toState.SetRunContinuously(ctx, toStateRunContinuously)
			}
		}
	}
	if !fromPlan.RunTriggered.IsNull() && !fromPlan.RunTriggered.IsUnknown() {
		if toStateRunTriggered, ok := toState.GetRunTriggered(ctx); ok {
			if fromPlanRunTriggered, ok := fromPlan.GetRunTriggered(ctx); ok {
				toStateRunTriggered.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanRunTriggered)
				toState.SetRunTriggered(ctx, toStateRunTriggered)
			}
		}
	}
}

func (toState *OnlineTableSpec) SyncFieldsDuringRead(ctx context.Context, fromState OnlineTableSpec) {
	if !fromState.RunContinuously.IsNull() && !fromState.RunContinuously.IsUnknown() {
		if toStateRunContinuously, ok := toState.GetRunContinuously(ctx); ok {
			if fromStateRunContinuously, ok := fromState.GetRunContinuously(ctx); ok {
				toStateRunContinuously.SyncFieldsDuringRead(ctx, fromStateRunContinuously)
				toState.SetRunContinuously(ctx, toStateRunContinuously)
			}
		}
	}
	if !fromState.RunTriggered.IsNull() && !fromState.RunTriggered.IsUnknown() {
		if toStateRunTriggered, ok := toState.GetRunTriggered(ctx); ok {
			if fromStateRunTriggered, ok := fromState.GetRunTriggered(ctx); ok {
				toStateRunTriggered.SyncFieldsDuringRead(ctx, fromStateRunTriggered)
				toState.SetRunTriggered(ctx, toStateRunTriggered)
			}
		}
	}
}

func (c OnlineTableSpec) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["perform_full_copy"] = attrs["perform_full_copy"].SetOptional()
	attrs["pipeline_id"] = attrs["pipeline_id"].SetComputed()
	attrs["primary_key_columns"] = attrs["primary_key_columns"].SetOptional()
	attrs["run_continuously"] = attrs["run_continuously"].SetOptional()
	attrs["run_triggered"] = attrs["run_triggered"].SetOptional()
	attrs["source_table_full_name"] = attrs["source_table_full_name"].SetOptional()
	attrs["timeseries_key"] = attrs["timeseries_key"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableSpec.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a OnlineTableSpec) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"primary_key_columns": reflect.TypeOf(types.String{}),
		"run_continuously":    reflect.TypeOf(OnlineTableSpecContinuousSchedulingPolicy{}),
		"run_triggered":       reflect.TypeOf(OnlineTableSpecTriggeredSchedulingPolicy{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableSpec
// only implements ToObjectValue() and Type().
func (o OnlineTableSpec) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"perform_full_copy":      o.PerformFullCopy,
			"pipeline_id":            o.PipelineId,
			"primary_key_columns":    o.PrimaryKeyColumns,
			"run_continuously":       o.RunContinuously,
			"run_triggered":          o.RunTriggered,
			"source_table_full_name": o.SourceTableFullName,
			"timeseries_key":         o.TimeseriesKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (o OnlineTableSpec) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"perform_full_copy": types.BoolType,
			"pipeline_id":       types.StringType,
			"primary_key_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"run_continuously":       OnlineTableSpecContinuousSchedulingPolicy{}.Type(ctx),
			"run_triggered":          OnlineTableSpecTriggeredSchedulingPolicy{}.Type(ctx),
			"source_table_full_name": types.StringType,
			"timeseries_key":         types.StringType,
		},
	}
}

// GetPrimaryKeyColumns returns the value of the PrimaryKeyColumns field in OnlineTableSpec as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableSpec) GetPrimaryKeyColumns(ctx context.Context) ([]types.String, bool) {
	if o.PrimaryKeyColumns.IsNull() || o.PrimaryKeyColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.PrimaryKeyColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrimaryKeyColumns sets the value of the PrimaryKeyColumns field in OnlineTableSpec.
func (o *OnlineTableSpec) SetPrimaryKeyColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["primary_key_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PrimaryKeyColumns = types.ListValueMust(t, vs)
}

// GetRunContinuously returns the value of the RunContinuously field in OnlineTableSpec as
// a OnlineTableSpecContinuousSchedulingPolicy value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableSpec) GetRunContinuously(ctx context.Context) (OnlineTableSpecContinuousSchedulingPolicy, bool) {
	var e OnlineTableSpecContinuousSchedulingPolicy
	if o.RunContinuously.IsNull() || o.RunContinuously.IsUnknown() {
		return e, false
	}
	var v OnlineTableSpecContinuousSchedulingPolicy
	d := o.RunContinuously.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunContinuously sets the value of the RunContinuously field in OnlineTableSpec.
func (o *OnlineTableSpec) SetRunContinuously(ctx context.Context, v OnlineTableSpecContinuousSchedulingPolicy) {
	vs := v.ToObjectValue(ctx)
	o.RunContinuously = vs
}

// GetRunTriggered returns the value of the RunTriggered field in OnlineTableSpec as
// a OnlineTableSpecTriggeredSchedulingPolicy value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableSpec) GetRunTriggered(ctx context.Context) (OnlineTableSpecTriggeredSchedulingPolicy, bool) {
	var e OnlineTableSpecTriggeredSchedulingPolicy
	if o.RunTriggered.IsNull() || o.RunTriggered.IsUnknown() {
		return e, false
	}
	var v OnlineTableSpecTriggeredSchedulingPolicy
	d := o.RunTriggered.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunTriggered sets the value of the RunTriggered field in OnlineTableSpec.
func (o *OnlineTableSpec) SetRunTriggered(ctx context.Context, v OnlineTableSpecTriggeredSchedulingPolicy) {
	vs := v.ToObjectValue(ctx)
	o.RunTriggered = vs
}

type OnlineTableSpecContinuousSchedulingPolicy struct {
}

func (toState *OnlineTableSpecContinuousSchedulingPolicy) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan OnlineTableSpecContinuousSchedulingPolicy) {
}

func (toState *OnlineTableSpecContinuousSchedulingPolicy) SyncFieldsDuringRead(ctx context.Context, fromState OnlineTableSpecContinuousSchedulingPolicy) {
}

func (c OnlineTableSpecContinuousSchedulingPolicy) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableSpecContinuousSchedulingPolicy.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a OnlineTableSpecContinuousSchedulingPolicy) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableSpecContinuousSchedulingPolicy
// only implements ToObjectValue() and Type().
func (o OnlineTableSpecContinuousSchedulingPolicy) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o OnlineTableSpecContinuousSchedulingPolicy) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type OnlineTableSpecTriggeredSchedulingPolicy struct {
}

func (toState *OnlineTableSpecTriggeredSchedulingPolicy) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan OnlineTableSpecTriggeredSchedulingPolicy) {
}

func (toState *OnlineTableSpecTriggeredSchedulingPolicy) SyncFieldsDuringRead(ctx context.Context, fromState OnlineTableSpecTriggeredSchedulingPolicy) {
}

func (c OnlineTableSpecTriggeredSchedulingPolicy) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableSpecTriggeredSchedulingPolicy.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a OnlineTableSpecTriggeredSchedulingPolicy) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableSpecTriggeredSchedulingPolicy
// only implements ToObjectValue() and Type().
func (o OnlineTableSpecTriggeredSchedulingPolicy) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o OnlineTableSpecTriggeredSchedulingPolicy) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

// Status of an online table.
type OnlineTableStatus struct {
	ContinuousUpdateStatus types.Object `tfsdk:"continuous_update_status"`
	// The state of the online table.
	DetailedState types.String `tfsdk:"detailed_state"`

	FailedStatus types.Object `tfsdk:"failed_status"`
	// A text description of the current state of the online table.
	Message types.String `tfsdk:"message"`

	ProvisioningStatus types.Object `tfsdk:"provisioning_status"`

	TriggeredUpdateStatus types.Object `tfsdk:"triggered_update_status"`
}

func (toState *OnlineTableStatus) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan OnlineTableStatus) {
	if !fromPlan.ContinuousUpdateStatus.IsNull() && !fromPlan.ContinuousUpdateStatus.IsUnknown() {
		if toStateContinuousUpdateStatus, ok := toState.GetContinuousUpdateStatus(ctx); ok {
			if fromPlanContinuousUpdateStatus, ok := fromPlan.GetContinuousUpdateStatus(ctx); ok {
				toStateContinuousUpdateStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanContinuousUpdateStatus)
				toState.SetContinuousUpdateStatus(ctx, toStateContinuousUpdateStatus)
			}
		}
	}
	if !fromPlan.FailedStatus.IsNull() && !fromPlan.FailedStatus.IsUnknown() {
		if toStateFailedStatus, ok := toState.GetFailedStatus(ctx); ok {
			if fromPlanFailedStatus, ok := fromPlan.GetFailedStatus(ctx); ok {
				toStateFailedStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFailedStatus)
				toState.SetFailedStatus(ctx, toStateFailedStatus)
			}
		}
	}
	if !fromPlan.ProvisioningStatus.IsNull() && !fromPlan.ProvisioningStatus.IsUnknown() {
		if toStateProvisioningStatus, ok := toState.GetProvisioningStatus(ctx); ok {
			if fromPlanProvisioningStatus, ok := fromPlan.GetProvisioningStatus(ctx); ok {
				toStateProvisioningStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanProvisioningStatus)
				toState.SetProvisioningStatus(ctx, toStateProvisioningStatus)
			}
		}
	}
	if !fromPlan.TriggeredUpdateStatus.IsNull() && !fromPlan.TriggeredUpdateStatus.IsUnknown() {
		if toStateTriggeredUpdateStatus, ok := toState.GetTriggeredUpdateStatus(ctx); ok {
			if fromPlanTriggeredUpdateStatus, ok := fromPlan.GetTriggeredUpdateStatus(ctx); ok {
				toStateTriggeredUpdateStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTriggeredUpdateStatus)
				toState.SetTriggeredUpdateStatus(ctx, toStateTriggeredUpdateStatus)
			}
		}
	}
}

func (toState *OnlineTableStatus) SyncFieldsDuringRead(ctx context.Context, fromState OnlineTableStatus) {
	if !fromState.ContinuousUpdateStatus.IsNull() && !fromState.ContinuousUpdateStatus.IsUnknown() {
		if toStateContinuousUpdateStatus, ok := toState.GetContinuousUpdateStatus(ctx); ok {
			if fromStateContinuousUpdateStatus, ok := fromState.GetContinuousUpdateStatus(ctx); ok {
				toStateContinuousUpdateStatus.SyncFieldsDuringRead(ctx, fromStateContinuousUpdateStatus)
				toState.SetContinuousUpdateStatus(ctx, toStateContinuousUpdateStatus)
			}
		}
	}
	if !fromState.FailedStatus.IsNull() && !fromState.FailedStatus.IsUnknown() {
		if toStateFailedStatus, ok := toState.GetFailedStatus(ctx); ok {
			if fromStateFailedStatus, ok := fromState.GetFailedStatus(ctx); ok {
				toStateFailedStatus.SyncFieldsDuringRead(ctx, fromStateFailedStatus)
				toState.SetFailedStatus(ctx, toStateFailedStatus)
			}
		}
	}
	if !fromState.ProvisioningStatus.IsNull() && !fromState.ProvisioningStatus.IsUnknown() {
		if toStateProvisioningStatus, ok := toState.GetProvisioningStatus(ctx); ok {
			if fromStateProvisioningStatus, ok := fromState.GetProvisioningStatus(ctx); ok {
				toStateProvisioningStatus.SyncFieldsDuringRead(ctx, fromStateProvisioningStatus)
				toState.SetProvisioningStatus(ctx, toStateProvisioningStatus)
			}
		}
	}
	if !fromState.TriggeredUpdateStatus.IsNull() && !fromState.TriggeredUpdateStatus.IsUnknown() {
		if toStateTriggeredUpdateStatus, ok := toState.GetTriggeredUpdateStatus(ctx); ok {
			if fromStateTriggeredUpdateStatus, ok := fromState.GetTriggeredUpdateStatus(ctx); ok {
				toStateTriggeredUpdateStatus.SyncFieldsDuringRead(ctx, fromStateTriggeredUpdateStatus)
				toState.SetTriggeredUpdateStatus(ctx, toStateTriggeredUpdateStatus)
			}
		}
	}
}

func (c OnlineTableStatus) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["continuous_update_status"] = attrs["continuous_update_status"].SetOptional()
	attrs["detailed_state"] = attrs["detailed_state"].SetOptional()
	attrs["failed_status"] = attrs["failed_status"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()
	attrs["provisioning_status"] = attrs["provisioning_status"].SetOptional()
	attrs["triggered_update_status"] = attrs["triggered_update_status"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OnlineTableStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a OnlineTableStatus) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"continuous_update_status": reflect.TypeOf(ContinuousUpdateStatus{}),
		"failed_status":            reflect.TypeOf(FailedStatus{}),
		"provisioning_status":      reflect.TypeOf(ProvisioningStatus{}),
		"triggered_update_status":  reflect.TypeOf(TriggeredUpdateStatus{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OnlineTableStatus
// only implements ToObjectValue() and Type().
func (o OnlineTableStatus) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"continuous_update_status": o.ContinuousUpdateStatus,
			"detailed_state":           o.DetailedState,
			"failed_status":            o.FailedStatus,
			"message":                  o.Message,
			"provisioning_status":      o.ProvisioningStatus,
			"triggered_update_status":  o.TriggeredUpdateStatus,
		})
}

// Type implements basetypes.ObjectValuable.
func (o OnlineTableStatus) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"continuous_update_status": ContinuousUpdateStatus{}.Type(ctx),
			"detailed_state":           types.StringType,
			"failed_status":            FailedStatus{}.Type(ctx),
			"message":                  types.StringType,
			"provisioning_status":      ProvisioningStatus{}.Type(ctx),
			"triggered_update_status":  TriggeredUpdateStatus{}.Type(ctx),
		},
	}
}

// GetContinuousUpdateStatus returns the value of the ContinuousUpdateStatus field in OnlineTableStatus as
// a ContinuousUpdateStatus value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableStatus) GetContinuousUpdateStatus(ctx context.Context) (ContinuousUpdateStatus, bool) {
	var e ContinuousUpdateStatus
	if o.ContinuousUpdateStatus.IsNull() || o.ContinuousUpdateStatus.IsUnknown() {
		return e, false
	}
	var v ContinuousUpdateStatus
	d := o.ContinuousUpdateStatus.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetContinuousUpdateStatus sets the value of the ContinuousUpdateStatus field in OnlineTableStatus.
func (o *OnlineTableStatus) SetContinuousUpdateStatus(ctx context.Context, v ContinuousUpdateStatus) {
	vs := v.ToObjectValue(ctx)
	o.ContinuousUpdateStatus = vs
}

// GetFailedStatus returns the value of the FailedStatus field in OnlineTableStatus as
// a FailedStatus value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableStatus) GetFailedStatus(ctx context.Context) (FailedStatus, bool) {
	var e FailedStatus
	if o.FailedStatus.IsNull() || o.FailedStatus.IsUnknown() {
		return e, false
	}
	var v FailedStatus
	d := o.FailedStatus.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFailedStatus sets the value of the FailedStatus field in OnlineTableStatus.
func (o *OnlineTableStatus) SetFailedStatus(ctx context.Context, v FailedStatus) {
	vs := v.ToObjectValue(ctx)
	o.FailedStatus = vs
}

// GetProvisioningStatus returns the value of the ProvisioningStatus field in OnlineTableStatus as
// a ProvisioningStatus value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableStatus) GetProvisioningStatus(ctx context.Context) (ProvisioningStatus, bool) {
	var e ProvisioningStatus
	if o.ProvisioningStatus.IsNull() || o.ProvisioningStatus.IsUnknown() {
		return e, false
	}
	var v ProvisioningStatus
	d := o.ProvisioningStatus.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProvisioningStatus sets the value of the ProvisioningStatus field in OnlineTableStatus.
func (o *OnlineTableStatus) SetProvisioningStatus(ctx context.Context, v ProvisioningStatus) {
	vs := v.ToObjectValue(ctx)
	o.ProvisioningStatus = vs
}

// GetTriggeredUpdateStatus returns the value of the TriggeredUpdateStatus field in OnlineTableStatus as
// a TriggeredUpdateStatus value.
// If the field is unknown or null, the boolean return value is false.
func (o *OnlineTableStatus) GetTriggeredUpdateStatus(ctx context.Context) (TriggeredUpdateStatus, bool) {
	var e TriggeredUpdateStatus
	if o.TriggeredUpdateStatus.IsNull() || o.TriggeredUpdateStatus.IsUnknown() {
		return e, false
	}
	var v TriggeredUpdateStatus
	d := o.TriggeredUpdateStatus.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTriggeredUpdateStatus sets the value of the TriggeredUpdateStatus field in OnlineTableStatus.
func (o *OnlineTableStatus) SetTriggeredUpdateStatus(ctx context.Context, v TriggeredUpdateStatus) {
	vs := v.ToObjectValue(ctx)
	o.TriggeredUpdateStatus = vs
}

// Spec of an allowed option on a securable kind and its attributes. This is
// mostly used by UI to provide user friendly hints and descriptions in order to
// facilitate the securable creation process.
type OptionSpec struct {
	// For drop down / radio button selections, UI will want to know the
	// possible input values, it can also be used by other option types to limit
	// input selections.
	AllowedValues types.List `tfsdk:"allowed_values"`
	// The default value of the option, for example, value '443' for 'port'
	// option.
	DefaultValue types.String `tfsdk:"default_value"`
	// A concise user facing description of what the input value of this option
	// should look like.
	Description types.String `tfsdk:"description"`
	// The hint is used on the UI to suggest what the input value can possibly
	// be like, for example: example.com for 'host' option. Unlike default
	// value, it will not be applied automatically without user input.
	Hint types.String `tfsdk:"hint"`
	// Indicates whether an option should be displayed with copy button on the
	// UI.
	IsCopiable types.Bool `tfsdk:"is_copiable"`
	// Indicates whether an option can be provided by users in the create/update
	// path of an entity.
	IsCreatable types.Bool `tfsdk:"is_creatable"`
	// Is the option value not user settable and is thus not shown on the UI.
	IsHidden types.Bool `tfsdk:"is_hidden"`
	// Specifies whether this option is safe to log, i.e. no sensitive
	// information.
	IsLoggable types.Bool `tfsdk:"is_loggable"`
	// Is the option required.
	IsRequired types.Bool `tfsdk:"is_required"`
	// Is the option value considered secret and thus redacted on the UI.
	IsSecret types.Bool `tfsdk:"is_secret"`
	// Is the option updatable by users.
	IsUpdatable types.Bool `tfsdk:"is_updatable"`
	// The unique name of the option.
	Name types.String `tfsdk:"name"`
	// Specifies when the option value is displayed on the UI within the OAuth
	// flow.
	OauthStage types.String `tfsdk:"oauth_stage"`
	// The type of the option.
	Type_ types.String `tfsdk:"type"`
}

func (toState *OptionSpec) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan OptionSpec) {
}

func (toState *OptionSpec) SyncFieldsDuringRead(ctx context.Context, fromState OptionSpec) {
}

func (c OptionSpec) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["allowed_values"] = attrs["allowed_values"].SetOptional()
	attrs["default_value"] = attrs["default_value"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["hint"] = attrs["hint"].SetOptional()
	attrs["is_copiable"] = attrs["is_copiable"].SetOptional()
	attrs["is_creatable"] = attrs["is_creatable"].SetOptional()
	attrs["is_hidden"] = attrs["is_hidden"].SetOptional()
	attrs["is_loggable"] = attrs["is_loggable"].SetOptional()
	attrs["is_required"] = attrs["is_required"].SetOptional()
	attrs["is_secret"] = attrs["is_secret"].SetOptional()
	attrs["is_updatable"] = attrs["is_updatable"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["oauth_stage"] = attrs["oauth_stage"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OptionSpec.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a OptionSpec) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"allowed_values": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OptionSpec
// only implements ToObjectValue() and Type().
func (o OptionSpec) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"allowed_values": o.AllowedValues,
			"default_value":  o.DefaultValue,
			"description":    o.Description,
			"hint":           o.Hint,
			"is_copiable":    o.IsCopiable,
			"is_creatable":   o.IsCreatable,
			"is_hidden":      o.IsHidden,
			"is_loggable":    o.IsLoggable,
			"is_required":    o.IsRequired,
			"is_secret":      o.IsSecret,
			"is_updatable":   o.IsUpdatable,
			"name":           o.Name,
			"oauth_stage":    o.OauthStage,
			"type":           o.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (o OptionSpec) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"allowed_values": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default_value": types.StringType,
			"description":   types.StringType,
			"hint":          types.StringType,
			"is_copiable":   types.BoolType,
			"is_creatable":  types.BoolType,
			"is_hidden":     types.BoolType,
			"is_loggable":   types.BoolType,
			"is_required":   types.BoolType,
			"is_secret":     types.BoolType,
			"is_updatable":  types.BoolType,
			"name":          types.StringType,
			"oauth_stage":   types.StringType,
			"type":          types.StringType,
		},
	}
}

// GetAllowedValues returns the value of the AllowedValues field in OptionSpec as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *OptionSpec) GetAllowedValues(ctx context.Context) ([]types.String, bool) {
	if o.AllowedValues.IsNull() || o.AllowedValues.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.AllowedValues.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAllowedValues sets the value of the AllowedValues field in OptionSpec.
func (o *OptionSpec) SetAllowedValues(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["allowed_values"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AllowedValues = types.ListValueMust(t, vs)
}

type PermissionsChange struct {
	// The set of privileges to add.
	Add types.List `tfsdk:"add"`
	// The principal whose privileges we are changing. Only one of principal or
	// principal_id should be specified, never both at the same time.
	Principal types.String `tfsdk:"principal"`
	// The set of privileges to remove.
	Remove types.List `tfsdk:"remove"`
}

func (toState *PermissionsChange) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan PermissionsChange) {
}

func (toState *PermissionsChange) SyncFieldsDuringRead(ctx context.Context, fromState PermissionsChange) {
}

func (c PermissionsChange) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["add"] = attrs["add"].SetOptional()
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["remove"] = attrs["remove"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PermissionsChange.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PermissionsChange) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"add":    reflect.TypeOf(types.String{}),
		"remove": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PermissionsChange
// only implements ToObjectValue() and Type().
func (o PermissionsChange) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"add":       o.Add,
			"principal": o.Principal,
			"remove":    o.Remove,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PermissionsChange) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"principal": types.StringType,
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetAdd returns the value of the Add field in PermissionsChange as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PermissionsChange) GetAdd(ctx context.Context) ([]types.String, bool) {
	if o.Add.IsNull() || o.Add.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Add.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAdd sets the value of the Add field in PermissionsChange.
func (o *PermissionsChange) SetAdd(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["add"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Add = types.ListValueMust(t, vs)
}

// GetRemove returns the value of the Remove field in PermissionsChange as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PermissionsChange) GetRemove(ctx context.Context) ([]types.String, bool) {
	if o.Remove.IsNull() || o.Remove.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Remove.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRemove sets the value of the Remove field in PermissionsChange.
func (o *PermissionsChange) SetRemove(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["remove"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Remove = types.ListValueMust(t, vs)
}

// Progress information of the Online Table data synchronization pipeline.
type PipelineProgress struct {
	// The estimated time remaining to complete this update in seconds.
	EstimatedCompletionTimeSeconds types.Float64 `tfsdk:"estimated_completion_time_seconds"`
	// The source table Delta version that was last processed by the pipeline.
	// The pipeline may not have completely processed this version yet.
	LatestVersionCurrentlyProcessing types.Int64 `tfsdk:"latest_version_currently_processing"`
	// The completion ratio of this update. This is a number between 0 and 1.
	SyncProgressCompletion types.Float64 `tfsdk:"sync_progress_completion"`
	// The number of rows that have been synced in this update.
	SyncedRowCount types.Int64 `tfsdk:"synced_row_count"`
	// The total number of rows that need to be synced in this update. This
	// number may be an estimate.
	TotalRowCount types.Int64 `tfsdk:"total_row_count"`
}

func (toState *PipelineProgress) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan PipelineProgress) {
}

func (toState *PipelineProgress) SyncFieldsDuringRead(ctx context.Context, fromState PipelineProgress) {
}

func (c PipelineProgress) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["estimated_completion_time_seconds"] = attrs["estimated_completion_time_seconds"].SetOptional()
	attrs["latest_version_currently_processing"] = attrs["latest_version_currently_processing"].SetOptional()
	attrs["sync_progress_completion"] = attrs["sync_progress_completion"].SetOptional()
	attrs["synced_row_count"] = attrs["synced_row_count"].SetOptional()
	attrs["total_row_count"] = attrs["total_row_count"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PipelineProgress.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PipelineProgress) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PipelineProgress
// only implements ToObjectValue() and Type().
func (o PipelineProgress) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"estimated_completion_time_seconds":   o.EstimatedCompletionTimeSeconds,
			"latest_version_currently_processing": o.LatestVersionCurrentlyProcessing,
			"sync_progress_completion":            o.SyncProgressCompletion,
			"synced_row_count":                    o.SyncedRowCount,
			"total_row_count":                     o.TotalRowCount,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PipelineProgress) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"estimated_completion_time_seconds":   types.Float64Type,
			"latest_version_currently_processing": types.Int64Type,
			"sync_progress_completion":            types.Float64Type,
			"synced_row_count":                    types.Int64Type,
			"total_row_count":                     types.Int64Type,
		},
	}
}

type PolicyInfo struct {
	// Options for column mask policies. Valid only if `policy_type` is
	// `POLICY_TYPE_COLUMN_MASK`. Required on create and optional on update.
	// When specified on update, the new options will replace the existing
	// options as a whole.
	ColumnMask types.Object `tfsdk:"column_mask"`
	// Optional description of the policy.
	Comment types.String `tfsdk:"comment"`
	// Time at which the policy was created, in epoch milliseconds. Output only.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who created the policy. Output only.
	CreatedBy types.String `tfsdk:"created_by"`
	// Optional list of user or group names that should be excluded from the
	// policy.
	ExceptPrincipals types.List `tfsdk:"except_principals"`
	// Type of securables that the policy should take effect on. Only `TABLE` is
	// supported at this moment. Required on create and optional on update.
	ForSecurableType types.String `tfsdk:"for_securable_type"`
	// Unique identifier of the policy. This field is output only and is
	// generated by the system.
	Id types.String `tfsdk:"id"`
	// Optional list of condition expressions used to match table columns. Only
	// valid when `for_securable_type` is `TABLE`. When specified, the policy
	// only applies to tables whose columns satisfy all match conditions.
	MatchColumns types.List `tfsdk:"match_columns"`
	// Name of the policy. Required on create and optional on update. To rename
	// the policy, set `name` to a different value on update.
	Name types.String `tfsdk:"name"`
	// Full name of the securable on which the policy is defined. Required on
	// create and ignored on update.
	OnSecurableFullname types.String `tfsdk:"on_securable_fullname"`
	// Type of the securable on which the policy is defined. Only `CATALOG`,
	// `SCHEMA` and `TABLE` are supported at this moment. Required on create and
	// ignored on update.
	OnSecurableType types.String `tfsdk:"on_securable_type"`
	// Type of the policy. Required on create and ignored on update.
	PolicyType types.String `tfsdk:"policy_type"`
	// Options for row filter policies. Valid only if `policy_type` is
	// `POLICY_TYPE_ROW_FILTER`. Required on create and optional on update. When
	// specified on update, the new options will replace the existing options as
	// a whole.
	RowFilter types.Object `tfsdk:"row_filter"`
	// List of user or group names that the policy applies to. Required on
	// create and optional on update.
	ToPrincipals types.List `tfsdk:"to_principals"`
	// Time at which the policy was last modified, in epoch milliseconds. Output
	// only.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of the user who last modified the policy. Output only.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Optional condition when the policy should take effect.
	WhenCondition types.String `tfsdk:"when_condition"`
}

func (toState *PolicyInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan PolicyInfo) {
	if !fromPlan.ColumnMask.IsNull() && !fromPlan.ColumnMask.IsUnknown() {
		if toStateColumnMask, ok := toState.GetColumnMask(ctx); ok {
			if fromPlanColumnMask, ok := fromPlan.GetColumnMask(ctx); ok {
				toStateColumnMask.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanColumnMask)
				toState.SetColumnMask(ctx, toStateColumnMask)
			}
		}
	}
	if !fromPlan.RowFilter.IsNull() && !fromPlan.RowFilter.IsUnknown() {
		if toStateRowFilter, ok := toState.GetRowFilter(ctx); ok {
			if fromPlanRowFilter, ok := fromPlan.GetRowFilter(ctx); ok {
				toStateRowFilter.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanRowFilter)
				toState.SetRowFilter(ctx, toStateRowFilter)
			}
		}
	}
}

func (toState *PolicyInfo) SyncFieldsDuringRead(ctx context.Context, fromState PolicyInfo) {
	if !fromState.ColumnMask.IsNull() && !fromState.ColumnMask.IsUnknown() {
		if toStateColumnMask, ok := toState.GetColumnMask(ctx); ok {
			if fromStateColumnMask, ok := fromState.GetColumnMask(ctx); ok {
				toStateColumnMask.SyncFieldsDuringRead(ctx, fromStateColumnMask)
				toState.SetColumnMask(ctx, toStateColumnMask)
			}
		}
	}
	if !fromState.RowFilter.IsNull() && !fromState.RowFilter.IsUnknown() {
		if toStateRowFilter, ok := toState.GetRowFilter(ctx); ok {
			if fromStateRowFilter, ok := fromState.GetRowFilter(ctx); ok {
				toStateRowFilter.SyncFieldsDuringRead(ctx, fromStateRowFilter)
				toState.SetRowFilter(ctx, toStateRowFilter)
			}
		}
	}
}

func (c PolicyInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["column_mask"] = attrs["column_mask"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["except_principals"] = attrs["except_principals"].SetOptional()
	attrs["for_securable_type"] = attrs["for_securable_type"].SetRequired()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["match_columns"] = attrs["match_columns"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetOptional()
	attrs["on_securable_type"] = attrs["on_securable_type"].SetOptional()
	attrs["policy_type"] = attrs["policy_type"].SetRequired()
	attrs["row_filter"] = attrs["row_filter"].SetOptional()
	attrs["to_principals"] = attrs["to_principals"].SetRequired()
	attrs["updated_at"] = attrs["updated_at"].SetComputed()
	attrs["updated_by"] = attrs["updated_by"].SetComputed()
	attrs["when_condition"] = attrs["when_condition"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PolicyInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PolicyInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"column_mask":       reflect.TypeOf(ColumnMaskOptions{}),
		"except_principals": reflect.TypeOf(types.String{}),
		"match_columns":     reflect.TypeOf(MatchColumn{}),
		"row_filter":        reflect.TypeOf(RowFilterOptions{}),
		"to_principals":     reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PolicyInfo
// only implements ToObjectValue() and Type().
func (o PolicyInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"column_mask":           o.ColumnMask,
			"comment":               o.Comment,
			"created_at":            o.CreatedAt,
			"created_by":            o.CreatedBy,
			"except_principals":     o.ExceptPrincipals,
			"for_securable_type":    o.ForSecurableType,
			"id":                    o.Id,
			"match_columns":         o.MatchColumns,
			"name":                  o.Name,
			"on_securable_fullname": o.OnSecurableFullname,
			"on_securable_type":     o.OnSecurableType,
			"policy_type":           o.PolicyType,
			"row_filter":            o.RowFilter,
			"to_principals":         o.ToPrincipals,
			"updated_at":            o.UpdatedAt,
			"updated_by":            o.UpdatedBy,
			"when_condition":        o.WhenCondition,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PolicyInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"column_mask": ColumnMaskOptions{}.Type(ctx),
			"comment":     types.StringType,
			"created_at":  types.Int64Type,
			"created_by":  types.StringType,
			"except_principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"for_securable_type": types.StringType,
			"id":                 types.StringType,
			"match_columns": basetypes.ListType{
				ElemType: MatchColumn{}.Type(ctx),
			},
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"policy_type":           types.StringType,
			"row_filter":            RowFilterOptions{}.Type(ctx),
			"to_principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"updated_at":     types.Int64Type,
			"updated_by":     types.StringType,
			"when_condition": types.StringType,
		},
	}
}

// GetColumnMask returns the value of the ColumnMask field in PolicyInfo as
// a ColumnMaskOptions value.
// If the field is unknown or null, the boolean return value is false.
func (o *PolicyInfo) GetColumnMask(ctx context.Context) (ColumnMaskOptions, bool) {
	var e ColumnMaskOptions
	if o.ColumnMask.IsNull() || o.ColumnMask.IsUnknown() {
		return e, false
	}
	var v ColumnMaskOptions
	d := o.ColumnMask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumnMask sets the value of the ColumnMask field in PolicyInfo.
func (o *PolicyInfo) SetColumnMask(ctx context.Context, v ColumnMaskOptions) {
	vs := v.ToObjectValue(ctx)
	o.ColumnMask = vs
}

// GetExceptPrincipals returns the value of the ExceptPrincipals field in PolicyInfo as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PolicyInfo) GetExceptPrincipals(ctx context.Context) ([]types.String, bool) {
	if o.ExceptPrincipals.IsNull() || o.ExceptPrincipals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.ExceptPrincipals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExceptPrincipals sets the value of the ExceptPrincipals field in PolicyInfo.
func (o *PolicyInfo) SetExceptPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["except_principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ExceptPrincipals = types.ListValueMust(t, vs)
}

// GetMatchColumns returns the value of the MatchColumns field in PolicyInfo as
// a slice of MatchColumn values.
// If the field is unknown or null, the boolean return value is false.
func (o *PolicyInfo) GetMatchColumns(ctx context.Context) ([]MatchColumn, bool) {
	if o.MatchColumns.IsNull() || o.MatchColumns.IsUnknown() {
		return nil, false
	}
	var v []MatchColumn
	d := o.MatchColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMatchColumns sets the value of the MatchColumns field in PolicyInfo.
func (o *PolicyInfo) SetMatchColumns(ctx context.Context, v []MatchColumn) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["match_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.MatchColumns = types.ListValueMust(t, vs)
}

// GetRowFilter returns the value of the RowFilter field in PolicyInfo as
// a RowFilterOptions value.
// If the field is unknown or null, the boolean return value is false.
func (o *PolicyInfo) GetRowFilter(ctx context.Context) (RowFilterOptions, bool) {
	var e RowFilterOptions
	if o.RowFilter.IsNull() || o.RowFilter.IsUnknown() {
		return e, false
	}
	var v RowFilterOptions
	d := o.RowFilter.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRowFilter sets the value of the RowFilter field in PolicyInfo.
func (o *PolicyInfo) SetRowFilter(ctx context.Context, v RowFilterOptions) {
	vs := v.ToObjectValue(ctx)
	o.RowFilter = vs
}

// GetToPrincipals returns the value of the ToPrincipals field in PolicyInfo as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PolicyInfo) GetToPrincipals(ctx context.Context) ([]types.String, bool) {
	if o.ToPrincipals.IsNull() || o.ToPrincipals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.ToPrincipals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetToPrincipals sets the value of the ToPrincipals field in PolicyInfo.
func (o *PolicyInfo) SetToPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["to_principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ToPrincipals = types.ListValueMust(t, vs)
}

type PrimaryKeyConstraint struct {
	// Column names for this constraint.
	ChildColumns types.List `tfsdk:"child_columns"`
	// The name of the constraint.
	Name types.String `tfsdk:"name"`
	// True if the constraint is RELY, false or unset if NORELY.
	Rely types.Bool `tfsdk:"rely"`
	// Column names that represent a timeseries.
	TimeseriesColumns types.List `tfsdk:"timeseries_columns"`
}

func (toState *PrimaryKeyConstraint) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan PrimaryKeyConstraint) {
}

func (toState *PrimaryKeyConstraint) SyncFieldsDuringRead(ctx context.Context, fromState PrimaryKeyConstraint) {
}

func (c PrimaryKeyConstraint) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["child_columns"] = attrs["child_columns"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["rely"] = attrs["rely"].SetOptional()
	attrs["timeseries_columns"] = attrs["timeseries_columns"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PrimaryKeyConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PrimaryKeyConstraint) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"child_columns":      reflect.TypeOf(types.String{}),
		"timeseries_columns": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PrimaryKeyConstraint
// only implements ToObjectValue() and Type().
func (o PrimaryKeyConstraint) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"child_columns":      o.ChildColumns,
			"name":               o.Name,
			"rely":               o.Rely,
			"timeseries_columns": o.TimeseriesColumns,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PrimaryKeyConstraint) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"child_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": types.StringType,
			"rely": types.BoolType,
			"timeseries_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetChildColumns returns the value of the ChildColumns field in PrimaryKeyConstraint as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PrimaryKeyConstraint) GetChildColumns(ctx context.Context) ([]types.String, bool) {
	if o.ChildColumns.IsNull() || o.ChildColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.ChildColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetChildColumns sets the value of the ChildColumns field in PrimaryKeyConstraint.
func (o *PrimaryKeyConstraint) SetChildColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["child_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ChildColumns = types.ListValueMust(t, vs)
}

// GetTimeseriesColumns returns the value of the TimeseriesColumns field in PrimaryKeyConstraint as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PrimaryKeyConstraint) GetTimeseriesColumns(ctx context.Context) ([]types.String, bool) {
	if o.TimeseriesColumns.IsNull() || o.TimeseriesColumns.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.TimeseriesColumns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTimeseriesColumns sets the value of the TimeseriesColumns field in PrimaryKeyConstraint.
func (o *PrimaryKeyConstraint) SetTimeseriesColumns(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["timeseries_columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.TimeseriesColumns = types.ListValueMust(t, vs)
}

type Principal struct {
	// Databricks user, group or service principal ID.
	Id types.String `tfsdk:"id"`

	PrincipalType types.String `tfsdk:"principal_type"`
}

func (toState *Principal) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan Principal) {
}

func (toState *Principal) SyncFieldsDuringRead(ctx context.Context, fromState Principal) {
}

func (c Principal) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetOptional()
	attrs["principal_type"] = attrs["principal_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Principal.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Principal) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Principal
// only implements ToObjectValue() and Type().
func (o Principal) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":             o.Id,
			"principal_type": o.PrincipalType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Principal) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id":             types.StringType,
			"principal_type": types.StringType,
		},
	}
}

type PrivilegeAssignment struct {
	// The principal (user email address or group name). For deleted principals,
	// `principal` is empty while `principal_id` is populated.
	Principal types.String `tfsdk:"principal"`
	// The privileges assigned to the principal.
	Privileges types.List `tfsdk:"privileges"`
}

func (toState *PrivilegeAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan PrivilegeAssignment) {
}

func (toState *PrivilegeAssignment) SyncFieldsDuringRead(ctx context.Context, fromState PrivilegeAssignment) {
}

func (c PrivilegeAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["principal"] = attrs["principal"].SetOptional()
	attrs["privileges"] = attrs["privileges"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PrivilegeAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PrivilegeAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privileges": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PrivilegeAssignment
// only implements ToObjectValue() and Type().
func (o PrivilegeAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"principal":  o.Principal,
			"privileges": o.Privileges,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PrivilegeAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"principal": types.StringType,
			"privileges": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetPrivileges returns the value of the Privileges field in PrivilegeAssignment as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PrivilegeAssignment) GetPrivileges(ctx context.Context) ([]types.String, bool) {
	if o.Privileges.IsNull() || o.Privileges.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Privileges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivileges sets the value of the Privileges field in PrivilegeAssignment.
func (o *PrivilegeAssignment) SetPrivileges(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["privileges"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Privileges = types.ListValueMust(t, vs)
}

// Status of an asynchronously provisioned resource.
type ProvisioningInfo struct {
	// The provisioning state of the resource.
	State types.String `tfsdk:"state"`
}

func (toState *ProvisioningInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ProvisioningInfo) {
}

func (toState *ProvisioningInfo) SyncFieldsDuringRead(ctx context.Context, fromState ProvisioningInfo) {
}

func (c ProvisioningInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["state"] = attrs["state"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ProvisioningInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ProvisioningInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ProvisioningInfo
// only implements ToObjectValue() and Type().
func (o ProvisioningInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"state": o.State,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ProvisioningInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"state": types.StringType,
		},
	}
}

// Detailed status of an online table. Shown if the online table is in the
// PROVISIONING_PIPELINE_RESOURCES or the PROVISIONING_INITIAL_SNAPSHOT state.
type ProvisioningStatus struct {
	// Details about initial data synchronization. Only populated when in the
	// PROVISIONING_INITIAL_SNAPSHOT state.
	InitialPipelineSyncProgress types.Object `tfsdk:"initial_pipeline_sync_progress"`
}

func (toState *ProvisioningStatus) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ProvisioningStatus) {
	if !fromPlan.InitialPipelineSyncProgress.IsNull() && !fromPlan.InitialPipelineSyncProgress.IsUnknown() {
		if toStateInitialPipelineSyncProgress, ok := toState.GetInitialPipelineSyncProgress(ctx); ok {
			if fromPlanInitialPipelineSyncProgress, ok := fromPlan.GetInitialPipelineSyncProgress(ctx); ok {
				toStateInitialPipelineSyncProgress.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInitialPipelineSyncProgress)
				toState.SetInitialPipelineSyncProgress(ctx, toStateInitialPipelineSyncProgress)
			}
		}
	}
}

func (toState *ProvisioningStatus) SyncFieldsDuringRead(ctx context.Context, fromState ProvisioningStatus) {
	if !fromState.InitialPipelineSyncProgress.IsNull() && !fromState.InitialPipelineSyncProgress.IsUnknown() {
		if toStateInitialPipelineSyncProgress, ok := toState.GetInitialPipelineSyncProgress(ctx); ok {
			if fromStateInitialPipelineSyncProgress, ok := fromState.GetInitialPipelineSyncProgress(ctx); ok {
				toStateInitialPipelineSyncProgress.SyncFieldsDuringRead(ctx, fromStateInitialPipelineSyncProgress)
				toState.SetInitialPipelineSyncProgress(ctx, toStateInitialPipelineSyncProgress)
			}
		}
	}
}

func (c ProvisioningStatus) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["initial_pipeline_sync_progress"] = attrs["initial_pipeline_sync_progress"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ProvisioningStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ProvisioningStatus) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"initial_pipeline_sync_progress": reflect.TypeOf(PipelineProgress{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ProvisioningStatus
// only implements ToObjectValue() and Type().
func (o ProvisioningStatus) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"initial_pipeline_sync_progress": o.InitialPipelineSyncProgress,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ProvisioningStatus) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"initial_pipeline_sync_progress": PipelineProgress{}.Type(ctx),
		},
	}
}

// GetInitialPipelineSyncProgress returns the value of the InitialPipelineSyncProgress field in ProvisioningStatus as
// a PipelineProgress value.
// If the field is unknown or null, the boolean return value is false.
func (o *ProvisioningStatus) GetInitialPipelineSyncProgress(ctx context.Context) (PipelineProgress, bool) {
	var e PipelineProgress
	if o.InitialPipelineSyncProgress.IsNull() || o.InitialPipelineSyncProgress.IsUnknown() {
		return e, false
	}
	var v PipelineProgress
	d := o.InitialPipelineSyncProgress.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInitialPipelineSyncProgress sets the value of the InitialPipelineSyncProgress field in ProvisioningStatus.
func (o *ProvisioningStatus) SetInitialPipelineSyncProgress(ctx context.Context, v PipelineProgress) {
	vs := v.ToObjectValue(ctx)
	o.InitialPipelineSyncProgress = vs
}

type QuotaInfo struct {
	// The timestamp that indicates when the quota count was last updated.
	LastRefreshedAt types.Int64 `tfsdk:"last_refreshed_at"`
	// Name of the parent resource. Returns metastore ID if the parent is a
	// metastore.
	ParentFullName types.String `tfsdk:"parent_full_name"`
	// The quota parent securable type.
	ParentSecurableType types.String `tfsdk:"parent_securable_type"`
	// The current usage of the resource quota.
	QuotaCount types.Int64 `tfsdk:"quota_count"`
	// The current limit of the resource quota.
	QuotaLimit types.Int64 `tfsdk:"quota_limit"`
	// The name of the quota.
	QuotaName types.String `tfsdk:"quota_name"`
}

func (toState *QuotaInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan QuotaInfo) {
}

func (toState *QuotaInfo) SyncFieldsDuringRead(ctx context.Context, fromState QuotaInfo) {
}

func (c QuotaInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_refreshed_at"] = attrs["last_refreshed_at"].SetOptional()
	attrs["parent_full_name"] = attrs["parent_full_name"].SetOptional()
	attrs["parent_securable_type"] = attrs["parent_securable_type"].SetOptional()
	attrs["quota_count"] = attrs["quota_count"].SetOptional()
	attrs["quota_limit"] = attrs["quota_limit"].SetOptional()
	attrs["quota_name"] = attrs["quota_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QuotaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a QuotaInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QuotaInfo
// only implements ToObjectValue() and Type().
func (o QuotaInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_refreshed_at":     o.LastRefreshedAt,
			"parent_full_name":      o.ParentFullName,
			"parent_securable_type": o.ParentSecurableType,
			"quota_count":           o.QuotaCount,
			"quota_limit":           o.QuotaLimit,
			"quota_name":            o.QuotaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o QuotaInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_refreshed_at":     types.Int64Type,
			"parent_full_name":      types.StringType,
			"parent_securable_type": types.StringType,
			"quota_count":           types.Int64Type,
			"quota_limit":           types.Int64Type,
			"quota_name":            types.StringType,
		},
	}
}

// R2 temporary credentials for API authentication. Read more at
// https://developers.cloudflare.com/r2/api/s3/tokens/.
type R2Credentials struct {
	// The access key ID that identifies the temporary credentials.
	AccessKeyId types.String `tfsdk:"access_key_id"`
	// The secret access key associated with the access key.
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
	// The generated JWT that users must pass to use the temporary credentials.
	SessionToken types.String `tfsdk:"session_token"`
}

func (toState *R2Credentials) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan R2Credentials) {
}

func (toState *R2Credentials) SyncFieldsDuringRead(ctx context.Context, fromState R2Credentials) {
}

func (c R2Credentials) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_key_id"] = attrs["access_key_id"].SetOptional()
	attrs["secret_access_key"] = attrs["secret_access_key"].SetOptional()
	attrs["session_token"] = attrs["session_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in R2Credentials.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a R2Credentials) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, R2Credentials
// only implements ToObjectValue() and Type().
func (o R2Credentials) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_key_id":     o.AccessKeyId,
			"secret_access_key": o.SecretAccessKey,
			"session_token":     o.SessionToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o R2Credentials) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_key_id":     types.StringType,
			"secret_access_key": types.StringType,
			"session_token":     types.StringType,
		},
	}
}

type ReadVolumeRequest struct {
	// Whether to include volumes in the response for which the principal can
	// only access selective metadata for
	IncludeBrowse types.Bool `tfsdk:"-"`
	// The three-level (fully qualified) name of the volume
	Name types.String `tfsdk:"-"`
}

func (toState *ReadVolumeRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ReadVolumeRequest) {
}

func (toState *ReadVolumeRequest) SyncFieldsDuringRead(ctx context.Context, fromState ReadVolumeRequest) {
}

func (c ReadVolumeRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["include_browse"] = attrs["include_browse"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ReadVolumeRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ReadVolumeRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ReadVolumeRequest
// only implements ToObjectValue() and Type().
func (o ReadVolumeRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_browse": o.IncludeBrowse,
			"name":           o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ReadVolumeRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_browse": types.BoolType,
			"name":           types.StringType,
		},
	}
}

type RegenerateDashboardRequest struct {
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
	// Optional argument to specify the warehouse for dashboard regeneration. If
	// not specified, the first running warehouse will be used.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (toState *RegenerateDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan RegenerateDashboardRequest) {
}

func (toState *RegenerateDashboardRequest) SyncFieldsDuringRead(ctx context.Context, fromState RegenerateDashboardRequest) {
}

func (c RegenerateDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegenerateDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RegenerateDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegenerateDashboardRequest
// only implements ToObjectValue() and Type().
func (o RegenerateDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name":   o.TableName,
			"warehouse_id": o.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RegenerateDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name":   types.StringType,
			"warehouse_id": types.StringType,
		},
	}
}

type RegenerateDashboardResponse struct {
	DashboardId types.String `tfsdk:"dashboard_id"`
	// Parent folder is equivalent to {assets_dir}/{tableName}
	ParentFolder types.String `tfsdk:"parent_folder"`
}

func (toState *RegenerateDashboardResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan RegenerateDashboardResponse) {
}

func (toState *RegenerateDashboardResponse) SyncFieldsDuringRead(ctx context.Context, fromState RegenerateDashboardResponse) {
}

func (c RegenerateDashboardResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetOptional()
	attrs["parent_folder"] = attrs["parent_folder"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegenerateDashboardResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RegenerateDashboardResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegenerateDashboardResponse
// only implements ToObjectValue() and Type().
func (o RegenerateDashboardResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id":  o.DashboardId,
			"parent_folder": o.ParentFolder,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RegenerateDashboardResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id":  types.StringType,
			"parent_folder": types.StringType,
		},
	}
}

// Registered model alias.
type RegisteredModelAlias struct {
	// Name of the alias, e.g. 'champion' or 'latest_stable'
	AliasName types.String `tfsdk:"alias_name"`
	// Integer version number of the model version to which this alias points.
	VersionNum types.Int64 `tfsdk:"version_num"`
}

func (toState *RegisteredModelAlias) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan RegisteredModelAlias) {
}

func (toState *RegisteredModelAlias) SyncFieldsDuringRead(ctx context.Context, fromState RegisteredModelAlias) {
}

func (c RegisteredModelAlias) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias_name"] = attrs["alias_name"].SetOptional()
	attrs["version_num"] = attrs["version_num"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegisteredModelAlias.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RegisteredModelAlias) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegisteredModelAlias
// only implements ToObjectValue() and Type().
func (o RegisteredModelAlias) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias_name":  o.AliasName,
			"version_num": o.VersionNum,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RegisteredModelAlias) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias_name":  types.StringType,
			"version_num": types.Int64Type,
		},
	}
}

type RegisteredModelInfo struct {
	// List of aliases associated with the registered model
	Aliases types.List `tfsdk:"aliases"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog where the schema and the registered model reside
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the registered model
	Comment types.String `tfsdk:"comment"`
	// Creation timestamp of the registered model in milliseconds since the Unix
	// epoch
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the registered model
	CreatedBy types.String `tfsdk:"created_by"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the metastore
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the registered model
	Name types.String `tfsdk:"name"`
	// The identifier of the user who owns the registered model
	Owner types.String `tfsdk:"owner"`
	// The name of the schema where the registered model resides
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud under which model version data files
	// are stored
	StorageLocation types.String `tfsdk:"storage_location"`
	// Last-update timestamp of the registered model in milliseconds since the
	// Unix epoch
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the registered model last time
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (toState *RegisteredModelInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan RegisteredModelInfo) {
}

func (toState *RegisteredModelInfo) SyncFieldsDuringRead(ctx context.Context, fromState RegisteredModelInfo) {
}

func (c RegisteredModelInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aliases"] = attrs["aliases"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RegisteredModelInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RegisteredModelInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aliases": reflect.TypeOf(RegisteredModelAlias{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RegisteredModelInfo
// only implements ToObjectValue() and Type().
func (o RegisteredModelInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aliases":          o.Aliases,
			"browse_only":      o.BrowseOnly,
			"catalog_name":     o.CatalogName,
			"comment":          o.Comment,
			"created_at":       o.CreatedAt,
			"created_by":       o.CreatedBy,
			"full_name":        o.FullName,
			"metastore_id":     o.MetastoreId,
			"name":             o.Name,
			"owner":            o.Owner,
			"schema_name":      o.SchemaName,
			"storage_location": o.StorageLocation,
			"updated_at":       o.UpdatedAt,
			"updated_by":       o.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RegisteredModelInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: RegisteredModelAlias{}.Type(ctx),
			},
			"browse_only":      types.BoolType,
			"catalog_name":     types.StringType,
			"comment":          types.StringType,
			"created_at":       types.Int64Type,
			"created_by":       types.StringType,
			"full_name":        types.StringType,
			"metastore_id":     types.StringType,
			"name":             types.StringType,
			"owner":            types.StringType,
			"schema_name":      types.StringType,
			"storage_location": types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetAliases returns the value of the Aliases field in RegisteredModelInfo as
// a slice of RegisteredModelAlias values.
// If the field is unknown or null, the boolean return value is false.
func (o *RegisteredModelInfo) GetAliases(ctx context.Context) ([]RegisteredModelAlias, bool) {
	if o.Aliases.IsNull() || o.Aliases.IsUnknown() {
		return nil, false
	}
	var v []RegisteredModelAlias
	d := o.Aliases.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAliases sets the value of the Aliases field in RegisteredModelInfo.
func (o *RegisteredModelInfo) SetAliases(ctx context.Context, v []RegisteredModelAlias) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["aliases"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Aliases = types.ListValueMust(t, vs)
}

type RowFilterOptions struct {
	// The fully qualified name of the row filter function. The function is
	// called on each row of the target table. It should return a boolean value
	// indicating whether the row should be visible to the user. Required on
	// create and update.
	FunctionName types.String `tfsdk:"function_name"`
	// Optional list of column aliases or constant literals to be passed as
	// arguments to the row filter function. The type of each column should
	// match the positional argument of the row filter function.
	Using types.List `tfsdk:"using"`
}

func (toState *RowFilterOptions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan RowFilterOptions) {
}

func (toState *RowFilterOptions) SyncFieldsDuringRead(ctx context.Context, fromState RowFilterOptions) {
}

func (c RowFilterOptions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetRequired()
	attrs["using"] = attrs["using"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RowFilterOptions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RowFilterOptions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"using": reflect.TypeOf(FunctionArgument{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RowFilterOptions
// only implements ToObjectValue() and Type().
func (o RowFilterOptions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name": o.FunctionName,
			"using":         o.Using,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RowFilterOptions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"using": basetypes.ListType{
				ElemType: FunctionArgument{}.Type(ctx),
			},
		},
	}
}

// GetUsing returns the value of the Using field in RowFilterOptions as
// a slice of FunctionArgument values.
// If the field is unknown or null, the boolean return value is false.
func (o *RowFilterOptions) GetUsing(ctx context.Context) ([]FunctionArgument, bool) {
	if o.Using.IsNull() || o.Using.IsUnknown() {
		return nil, false
	}
	var v []FunctionArgument
	d := o.Using.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUsing sets the value of the Using field in RowFilterOptions.
func (o *RowFilterOptions) SetUsing(ctx context.Context, v []FunctionArgument) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["using"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Using = types.ListValueMust(t, vs)
}

type RunRefreshRequest struct {
	// UC table name in format `catalog.schema.table_name`. table_name is case
	// insensitive and spaces are disallowed.
	TableName types.String `tfsdk:"-"`
}

func (toState *RunRefreshRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan RunRefreshRequest) {
}

func (toState *RunRefreshRequest) SyncFieldsDuringRead(ctx context.Context, fromState RunRefreshRequest) {
}

func (c RunRefreshRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunRefreshRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RunRefreshRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunRefreshRequest
// only implements ToObjectValue() and Type().
func (o RunRefreshRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_name": o.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RunRefreshRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_name": types.StringType,
		},
	}
}

// Next ID: 40
type SchemaInfo struct {
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// The type of the parent catalog.
	CatalogType types.String `tfsdk:"catalog_type"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this schema was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of schema creator.
	CreatedBy types.String `tfsdk:"created_by"`

	EffectivePredictiveOptimizationFlag types.Object `tfsdk:"effective_predictive_optimization_flag"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// Full name of schema, in form of __catalog_name__.__schema_name__.
	FullName types.String `tfsdk:"full_name"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of schema, relative to parent catalog.
	Name types.String `tfsdk:"name"`
	// Username of current owner of schema.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
	// The unique identifier of the schema.
	SchemaId types.String `tfsdk:"schema_id"`
	// Storage location for managed tables within schema.
	StorageLocation types.String `tfsdk:"storage_location"`
	// Storage root URL for managed tables within schema.
	StorageRoot types.String `tfsdk:"storage_root"`
	// Time at which this schema was created, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified schema.
	UpdatedBy types.String `tfsdk:"updated_by"`
}

func (toState *SchemaInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SchemaInfo) {
	if !fromPlan.EffectivePredictiveOptimizationFlag.IsNull() && !fromPlan.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toStateEffectivePredictiveOptimizationFlag, ok := toState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromPlanEffectivePredictiveOptimizationFlag, ok := fromPlan.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toStateEffectivePredictiveOptimizationFlag.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEffectivePredictiveOptimizationFlag)
				toState.SetEffectivePredictiveOptimizationFlag(ctx, toStateEffectivePredictiveOptimizationFlag)
			}
		}
	}
}

func (toState *SchemaInfo) SyncFieldsDuringRead(ctx context.Context, fromState SchemaInfo) {
	if !fromState.EffectivePredictiveOptimizationFlag.IsNull() && !fromState.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toStateEffectivePredictiveOptimizationFlag, ok := toState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromStateEffectivePredictiveOptimizationFlag, ok := fromState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toStateEffectivePredictiveOptimizationFlag.SyncFieldsDuringRead(ctx, fromStateEffectivePredictiveOptimizationFlag)
				toState.SetEffectivePredictiveOptimizationFlag(ctx, toStateEffectivePredictiveOptimizationFlag)
			}
		}
	}
}

func (c SchemaInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["catalog_type"] = attrs["catalog_type"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["schema_id"] = attrs["schema_id"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["storage_root"] = attrs["storage_root"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SchemaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SchemaInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"effective_predictive_optimization_flag": reflect.TypeOf(EffectivePredictiveOptimizationFlag{}),
		"properties":                             reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SchemaInfo
// only implements ToObjectValue() and Type().
func (o SchemaInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"browse_only":                            o.BrowseOnly,
			"catalog_name":                           o.CatalogName,
			"catalog_type":                           o.CatalogType,
			"comment":                                o.Comment,
			"created_at":                             o.CreatedAt,
			"created_by":                             o.CreatedBy,
			"effective_predictive_optimization_flag": o.EffectivePredictiveOptimizationFlag,
			"enable_predictive_optimization":         o.EnablePredictiveOptimization,
			"full_name":                              o.FullName,
			"metastore_id":                           o.MetastoreId,
			"name":                                   o.Name,
			"owner":                                  o.Owner,
			"properties":                             o.Properties,
			"schema_id":                              o.SchemaId,
			"storage_location":                       o.StorageLocation,
			"storage_root":                           o.StorageRoot,
			"updated_at":                             o.UpdatedAt,
			"updated_by":                             o.UpdatedBy,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SchemaInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"browse_only":                            types.BoolType,
			"catalog_name":                           types.StringType,
			"catalog_type":                           types.StringType,
			"comment":                                types.StringType,
			"created_at":                             types.Int64Type,
			"created_by":                             types.StringType,
			"effective_predictive_optimization_flag": EffectivePredictiveOptimizationFlag{}.Type(ctx),
			"enable_predictive_optimization":         types.StringType,
			"full_name":                              types.StringType,
			"metastore_id":                           types.StringType,
			"name":                                   types.StringType,
			"owner":                                  types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"schema_id":        types.StringType,
			"storage_location": types.StringType,
			"storage_root":     types.StringType,
			"updated_at":       types.Int64Type,
			"updated_by":       types.StringType,
		},
	}
}

// GetEffectivePredictiveOptimizationFlag returns the value of the EffectivePredictiveOptimizationFlag field in SchemaInfo as
// a EffectivePredictiveOptimizationFlag value.
// If the field is unknown or null, the boolean return value is false.
func (o *SchemaInfo) GetEffectivePredictiveOptimizationFlag(ctx context.Context) (EffectivePredictiveOptimizationFlag, bool) {
	var e EffectivePredictiveOptimizationFlag
	if o.EffectivePredictiveOptimizationFlag.IsNull() || o.EffectivePredictiveOptimizationFlag.IsUnknown() {
		return e, false
	}
	var v EffectivePredictiveOptimizationFlag
	d := o.EffectivePredictiveOptimizationFlag.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEffectivePredictiveOptimizationFlag sets the value of the EffectivePredictiveOptimizationFlag field in SchemaInfo.
func (o *SchemaInfo) SetEffectivePredictiveOptimizationFlag(ctx context.Context, v EffectivePredictiveOptimizationFlag) {
	vs := v.ToObjectValue(ctx)
	o.EffectivePredictiveOptimizationFlag = vs
}

// GetProperties returns the value of the Properties field in SchemaInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *SchemaInfo) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in SchemaInfo.
func (o *SchemaInfo) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// Generic definition of a securable, which is uniquely defined in a metastore
// by its type and full name.
type Securable struct {
	// Required. The full name of the catalog/schema/table. Optional if
	// resource_name is present.
	FullName types.String `tfsdk:"full_name"`
	// Optional. The name of the Share object that contains the securable when
	// the securable is getting shared in D2D Delta Sharing.
	ProviderShare types.String `tfsdk:"provider_share"`
	// Required. The type of securable (catalog/schema/table). Optional if
	// resource_name is present.
	Type_ types.String `tfsdk:"type"`
}

func (toState *Securable) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan Securable) {
}

func (toState *Securable) SyncFieldsDuringRead(ctx context.Context, fromState Securable) {
}

func (c Securable) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["provider_share"] = attrs["provider_share"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Securable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Securable) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Securable
// only implements ToObjectValue() and Type().
func (o Securable) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":      o.FullName,
			"provider_share": o.ProviderShare,
			"type":           o.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Securable) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":      types.StringType,
			"provider_share": types.StringType,
			"type":           types.StringType,
		},
	}
}

// Manifest of a specific securable kind.
type SecurableKindManifest struct {
	// Privileges that can be assigned to the securable.
	AssignablePrivileges types.List `tfsdk:"assignable_privileges"`
	// A list of capabilities in the securable kind.
	Capabilities types.List `tfsdk:"capabilities"`
	// Detailed specs of allowed options.
	Options types.List `tfsdk:"options"`
	// Securable kind to get manifest of.
	SecurableKind types.String `tfsdk:"securable_kind"`
	// Securable Type of the kind.
	SecurableType types.String `tfsdk:"securable_type"`
}

func (toState *SecurableKindManifest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SecurableKindManifest) {
}

func (toState *SecurableKindManifest) SyncFieldsDuringRead(ctx context.Context, fromState SecurableKindManifest) {
}

func (c SecurableKindManifest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assignable_privileges"] = attrs["assignable_privileges"].SetOptional()
	attrs["capabilities"] = attrs["capabilities"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["securable_kind"] = attrs["securable_kind"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SecurableKindManifest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SecurableKindManifest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"assignable_privileges": reflect.TypeOf(types.String{}),
		"capabilities":          reflect.TypeOf(types.String{}),
		"options":               reflect.TypeOf(OptionSpec{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SecurableKindManifest
// only implements ToObjectValue() and Type().
func (o SecurableKindManifest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assignable_privileges": o.AssignablePrivileges,
			"capabilities":          o.Capabilities,
			"options":               o.Options,
			"securable_kind":        o.SecurableKind,
			"securable_type":        o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SecurableKindManifest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assignable_privileges": basetypes.ListType{
				ElemType: types.StringType,
			},
			"capabilities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"options": basetypes.ListType{
				ElemType: OptionSpec{}.Type(ctx),
			},
			"securable_kind": types.StringType,
			"securable_type": types.StringType,
		},
	}
}

// GetAssignablePrivileges returns the value of the AssignablePrivileges field in SecurableKindManifest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *SecurableKindManifest) GetAssignablePrivileges(ctx context.Context) ([]types.String, bool) {
	if o.AssignablePrivileges.IsNull() || o.AssignablePrivileges.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.AssignablePrivileges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAssignablePrivileges sets the value of the AssignablePrivileges field in SecurableKindManifest.
func (o *SecurableKindManifest) SetAssignablePrivileges(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["assignable_privileges"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AssignablePrivileges = types.ListValueMust(t, vs)
}

// GetCapabilities returns the value of the Capabilities field in SecurableKindManifest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *SecurableKindManifest) GetCapabilities(ctx context.Context) ([]types.String, bool) {
	if o.Capabilities.IsNull() || o.Capabilities.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Capabilities.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCapabilities sets the value of the Capabilities field in SecurableKindManifest.
func (o *SecurableKindManifest) SetCapabilities(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["capabilities"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Capabilities = types.ListValueMust(t, vs)
}

// GetOptions returns the value of the Options field in SecurableKindManifest as
// a slice of OptionSpec values.
// If the field is unknown or null, the boolean return value is false.
func (o *SecurableKindManifest) GetOptions(ctx context.Context) ([]OptionSpec, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v []OptionSpec
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in SecurableKindManifest.
func (o *SecurableKindManifest) SetOptions(ctx context.Context, v []OptionSpec) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.ListValueMust(t, vs)
}

type SecurablePermissions struct {
	// List of requested Unity Catalog permissions.
	Permissions types.List `tfsdk:"permissions"`
	// The securable for which the access request destinations are being
	// requested.
	Securable types.Object `tfsdk:"securable"`
}

func (toState *SecurablePermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SecurablePermissions) {
	if !fromPlan.Securable.IsNull() && !fromPlan.Securable.IsUnknown() {
		if toStateSecurable, ok := toState.GetSecurable(ctx); ok {
			if fromPlanSecurable, ok := fromPlan.GetSecurable(ctx); ok {
				toStateSecurable.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSecurable)
				toState.SetSecurable(ctx, toStateSecurable)
			}
		}
	}
}

func (toState *SecurablePermissions) SyncFieldsDuringRead(ctx context.Context, fromState SecurablePermissions) {
	if !fromState.Securable.IsNull() && !fromState.Securable.IsUnknown() {
		if toStateSecurable, ok := toState.GetSecurable(ctx); ok {
			if fromStateSecurable, ok := fromState.GetSecurable(ctx); ok {
				toStateSecurable.SyncFieldsDuringRead(ctx, fromStateSecurable)
				toState.SetSecurable(ctx, toStateSecurable)
			}
		}
	}
}

func (c SecurablePermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permissions"] = attrs["permissions"].SetOptional()
	attrs["securable"] = attrs["securable"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SecurablePermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SecurablePermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permissions": reflect.TypeOf(types.String{}),
		"securable":   reflect.TypeOf(Securable{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SecurablePermissions
// only implements ToObjectValue() and Type().
func (o SecurablePermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permissions": o.Permissions,
			"securable":   o.Securable,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SecurablePermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permissions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"securable": Securable{}.Type(ctx),
		},
	}
}

// GetPermissions returns the value of the Permissions field in SecurablePermissions as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *SecurablePermissions) GetPermissions(ctx context.Context) ([]types.String, bool) {
	if o.Permissions.IsNull() || o.Permissions.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Permissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissions sets the value of the Permissions field in SecurablePermissions.
func (o *SecurablePermissions) SetPermissions(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Permissions = types.ListValueMust(t, vs)
}

// GetSecurable returns the value of the Securable field in SecurablePermissions as
// a Securable value.
// If the field is unknown or null, the boolean return value is false.
func (o *SecurablePermissions) GetSecurable(ctx context.Context) (Securable, bool) {
	var e Securable
	if o.Securable.IsNull() || o.Securable.IsUnknown() {
		return e, false
	}
	var v Securable
	d := o.Securable.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSecurable sets the value of the Securable field in SecurablePermissions.
func (o *SecurablePermissions) SetSecurable(ctx context.Context, v Securable) {
	vs := v.ToObjectValue(ctx)
	o.Securable = vs
}

type SetArtifactAllowlist struct {
	// A list of allowed artifact match patterns.
	ArtifactMatchers types.List `tfsdk:"artifact_matchers"`
	// The artifact type of the allowlist.
	ArtifactType types.String `tfsdk:"-"`
	// Time at which this artifact allowlist was set, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of the user who set the artifact allowlist.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
}

func (toState *SetArtifactAllowlist) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SetArtifactAllowlist) {
}

func (toState *SetArtifactAllowlist) SyncFieldsDuringRead(ctx context.Context, fromState SetArtifactAllowlist) {
}

func (c SetArtifactAllowlist) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifact_matchers"] = attrs["artifact_matchers"].SetRequired()
	attrs["created_at"] = attrs["created_at"].SetComputed()
	attrs["created_by"] = attrs["created_by"].SetComputed()
	attrs["metastore_id"] = attrs["metastore_id"].SetComputed()
	attrs["artifact_type"] = attrs["artifact_type"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SetArtifactAllowlist.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SetArtifactAllowlist) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"artifact_matchers": reflect.TypeOf(ArtifactMatcher{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SetArtifactAllowlist
// only implements ToObjectValue() and Type().
func (o SetArtifactAllowlist) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifact_matchers": o.ArtifactMatchers,
			"artifact_type":     o.ArtifactType,
			"created_at":        o.CreatedAt,
			"created_by":        o.CreatedBy,
			"metastore_id":      o.MetastoreId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SetArtifactAllowlist) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifact_matchers": basetypes.ListType{
				ElemType: ArtifactMatcher{}.Type(ctx),
			},
			"artifact_type": types.StringType,
			"created_at":    types.Int64Type,
			"created_by":    types.StringType,
			"metastore_id":  types.StringType,
		},
	}
}

// GetArtifactMatchers returns the value of the ArtifactMatchers field in SetArtifactAllowlist as
// a slice of ArtifactMatcher values.
// If the field is unknown or null, the boolean return value is false.
func (o *SetArtifactAllowlist) GetArtifactMatchers(ctx context.Context) ([]ArtifactMatcher, bool) {
	if o.ArtifactMatchers.IsNull() || o.ArtifactMatchers.IsUnknown() {
		return nil, false
	}
	var v []ArtifactMatcher
	d := o.ArtifactMatchers.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetArtifactMatchers sets the value of the ArtifactMatchers field in SetArtifactAllowlist.
func (o *SetArtifactAllowlist) SetArtifactMatchers(ctx context.Context, v []ArtifactMatcher) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["artifact_matchers"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.ArtifactMatchers = types.ListValueMust(t, vs)
}

type SetRegisteredModelAliasRequest struct {
	// The name of the alias
	Alias types.String `tfsdk:"alias"`
	// Full name of the registered model
	FullName types.String `tfsdk:"full_name"`
	// The version number of the model version to which the alias points
	VersionNum types.Int64 `tfsdk:"version_num"`
}

func (toState *SetRegisteredModelAliasRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SetRegisteredModelAliasRequest) {
}

func (toState *SetRegisteredModelAliasRequest) SyncFieldsDuringRead(ctx context.Context, fromState SetRegisteredModelAliasRequest) {
}

func (c SetRegisteredModelAliasRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alias"] = attrs["alias"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version_num"] = attrs["version_num"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SetRegisteredModelAliasRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SetRegisteredModelAliasRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SetRegisteredModelAliasRequest
// only implements ToObjectValue() and Type().
func (o SetRegisteredModelAliasRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alias":       o.Alias,
			"full_name":   o.FullName,
			"version_num": o.VersionNum,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SetRegisteredModelAliasRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alias":       types.StringType,
			"full_name":   types.StringType,
			"version_num": types.Int64Type,
		},
	}
}

// Server-Side Encryption properties for clients communicating with AWS s3.
type SseEncryptionDetails struct {
	// Sets the value of the 'x-amz-server-side-encryption' header in S3
	// request.
	Algorithm types.String `tfsdk:"algorithm"`
	// Optional. The ARN of the SSE-KMS key used with the S3 location, when
	// algorithm = "SSE-KMS". Sets the value of the
	// 'x-amz-server-side-encryption-aws-kms-key-id' header.
	AwsKmsKeyArn types.String `tfsdk:"aws_kms_key_arn"`
}

func (toState *SseEncryptionDetails) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SseEncryptionDetails) {
}

func (toState *SseEncryptionDetails) SyncFieldsDuringRead(ctx context.Context, fromState SseEncryptionDetails) {
}

func (c SseEncryptionDetails) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["algorithm"] = attrs["algorithm"].SetOptional()
	attrs["aws_kms_key_arn"] = attrs["aws_kms_key_arn"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SseEncryptionDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SseEncryptionDetails) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SseEncryptionDetails
// only implements ToObjectValue() and Type().
func (o SseEncryptionDetails) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"algorithm":       o.Algorithm,
			"aws_kms_key_arn": o.AwsKmsKeyArn,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SseEncryptionDetails) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"algorithm":       types.StringType,
			"aws_kms_key_arn": types.StringType,
		},
	}
}

type StorageCredentialInfo struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.Object `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// Time at which this credential was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of credential creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// The full name of the credential.
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the credential.
	Id types.String `tfsdk:"id"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Unique identifier of the parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The credential name. The name must be unique among storage and service
	// credentials within the metastore.
	Name types.String `tfsdk:"name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Time at which this credential was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the credential.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// Whether this credential is the current metastore's root storage
	// credential. Only applicable when purpose is **STORAGE**.
	UsedForManagedStorage types.Bool `tfsdk:"used_for_managed_storage"`
}

func (toState *StorageCredentialInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan StorageCredentialInfo) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.CloudflareApiToken.IsNull() && !fromPlan.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromPlanCloudflareApiToken, ok := fromPlan.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *StorageCredentialInfo) SyncFieldsDuringRead(ctx context.Context, fromState StorageCredentialInfo) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.CloudflareApiToken.IsNull() && !fromState.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromStateCloudflareApiToken, ok := fromState.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringRead(ctx, fromStateCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c StorageCredentialInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["used_for_managed_storage"] = attrs["used_for_managed_storage"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in StorageCredentialInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a StorageCredentialInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleResponse{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityResponse{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountResponse{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, StorageCredentialInfo
// only implements ToObjectValue() and Type().
func (o StorageCredentialInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"cloudflare_api_token":           o.CloudflareApiToken,
			"comment":                        o.Comment,
			"created_at":                     o.CreatedAt,
			"created_by":                     o.CreatedBy,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"full_name":                      o.FullName,
			"id":                             o.Id,
			"isolation_mode":                 o.IsolationMode,
			"metastore_id":                   o.MetastoreId,
			"name":                           o.Name,
			"owner":                          o.Owner,
			"read_only":                      o.ReadOnly,
			"updated_at":                     o.UpdatedAt,
			"updated_by":                     o.UpdatedBy,
			"used_for_managed_storage":       o.UsedForManagedStorage,
		})
}

// Type implements basetypes.ObjectValuable.
func (o StorageCredentialInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRoleResponse{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentityResponse{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"cloudflare_api_token":           CloudflareApiToken{}.Type(ctx),
			"comment":                        types.StringType,
			"created_at":                     types.Int64Type,
			"created_by":                     types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccountResponse{}.Type(ctx),
			"full_name":                      types.StringType,
			"id":                             types.StringType,
			"isolation_mode":                 types.StringType,
			"metastore_id":                   types.StringType,
			"name":                           types.StringType,
			"owner":                          types.StringType,
			"read_only":                      types.BoolType,
			"updated_at":                     types.Int64Type,
			"updated_by":                     types.StringType,
			"used_for_managed_storage":       types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in StorageCredentialInfo as
// a AwsIamRoleResponse value.
// If the field is unknown or null, the boolean return value is false.
func (o *StorageCredentialInfo) GetAwsIamRole(ctx context.Context) (AwsIamRoleResponse, bool) {
	var e AwsIamRoleResponse
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRoleResponse
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in StorageCredentialInfo.
func (o *StorageCredentialInfo) SetAwsIamRole(ctx context.Context, v AwsIamRoleResponse) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in StorageCredentialInfo as
// a AzureManagedIdentityResponse value.
// If the field is unknown or null, the boolean return value is false.
func (o *StorageCredentialInfo) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityResponse, bool) {
	var e AzureManagedIdentityResponse
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentityResponse
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in StorageCredentialInfo.
func (o *StorageCredentialInfo) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityResponse) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in StorageCredentialInfo as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *StorageCredentialInfo) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in StorageCredentialInfo.
func (o *StorageCredentialInfo) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in StorageCredentialInfo as
// a CloudflareApiToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *StorageCredentialInfo) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken, bool) {
	var e CloudflareApiToken
	if o.CloudflareApiToken.IsNull() || o.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v CloudflareApiToken
	d := o.CloudflareApiToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in StorageCredentialInfo.
func (o *StorageCredentialInfo) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken) {
	vs := v.ToObjectValue(ctx)
	o.CloudflareApiToken = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in StorageCredentialInfo as
// a DatabricksGcpServiceAccountResponse value.
// If the field is unknown or null, the boolean return value is false.
func (o *StorageCredentialInfo) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountResponse, bool) {
	var e DatabricksGcpServiceAccountResponse
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccountResponse
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in StorageCredentialInfo.
func (o *StorageCredentialInfo) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountResponse) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type SummaryRequest struct {
}

func (toState *SummaryRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SummaryRequest) {
}

func (toState *SummaryRequest) SyncFieldsDuringRead(ctx context.Context, fromState SummaryRequest) {
}

func (c SummaryRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SummaryRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SummaryRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SummaryRequest
// only implements ToObjectValue() and Type().
func (o SummaryRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o SummaryRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type SystemSchemaInfo struct {
	// Name of the system schema.
	Schema types.String `tfsdk:"schema"`
	// The current state of enablement for the system schema. An empty string
	// means the system schema is available and ready for opt-in. Possible
	// values: AVAILABLE | ENABLE_INITIALIZED | ENABLE_COMPLETED |
	// DISABLE_INITIALIZED | UNAVAILABLE | MANAGED
	State types.String `tfsdk:"state"`
}

func (toState *SystemSchemaInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan SystemSchemaInfo) {
}

func (toState *SystemSchemaInfo) SyncFieldsDuringRead(ctx context.Context, fromState SystemSchemaInfo) {
}

func (c SystemSchemaInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["schema"] = attrs["schema"].SetRequired()
	attrs["state"] = attrs["state"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SystemSchemaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SystemSchemaInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SystemSchemaInfo
// only implements ToObjectValue() and Type().
func (o SystemSchemaInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"schema": o.Schema,
			"state":  o.State,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SystemSchemaInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"schema": types.StringType,
			"state":  types.StringType,
		},
	}
}

// A table constraint, as defined by *one* of the following fields being set:
// __primary_key_constraint__, __foreign_key_constraint__,
// __named_table_constraint__.
type TableConstraint struct {
	ForeignKeyConstraint types.Object `tfsdk:"foreign_key_constraint"`

	NamedTableConstraint types.Object `tfsdk:"named_table_constraint"`

	PrimaryKeyConstraint types.Object `tfsdk:"primary_key_constraint"`
}

func (toState *TableConstraint) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TableConstraint) {
	if !fromPlan.ForeignKeyConstraint.IsNull() && !fromPlan.ForeignKeyConstraint.IsUnknown() {
		if toStateForeignKeyConstraint, ok := toState.GetForeignKeyConstraint(ctx); ok {
			if fromPlanForeignKeyConstraint, ok := fromPlan.GetForeignKeyConstraint(ctx); ok {
				toStateForeignKeyConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanForeignKeyConstraint)
				toState.SetForeignKeyConstraint(ctx, toStateForeignKeyConstraint)
			}
		}
	}
	if !fromPlan.NamedTableConstraint.IsNull() && !fromPlan.NamedTableConstraint.IsUnknown() {
		if toStateNamedTableConstraint, ok := toState.GetNamedTableConstraint(ctx); ok {
			if fromPlanNamedTableConstraint, ok := fromPlan.GetNamedTableConstraint(ctx); ok {
				toStateNamedTableConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanNamedTableConstraint)
				toState.SetNamedTableConstraint(ctx, toStateNamedTableConstraint)
			}
		}
	}
	if !fromPlan.PrimaryKeyConstraint.IsNull() && !fromPlan.PrimaryKeyConstraint.IsUnknown() {
		if toStatePrimaryKeyConstraint, ok := toState.GetPrimaryKeyConstraint(ctx); ok {
			if fromPlanPrimaryKeyConstraint, ok := fromPlan.GetPrimaryKeyConstraint(ctx); ok {
				toStatePrimaryKeyConstraint.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanPrimaryKeyConstraint)
				toState.SetPrimaryKeyConstraint(ctx, toStatePrimaryKeyConstraint)
			}
		}
	}
}

func (toState *TableConstraint) SyncFieldsDuringRead(ctx context.Context, fromState TableConstraint) {
	if !fromState.ForeignKeyConstraint.IsNull() && !fromState.ForeignKeyConstraint.IsUnknown() {
		if toStateForeignKeyConstraint, ok := toState.GetForeignKeyConstraint(ctx); ok {
			if fromStateForeignKeyConstraint, ok := fromState.GetForeignKeyConstraint(ctx); ok {
				toStateForeignKeyConstraint.SyncFieldsDuringRead(ctx, fromStateForeignKeyConstraint)
				toState.SetForeignKeyConstraint(ctx, toStateForeignKeyConstraint)
			}
		}
	}
	if !fromState.NamedTableConstraint.IsNull() && !fromState.NamedTableConstraint.IsUnknown() {
		if toStateNamedTableConstraint, ok := toState.GetNamedTableConstraint(ctx); ok {
			if fromStateNamedTableConstraint, ok := fromState.GetNamedTableConstraint(ctx); ok {
				toStateNamedTableConstraint.SyncFieldsDuringRead(ctx, fromStateNamedTableConstraint)
				toState.SetNamedTableConstraint(ctx, toStateNamedTableConstraint)
			}
		}
	}
	if !fromState.PrimaryKeyConstraint.IsNull() && !fromState.PrimaryKeyConstraint.IsUnknown() {
		if toStatePrimaryKeyConstraint, ok := toState.GetPrimaryKeyConstraint(ctx); ok {
			if fromStatePrimaryKeyConstraint, ok := fromState.GetPrimaryKeyConstraint(ctx); ok {
				toStatePrimaryKeyConstraint.SyncFieldsDuringRead(ctx, fromStatePrimaryKeyConstraint)
				toState.SetPrimaryKeyConstraint(ctx, toStatePrimaryKeyConstraint)
			}
		}
	}
}

func (c TableConstraint) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["foreign_key_constraint"] = attrs["foreign_key_constraint"].SetOptional()
	attrs["named_table_constraint"] = attrs["named_table_constraint"].SetOptional()
	attrs["primary_key_constraint"] = attrs["primary_key_constraint"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableConstraint.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TableConstraint) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"foreign_key_constraint": reflect.TypeOf(ForeignKeyConstraint{}),
		"named_table_constraint": reflect.TypeOf(NamedTableConstraint{}),
		"primary_key_constraint": reflect.TypeOf(PrimaryKeyConstraint{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableConstraint
// only implements ToObjectValue() and Type().
func (o TableConstraint) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"foreign_key_constraint": o.ForeignKeyConstraint,
			"named_table_constraint": o.NamedTableConstraint,
			"primary_key_constraint": o.PrimaryKeyConstraint,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TableConstraint) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"foreign_key_constraint": ForeignKeyConstraint{}.Type(ctx),
			"named_table_constraint": NamedTableConstraint{}.Type(ctx),
			"primary_key_constraint": PrimaryKeyConstraint{}.Type(ctx),
		},
	}
}

// GetForeignKeyConstraint returns the value of the ForeignKeyConstraint field in TableConstraint as
// a ForeignKeyConstraint value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableConstraint) GetForeignKeyConstraint(ctx context.Context) (ForeignKeyConstraint, bool) {
	var e ForeignKeyConstraint
	if o.ForeignKeyConstraint.IsNull() || o.ForeignKeyConstraint.IsUnknown() {
		return e, false
	}
	var v ForeignKeyConstraint
	d := o.ForeignKeyConstraint.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetForeignKeyConstraint sets the value of the ForeignKeyConstraint field in TableConstraint.
func (o *TableConstraint) SetForeignKeyConstraint(ctx context.Context, v ForeignKeyConstraint) {
	vs := v.ToObjectValue(ctx)
	o.ForeignKeyConstraint = vs
}

// GetNamedTableConstraint returns the value of the NamedTableConstraint field in TableConstraint as
// a NamedTableConstraint value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableConstraint) GetNamedTableConstraint(ctx context.Context) (NamedTableConstraint, bool) {
	var e NamedTableConstraint
	if o.NamedTableConstraint.IsNull() || o.NamedTableConstraint.IsUnknown() {
		return e, false
	}
	var v NamedTableConstraint
	d := o.NamedTableConstraint.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNamedTableConstraint sets the value of the NamedTableConstraint field in TableConstraint.
func (o *TableConstraint) SetNamedTableConstraint(ctx context.Context, v NamedTableConstraint) {
	vs := v.ToObjectValue(ctx)
	o.NamedTableConstraint = vs
}

// GetPrimaryKeyConstraint returns the value of the PrimaryKeyConstraint field in TableConstraint as
// a PrimaryKeyConstraint value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableConstraint) GetPrimaryKeyConstraint(ctx context.Context) (PrimaryKeyConstraint, bool) {
	var e PrimaryKeyConstraint
	if o.PrimaryKeyConstraint.IsNull() || o.PrimaryKeyConstraint.IsUnknown() {
		return e, false
	}
	var v PrimaryKeyConstraint
	d := o.PrimaryKeyConstraint.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrimaryKeyConstraint sets the value of the PrimaryKeyConstraint field in TableConstraint.
func (o *TableConstraint) SetPrimaryKeyConstraint(ctx context.Context, v PrimaryKeyConstraint) {
	vs := v.ToObjectValue(ctx)
	o.PrimaryKeyConstraint = vs
}

// A table that is dependent on a SQL object.
type TableDependency struct {
	// Full name of the dependent table, in the form of
	// __catalog_name__.__schema_name__.__table_name__.
	TableFullName types.String `tfsdk:"table_full_name"`
}

func (toState *TableDependency) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TableDependency) {
}

func (toState *TableDependency) SyncFieldsDuringRead(ctx context.Context, fromState TableDependency) {
}

func (c TableDependency) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_full_name"] = attrs["table_full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TableDependency) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableDependency
// only implements ToObjectValue() and Type().
func (o TableDependency) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_full_name": o.TableFullName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TableDependency) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_full_name": types.StringType,
		},
	}
}

type TableExistsResponse struct {
	// Whether the table exists or not.
	TableExists types.Bool `tfsdk:"table_exists"`
}

func (toState *TableExistsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TableExistsResponse) {
}

func (toState *TableExistsResponse) SyncFieldsDuringRead(ctx context.Context, fromState TableExistsResponse) {
}

func (c TableExistsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["table_exists"] = attrs["table_exists"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableExistsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TableExistsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableExistsResponse
// only implements ToObjectValue() and Type().
func (o TableExistsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"table_exists": o.TableExists,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TableExistsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"table_exists": types.BoolType,
		},
	}
}

type TableInfo struct {
	// The AWS access point to use when accesing s3 for this external location.
	AccessPoint types.String `tfsdk:"access_point"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// Name of parent catalog.
	CatalogName types.String `tfsdk:"catalog_name"`
	// The array of __ColumnInfo__ definitions of the table's columns.
	Columns types.List `tfsdk:"columns"`
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Time at which this table was created, in epoch milliseconds.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// Username of table creator.
	CreatedBy types.String `tfsdk:"created_by"`
	// Unique ID of the Data Access Configuration to use with the table data.
	DataAccessConfigurationId types.String `tfsdk:"data_access_configuration_id"`

	DataSourceFormat types.String `tfsdk:"data_source_format"`
	// Time at which this table was deleted, in epoch milliseconds. Field is
	// omitted if table is not deleted.
	DeletedAt types.Int64 `tfsdk:"deleted_at"`
	// Information pertaining to current state of the delta table.
	DeltaRuntimePropertiesKvpairs types.Object `tfsdk:"delta_runtime_properties_kvpairs"`

	EffectivePredictiveOptimizationFlag types.Object `tfsdk:"effective_predictive_optimization_flag"`

	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`

	EncryptionDetails types.Object `tfsdk:"encryption_details"`
	// Full name of table, in form of
	// __catalog_name__.__schema_name__.__table_name__
	FullName types.String `tfsdk:"full_name"`
	// Unique identifier of parent metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// Name of table, relative to parent schema.
	Name types.String `tfsdk:"name"`
	// Username of current owner of table.
	Owner types.String `tfsdk:"owner"`
	// The pipeline ID of the table. Applicable for tables created by pipelines
	// (Materialized View, Streaming Table, etc.).
	PipelineId types.String `tfsdk:"pipeline_id"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`

	RowFilter types.Object `tfsdk:"row_filter"`
	// Name of parent schema relative to its parent catalog.
	SchemaName types.String `tfsdk:"schema_name"`
	// SecurableKindManifest of table, including capabilities the table has.
	SecurableKindManifest types.Object `tfsdk:"securable_kind_manifest"`
	// List of schemes whose objects can be referenced without qualification.
	SqlPath types.String `tfsdk:"sql_path"`
	// Name of the storage credential, when a storage credential is configured
	// for use with this table.
	StorageCredentialName types.String `tfsdk:"storage_credential_name"`
	// Storage root URL for table (for **MANAGED**, **EXTERNAL** tables).
	StorageLocation types.String `tfsdk:"storage_location"`
	// List of table constraints. Note: this field is not set in the output of
	// the __listTables__ API.
	TableConstraints types.List `tfsdk:"table_constraints"`
	// The unique identifier of the table.
	TableId types.String `tfsdk:"table_id"`

	TableType types.String `tfsdk:"table_type"`
	// Time at which this table was last modified, in epoch milliseconds.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// Username of user who last modified the table.
	UpdatedBy types.String `tfsdk:"updated_by"`
	// View definition SQL (when __table_type__ is **VIEW**,
	// **MATERIALIZED_VIEW**, or **STREAMING_TABLE**)
	ViewDefinition types.String `tfsdk:"view_definition"`
	// View dependencies (when table_type == **VIEW** or **MATERIALIZED_VIEW**,
	// **STREAMING_TABLE**) - when DependencyList is None, the dependency is not
	// provided; - when DependencyList is an empty list, the dependency is
	// provided but is empty; - when DependencyList is not an empty list,
	// dependencies are provided and recorded.
	ViewDependencies types.Object `tfsdk:"view_dependencies"`
}

func (toState *TableInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TableInfo) {
	if !fromPlan.DeltaRuntimePropertiesKvpairs.IsNull() && !fromPlan.DeltaRuntimePropertiesKvpairs.IsUnknown() {
		if toStateDeltaRuntimePropertiesKvpairs, ok := toState.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
			if fromPlanDeltaRuntimePropertiesKvpairs, ok := fromPlan.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
				toStateDeltaRuntimePropertiesKvpairs.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDeltaRuntimePropertiesKvpairs)
				toState.SetDeltaRuntimePropertiesKvpairs(ctx, toStateDeltaRuntimePropertiesKvpairs)
			}
		}
	}
	if !fromPlan.EffectivePredictiveOptimizationFlag.IsNull() && !fromPlan.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toStateEffectivePredictiveOptimizationFlag, ok := toState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromPlanEffectivePredictiveOptimizationFlag, ok := fromPlan.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toStateEffectivePredictiveOptimizationFlag.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEffectivePredictiveOptimizationFlag)
				toState.SetEffectivePredictiveOptimizationFlag(ctx, toStateEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !fromPlan.EncryptionDetails.IsNull() && !fromPlan.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromPlanEncryptionDetails, ok := fromPlan.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromPlan.RowFilter.IsNull() && !fromPlan.RowFilter.IsUnknown() {
		if toStateRowFilter, ok := toState.GetRowFilter(ctx); ok {
			if fromPlanRowFilter, ok := fromPlan.GetRowFilter(ctx); ok {
				toStateRowFilter.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanRowFilter)
				toState.SetRowFilter(ctx, toStateRowFilter)
			}
		}
	}
	if !fromPlan.SecurableKindManifest.IsNull() && !fromPlan.SecurableKindManifest.IsUnknown() {
		if toStateSecurableKindManifest, ok := toState.GetSecurableKindManifest(ctx); ok {
			if fromPlanSecurableKindManifest, ok := fromPlan.GetSecurableKindManifest(ctx); ok {
				toStateSecurableKindManifest.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSecurableKindManifest)
				toState.SetSecurableKindManifest(ctx, toStateSecurableKindManifest)
			}
		}
	}
	if !fromPlan.ViewDependencies.IsNull() && !fromPlan.ViewDependencies.IsUnknown() {
		if toStateViewDependencies, ok := toState.GetViewDependencies(ctx); ok {
			if fromPlanViewDependencies, ok := fromPlan.GetViewDependencies(ctx); ok {
				toStateViewDependencies.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanViewDependencies)
				toState.SetViewDependencies(ctx, toStateViewDependencies)
			}
		}
	}
}

func (toState *TableInfo) SyncFieldsDuringRead(ctx context.Context, fromState TableInfo) {
	if !fromState.DeltaRuntimePropertiesKvpairs.IsNull() && !fromState.DeltaRuntimePropertiesKvpairs.IsUnknown() {
		if toStateDeltaRuntimePropertiesKvpairs, ok := toState.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
			if fromStateDeltaRuntimePropertiesKvpairs, ok := fromState.GetDeltaRuntimePropertiesKvpairs(ctx); ok {
				toStateDeltaRuntimePropertiesKvpairs.SyncFieldsDuringRead(ctx, fromStateDeltaRuntimePropertiesKvpairs)
				toState.SetDeltaRuntimePropertiesKvpairs(ctx, toStateDeltaRuntimePropertiesKvpairs)
			}
		}
	}
	if !fromState.EffectivePredictiveOptimizationFlag.IsNull() && !fromState.EffectivePredictiveOptimizationFlag.IsUnknown() {
		if toStateEffectivePredictiveOptimizationFlag, ok := toState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
			if fromStateEffectivePredictiveOptimizationFlag, ok := fromState.GetEffectivePredictiveOptimizationFlag(ctx); ok {
				toStateEffectivePredictiveOptimizationFlag.SyncFieldsDuringRead(ctx, fromStateEffectivePredictiveOptimizationFlag)
				toState.SetEffectivePredictiveOptimizationFlag(ctx, toStateEffectivePredictiveOptimizationFlag)
			}
		}
	}
	if !fromState.EncryptionDetails.IsNull() && !fromState.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromStateEncryptionDetails, ok := fromState.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringRead(ctx, fromStateEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromState.RowFilter.IsNull() && !fromState.RowFilter.IsUnknown() {
		if toStateRowFilter, ok := toState.GetRowFilter(ctx); ok {
			if fromStateRowFilter, ok := fromState.GetRowFilter(ctx); ok {
				toStateRowFilter.SyncFieldsDuringRead(ctx, fromStateRowFilter)
				toState.SetRowFilter(ctx, toStateRowFilter)
			}
		}
	}
	if !fromState.SecurableKindManifest.IsNull() && !fromState.SecurableKindManifest.IsUnknown() {
		if toStateSecurableKindManifest, ok := toState.GetSecurableKindManifest(ctx); ok {
			if fromStateSecurableKindManifest, ok := fromState.GetSecurableKindManifest(ctx); ok {
				toStateSecurableKindManifest.SyncFieldsDuringRead(ctx, fromStateSecurableKindManifest)
				toState.SetSecurableKindManifest(ctx, toStateSecurableKindManifest)
			}
		}
	}
	if !fromState.ViewDependencies.IsNull() && !fromState.ViewDependencies.IsUnknown() {
		if toStateViewDependencies, ok := toState.GetViewDependencies(ctx); ok {
			if fromStateViewDependencies, ok := fromState.GetViewDependencies(ctx); ok {
				toStateViewDependencies.SyncFieldsDuringRead(ctx, fromStateViewDependencies)
				toState.SetViewDependencies(ctx, toStateViewDependencies)
			}
		}
	}
}

func (c TableInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_point"] = attrs["access_point"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["data_access_configuration_id"] = attrs["data_access_configuration_id"].SetOptional()
	attrs["data_source_format"] = attrs["data_source_format"].SetOptional()
	attrs["deleted_at"] = attrs["deleted_at"].SetOptional()
	attrs["delta_runtime_properties_kvpairs"] = attrs["delta_runtime_properties_kvpairs"].SetOptional()
	attrs["effective_predictive_optimization_flag"] = attrs["effective_predictive_optimization_flag"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["pipeline_id"] = attrs["pipeline_id"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["row_filter"] = attrs["row_filter"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["securable_kind_manifest"] = attrs["securable_kind_manifest"].SetOptional()
	attrs["sql_path"] = attrs["sql_path"].SetOptional()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["table_constraints"] = attrs["table_constraints"].SetOptional()
	attrs["table_id"] = attrs["table_id"].SetOptional()
	attrs["table_type"] = attrs["table_type"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["view_definition"] = attrs["view_definition"].SetOptional()
	attrs["view_dependencies"] = attrs["view_dependencies"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TableInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":                                reflect.TypeOf(ColumnInfo{}),
		"delta_runtime_properties_kvpairs":       reflect.TypeOf(DeltaRuntimePropertiesKvPairs{}),
		"effective_predictive_optimization_flag": reflect.TypeOf(EffectivePredictiveOptimizationFlag{}),
		"encryption_details":                     reflect.TypeOf(EncryptionDetails{}),
		"properties":                             reflect.TypeOf(types.String{}),
		"row_filter":                             reflect.TypeOf(TableRowFilter{}),
		"securable_kind_manifest":                reflect.TypeOf(SecurableKindManifest{}),
		"table_constraints":                      reflect.TypeOf(TableConstraint{}),
		"view_dependencies":                      reflect.TypeOf(DependencyList{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableInfo
// only implements ToObjectValue() and Type().
func (o TableInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_point":                           o.AccessPoint,
			"browse_only":                            o.BrowseOnly,
			"catalog_name":                           o.CatalogName,
			"columns":                                o.Columns,
			"comment":                                o.Comment,
			"created_at":                             o.CreatedAt,
			"created_by":                             o.CreatedBy,
			"data_access_configuration_id":           o.DataAccessConfigurationId,
			"data_source_format":                     o.DataSourceFormat,
			"deleted_at":                             o.DeletedAt,
			"delta_runtime_properties_kvpairs":       o.DeltaRuntimePropertiesKvpairs,
			"effective_predictive_optimization_flag": o.EffectivePredictiveOptimizationFlag,
			"enable_predictive_optimization":         o.EnablePredictiveOptimization,
			"encryption_details":                     o.EncryptionDetails,
			"full_name":                              o.FullName,
			"metastore_id":                           o.MetastoreId,
			"name":                                   o.Name,
			"owner":                                  o.Owner,
			"pipeline_id":                            o.PipelineId,
			"properties":                             o.Properties,
			"row_filter":                             o.RowFilter,
			"schema_name":                            o.SchemaName,
			"securable_kind_manifest":                o.SecurableKindManifest,
			"sql_path":                               o.SqlPath,
			"storage_credential_name":                o.StorageCredentialName,
			"storage_location":                       o.StorageLocation,
			"table_constraints":                      o.TableConstraints,
			"table_id":                               o.TableId,
			"table_type":                             o.TableType,
			"updated_at":                             o.UpdatedAt,
			"updated_by":                             o.UpdatedBy,
			"view_definition":                        o.ViewDefinition,
			"view_dependencies":                      o.ViewDependencies,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TableInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_point": types.StringType,
			"browse_only":  types.BoolType,
			"catalog_name": types.StringType,
			"columns": basetypes.ListType{
				ElemType: ColumnInfo{}.Type(ctx),
			},
			"comment":                                types.StringType,
			"created_at":                             types.Int64Type,
			"created_by":                             types.StringType,
			"data_access_configuration_id":           types.StringType,
			"data_source_format":                     types.StringType,
			"deleted_at":                             types.Int64Type,
			"delta_runtime_properties_kvpairs":       DeltaRuntimePropertiesKvPairs{}.Type(ctx),
			"effective_predictive_optimization_flag": EffectivePredictiveOptimizationFlag{}.Type(ctx),
			"enable_predictive_optimization":         types.StringType,
			"encryption_details":                     EncryptionDetails{}.Type(ctx),
			"full_name":                              types.StringType,
			"metastore_id":                           types.StringType,
			"name":                                   types.StringType,
			"owner":                                  types.StringType,
			"pipeline_id":                            types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"row_filter":              TableRowFilter{}.Type(ctx),
			"schema_name":             types.StringType,
			"securable_kind_manifest": SecurableKindManifest{}.Type(ctx),
			"sql_path":                types.StringType,
			"storage_credential_name": types.StringType,
			"storage_location":        types.StringType,
			"table_constraints": basetypes.ListType{
				ElemType: TableConstraint{}.Type(ctx),
			},
			"table_id":          types.StringType,
			"table_type":        types.StringType,
			"updated_at":        types.Int64Type,
			"updated_by":        types.StringType,
			"view_definition":   types.StringType,
			"view_dependencies": DependencyList{}.Type(ctx),
		},
	}
}

// GetColumns returns the value of the Columns field in TableInfo as
// a slice of ColumnInfo values.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetColumns(ctx context.Context) ([]ColumnInfo, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnInfo
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in TableInfo.
func (o *TableInfo) SetColumns(ctx context.Context, v []ColumnInfo) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetDeltaRuntimePropertiesKvpairs returns the value of the DeltaRuntimePropertiesKvpairs field in TableInfo as
// a DeltaRuntimePropertiesKvPairs value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetDeltaRuntimePropertiesKvpairs(ctx context.Context) (DeltaRuntimePropertiesKvPairs, bool) {
	var e DeltaRuntimePropertiesKvPairs
	if o.DeltaRuntimePropertiesKvpairs.IsNull() || o.DeltaRuntimePropertiesKvpairs.IsUnknown() {
		return e, false
	}
	var v DeltaRuntimePropertiesKvPairs
	d := o.DeltaRuntimePropertiesKvpairs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDeltaRuntimePropertiesKvpairs sets the value of the DeltaRuntimePropertiesKvpairs field in TableInfo.
func (o *TableInfo) SetDeltaRuntimePropertiesKvpairs(ctx context.Context, v DeltaRuntimePropertiesKvPairs) {
	vs := v.ToObjectValue(ctx)
	o.DeltaRuntimePropertiesKvpairs = vs
}

// GetEffectivePredictiveOptimizationFlag returns the value of the EffectivePredictiveOptimizationFlag field in TableInfo as
// a EffectivePredictiveOptimizationFlag value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetEffectivePredictiveOptimizationFlag(ctx context.Context) (EffectivePredictiveOptimizationFlag, bool) {
	var e EffectivePredictiveOptimizationFlag
	if o.EffectivePredictiveOptimizationFlag.IsNull() || o.EffectivePredictiveOptimizationFlag.IsUnknown() {
		return e, false
	}
	var v EffectivePredictiveOptimizationFlag
	d := o.EffectivePredictiveOptimizationFlag.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEffectivePredictiveOptimizationFlag sets the value of the EffectivePredictiveOptimizationFlag field in TableInfo.
func (o *TableInfo) SetEffectivePredictiveOptimizationFlag(ctx context.Context, v EffectivePredictiveOptimizationFlag) {
	vs := v.ToObjectValue(ctx)
	o.EffectivePredictiveOptimizationFlag = vs
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in TableInfo as
// a EncryptionDetails value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetEncryptionDetails(ctx context.Context) (EncryptionDetails, bool) {
	var e EncryptionDetails
	if o.EncryptionDetails.IsNull() || o.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v EncryptionDetails
	d := o.EncryptionDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in TableInfo.
func (o *TableInfo) SetEncryptionDetails(ctx context.Context, v EncryptionDetails) {
	vs := v.ToObjectValue(ctx)
	o.EncryptionDetails = vs
}

// GetProperties returns the value of the Properties field in TableInfo as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in TableInfo.
func (o *TableInfo) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetRowFilter returns the value of the RowFilter field in TableInfo as
// a TableRowFilter value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetRowFilter(ctx context.Context) (TableRowFilter, bool) {
	var e TableRowFilter
	if o.RowFilter.IsNull() || o.RowFilter.IsUnknown() {
		return e, false
	}
	var v TableRowFilter
	d := o.RowFilter.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRowFilter sets the value of the RowFilter field in TableInfo.
func (o *TableInfo) SetRowFilter(ctx context.Context, v TableRowFilter) {
	vs := v.ToObjectValue(ctx)
	o.RowFilter = vs
}

// GetSecurableKindManifest returns the value of the SecurableKindManifest field in TableInfo as
// a SecurableKindManifest value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetSecurableKindManifest(ctx context.Context) (SecurableKindManifest, bool) {
	var e SecurableKindManifest
	if o.SecurableKindManifest.IsNull() || o.SecurableKindManifest.IsUnknown() {
		return e, false
	}
	var v SecurableKindManifest
	d := o.SecurableKindManifest.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSecurableKindManifest sets the value of the SecurableKindManifest field in TableInfo.
func (o *TableInfo) SetSecurableKindManifest(ctx context.Context, v SecurableKindManifest) {
	vs := v.ToObjectValue(ctx)
	o.SecurableKindManifest = vs
}

// GetTableConstraints returns the value of the TableConstraints field in TableInfo as
// a slice of TableConstraint values.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetTableConstraints(ctx context.Context) ([]TableConstraint, bool) {
	if o.TableConstraints.IsNull() || o.TableConstraints.IsUnknown() {
		return nil, false
	}
	var v []TableConstraint
	d := o.TableConstraints.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTableConstraints sets the value of the TableConstraints field in TableInfo.
func (o *TableInfo) SetTableConstraints(ctx context.Context, v []TableConstraint) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["table_constraints"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.TableConstraints = types.ListValueMust(t, vs)
}

// GetViewDependencies returns the value of the ViewDependencies field in TableInfo as
// a DependencyList value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableInfo) GetViewDependencies(ctx context.Context) (DependencyList, bool) {
	var e DependencyList
	if o.ViewDependencies.IsNull() || o.ViewDependencies.IsUnknown() {
		return e, false
	}
	var v DependencyList
	d := o.ViewDependencies.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViewDependencies sets the value of the ViewDependencies field in TableInfo.
func (o *TableInfo) SetViewDependencies(ctx context.Context, v DependencyList) {
	vs := v.ToObjectValue(ctx)
	o.ViewDependencies = vs
}

type TableRowFilter struct {
	// The full name of the row filter SQL UDF.
	FunctionName types.String `tfsdk:"function_name"`
	// The list of table columns to be passed as input to the row filter
	// function. The column types should match the types of the filter function
	// arguments.
	InputColumnNames types.List `tfsdk:"input_column_names"`
}

func (toState *TableRowFilter) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TableRowFilter) {
}

func (toState *TableRowFilter) SyncFieldsDuringRead(ctx context.Context, fromState TableRowFilter) {
}

func (c TableRowFilter) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["function_name"] = attrs["function_name"].SetRequired()
	attrs["input_column_names"] = attrs["input_column_names"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableRowFilter.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TableRowFilter) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"input_column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableRowFilter
// only implements ToObjectValue() and Type().
func (o TableRowFilter) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"function_name":      o.FunctionName,
			"input_column_names": o.InputColumnNames,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TableRowFilter) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"function_name": types.StringType,
			"input_column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetInputColumnNames returns the value of the InputColumnNames field in TableRowFilter as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *TableRowFilter) GetInputColumnNames(ctx context.Context) ([]types.String, bool) {
	if o.InputColumnNames.IsNull() || o.InputColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.InputColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInputColumnNames sets the value of the InputColumnNames field in TableRowFilter.
func (o *TableRowFilter) SetInputColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["input_column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.InputColumnNames = types.ListValueMust(t, vs)
}

type TableSummary struct {
	// The full name of the table.
	FullName types.String `tfsdk:"full_name"`
	// SecurableKindManifest of table, including capabilities the table has.
	SecurableKindManifest types.Object `tfsdk:"securable_kind_manifest"`

	TableType types.String `tfsdk:"table_type"`
}

func (toState *TableSummary) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TableSummary) {
	if !fromPlan.SecurableKindManifest.IsNull() && !fromPlan.SecurableKindManifest.IsUnknown() {
		if toStateSecurableKindManifest, ok := toState.GetSecurableKindManifest(ctx); ok {
			if fromPlanSecurableKindManifest, ok := fromPlan.GetSecurableKindManifest(ctx); ok {
				toStateSecurableKindManifest.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSecurableKindManifest)
				toState.SetSecurableKindManifest(ctx, toStateSecurableKindManifest)
			}
		}
	}
}

func (toState *TableSummary) SyncFieldsDuringRead(ctx context.Context, fromState TableSummary) {
	if !fromState.SecurableKindManifest.IsNull() && !fromState.SecurableKindManifest.IsUnknown() {
		if toStateSecurableKindManifest, ok := toState.GetSecurableKindManifest(ctx); ok {
			if fromStateSecurableKindManifest, ok := fromState.GetSecurableKindManifest(ctx); ok {
				toStateSecurableKindManifest.SyncFieldsDuringRead(ctx, fromStateSecurableKindManifest)
				toState.SetSecurableKindManifest(ctx, toStateSecurableKindManifest)
			}
		}
	}
}

func (c TableSummary) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["securable_kind_manifest"] = attrs["securable_kind_manifest"].SetOptional()
	attrs["table_type"] = attrs["table_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableSummary.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TableSummary) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"securable_kind_manifest": reflect.TypeOf(SecurableKindManifest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableSummary
// only implements ToObjectValue() and Type().
func (o TableSummary) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name":               o.FullName,
			"securable_kind_manifest": o.SecurableKindManifest,
			"table_type":              o.TableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TableSummary) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name":               types.StringType,
			"securable_kind_manifest": SecurableKindManifest{}.Type(ctx),
			"table_type":              types.StringType,
		},
	}
}

// GetSecurableKindManifest returns the value of the SecurableKindManifest field in TableSummary as
// a SecurableKindManifest value.
// If the field is unknown or null, the boolean return value is false.
func (o *TableSummary) GetSecurableKindManifest(ctx context.Context) (SecurableKindManifest, bool) {
	var e SecurableKindManifest
	if o.SecurableKindManifest.IsNull() || o.SecurableKindManifest.IsUnknown() {
		return e, false
	}
	var v SecurableKindManifest
	d := o.SecurableKindManifest.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSecurableKindManifest sets the value of the SecurableKindManifest field in TableSummary.
func (o *TableSummary) SetSecurableKindManifest(ctx context.Context, v SecurableKindManifest) {
	vs := v.ToObjectValue(ctx)
	o.SecurableKindManifest = vs
}

type TagKeyValue struct {
	// name of the tag
	Key types.String `tfsdk:"key"`
	// value of the tag associated with the key, could be optional
	Value types.String `tfsdk:"value"`
}

func (toState *TagKeyValue) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TagKeyValue) {
}

func (toState *TagKeyValue) SyncFieldsDuringRead(ctx context.Context, fromState TagKeyValue) {
}

func (c TagKeyValue) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["key"] = attrs["key"].SetOptional()
	attrs["value"] = attrs["value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TagKeyValue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TagKeyValue) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TagKeyValue
// only implements ToObjectValue() and Type().
func (o TagKeyValue) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"key":   o.Key,
			"value": o.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TagKeyValue) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"key":   types.StringType,
			"value": types.StringType,
		},
	}
}

type TemporaryCredentials struct {
	AwsTempCredentials types.Object `tfsdk:"aws_temp_credentials"`

	AzureAad types.Object `tfsdk:"azure_aad"`
	// Server time when the credential will expire, in epoch milliseconds. The
	// API client is advised to cache the credential given this expiration time.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	GcpOauthToken types.Object `tfsdk:"gcp_oauth_token"`
}

func (toState *TemporaryCredentials) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TemporaryCredentials) {
	if !fromPlan.AwsTempCredentials.IsNull() && !fromPlan.AwsTempCredentials.IsUnknown() {
		if toStateAwsTempCredentials, ok := toState.GetAwsTempCredentials(ctx); ok {
			if fromPlanAwsTempCredentials, ok := fromPlan.GetAwsTempCredentials(ctx); ok {
				toStateAwsTempCredentials.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsTempCredentials)
				toState.SetAwsTempCredentials(ctx, toStateAwsTempCredentials)
			}
		}
	}
	if !fromPlan.AzureAad.IsNull() && !fromPlan.AzureAad.IsUnknown() {
		if toStateAzureAad, ok := toState.GetAzureAad(ctx); ok {
			if fromPlanAzureAad, ok := fromPlan.GetAzureAad(ctx); ok {
				toStateAzureAad.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureAad)
				toState.SetAzureAad(ctx, toStateAzureAad)
			}
		}
	}
	if !fromPlan.GcpOauthToken.IsNull() && !fromPlan.GcpOauthToken.IsUnknown() {
		if toStateGcpOauthToken, ok := toState.GetGcpOauthToken(ctx); ok {
			if fromPlanGcpOauthToken, ok := fromPlan.GetGcpOauthToken(ctx); ok {
				toStateGcpOauthToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanGcpOauthToken)
				toState.SetGcpOauthToken(ctx, toStateGcpOauthToken)
			}
		}
	}
}

func (toState *TemporaryCredentials) SyncFieldsDuringRead(ctx context.Context, fromState TemporaryCredentials) {
	if !fromState.AwsTempCredentials.IsNull() && !fromState.AwsTempCredentials.IsUnknown() {
		if toStateAwsTempCredentials, ok := toState.GetAwsTempCredentials(ctx); ok {
			if fromStateAwsTempCredentials, ok := fromState.GetAwsTempCredentials(ctx); ok {
				toStateAwsTempCredentials.SyncFieldsDuringRead(ctx, fromStateAwsTempCredentials)
				toState.SetAwsTempCredentials(ctx, toStateAwsTempCredentials)
			}
		}
	}
	if !fromState.AzureAad.IsNull() && !fromState.AzureAad.IsUnknown() {
		if toStateAzureAad, ok := toState.GetAzureAad(ctx); ok {
			if fromStateAzureAad, ok := fromState.GetAzureAad(ctx); ok {
				toStateAzureAad.SyncFieldsDuringRead(ctx, fromStateAzureAad)
				toState.SetAzureAad(ctx, toStateAzureAad)
			}
		}
	}
	if !fromState.GcpOauthToken.IsNull() && !fromState.GcpOauthToken.IsUnknown() {
		if toStateGcpOauthToken, ok := toState.GetGcpOauthToken(ctx); ok {
			if fromStateGcpOauthToken, ok := fromState.GetGcpOauthToken(ctx); ok {
				toStateGcpOauthToken.SyncFieldsDuringRead(ctx, fromStateGcpOauthToken)
				toState.SetGcpOauthToken(ctx, toStateGcpOauthToken)
			}
		}
	}
}

func (c TemporaryCredentials) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_temp_credentials"] = attrs["aws_temp_credentials"].SetOptional()
	attrs["azure_aad"] = attrs["azure_aad"].SetOptional()
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["gcp_oauth_token"] = attrs["gcp_oauth_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TemporaryCredentials.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TemporaryCredentials) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_temp_credentials": reflect.TypeOf(AwsCredentials{}),
		"azure_aad":            reflect.TypeOf(AzureActiveDirectoryToken{}),
		"gcp_oauth_token":      reflect.TypeOf(GcpOauthToken{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TemporaryCredentials
// only implements ToObjectValue() and Type().
func (o TemporaryCredentials) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_temp_credentials": o.AwsTempCredentials,
			"azure_aad":            o.AzureAad,
			"expiration_time":      o.ExpirationTime,
			"gcp_oauth_token":      o.GcpOauthToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TemporaryCredentials) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_temp_credentials": AwsCredentials{}.Type(ctx),
			"azure_aad":            AzureActiveDirectoryToken{}.Type(ctx),
			"expiration_time":      types.Int64Type,
			"gcp_oauth_token":      GcpOauthToken{}.Type(ctx),
		},
	}
}

// GetAwsTempCredentials returns the value of the AwsTempCredentials field in TemporaryCredentials as
// a AwsCredentials value.
// If the field is unknown or null, the boolean return value is false.
func (o *TemporaryCredentials) GetAwsTempCredentials(ctx context.Context) (AwsCredentials, bool) {
	var e AwsCredentials
	if o.AwsTempCredentials.IsNull() || o.AwsTempCredentials.IsUnknown() {
		return e, false
	}
	var v AwsCredentials
	d := o.AwsTempCredentials.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsTempCredentials sets the value of the AwsTempCredentials field in TemporaryCredentials.
func (o *TemporaryCredentials) SetAwsTempCredentials(ctx context.Context, v AwsCredentials) {
	vs := v.ToObjectValue(ctx)
	o.AwsTempCredentials = vs
}

// GetAzureAad returns the value of the AzureAad field in TemporaryCredentials as
// a AzureActiveDirectoryToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *TemporaryCredentials) GetAzureAad(ctx context.Context) (AzureActiveDirectoryToken, bool) {
	var e AzureActiveDirectoryToken
	if o.AzureAad.IsNull() || o.AzureAad.IsUnknown() {
		return e, false
	}
	var v AzureActiveDirectoryToken
	d := o.AzureAad.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureAad sets the value of the AzureAad field in TemporaryCredentials.
func (o *TemporaryCredentials) SetAzureAad(ctx context.Context, v AzureActiveDirectoryToken) {
	vs := v.ToObjectValue(ctx)
	o.AzureAad = vs
}

// GetGcpOauthToken returns the value of the GcpOauthToken field in TemporaryCredentials as
// a GcpOauthToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *TemporaryCredentials) GetGcpOauthToken(ctx context.Context) (GcpOauthToken, bool) {
	var e GcpOauthToken
	if o.GcpOauthToken.IsNull() || o.GcpOauthToken.IsUnknown() {
		return e, false
	}
	var v GcpOauthToken
	d := o.GcpOauthToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGcpOauthToken sets the value of the GcpOauthToken field in TemporaryCredentials.
func (o *TemporaryCredentials) SetGcpOauthToken(ctx context.Context, v GcpOauthToken) {
	vs := v.ToObjectValue(ctx)
	o.GcpOauthToken = vs
}

// Detailed status of an online table. Shown if the online table is in the
// ONLINE_TRIGGERED_UPDATE or the ONLINE_NO_PENDING_UPDATE state.
type TriggeredUpdateStatus struct {
	// The last source table Delta version that was synced to the online table.
	// Note that this Delta version may not be completely synced to the online
	// table yet.
	LastProcessedCommitVersion types.Int64 `tfsdk:"last_processed_commit_version"`
	// The timestamp of the last time any data was synchronized from the source
	// table to the online table.
	Timestamp types.String `tfsdk:"timestamp"`
	// Progress of the active data synchronization pipeline.
	TriggeredUpdateProgress types.Object `tfsdk:"triggered_update_progress"`
}

func (toState *TriggeredUpdateStatus) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan TriggeredUpdateStatus) {
	if !fromPlan.TriggeredUpdateProgress.IsNull() && !fromPlan.TriggeredUpdateProgress.IsUnknown() {
		if toStateTriggeredUpdateProgress, ok := toState.GetTriggeredUpdateProgress(ctx); ok {
			if fromPlanTriggeredUpdateProgress, ok := fromPlan.GetTriggeredUpdateProgress(ctx); ok {
				toStateTriggeredUpdateProgress.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTriggeredUpdateProgress)
				toState.SetTriggeredUpdateProgress(ctx, toStateTriggeredUpdateProgress)
			}
		}
	}
}

func (toState *TriggeredUpdateStatus) SyncFieldsDuringRead(ctx context.Context, fromState TriggeredUpdateStatus) {
	if !fromState.TriggeredUpdateProgress.IsNull() && !fromState.TriggeredUpdateProgress.IsUnknown() {
		if toStateTriggeredUpdateProgress, ok := toState.GetTriggeredUpdateProgress(ctx); ok {
			if fromStateTriggeredUpdateProgress, ok := fromState.GetTriggeredUpdateProgress(ctx); ok {
				toStateTriggeredUpdateProgress.SyncFieldsDuringRead(ctx, fromStateTriggeredUpdateProgress)
				toState.SetTriggeredUpdateProgress(ctx, toStateTriggeredUpdateProgress)
			}
		}
	}
}

func (c TriggeredUpdateStatus) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_processed_commit_version"] = attrs["last_processed_commit_version"].SetOptional()
	attrs["timestamp"] = attrs["timestamp"].SetOptional()
	attrs["triggered_update_progress"] = attrs["triggered_update_progress"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggeredUpdateStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a TriggeredUpdateStatus) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"triggered_update_progress": reflect.TypeOf(PipelineProgress{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggeredUpdateStatus
// only implements ToObjectValue() and Type().
func (o TriggeredUpdateStatus) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_processed_commit_version": o.LastProcessedCommitVersion,
			"timestamp":                     o.Timestamp,
			"triggered_update_progress":     o.TriggeredUpdateProgress,
		})
}

// Type implements basetypes.ObjectValuable.
func (o TriggeredUpdateStatus) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_processed_commit_version": types.Int64Type,
			"timestamp":                     types.StringType,
			"triggered_update_progress":     PipelineProgress{}.Type(ctx),
		},
	}
}

// GetTriggeredUpdateProgress returns the value of the TriggeredUpdateProgress field in TriggeredUpdateStatus as
// a PipelineProgress value.
// If the field is unknown or null, the boolean return value is false.
func (o *TriggeredUpdateStatus) GetTriggeredUpdateProgress(ctx context.Context) (PipelineProgress, bool) {
	var e PipelineProgress
	if o.TriggeredUpdateProgress.IsNull() || o.TriggeredUpdateProgress.IsUnknown() {
		return e, false
	}
	var v PipelineProgress
	d := o.TriggeredUpdateProgress.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTriggeredUpdateProgress sets the value of the TriggeredUpdateProgress field in TriggeredUpdateStatus.
func (o *TriggeredUpdateStatus) SetTriggeredUpdateProgress(ctx context.Context, v PipelineProgress) {
	vs := v.ToObjectValue(ctx)
	o.TriggeredUpdateProgress = vs
}

type UnassignRequest struct {
	// Query for the ID of the metastore to delete.
	MetastoreId types.String `tfsdk:"-"`
	// A workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *UnassignRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UnassignRequest) {
}

func (toState *UnassignRequest) SyncFieldsDuringRead(ctx context.Context, fromState UnassignRequest) {
}

func (c UnassignRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["metastore_id"] = attrs["metastore_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UnassignRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UnassignRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UnassignRequest
// only implements ToObjectValue() and Type().
func (o UnassignRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metastore_id": o.MetastoreId,
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UnassignRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metastore_id": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}

type UnassignResponse struct {
}

func (toState *UnassignResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UnassignResponse) {
}

func (toState *UnassignResponse) SyncFieldsDuringRead(ctx context.Context, fromState UnassignResponse) {
}

func (c UnassignResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UnassignResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UnassignResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UnassignResponse
// only implements ToObjectValue() and Type().
func (o UnassignResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o UnassignResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateAccessRequestDestinationsRequest struct {
	// The access request destinations to assign to the securable. For each
	// destination, a **destination_id** and **destination_type** must be
	// defined.
	AccessRequestDestinations types.Object `tfsdk:"access_request_destinations"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (toState *UpdateAccessRequestDestinationsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateAccessRequestDestinationsRequest) {
	if !fromPlan.AccessRequestDestinations.IsNull() && !fromPlan.AccessRequestDestinations.IsUnknown() {
		if toStateAccessRequestDestinations, ok := toState.GetAccessRequestDestinations(ctx); ok {
			if fromPlanAccessRequestDestinations, ok := fromPlan.GetAccessRequestDestinations(ctx); ok {
				toStateAccessRequestDestinations.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAccessRequestDestinations)
				toState.SetAccessRequestDestinations(ctx, toStateAccessRequestDestinations)
			}
		}
	}
}

func (toState *UpdateAccessRequestDestinationsRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateAccessRequestDestinationsRequest) {
	if !fromState.AccessRequestDestinations.IsNull() && !fromState.AccessRequestDestinations.IsUnknown() {
		if toStateAccessRequestDestinations, ok := toState.GetAccessRequestDestinations(ctx); ok {
			if fromStateAccessRequestDestinations, ok := fromState.GetAccessRequestDestinations(ctx); ok {
				toStateAccessRequestDestinations.SyncFieldsDuringRead(ctx, fromStateAccessRequestDestinations)
				toState.SetAccessRequestDestinations(ctx, toStateAccessRequestDestinations)
			}
		}
	}
}

func (c UpdateAccessRequestDestinationsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_request_destinations"] = attrs["access_request_destinations"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccessRequestDestinationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateAccessRequestDestinationsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_request_destinations": reflect.TypeOf(AccessRequestDestinations{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccessRequestDestinationsRequest
// only implements ToObjectValue() and Type().
func (o UpdateAccessRequestDestinationsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_request_destinations": o.AccessRequestDestinations,
			"update_mask":                 o.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateAccessRequestDestinationsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_request_destinations": AccessRequestDestinations{}.Type(ctx),
			"update_mask":                 types.StringType,
		},
	}
}

// GetAccessRequestDestinations returns the value of the AccessRequestDestinations field in UpdateAccessRequestDestinationsRequest as
// a AccessRequestDestinations value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccessRequestDestinationsRequest) GetAccessRequestDestinations(ctx context.Context) (AccessRequestDestinations, bool) {
	var e AccessRequestDestinations
	if o.AccessRequestDestinations.IsNull() || o.AccessRequestDestinations.IsUnknown() {
		return e, false
	}
	var v AccessRequestDestinations
	d := o.AccessRequestDestinations.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessRequestDestinations sets the value of the AccessRequestDestinations field in UpdateAccessRequestDestinationsRequest.
func (o *UpdateAccessRequestDestinationsRequest) SetAccessRequestDestinations(ctx context.Context, v AccessRequestDestinations) {
	vs := v.ToObjectValue(ctx)
	o.AccessRequestDestinations = vs
}

type UpdateAssignmentResponse struct {
}

func (toState *UpdateAssignmentResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateAssignmentResponse) {
}

func (toState *UpdateAssignmentResponse) SyncFieldsDuringRead(ctx context.Context, fromState UpdateAssignmentResponse) {
}

func (c UpdateAssignmentResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAssignmentResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateAssignmentResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAssignmentResponse
// only implements ToObjectValue() and Type().
func (o UpdateAssignmentResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateAssignmentResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateCatalog struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
	// New name for the catalog.
	NewName types.String `tfsdk:"new_name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of catalog.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
}

func (toState *UpdateCatalog) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateCatalog) {
}

func (toState *UpdateCatalog) SyncFieldsDuringRead(ctx context.Context, fromState UpdateCatalog) {
}

func (c UpdateCatalog) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["options"] = attrs["options"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCatalog.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateCatalog) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options":    reflect.TypeOf(types.String{}),
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCatalog
// only implements ToObjectValue() and Type().
func (o UpdateCatalog) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":                        o.Comment,
			"enable_predictive_optimization": o.EnablePredictiveOptimization,
			"isolation_mode":                 o.IsolationMode,
			"name":                           o.Name,
			"new_name":                       o.NewName,
			"options":                        o.Options,
			"owner":                          o.Owner,
			"properties":                     o.Properties,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateCatalog) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":                        types.StringType,
			"enable_predictive_optimization": types.StringType,
			"isolation_mode":                 types.StringType,
			"name":                           types.StringType,
			"new_name":                       types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOptions returns the value of the Options field in UpdateCatalog as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCatalog) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in UpdateCatalog.
func (o *UpdateCatalog) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.MapValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in UpdateCatalog as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCatalog) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in UpdateCatalog.
func (o *UpdateCatalog) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

type UpdateCatalogWorkspaceBindingsResponse struct {
	// A list of workspace IDs
	Workspaces types.List `tfsdk:"workspaces"`
}

func (toState *UpdateCatalogWorkspaceBindingsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateCatalogWorkspaceBindingsResponse) {
}

func (toState *UpdateCatalogWorkspaceBindingsResponse) SyncFieldsDuringRead(ctx context.Context, fromState UpdateCatalogWorkspaceBindingsResponse) {
}

func (c UpdateCatalogWorkspaceBindingsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["workspaces"] = attrs["workspaces"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCatalogWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateCatalogWorkspaceBindingsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"workspaces": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCatalogWorkspaceBindingsResponse
// only implements ToObjectValue() and Type().
func (o UpdateCatalogWorkspaceBindingsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspaces": o.Workspaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateCatalogWorkspaceBindingsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetWorkspaces returns the value of the Workspaces field in UpdateCatalogWorkspaceBindingsResponse as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCatalogWorkspaceBindingsResponse) GetWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if o.Workspaces.IsNull() || o.Workspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := o.Workspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWorkspaces sets the value of the Workspaces field in UpdateCatalogWorkspaceBindingsResponse.
func (o *UpdateCatalogWorkspaceBindingsResponse) SetWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Workspaces = types.ListValueMust(t, vs)
}

type UpdateConnection struct {
	// Name of the connection.
	Name types.String `tfsdk:"-"`
	// New name for the connection.
	NewName types.String `tfsdk:"new_name"`
	// A map of key-value properties attached to the securable.
	Options types.Map `tfsdk:"options"`
	// Username of current owner of the connection.
	Owner types.String `tfsdk:"owner"`
}

func (toState *UpdateConnection) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateConnection) {
}

func (toState *UpdateConnection) SyncFieldsDuringRead(ctx context.Context, fromState UpdateConnection) {
}

func (c UpdateConnection) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["options"] = attrs["options"].SetRequired()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateConnection.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateConnection) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"options": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateConnection
// only implements ToObjectValue() and Type().
func (o UpdateConnection) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":     o.Name,
			"new_name": o.NewName,
			"options":  o.Options,
			"owner":    o.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateConnection) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":     types.StringType,
			"new_name": types.StringType,
			"options": basetypes.MapType{
				ElemType: types.StringType,
			},
			"owner": types.StringType,
		},
	}
}

// GetOptions returns the value of the Options field in UpdateConnection as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateConnection) GetOptions(ctx context.Context) (map[string]types.String, bool) {
	if o.Options.IsNull() || o.Options.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Options.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOptions sets the value of the Options field in UpdateConnection.
func (o *UpdateConnection) SetOptions(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["options"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Options = types.MapValueMust(t, vs)
}

type UpdateCredentialRequest struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// Force an update even if there are dependent services (when purpose is
	// **SERVICE**) or dependent external locations and external tables (when
	// purpose is **STORAGE**).
	Force types.Bool `tfsdk:"force"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Name of the credential.
	NameArg types.String `tfsdk:"-"`
	// New name of credential.
	NewName types.String `tfsdk:"new_name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Supply true to this argument to skip validation of the updated
	// credential.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (toState *UpdateCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateCredentialRequest) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *UpdateCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateCredentialRequest) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c UpdateCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["force"] = attrs["force"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["name_arg"] = attrs["name_arg"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateCredentialRequest
// only implements ToObjectValue() and Type().
func (o UpdateCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"comment":                        o.Comment,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"force":                          o.Force,
			"isolation_mode":                 o.IsolationMode,
			"name_arg":                       o.NameArg,
			"new_name":                       o.NewName,
			"owner":                          o.Owner,
			"read_only":                      o.ReadOnly,
			"skip_validation":                o.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRole{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentity{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"comment":                        types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccount{}.Type(ctx),
			"force":                          types.BoolType,
			"isolation_mode":                 types.StringType,
			"name_arg":                       types.StringType,
			"new_name":                       types.StringType,
			"owner":                          types.StringType,
			"read_only":                      types.BoolType,
			"skip_validation":                types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in UpdateCredentialRequest as
// a AwsIamRole value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCredentialRequest) GetAwsIamRole(ctx context.Context) (AwsIamRole, bool) {
	var e AwsIamRole
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRole
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in UpdateCredentialRequest.
func (o *UpdateCredentialRequest) SetAwsIamRole(ctx context.Context, v AwsIamRole) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in UpdateCredentialRequest as
// a AzureManagedIdentity value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCredentialRequest) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity, bool) {
	var e AzureManagedIdentity
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentity
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in UpdateCredentialRequest.
func (o *UpdateCredentialRequest) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in UpdateCredentialRequest as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCredentialRequest) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in UpdateCredentialRequest.
func (o *UpdateCredentialRequest) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in UpdateCredentialRequest as
// a DatabricksGcpServiceAccount value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateCredentialRequest) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount, bool) {
	var e DatabricksGcpServiceAccount
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccount
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in UpdateCredentialRequest.
func (o *UpdateCredentialRequest) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type UpdateEntityTagAssignmentRequest struct {
	// The fully qualified name of the entity to which the tag is assigned
	EntityName types.String `tfsdk:"-"`
	// The type of the entity to which the tag is assigned. Allowed values are:
	// catalogs, schemas, tables, columns, volumes.
	EntityType types.String `tfsdk:"-"`

	TagAssignment types.Object `tfsdk:"tag_assignment"`
	// The key of the tag
	TagKey types.String `tfsdk:"-"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (toState *UpdateEntityTagAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateEntityTagAssignmentRequest) {
	if !fromPlan.TagAssignment.IsNull() && !fromPlan.TagAssignment.IsUnknown() {
		if toStateTagAssignment, ok := toState.GetTagAssignment(ctx); ok {
			if fromPlanTagAssignment, ok := fromPlan.GetTagAssignment(ctx); ok {
				toStateTagAssignment.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTagAssignment)
				toState.SetTagAssignment(ctx, toStateTagAssignment)
			}
		}
	}
}

func (toState *UpdateEntityTagAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateEntityTagAssignmentRequest) {
	if !fromState.TagAssignment.IsNull() && !fromState.TagAssignment.IsUnknown() {
		if toStateTagAssignment, ok := toState.GetTagAssignment(ctx); ok {
			if fromStateTagAssignment, ok := fromState.GetTagAssignment(ctx); ok {
				toStateTagAssignment.SyncFieldsDuringRead(ctx, fromStateTagAssignment)
				toState.SetTagAssignment(ctx, toStateTagAssignment)
			}
		}
	}
}

func (c UpdateEntityTagAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["tag_assignment"] = attrs["tag_assignment"].SetRequired()
	attrs["entity_type"] = attrs["entity_type"].SetRequired()
	attrs["entity_type"] = attrs["entity_type"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["entity_name"] = attrs["entity_name"].SetRequired()
	attrs["entity_name"] = attrs["entity_name"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["tag_key"] = attrs["tag_key"].SetRequired()
	attrs["tag_key"] = attrs["tag_key"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.RequiresReplace()).(tfschema.AttributeBuilder)
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateEntityTagAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateEntityTagAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"tag_assignment": reflect.TypeOf(EntityTagAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateEntityTagAssignmentRequest
// only implements ToObjectValue() and Type().
func (o UpdateEntityTagAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entity_name":    o.EntityName,
			"entity_type":    o.EntityType,
			"tag_assignment": o.TagAssignment,
			"tag_key":        o.TagKey,
			"update_mask":    o.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateEntityTagAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entity_name":    types.StringType,
			"entity_type":    types.StringType,
			"tag_assignment": EntityTagAssignment{}.Type(ctx),
			"tag_key":        types.StringType,
			"update_mask":    types.StringType,
		},
	}
}

// GetTagAssignment returns the value of the TagAssignment field in UpdateEntityTagAssignmentRequest as
// a EntityTagAssignment value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateEntityTagAssignmentRequest) GetTagAssignment(ctx context.Context) (EntityTagAssignment, bool) {
	var e EntityTagAssignment
	if o.TagAssignment.IsNull() || o.TagAssignment.IsUnknown() {
		return e, false
	}
	var v EntityTagAssignment
	d := o.TagAssignment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTagAssignment sets the value of the TagAssignment field in UpdateEntityTagAssignmentRequest.
func (o *UpdateEntityTagAssignmentRequest) SetTagAssignment(ctx context.Context, v EntityTagAssignment) {
	vs := v.ToObjectValue(ctx)
	o.TagAssignment = vs
}

type UpdateExternalLineageRelationshipRequest struct {
	ExternalLineageRelationship types.Object `tfsdk:"external_lineage_relationship"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (toState *UpdateExternalLineageRelationshipRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateExternalLineageRelationshipRequest) {
	if !fromPlan.ExternalLineageRelationship.IsNull() && !fromPlan.ExternalLineageRelationship.IsUnknown() {
		if toStateExternalLineageRelationship, ok := toState.GetExternalLineageRelationship(ctx); ok {
			if fromPlanExternalLineageRelationship, ok := fromPlan.GetExternalLineageRelationship(ctx); ok {
				toStateExternalLineageRelationship.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalLineageRelationship)
				toState.SetExternalLineageRelationship(ctx, toStateExternalLineageRelationship)
			}
		}
	}
}

func (toState *UpdateExternalLineageRelationshipRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateExternalLineageRelationshipRequest) {
	if !fromState.ExternalLineageRelationship.IsNull() && !fromState.ExternalLineageRelationship.IsUnknown() {
		if toStateExternalLineageRelationship, ok := toState.GetExternalLineageRelationship(ctx); ok {
			if fromStateExternalLineageRelationship, ok := fromState.GetExternalLineageRelationship(ctx); ok {
				toStateExternalLineageRelationship.SyncFieldsDuringRead(ctx, fromStateExternalLineageRelationship)
				toState.SetExternalLineageRelationship(ctx, toStateExternalLineageRelationship)
			}
		}
	}
}

func (c UpdateExternalLineageRelationshipRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_lineage_relationship"] = attrs["external_lineage_relationship"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateExternalLineageRelationshipRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateExternalLineageRelationshipRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_lineage_relationship": reflect.TypeOf(UpdateRequestExternalLineage{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateExternalLineageRelationshipRequest
// only implements ToObjectValue() and Type().
func (o UpdateExternalLineageRelationshipRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_lineage_relationship": o.ExternalLineageRelationship,
			"update_mask":                   o.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateExternalLineageRelationshipRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_lineage_relationship": UpdateRequestExternalLineage{}.Type(ctx),
			"update_mask":                   types.StringType,
		},
	}
}

// GetExternalLineageRelationship returns the value of the ExternalLineageRelationship field in UpdateExternalLineageRelationshipRequest as
// a UpdateRequestExternalLineage value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateExternalLineageRelationshipRequest) GetExternalLineageRelationship(ctx context.Context) (UpdateRequestExternalLineage, bool) {
	var e UpdateRequestExternalLineage
	if o.ExternalLineageRelationship.IsNull() || o.ExternalLineageRelationship.IsUnknown() {
		return e, false
	}
	var v UpdateRequestExternalLineage
	d := o.ExternalLineageRelationship.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalLineageRelationship sets the value of the ExternalLineageRelationship field in UpdateExternalLineageRelationshipRequest.
func (o *UpdateExternalLineageRelationshipRequest) SetExternalLineageRelationship(ctx context.Context, v UpdateRequestExternalLineage) {
	vs := v.ToObjectValue(ctx)
	o.ExternalLineageRelationship = vs
}

type UpdateExternalLocation struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Name of the storage credential used with this location.
	CredentialName types.String `tfsdk:"credential_name"`
	// Whether to enable file events on this external location.
	EnableFileEvents types.Bool `tfsdk:"enable_file_events"`

	EncryptionDetails types.Object `tfsdk:"encryption_details"`
	// Indicates whether fallback mode is enabled for this external location.
	// When fallback mode is enabled, the access to the location falls back to
	// cluster credentials if UC credentials are not sufficient.
	Fallback types.Bool `tfsdk:"fallback"`
	// File event queue settings. If `enable_file_events` is `true`, must be
	// defined and have exactly one of the documented properties.
	FileEventQueue types.Object `tfsdk:"file_event_queue"`
	// Force update even if changing url invalidates dependent external tables
	// or mounts.
	Force types.Bool `tfsdk:"force"`

	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Name of the external location.
	Name types.String `tfsdk:"-"`
	// New name for the external location.
	NewName types.String `tfsdk:"new_name"`
	// The owner of the external location.
	Owner types.String `tfsdk:"owner"`
	// Indicates whether the external location is read-only.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Skips validation of the storage credential associated with the external
	// location.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
	// Path URL of the external location.
	Url types.String `tfsdk:"url"`
}

func (toState *UpdateExternalLocation) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateExternalLocation) {
	if !fromPlan.EncryptionDetails.IsNull() && !fromPlan.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromPlanEncryptionDetails, ok := fromPlan.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromPlan.FileEventQueue.IsNull() && !fromPlan.FileEventQueue.IsUnknown() {
		if toStateFileEventQueue, ok := toState.GetFileEventQueue(ctx); ok {
			if fromPlanFileEventQueue, ok := fromPlan.GetFileEventQueue(ctx); ok {
				toStateFileEventQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanFileEventQueue)
				toState.SetFileEventQueue(ctx, toStateFileEventQueue)
			}
		}
	}
}

func (toState *UpdateExternalLocation) SyncFieldsDuringRead(ctx context.Context, fromState UpdateExternalLocation) {
	if !fromState.EncryptionDetails.IsNull() && !fromState.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromStateEncryptionDetails, ok := fromState.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringRead(ctx, fromStateEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
	if !fromState.FileEventQueue.IsNull() && !fromState.FileEventQueue.IsUnknown() {
		if toStateFileEventQueue, ok := toState.GetFileEventQueue(ctx); ok {
			if fromStateFileEventQueue, ok := fromState.GetFileEventQueue(ctx); ok {
				toStateFileEventQueue.SyncFieldsDuringRead(ctx, fromStateFileEventQueue)
				toState.SetFileEventQueue(ctx, toStateFileEventQueue)
			}
		}
	}
}

func (c UpdateExternalLocation) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetOptional()
	attrs["enable_file_events"] = attrs["enable_file_events"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["fallback"] = attrs["fallback"].SetOptional()
	attrs["file_event_queue"] = attrs["file_event_queue"].SetOptional()
	attrs["force"] = attrs["force"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateExternalLocation.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateExternalLocation) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails{}),
		"file_event_queue":   reflect.TypeOf(FileEventQueue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateExternalLocation
// only implements ToObjectValue() and Type().
func (o UpdateExternalLocation) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":            o.Comment,
			"credential_name":    o.CredentialName,
			"enable_file_events": o.EnableFileEvents,
			"encryption_details": o.EncryptionDetails,
			"fallback":           o.Fallback,
			"file_event_queue":   o.FileEventQueue,
			"force":              o.Force,
			"isolation_mode":     o.IsolationMode,
			"name":               o.Name,
			"new_name":           o.NewName,
			"owner":              o.Owner,
			"read_only":          o.ReadOnly,
			"skip_validation":    o.SkipValidation,
			"url":                o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateExternalLocation) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":            types.StringType,
			"credential_name":    types.StringType,
			"enable_file_events": types.BoolType,
			"encryption_details": EncryptionDetails{}.Type(ctx),
			"fallback":           types.BoolType,
			"file_event_queue":   FileEventQueue{}.Type(ctx),
			"force":              types.BoolType,
			"isolation_mode":     types.StringType,
			"name":               types.StringType,
			"new_name":           types.StringType,
			"owner":              types.StringType,
			"read_only":          types.BoolType,
			"skip_validation":    types.BoolType,
			"url":                types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in UpdateExternalLocation as
// a EncryptionDetails value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateExternalLocation) GetEncryptionDetails(ctx context.Context) (EncryptionDetails, bool) {
	var e EncryptionDetails
	if o.EncryptionDetails.IsNull() || o.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v EncryptionDetails
	d := o.EncryptionDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in UpdateExternalLocation.
func (o *UpdateExternalLocation) SetEncryptionDetails(ctx context.Context, v EncryptionDetails) {
	vs := v.ToObjectValue(ctx)
	o.EncryptionDetails = vs
}

// GetFileEventQueue returns the value of the FileEventQueue field in UpdateExternalLocation as
// a FileEventQueue value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateExternalLocation) GetFileEventQueue(ctx context.Context) (FileEventQueue, bool) {
	var e FileEventQueue
	if o.FileEventQueue.IsNull() || o.FileEventQueue.IsUnknown() {
		return e, false
	}
	var v FileEventQueue
	d := o.FileEventQueue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFileEventQueue sets the value of the FileEventQueue field in UpdateExternalLocation.
func (o *UpdateExternalLocation) SetFileEventQueue(ctx context.Context, v FileEventQueue) {
	vs := v.ToObjectValue(ctx)
	o.FileEventQueue = vs
}

type UpdateExternalMetadataRequest struct {
	ExternalMetadata types.Object `tfsdk:"external_metadata"`
	// Name of the external metadata object.
	Name types.String `tfsdk:"-"`
	// The field mask must be a single string, with multiple fields separated by
	// commas (no spaces). The field path is relative to the resource object,
	// using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`).
	// Specification of elements in sequence or map fields is not allowed, as
	// only the entire collection field can be specified. Field names must
	// exactly match the resource field names.
	//
	// A field mask of `*` indicates full replacement. Its recommended to
	// always explicitly list the fields being updated and avoid using `*`
	// wildcards, as it can lead to unintended results if the API changes in the
	// future.
	UpdateMask types.String `tfsdk:"-"`
}

func (toState *UpdateExternalMetadataRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateExternalMetadataRequest) {
	if !fromPlan.ExternalMetadata.IsNull() && !fromPlan.ExternalMetadata.IsUnknown() {
		if toStateExternalMetadata, ok := toState.GetExternalMetadata(ctx); ok {
			if fromPlanExternalMetadata, ok := fromPlan.GetExternalMetadata(ctx); ok {
				toStateExternalMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanExternalMetadata)
				toState.SetExternalMetadata(ctx, toStateExternalMetadata)
			}
		}
	}
}

func (toState *UpdateExternalMetadataRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateExternalMetadataRequest) {
	if !fromState.ExternalMetadata.IsNull() && !fromState.ExternalMetadata.IsUnknown() {
		if toStateExternalMetadata, ok := toState.GetExternalMetadata(ctx); ok {
			if fromStateExternalMetadata, ok := fromState.GetExternalMetadata(ctx); ok {
				toStateExternalMetadata.SyncFieldsDuringRead(ctx, fromStateExternalMetadata)
				toState.SetExternalMetadata(ctx, toStateExternalMetadata)
			}
		}
	}
}

func (c UpdateExternalMetadataRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["external_metadata"] = attrs["external_metadata"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateExternalMetadataRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateExternalMetadataRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"external_metadata": reflect.TypeOf(ExternalMetadata{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateExternalMetadataRequest
// only implements ToObjectValue() and Type().
func (o UpdateExternalMetadataRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"external_metadata": o.ExternalMetadata,
			"name":              o.Name,
			"update_mask":       o.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateExternalMetadataRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"external_metadata": ExternalMetadata{}.Type(ctx),
			"name":              types.StringType,
			"update_mask":       types.StringType,
		},
	}
}

// GetExternalMetadata returns the value of the ExternalMetadata field in UpdateExternalMetadataRequest as
// a ExternalMetadata value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateExternalMetadataRequest) GetExternalMetadata(ctx context.Context) (ExternalMetadata, bool) {
	var e ExternalMetadata
	if o.ExternalMetadata.IsNull() || o.ExternalMetadata.IsUnknown() {
		return e, false
	}
	var v ExternalMetadata
	d := o.ExternalMetadata.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExternalMetadata sets the value of the ExternalMetadata field in UpdateExternalMetadataRequest.
func (o *UpdateExternalMetadataRequest) SetExternalMetadata(ctx context.Context, v ExternalMetadata) {
	vs := v.ToObjectValue(ctx)
	o.ExternalMetadata = vs
}

type UpdateFunction struct {
	// The fully-qualified name of the function (of the form
	// __catalog_name__.__schema_name__.__function__name__).
	Name types.String `tfsdk:"-"`
	// Username of current owner of function.
	Owner types.String `tfsdk:"owner"`
}

func (toState *UpdateFunction) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateFunction) {
}

func (toState *UpdateFunction) SyncFieldsDuringRead(ctx context.Context, fromState UpdateFunction) {
}

func (c UpdateFunction) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateFunction.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateFunction) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateFunction
// only implements ToObjectValue() and Type().
func (o UpdateFunction) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":  o.Name,
			"owner": o.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateFunction) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":  types.StringType,
			"owner": types.StringType,
		},
	}
}

type UpdateMetastore struct {
	// The organization name of a Delta Sharing entity, to be used in
	// Databricks-to-Databricks Delta Sharing as the official name.
	DeltaSharingOrganizationName types.String `tfsdk:"delta_sharing_organization_name"`
	// The lifetime of delta sharing recipient token in seconds.
	DeltaSharingRecipientTokenLifetimeInSeconds types.Int64 `tfsdk:"delta_sharing_recipient_token_lifetime_in_seconds"`
	// The scope of Delta Sharing enabled for the metastore.
	DeltaSharingScope types.String `tfsdk:"delta_sharing_scope"`
	// Unique ID of the metastore.
	Id types.String `tfsdk:"-"`
	// New name for the metastore.
	NewName types.String `tfsdk:"new_name"`
	// The owner of the metastore.
	Owner types.String `tfsdk:"owner"`
	// Privilege model version of the metastore, of the form `major.minor`
	// (e.g., `1.0`).
	PrivilegeModelVersion types.String `tfsdk:"privilege_model_version"`
	// UUID of storage credential to access the metastore storage_root.
	StorageRootCredentialId types.String `tfsdk:"storage_root_credential_id"`
}

func (toState *UpdateMetastore) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateMetastore) {
}

func (toState *UpdateMetastore) SyncFieldsDuringRead(ctx context.Context, fromState UpdateMetastore) {
}

func (c UpdateMetastore) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["delta_sharing_organization_name"] = attrs["delta_sharing_organization_name"].SetOptional()
	attrs["delta_sharing_recipient_token_lifetime_in_seconds"] = attrs["delta_sharing_recipient_token_lifetime_in_seconds"].SetOptional()
	attrs["delta_sharing_scope"] = attrs["delta_sharing_scope"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["privilege_model_version"] = attrs["privilege_model_version"].SetOptional()
	attrs["storage_root_credential_id"] = attrs["storage_root_credential_id"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateMetastore.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateMetastore) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateMetastore
// only implements ToObjectValue() and Type().
func (o UpdateMetastore) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"delta_sharing_organization_name":                   o.DeltaSharingOrganizationName,
			"delta_sharing_recipient_token_lifetime_in_seconds": o.DeltaSharingRecipientTokenLifetimeInSeconds,
			"delta_sharing_scope":                               o.DeltaSharingScope,
			"id":                                                o.Id,
			"new_name":                                          o.NewName,
			"owner":                                             o.Owner,
			"privilege_model_version":                           o.PrivilegeModelVersion,
			"storage_root_credential_id":                        o.StorageRootCredentialId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateMetastore) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"delta_sharing_organization_name":                   types.StringType,
			"delta_sharing_recipient_token_lifetime_in_seconds": types.Int64Type,
			"delta_sharing_scope":                               types.StringType,
			"id":                                                types.StringType,
			"new_name":                                          types.StringType,
			"owner":                                             types.StringType,
			"privilege_model_version":                           types.StringType,
			"storage_root_credential_id":                        types.StringType,
		},
	}
}

type UpdateMetastoreAssignment struct {
	// The name of the default catalog in the metastore. This field is
	// deprecated. Please use "Default Namespace API" to configure the default
	// catalog for a Databricks workspace.
	DefaultCatalogName types.String `tfsdk:"default_catalog_name"`
	// The unique ID of the metastore.
	MetastoreId types.String `tfsdk:"metastore_id"`
	// A workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (toState *UpdateMetastoreAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateMetastoreAssignment) {
}

func (toState *UpdateMetastoreAssignment) SyncFieldsDuringRead(ctx context.Context, fromState UpdateMetastoreAssignment) {
}

func (c UpdateMetastoreAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default_catalog_name"] = attrs["default_catalog_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateMetastoreAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateMetastoreAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateMetastoreAssignment
// only implements ToObjectValue() and Type().
func (o UpdateMetastoreAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default_catalog_name": o.DefaultCatalogName,
			"metastore_id":         o.MetastoreId,
			"workspace_id":         o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateMetastoreAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default_catalog_name": types.StringType,
			"metastore_id":         types.StringType,
			"workspace_id":         types.Int64Type,
		},
	}
}

type UpdateModelVersionRequest struct {
	// The comment attached to the model version
	Comment types.String `tfsdk:"comment"`
	// The three-level (fully qualified) name of the model version
	FullName types.String `tfsdk:"-"`
	// The integer version number of the model version
	Version types.Int64 `tfsdk:"-"`
}

func (toState *UpdateModelVersionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateModelVersionRequest) {
}

func (toState *UpdateModelVersionRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateModelVersionRequest) {
}

func (c UpdateModelVersionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()
	attrs["version"] = attrs["version"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateModelVersionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateModelVersionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateModelVersionRequest
// only implements ToObjectValue() and Type().
func (o UpdateModelVersionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":   o.Comment,
			"full_name": o.FullName,
			"version":   o.Version,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateModelVersionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":   types.StringType,
			"full_name": types.StringType,
			"version":   types.Int64Type,
		},
	}
}

type UpdateMonitor struct {
	// [Create:OPT Update:OPT] Baseline table name. Baseline data is used to
	// compute drift from the data in the monitored `table_name`. The baseline
	// table and the monitored table shall have the same schema.
	BaselineTableName types.String `tfsdk:"baseline_table_name"`
	// [Create:OPT Update:OPT] Custom metrics.
	CustomMetrics types.List `tfsdk:"custom_metrics"`
	// [Create:ERR Update:OPT] Id of dashboard that visualizes the computed
	// metrics. This can be empty if the monitor is in PENDING state.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// [Create:OPT Update:OPT] Data classification related config.
	DataClassificationConfig types.Object `tfsdk:"data_classification_config"`

	InferenceLog types.Object `tfsdk:"inference_log"`
	// [Create:ERR Update:IGN] The latest error message for a monitor failure.
	LatestMonitorFailureMsg types.String `tfsdk:"latest_monitor_failure_msg"`
	// [Create:OPT Update:OPT] Field for specifying notification settings.
	Notifications types.Object `tfsdk:"notifications"`
	// [Create:REQ Update:REQ] Schema where output tables are created. Needs to
	// be in 2-level format {catalog}.{schema}
	OutputSchemaName types.String `tfsdk:"output_schema_name"`
	// [Create:OPT Update:OPT] The monitor schedule.
	Schedule types.Object `tfsdk:"schedule"`
	// [Create:OPT Update:OPT] List of column expressions to slice data with for
	// targeted analysis. The data is grouped by each expression independently,
	// resulting in a separate slice for each predicate and its complements. For
	// example `slicing_exprs=[col_1, col_2 > 10]` will generate the
	// following slices: two slices for `col_2 > 10` (True and False), and one
	// slice per unique value in `col1`. For high-cardinality columns, only the
	// top 100 unique values by frequency will generate slices.
	SlicingExprs types.List `tfsdk:"slicing_exprs"`
	// Configuration for monitoring snapshot tables.
	Snapshot types.Object `tfsdk:"snapshot"`
	// UC table name in format `catalog.schema.table_name`. This field
	// corresponds to the {full_table_name_arg} arg in the endpoint path.
	TableName types.String `tfsdk:"-"`
	// Configuration for monitoring time series tables.
	TimeSeries types.Object `tfsdk:"time_series"`
}

func (toState *UpdateMonitor) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateMonitor) {
	if !fromPlan.DataClassificationConfig.IsNull() && !fromPlan.DataClassificationConfig.IsUnknown() {
		if toStateDataClassificationConfig, ok := toState.GetDataClassificationConfig(ctx); ok {
			if fromPlanDataClassificationConfig, ok := fromPlan.GetDataClassificationConfig(ctx); ok {
				toStateDataClassificationConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDataClassificationConfig)
				toState.SetDataClassificationConfig(ctx, toStateDataClassificationConfig)
			}
		}
	}
	if !fromPlan.InferenceLog.IsNull() && !fromPlan.InferenceLog.IsUnknown() {
		if toStateInferenceLog, ok := toState.GetInferenceLog(ctx); ok {
			if fromPlanInferenceLog, ok := fromPlan.GetInferenceLog(ctx); ok {
				toStateInferenceLog.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanInferenceLog)
				toState.SetInferenceLog(ctx, toStateInferenceLog)
			}
		}
	}
	if !fromPlan.Notifications.IsNull() && !fromPlan.Notifications.IsUnknown() {
		if toStateNotifications, ok := toState.GetNotifications(ctx); ok {
			if fromPlanNotifications, ok := fromPlan.GetNotifications(ctx); ok {
				toStateNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanNotifications)
				toState.SetNotifications(ctx, toStateNotifications)
			}
		}
	}
	if !fromPlan.Schedule.IsNull() && !fromPlan.Schedule.IsUnknown() {
		if toStateSchedule, ok := toState.GetSchedule(ctx); ok {
			if fromPlanSchedule, ok := fromPlan.GetSchedule(ctx); ok {
				toStateSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSchedule)
				toState.SetSchedule(ctx, toStateSchedule)
			}
		}
	}
	if !fromPlan.Snapshot.IsNull() && !fromPlan.Snapshot.IsUnknown() {
		if toStateSnapshot, ok := toState.GetSnapshot(ctx); ok {
			if fromPlanSnapshot, ok := fromPlan.GetSnapshot(ctx); ok {
				toStateSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSnapshot)
				toState.SetSnapshot(ctx, toStateSnapshot)
			}
		}
	}
	if !fromPlan.TimeSeries.IsNull() && !fromPlan.TimeSeries.IsUnknown() {
		if toStateTimeSeries, ok := toState.GetTimeSeries(ctx); ok {
			if fromPlanTimeSeries, ok := fromPlan.GetTimeSeries(ctx); ok {
				toStateTimeSeries.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTimeSeries)
				toState.SetTimeSeries(ctx, toStateTimeSeries)
			}
		}
	}
}

func (toState *UpdateMonitor) SyncFieldsDuringRead(ctx context.Context, fromState UpdateMonitor) {
	if !fromState.DataClassificationConfig.IsNull() && !fromState.DataClassificationConfig.IsUnknown() {
		if toStateDataClassificationConfig, ok := toState.GetDataClassificationConfig(ctx); ok {
			if fromStateDataClassificationConfig, ok := fromState.GetDataClassificationConfig(ctx); ok {
				toStateDataClassificationConfig.SyncFieldsDuringRead(ctx, fromStateDataClassificationConfig)
				toState.SetDataClassificationConfig(ctx, toStateDataClassificationConfig)
			}
		}
	}
	if !fromState.InferenceLog.IsNull() && !fromState.InferenceLog.IsUnknown() {
		if toStateInferenceLog, ok := toState.GetInferenceLog(ctx); ok {
			if fromStateInferenceLog, ok := fromState.GetInferenceLog(ctx); ok {
				toStateInferenceLog.SyncFieldsDuringRead(ctx, fromStateInferenceLog)
				toState.SetInferenceLog(ctx, toStateInferenceLog)
			}
		}
	}
	if !fromState.Notifications.IsNull() && !fromState.Notifications.IsUnknown() {
		if toStateNotifications, ok := toState.GetNotifications(ctx); ok {
			if fromStateNotifications, ok := fromState.GetNotifications(ctx); ok {
				toStateNotifications.SyncFieldsDuringRead(ctx, fromStateNotifications)
				toState.SetNotifications(ctx, toStateNotifications)
			}
		}
	}
	if !fromState.Schedule.IsNull() && !fromState.Schedule.IsUnknown() {
		if toStateSchedule, ok := toState.GetSchedule(ctx); ok {
			if fromStateSchedule, ok := fromState.GetSchedule(ctx); ok {
				toStateSchedule.SyncFieldsDuringRead(ctx, fromStateSchedule)
				toState.SetSchedule(ctx, toStateSchedule)
			}
		}
	}
	if !fromState.Snapshot.IsNull() && !fromState.Snapshot.IsUnknown() {
		if toStateSnapshot, ok := toState.GetSnapshot(ctx); ok {
			if fromStateSnapshot, ok := fromState.GetSnapshot(ctx); ok {
				toStateSnapshot.SyncFieldsDuringRead(ctx, fromStateSnapshot)
				toState.SetSnapshot(ctx, toStateSnapshot)
			}
		}
	}
	if !fromState.TimeSeries.IsNull() && !fromState.TimeSeries.IsUnknown() {
		if toStateTimeSeries, ok := toState.GetTimeSeries(ctx); ok {
			if fromStateTimeSeries, ok := fromState.GetTimeSeries(ctx); ok {
				toStateTimeSeries.SyncFieldsDuringRead(ctx, fromStateTimeSeries)
				toState.SetTimeSeries(ctx, toStateTimeSeries)
			}
		}
	}
}

func (c UpdateMonitor) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["baseline_table_name"] = attrs["baseline_table_name"].SetOptional()
	attrs["custom_metrics"] = attrs["custom_metrics"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetOptional()
	attrs["data_classification_config"] = attrs["data_classification_config"].SetOptional()
	attrs["inference_log"] = attrs["inference_log"].SetOptional()
	attrs["latest_monitor_failure_msg"] = attrs["latest_monitor_failure_msg"].SetOptional()
	attrs["notifications"] = attrs["notifications"].SetOptional()
	attrs["output_schema_name"] = attrs["output_schema_name"].SetRequired()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["slicing_exprs"] = attrs["slicing_exprs"].SetOptional()
	attrs["snapshot"] = attrs["snapshot"].SetOptional()
	attrs["time_series"] = attrs["time_series"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateMonitor.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateMonitor) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"custom_metrics":             reflect.TypeOf(MonitorMetric{}),
		"data_classification_config": reflect.TypeOf(MonitorDataClassificationConfig{}),
		"inference_log":              reflect.TypeOf(MonitorInferenceLog{}),
		"notifications":              reflect.TypeOf(MonitorNotifications{}),
		"schedule":                   reflect.TypeOf(MonitorCronSchedule{}),
		"slicing_exprs":              reflect.TypeOf(types.String{}),
		"snapshot":                   reflect.TypeOf(MonitorSnapshot{}),
		"time_series":                reflect.TypeOf(MonitorTimeSeries{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateMonitor
// only implements ToObjectValue() and Type().
func (o UpdateMonitor) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"baseline_table_name":        o.BaselineTableName,
			"custom_metrics":             o.CustomMetrics,
			"dashboard_id":               o.DashboardId,
			"data_classification_config": o.DataClassificationConfig,
			"inference_log":              o.InferenceLog,
			"latest_monitor_failure_msg": o.LatestMonitorFailureMsg,
			"notifications":              o.Notifications,
			"output_schema_name":         o.OutputSchemaName,
			"schedule":                   o.Schedule,
			"slicing_exprs":              o.SlicingExprs,
			"snapshot":                   o.Snapshot,
			"table_name":                 o.TableName,
			"time_series":                o.TimeSeries,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateMonitor) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"baseline_table_name": types.StringType,
			"custom_metrics": basetypes.ListType{
				ElemType: MonitorMetric{}.Type(ctx),
			},
			"dashboard_id":               types.StringType,
			"data_classification_config": MonitorDataClassificationConfig{}.Type(ctx),
			"inference_log":              MonitorInferenceLog{}.Type(ctx),
			"latest_monitor_failure_msg": types.StringType,
			"notifications":              MonitorNotifications{}.Type(ctx),
			"output_schema_name":         types.StringType,
			"schedule":                   MonitorCronSchedule{}.Type(ctx),
			"slicing_exprs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"snapshot":    MonitorSnapshot{}.Type(ctx),
			"table_name":  types.StringType,
			"time_series": MonitorTimeSeries{}.Type(ctx),
		},
	}
}

// GetCustomMetrics returns the value of the CustomMetrics field in UpdateMonitor as
// a slice of MonitorMetric values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetCustomMetrics(ctx context.Context) ([]MonitorMetric, bool) {
	if o.CustomMetrics.IsNull() || o.CustomMetrics.IsUnknown() {
		return nil, false
	}
	var v []MonitorMetric
	d := o.CustomMetrics.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCustomMetrics sets the value of the CustomMetrics field in UpdateMonitor.
func (o *UpdateMonitor) SetCustomMetrics(ctx context.Context, v []MonitorMetric) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["custom_metrics"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.CustomMetrics = types.ListValueMust(t, vs)
}

// GetDataClassificationConfig returns the value of the DataClassificationConfig field in UpdateMonitor as
// a MonitorDataClassificationConfig value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetDataClassificationConfig(ctx context.Context) (MonitorDataClassificationConfig, bool) {
	var e MonitorDataClassificationConfig
	if o.DataClassificationConfig.IsNull() || o.DataClassificationConfig.IsUnknown() {
		return e, false
	}
	var v MonitorDataClassificationConfig
	d := o.DataClassificationConfig.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDataClassificationConfig sets the value of the DataClassificationConfig field in UpdateMonitor.
func (o *UpdateMonitor) SetDataClassificationConfig(ctx context.Context, v MonitorDataClassificationConfig) {
	vs := v.ToObjectValue(ctx)
	o.DataClassificationConfig = vs
}

// GetInferenceLog returns the value of the InferenceLog field in UpdateMonitor as
// a MonitorInferenceLog value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetInferenceLog(ctx context.Context) (MonitorInferenceLog, bool) {
	var e MonitorInferenceLog
	if o.InferenceLog.IsNull() || o.InferenceLog.IsUnknown() {
		return e, false
	}
	var v MonitorInferenceLog
	d := o.InferenceLog.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInferenceLog sets the value of the InferenceLog field in UpdateMonitor.
func (o *UpdateMonitor) SetInferenceLog(ctx context.Context, v MonitorInferenceLog) {
	vs := v.ToObjectValue(ctx)
	o.InferenceLog = vs
}

// GetNotifications returns the value of the Notifications field in UpdateMonitor as
// a MonitorNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetNotifications(ctx context.Context) (MonitorNotifications, bool) {
	var e MonitorNotifications
	if o.Notifications.IsNull() || o.Notifications.IsUnknown() {
		return e, false
	}
	var v MonitorNotifications
	d := o.Notifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotifications sets the value of the Notifications field in UpdateMonitor.
func (o *UpdateMonitor) SetNotifications(ctx context.Context, v MonitorNotifications) {
	vs := v.ToObjectValue(ctx)
	o.Notifications = vs
}

// GetSchedule returns the value of the Schedule field in UpdateMonitor as
// a MonitorCronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetSchedule(ctx context.Context) (MonitorCronSchedule, bool) {
	var e MonitorCronSchedule
	if o.Schedule.IsNull() || o.Schedule.IsUnknown() {
		return e, false
	}
	var v MonitorCronSchedule
	d := o.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in UpdateMonitor.
func (o *UpdateMonitor) SetSchedule(ctx context.Context, v MonitorCronSchedule) {
	vs := v.ToObjectValue(ctx)
	o.Schedule = vs
}

// GetSlicingExprs returns the value of the SlicingExprs field in UpdateMonitor as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetSlicingExprs(ctx context.Context) ([]types.String, bool) {
	if o.SlicingExprs.IsNull() || o.SlicingExprs.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.SlicingExprs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSlicingExprs sets the value of the SlicingExprs field in UpdateMonitor.
func (o *UpdateMonitor) SetSlicingExprs(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["slicing_exprs"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.SlicingExprs = types.ListValueMust(t, vs)
}

// GetSnapshot returns the value of the Snapshot field in UpdateMonitor as
// a MonitorSnapshot value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetSnapshot(ctx context.Context) (MonitorSnapshot, bool) {
	var e MonitorSnapshot
	if o.Snapshot.IsNull() || o.Snapshot.IsUnknown() {
		return e, false
	}
	var v MonitorSnapshot
	d := o.Snapshot.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSnapshot sets the value of the Snapshot field in UpdateMonitor.
func (o *UpdateMonitor) SetSnapshot(ctx context.Context, v MonitorSnapshot) {
	vs := v.ToObjectValue(ctx)
	o.Snapshot = vs
}

// GetTimeSeries returns the value of the TimeSeries field in UpdateMonitor as
// a MonitorTimeSeries value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateMonitor) GetTimeSeries(ctx context.Context) (MonitorTimeSeries, bool) {
	var e MonitorTimeSeries
	if o.TimeSeries.IsNull() || o.TimeSeries.IsUnknown() {
		return e, false
	}
	var v MonitorTimeSeries
	d := o.TimeSeries.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTimeSeries sets the value of the TimeSeries field in UpdateMonitor.
func (o *UpdateMonitor) SetTimeSeries(ctx context.Context, v MonitorTimeSeries) {
	vs := v.ToObjectValue(ctx)
	o.TimeSeries = vs
}

type UpdatePermissions struct {
	// Array of permissions change objects.
	Changes types.List `tfsdk:"changes"`
	// Full name of securable.
	FullName types.String `tfsdk:"-"`
	// Type of securable.
	SecurableType types.String `tfsdk:"-"`
}

func (toState *UpdatePermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdatePermissions) {
}

func (toState *UpdatePermissions) SyncFieldsDuringRead(ctx context.Context, fromState UpdatePermissions) {
}

func (c UpdatePermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["changes"] = attrs["changes"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdatePermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdatePermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"changes": reflect.TypeOf(PermissionsChange{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdatePermissions
// only implements ToObjectValue() and Type().
func (o UpdatePermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"changes":        o.Changes,
			"full_name":      o.FullName,
			"securable_type": o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdatePermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"changes": basetypes.ListType{
				ElemType: PermissionsChange{}.Type(ctx),
			},
			"full_name":      types.StringType,
			"securable_type": types.StringType,
		},
	}
}

// GetChanges returns the value of the Changes field in UpdatePermissions as
// a slice of PermissionsChange values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdatePermissions) GetChanges(ctx context.Context) ([]PermissionsChange, bool) {
	if o.Changes.IsNull() || o.Changes.IsUnknown() {
		return nil, false
	}
	var v []PermissionsChange
	d := o.Changes.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetChanges sets the value of the Changes field in UpdatePermissions.
func (o *UpdatePermissions) SetChanges(ctx context.Context, v []PermissionsChange) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["changes"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Changes = types.ListValueMust(t, vs)
}

type UpdatePermissionsResponse struct {
	// The privileges assigned to each principal
	PrivilegeAssignments types.List `tfsdk:"privilege_assignments"`
}

func (toState *UpdatePermissionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdatePermissionsResponse) {
}

func (toState *UpdatePermissionsResponse) SyncFieldsDuringRead(ctx context.Context, fromState UpdatePermissionsResponse) {
}

func (c UpdatePermissionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["privilege_assignments"] = attrs["privilege_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdatePermissionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdatePermissionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"privilege_assignments": reflect.TypeOf(PrivilegeAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdatePermissionsResponse
// only implements ToObjectValue() and Type().
func (o UpdatePermissionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"privilege_assignments": o.PrivilegeAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdatePermissionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"privilege_assignments": basetypes.ListType{
				ElemType: PrivilegeAssignment{}.Type(ctx),
			},
		},
	}
}

// GetPrivilegeAssignments returns the value of the PrivilegeAssignments field in UpdatePermissionsResponse as
// a slice of PrivilegeAssignment values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdatePermissionsResponse) GetPrivilegeAssignments(ctx context.Context) ([]PrivilegeAssignment, bool) {
	if o.PrivilegeAssignments.IsNull() || o.PrivilegeAssignments.IsUnknown() {
		return nil, false
	}
	var v []PrivilegeAssignment
	d := o.PrivilegeAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrivilegeAssignments sets the value of the PrivilegeAssignments field in UpdatePermissionsResponse.
func (o *UpdatePermissionsResponse) SetPrivilegeAssignments(ctx context.Context, v []PrivilegeAssignment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["privilege_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PrivilegeAssignments = types.ListValueMust(t, vs)
}

type UpdatePolicyRequest struct {
	// Required. The name of the policy to update.
	Name types.String `tfsdk:"-"`
	// Required. The fully qualified name of the securable to update the policy
	// for.
	OnSecurableFullname types.String `tfsdk:"-"`
	// Required. The type of the securable to update the policy for.
	OnSecurableType types.String `tfsdk:"-"`
	// Optional fields to update. This is the request body for updating a
	// policy. Use `update_mask` field to specify which fields in the request is
	// to be updated. - If `update_mask` is empty or "*", all specified fields
	// will be updated. - If `update_mask` is specified, only the fields
	// specified in the `update_mask` will be updated. If a field is specified
	// in `update_mask` and not set in the request, the field will be cleared.
	// Users can use the update mask to explicitly unset optional fields such as
	// `exception_principals` and `when_condition`.
	PolicyInfo types.Object `tfsdk:"policy_info"`
	// Optional. The update mask field for specifying user intentions on which
	// fields to update in the request.
	UpdateMask types.String `tfsdk:"-"`
}

func (toState *UpdatePolicyRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdatePolicyRequest) {
	if !fromPlan.PolicyInfo.IsNull() && !fromPlan.PolicyInfo.IsUnknown() {
		if toStatePolicyInfo, ok := toState.GetPolicyInfo(ctx); ok {
			if fromPlanPolicyInfo, ok := fromPlan.GetPolicyInfo(ctx); ok {
				toStatePolicyInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanPolicyInfo)
				toState.SetPolicyInfo(ctx, toStatePolicyInfo)
			}
		}
	}
}

func (toState *UpdatePolicyRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdatePolicyRequest) {
	if !fromState.PolicyInfo.IsNull() && !fromState.PolicyInfo.IsUnknown() {
		if toStatePolicyInfo, ok := toState.GetPolicyInfo(ctx); ok {
			if fromStatePolicyInfo, ok := fromState.GetPolicyInfo(ctx); ok {
				toStatePolicyInfo.SyncFieldsDuringRead(ctx, fromStatePolicyInfo)
				toState.SetPolicyInfo(ctx, toStatePolicyInfo)
			}
		}
	}
}

func (c UpdatePolicyRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["policy_info"] = attrs["policy_info"].SetRequired()
	attrs["on_securable_type"] = attrs["on_securable_type"].SetRequired()
	attrs["on_securable_fullname"] = attrs["on_securable_fullname"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["update_mask"] = attrs["update_mask"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdatePolicyRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdatePolicyRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"policy_info": reflect.TypeOf(PolicyInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdatePolicyRequest
// only implements ToObjectValue() and Type().
func (o UpdatePolicyRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                  o.Name,
			"on_securable_fullname": o.OnSecurableFullname,
			"on_securable_type":     o.OnSecurableType,
			"policy_info":           o.PolicyInfo,
			"update_mask":           o.UpdateMask,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdatePolicyRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":                  types.StringType,
			"on_securable_fullname": types.StringType,
			"on_securable_type":     types.StringType,
			"policy_info":           PolicyInfo{}.Type(ctx),
			"update_mask":           types.StringType,
		},
	}
}

// GetPolicyInfo returns the value of the PolicyInfo field in UpdatePolicyRequest as
// a PolicyInfo value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdatePolicyRequest) GetPolicyInfo(ctx context.Context) (PolicyInfo, bool) {
	var e PolicyInfo
	if o.PolicyInfo.IsNull() || o.PolicyInfo.IsUnknown() {
		return e, false
	}
	var v PolicyInfo
	d := o.PolicyInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPolicyInfo sets the value of the PolicyInfo field in UpdatePolicyRequest.
func (o *UpdatePolicyRequest) SetPolicyInfo(ctx context.Context, v PolicyInfo) {
	vs := v.ToObjectValue(ctx)
	o.PolicyInfo = vs
}

type UpdateRegisteredModelRequest struct {
	// The comment attached to the registered model
	Comment types.String `tfsdk:"comment"`
	// The three-level (fully qualified) name of the registered model
	FullName types.String `tfsdk:"-"`
	// New name for the registered model.
	NewName types.String `tfsdk:"new_name"`
	// The identifier of the user who owns the registered model
	Owner types.String `tfsdk:"owner"`
}

func (toState *UpdateRegisteredModelRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateRegisteredModelRequest) {
}

func (toState *UpdateRegisteredModelRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateRegisteredModelRequest) {
}

func (c UpdateRegisteredModelRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateRegisteredModelRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateRegisteredModelRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateRegisteredModelRequest
// only implements ToObjectValue() and Type().
func (o UpdateRegisteredModelRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":   o.Comment,
			"full_name": o.FullName,
			"new_name":  o.NewName,
			"owner":     o.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateRegisteredModelRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":   types.StringType,
			"full_name": types.StringType,
			"new_name":  types.StringType,
			"owner":     types.StringType,
		},
	}
}

type UpdateRequestExternalLineage struct {
	// List of column relationships between source and target objects.
	Columns types.List `tfsdk:"columns"`
	// Unique identifier of the external lineage relationship.
	Id types.String `tfsdk:"id"`
	// Key-value properties associated with the external lineage relationship.
	Properties types.Map `tfsdk:"properties"`
	// Source object of the external lineage relationship.
	Source types.Object `tfsdk:"source"`
	// Target object of the external lineage relationship.
	Target types.Object `tfsdk:"target"`
}

func (toState *UpdateRequestExternalLineage) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateRequestExternalLineage) {
	if !fromPlan.Source.IsNull() && !fromPlan.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromPlanSource, ok := fromPlan.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromPlan.Target.IsNull() && !fromPlan.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromPlanTarget, ok := fromPlan.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (toState *UpdateRequestExternalLineage) SyncFieldsDuringRead(ctx context.Context, fromState UpdateRequestExternalLineage) {
	if !fromState.Source.IsNull() && !fromState.Source.IsUnknown() {
		if toStateSource, ok := toState.GetSource(ctx); ok {
			if fromStateSource, ok := fromState.GetSource(ctx); ok {
				toStateSource.SyncFieldsDuringRead(ctx, fromStateSource)
				toState.SetSource(ctx, toStateSource)
			}
		}
	}
	if !fromState.Target.IsNull() && !fromState.Target.IsUnknown() {
		if toStateTarget, ok := toState.GetTarget(ctx); ok {
			if fromStateTarget, ok := fromState.GetTarget(ctx); ok {
				toStateTarget.SyncFieldsDuringRead(ctx, fromStateTarget)
				toState.SetTarget(ctx, toStateTarget)
			}
		}
	}
}

func (c UpdateRequestExternalLineage) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["columns"] = attrs["columns"].SetOptional()
	attrs["id"] = attrs["id"].SetComputed()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["source"] = attrs["source"].SetRequired()
	attrs["target"] = attrs["target"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateRequestExternalLineage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateRequestExternalLineage) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"columns":    reflect.TypeOf(ColumnRelationship{}),
		"properties": reflect.TypeOf(types.String{}),
		"source":     reflect.TypeOf(ExternalLineageObject{}),
		"target":     reflect.TypeOf(ExternalLineageObject{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateRequestExternalLineage
// only implements ToObjectValue() and Type().
func (o UpdateRequestExternalLineage) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"columns":    o.Columns,
			"id":         o.Id,
			"properties": o.Properties,
			"source":     o.Source,
			"target":     o.Target,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateRequestExternalLineage) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"columns": basetypes.ListType{
				ElemType: ColumnRelationship{}.Type(ctx),
			},
			"id": types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
			"source": ExternalLineageObject{}.Type(ctx),
			"target": ExternalLineageObject{}.Type(ctx),
		},
	}
}

// GetColumns returns the value of the Columns field in UpdateRequestExternalLineage as
// a slice of ColumnRelationship values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateRequestExternalLineage) GetColumns(ctx context.Context) ([]ColumnRelationship, bool) {
	if o.Columns.IsNull() || o.Columns.IsUnknown() {
		return nil, false
	}
	var v []ColumnRelationship
	d := o.Columns.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumns sets the value of the Columns field in UpdateRequestExternalLineage.
func (o *UpdateRequestExternalLineage) SetColumns(ctx context.Context, v []ColumnRelationship) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["columns"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Columns = types.ListValueMust(t, vs)
}

// GetProperties returns the value of the Properties field in UpdateRequestExternalLineage as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateRequestExternalLineage) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in UpdateRequestExternalLineage.
func (o *UpdateRequestExternalLineage) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

// GetSource returns the value of the Source field in UpdateRequestExternalLineage as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateRequestExternalLineage) GetSource(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Source.IsNull() || o.Source.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Source.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSource sets the value of the Source field in UpdateRequestExternalLineage.
func (o *UpdateRequestExternalLineage) SetSource(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Source = vs
}

// GetTarget returns the value of the Target field in UpdateRequestExternalLineage as
// a ExternalLineageObject value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateRequestExternalLineage) GetTarget(ctx context.Context) (ExternalLineageObject, bool) {
	var e ExternalLineageObject
	if o.Target.IsNull() || o.Target.IsUnknown() {
		return e, false
	}
	var v ExternalLineageObject
	d := o.Target.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTarget sets the value of the Target field in UpdateRequestExternalLineage.
func (o *UpdateRequestExternalLineage) SetTarget(ctx context.Context, v ExternalLineageObject) {
	vs := v.ToObjectValue(ctx)
	o.Target = vs
}

type UpdateResponse struct {
}

func (toState *UpdateResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateResponse) {
}

func (toState *UpdateResponse) SyncFieldsDuringRead(ctx context.Context, fromState UpdateResponse) {
}

func (c UpdateResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateResponse
// only implements ToObjectValue() and Type().
func (o UpdateResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateSchema struct {
	// User-provided free-form text description.
	Comment types.String `tfsdk:"comment"`
	// Whether predictive optimization should be enabled for this object and
	// objects under it.
	EnablePredictiveOptimization types.String `tfsdk:"enable_predictive_optimization"`
	// Full name of the schema.
	FullName types.String `tfsdk:"-"`
	// New name for the schema.
	NewName types.String `tfsdk:"new_name"`
	// Username of current owner of schema.
	Owner types.String `tfsdk:"owner"`
	// A map of key-value properties attached to the securable.
	Properties types.Map `tfsdk:"properties"`
}

func (toState *UpdateSchema) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateSchema) {
}

func (toState *UpdateSchema) SyncFieldsDuringRead(ctx context.Context, fromState UpdateSchema) {
}

func (c UpdateSchema) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["enable_predictive_optimization"] = attrs["enable_predictive_optimization"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["properties"] = attrs["properties"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateSchema.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateSchema) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"properties": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateSchema
// only implements ToObjectValue() and Type().
func (o UpdateSchema) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":                        o.Comment,
			"enable_predictive_optimization": o.EnablePredictiveOptimization,
			"full_name":                      o.FullName,
			"new_name":                       o.NewName,
			"owner":                          o.Owner,
			"properties":                     o.Properties,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateSchema) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":                        types.StringType,
			"enable_predictive_optimization": types.StringType,
			"full_name":                      types.StringType,
			"new_name":                       types.StringType,
			"owner":                          types.StringType,
			"properties": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetProperties returns the value of the Properties field in UpdateSchema as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateSchema) GetProperties(ctx context.Context) (map[string]types.String, bool) {
	if o.Properties.IsNull() || o.Properties.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := o.Properties.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetProperties sets the value of the Properties field in UpdateSchema.
func (o *UpdateSchema) SetProperties(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["properties"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Properties = types.MapValueMust(t, vs)
}

type UpdateStorageCredential struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.Object `tfsdk:"cloudflare_api_token"`
	// Comment associated with the credential.
	Comment types.String `tfsdk:"comment"`
	// The Databricks managed GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// Force update even if there are dependent external locations or external
	// tables.
	Force types.Bool `tfsdk:"force"`
	// Whether the current securable is accessible from all workspaces or a
	// specific set of workspaces.
	IsolationMode types.String `tfsdk:"isolation_mode"`
	// Name of the storage credential.
	Name types.String `tfsdk:"-"`
	// New name for the storage credential.
	NewName types.String `tfsdk:"new_name"`
	// Username of current owner of credential.
	Owner types.String `tfsdk:"owner"`
	// Whether the credential is usable only for read operations. Only
	// applicable when purpose is **STORAGE**.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Supplying true to this argument skips validation of the updated
	// credential.
	SkipValidation types.Bool `tfsdk:"skip_validation"`
}

func (toState *UpdateStorageCredential) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateStorageCredential) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.CloudflareApiToken.IsNull() && !fromPlan.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromPlanCloudflareApiToken, ok := fromPlan.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *UpdateStorageCredential) SyncFieldsDuringRead(ctx context.Context, fromState UpdateStorageCredential) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.CloudflareApiToken.IsNull() && !fromState.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromStateCloudflareApiToken, ok := fromState.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringRead(ctx, fromStateCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c UpdateStorageCredential) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["force"] = attrs["force"].SetOptional()
	attrs["isolation_mode"] = attrs["isolation_mode"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["skip_validation"] = attrs["skip_validation"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateStorageCredential) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityResponse{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateStorageCredential
// only implements ToObjectValue() and Type().
func (o UpdateStorageCredential) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"cloudflare_api_token":           o.CloudflareApiToken,
			"comment":                        o.Comment,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"force":                          o.Force,
			"isolation_mode":                 o.IsolationMode,
			"name":                           o.Name,
			"new_name":                       o.NewName,
			"owner":                          o.Owner,
			"read_only":                      o.ReadOnly,
			"skip_validation":                o.SkipValidation,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateStorageCredential) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRoleRequest{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentityResponse{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"cloudflare_api_token":           CloudflareApiToken{}.Type(ctx),
			"comment":                        types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccountRequest{}.Type(ctx),
			"force":                          types.BoolType,
			"isolation_mode":                 types.StringType,
			"name":                           types.StringType,
			"new_name":                       types.StringType,
			"owner":                          types.StringType,
			"read_only":                      types.BoolType,
			"skip_validation":                types.BoolType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in UpdateStorageCredential as
// a AwsIamRoleRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateStorageCredential) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest, bool) {
	var e AwsIamRoleRequest
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRoleRequest
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in UpdateStorageCredential.
func (o *UpdateStorageCredential) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in UpdateStorageCredential as
// a AzureManagedIdentityResponse value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateStorageCredential) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityResponse, bool) {
	var e AzureManagedIdentityResponse
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentityResponse
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in UpdateStorageCredential.
func (o *UpdateStorageCredential) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityResponse) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in UpdateStorageCredential as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateStorageCredential) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in UpdateStorageCredential.
func (o *UpdateStorageCredential) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in UpdateStorageCredential as
// a CloudflareApiToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateStorageCredential) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken, bool) {
	var e CloudflareApiToken
	if o.CloudflareApiToken.IsNull() || o.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v CloudflareApiToken
	d := o.CloudflareApiToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in UpdateStorageCredential.
func (o *UpdateStorageCredential) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken) {
	vs := v.ToObjectValue(ctx)
	o.CloudflareApiToken = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in UpdateStorageCredential as
// a DatabricksGcpServiceAccountRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateStorageCredential) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest, bool) {
	var e DatabricksGcpServiceAccountRequest
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccountRequest
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in UpdateStorageCredential.
func (o *UpdateStorageCredential) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type UpdateTableRequest struct {
	// Full name of the table.
	FullName types.String `tfsdk:"-"`
	// Username of current owner of table.
	Owner types.String `tfsdk:"owner"`
}

func (toState *UpdateTableRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateTableRequest) {
}

func (toState *UpdateTableRequest) SyncFieldsDuringRead(ctx context.Context, fromState UpdateTableRequest) {
}

func (c UpdateTableRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateTableRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateTableRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateTableRequest
// only implements ToObjectValue() and Type().
func (o UpdateTableRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_name": o.FullName,
			"owner":     o.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateTableRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_name": types.StringType,
			"owner":     types.StringType,
		},
	}
}

type UpdateVolumeRequestContent struct {
	// The comment attached to the volume
	Comment types.String `tfsdk:"comment"`
	// The three-level (fully qualified) name of the volume
	Name types.String `tfsdk:"-"`
	// New name for the volume.
	NewName types.String `tfsdk:"new_name"`
	// The identifier of the user who owns the volume
	Owner types.String `tfsdk:"owner"`
}

func (toState *UpdateVolumeRequestContent) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateVolumeRequestContent) {
}

func (toState *UpdateVolumeRequestContent) SyncFieldsDuringRead(ctx context.Context, fromState UpdateVolumeRequestContent) {
}

func (c UpdateVolumeRequestContent) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["new_name"] = attrs["new_name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateVolumeRequestContent.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateVolumeRequestContent) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateVolumeRequestContent
// only implements ToObjectValue() and Type().
func (o UpdateVolumeRequestContent) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"comment":  o.Comment,
			"name":     o.Name,
			"new_name": o.NewName,
			"owner":    o.Owner,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateVolumeRequestContent) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"comment":  types.StringType,
			"name":     types.StringType,
			"new_name": types.StringType,
			"owner":    types.StringType,
		},
	}
}

type UpdateWorkspaceBindings struct {
	// A list of workspace IDs.
	AssignWorkspaces types.List `tfsdk:"assign_workspaces"`
	// The name of the catalog.
	Name types.String `tfsdk:"-"`
	// A list of workspace IDs.
	UnassignWorkspaces types.List `tfsdk:"unassign_workspaces"`
}

func (toState *UpdateWorkspaceBindings) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateWorkspaceBindings) {
}

func (toState *UpdateWorkspaceBindings) SyncFieldsDuringRead(ctx context.Context, fromState UpdateWorkspaceBindings) {
}

func (c UpdateWorkspaceBindings) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["assign_workspaces"] = attrs["assign_workspaces"].SetOptional()
	attrs["unassign_workspaces"] = attrs["unassign_workspaces"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceBindings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateWorkspaceBindings) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"assign_workspaces":   reflect.TypeOf(types.Int64{}),
		"unassign_workspaces": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceBindings
// only implements ToObjectValue() and Type().
func (o UpdateWorkspaceBindings) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"assign_workspaces":   o.AssignWorkspaces,
			"name":                o.Name,
			"unassign_workspaces": o.UnassignWorkspaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateWorkspaceBindings) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"assign_workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"name": types.StringType,
			"unassign_workspaces": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		},
	}
}

// GetAssignWorkspaces returns the value of the AssignWorkspaces field in UpdateWorkspaceBindings as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateWorkspaceBindings) GetAssignWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if o.AssignWorkspaces.IsNull() || o.AssignWorkspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := o.AssignWorkspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAssignWorkspaces sets the value of the AssignWorkspaces field in UpdateWorkspaceBindings.
func (o *UpdateWorkspaceBindings) SetAssignWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["assign_workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AssignWorkspaces = types.ListValueMust(t, vs)
}

// GetUnassignWorkspaces returns the value of the UnassignWorkspaces field in UpdateWorkspaceBindings as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateWorkspaceBindings) GetUnassignWorkspaces(ctx context.Context) ([]types.Int64, bool) {
	if o.UnassignWorkspaces.IsNull() || o.UnassignWorkspaces.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := o.UnassignWorkspaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUnassignWorkspaces sets the value of the UnassignWorkspaces field in UpdateWorkspaceBindings.
func (o *UpdateWorkspaceBindings) SetUnassignWorkspaces(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["unassign_workspaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.UnassignWorkspaces = types.ListValueMust(t, vs)
}

type UpdateWorkspaceBindingsParameters struct {
	// List of workspace bindings.
	Add types.List `tfsdk:"add"`
	// List of workspace bindings.
	Remove types.List `tfsdk:"remove"`
	// The name of the securable.
	SecurableName types.String `tfsdk:"-"`
	// The type of the securable to bind to a workspace (catalog,
	// storage_credential, credential, or external_location).
	SecurableType types.String `tfsdk:"-"`
}

func (toState *UpdateWorkspaceBindingsParameters) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateWorkspaceBindingsParameters) {
}

func (toState *UpdateWorkspaceBindingsParameters) SyncFieldsDuringRead(ctx context.Context, fromState UpdateWorkspaceBindingsParameters) {
}

func (c UpdateWorkspaceBindingsParameters) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["add"] = attrs["add"].SetOptional()
	attrs["remove"] = attrs["remove"].SetOptional()
	attrs["securable_type"] = attrs["securable_type"].SetRequired()
	attrs["securable_name"] = attrs["securable_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceBindingsParameters.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateWorkspaceBindingsParameters) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"add":    reflect.TypeOf(WorkspaceBinding{}),
		"remove": reflect.TypeOf(WorkspaceBinding{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceBindingsParameters
// only implements ToObjectValue() and Type().
func (o UpdateWorkspaceBindingsParameters) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"add":            o.Add,
			"remove":         o.Remove,
			"securable_name": o.SecurableName,
			"securable_type": o.SecurableType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateWorkspaceBindingsParameters) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: WorkspaceBinding{}.Type(ctx),
			},
			"remove": basetypes.ListType{
				ElemType: WorkspaceBinding{}.Type(ctx),
			},
			"securable_name": types.StringType,
			"securable_type": types.StringType,
		},
	}
}

// GetAdd returns the value of the Add field in UpdateWorkspaceBindingsParameters as
// a slice of WorkspaceBinding values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateWorkspaceBindingsParameters) GetAdd(ctx context.Context) ([]WorkspaceBinding, bool) {
	if o.Add.IsNull() || o.Add.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding
	d := o.Add.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAdd sets the value of the Add field in UpdateWorkspaceBindingsParameters.
func (o *UpdateWorkspaceBindingsParameters) SetAdd(ctx context.Context, v []WorkspaceBinding) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["add"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Add = types.ListValueMust(t, vs)
}

// GetRemove returns the value of the Remove field in UpdateWorkspaceBindingsParameters as
// a slice of WorkspaceBinding values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateWorkspaceBindingsParameters) GetRemove(ctx context.Context) ([]WorkspaceBinding, bool) {
	if o.Remove.IsNull() || o.Remove.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding
	d := o.Remove.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRemove sets the value of the Remove field in UpdateWorkspaceBindingsParameters.
func (o *UpdateWorkspaceBindingsParameters) SetRemove(ctx context.Context, v []WorkspaceBinding) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["remove"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Remove = types.ListValueMust(t, vs)
}

// A list of workspace IDs that are bound to the securable
type UpdateWorkspaceBindingsResponse struct {
	// List of workspace bindings.
	Bindings types.List `tfsdk:"bindings"`
}

func (toState *UpdateWorkspaceBindingsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan UpdateWorkspaceBindingsResponse) {
}

func (toState *UpdateWorkspaceBindingsResponse) SyncFieldsDuringRead(ctx context.Context, fromState UpdateWorkspaceBindingsResponse) {
}

func (c UpdateWorkspaceBindingsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["bindings"] = attrs["bindings"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceBindingsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateWorkspaceBindingsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"bindings": reflect.TypeOf(WorkspaceBinding{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceBindingsResponse
// only implements ToObjectValue() and Type().
func (o UpdateWorkspaceBindingsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"bindings": o.Bindings,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateWorkspaceBindingsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"bindings": basetypes.ListType{
				ElemType: WorkspaceBinding{}.Type(ctx),
			},
		},
	}
}

// GetBindings returns the value of the Bindings field in UpdateWorkspaceBindingsResponse as
// a slice of WorkspaceBinding values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateWorkspaceBindingsResponse) GetBindings(ctx context.Context) ([]WorkspaceBinding, bool) {
	if o.Bindings.IsNull() || o.Bindings.IsUnknown() {
		return nil, false
	}
	var v []WorkspaceBinding
	d := o.Bindings.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBindings sets the value of the Bindings field in UpdateWorkspaceBindingsResponse.
func (o *UpdateWorkspaceBindingsResponse) SetBindings(ctx context.Context, v []WorkspaceBinding) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["bindings"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Bindings = types.ListValueMust(t, vs)
}

// Next ID: 17
type ValidateCredentialRequest struct {
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`

	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// Required. The name of an existing credential or long-lived cloud
	// credential to validate.
	CredentialName types.String `tfsdk:"credential_name"`

	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// The name of an existing external location to validate. Only applicable
	// for storage credentials (purpose is **STORAGE**.)
	ExternalLocationName types.String `tfsdk:"external_location_name"`
	// The purpose of the credential. This should only be used when the
	// credential is specified.
	Purpose types.String `tfsdk:"purpose"`
	// Whether the credential is only usable for read operations. Only
	// applicable for storage credentials (purpose is **STORAGE**.)
	ReadOnly types.Bool `tfsdk:"read_only"`
	// The external location url to validate. Only applicable when purpose is
	// **STORAGE**.
	Url types.String `tfsdk:"url"`
}

func (toState *ValidateCredentialRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ValidateCredentialRequest) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *ValidateCredentialRequest) SyncFieldsDuringRead(ctx context.Context, fromState ValidateCredentialRequest) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c ValidateCredentialRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["credential_name"] = attrs["credential_name"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["external_location_name"] = attrs["external_location_name"].SetOptional()
	attrs["purpose"] = attrs["purpose"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateCredentialRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ValidateCredentialRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRole{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentity{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccount{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateCredentialRequest
// only implements ToObjectValue() and Type().
func (o ValidateCredentialRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"credential_name":                o.CredentialName,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"external_location_name":         o.ExternalLocationName,
			"purpose":                        o.Purpose,
			"read_only":                      o.ReadOnly,
			"url":                            o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ValidateCredentialRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRole{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentity{}.Type(ctx),
			"credential_name":                types.StringType,
			"databricks_gcp_service_account": DatabricksGcpServiceAccount{}.Type(ctx),
			"external_location_name":         types.StringType,
			"purpose":                        types.StringType,
			"read_only":                      types.BoolType,
			"url":                            types.StringType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in ValidateCredentialRequest as
// a AwsIamRole value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateCredentialRequest) GetAwsIamRole(ctx context.Context) (AwsIamRole, bool) {
	var e AwsIamRole
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRole
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in ValidateCredentialRequest.
func (o *ValidateCredentialRequest) SetAwsIamRole(ctx context.Context, v AwsIamRole) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in ValidateCredentialRequest as
// a AzureManagedIdentity value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateCredentialRequest) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentity, bool) {
	var e AzureManagedIdentity
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentity
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in ValidateCredentialRequest.
func (o *ValidateCredentialRequest) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentity) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in ValidateCredentialRequest as
// a DatabricksGcpServiceAccount value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateCredentialRequest) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccount, bool) {
	var e DatabricksGcpServiceAccount
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccount
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in ValidateCredentialRequest.
func (o *ValidateCredentialRequest) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccount) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type ValidateCredentialResponse struct {
	// Whether the tested location is a directory in cloud storage. Only
	// applicable for when purpose is **STORAGE**.
	IsDir types.Bool `tfsdk:"is_dir"`
	// The results of the validation check.
	Results types.List `tfsdk:"results"`
}

func (toState *ValidateCredentialResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ValidateCredentialResponse) {
}

func (toState *ValidateCredentialResponse) SyncFieldsDuringRead(ctx context.Context, fromState ValidateCredentialResponse) {
}

func (c ValidateCredentialResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_dir"] = attrs["is_dir"].SetOptional()
	attrs["results"] = attrs["results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ValidateCredentialResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"results": reflect.TypeOf(CredentialValidationResult{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateCredentialResponse
// only implements ToObjectValue() and Type().
func (o ValidateCredentialResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_dir":  o.IsDir,
			"results": o.Results,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ValidateCredentialResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_dir": types.BoolType,
			"results": basetypes.ListType{
				ElemType: CredentialValidationResult{}.Type(ctx),
			},
		},
	}
}

// GetResults returns the value of the Results field in ValidateCredentialResponse as
// a slice of CredentialValidationResult values.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateCredentialResponse) GetResults(ctx context.Context) ([]CredentialValidationResult, bool) {
	if o.Results.IsNull() || o.Results.IsUnknown() {
		return nil, false
	}
	var v []CredentialValidationResult
	d := o.Results.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResults sets the value of the Results field in ValidateCredentialResponse.
func (o *ValidateCredentialResponse) SetResults(ctx context.Context, v []CredentialValidationResult) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["results"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Results = types.ListValueMust(t, vs)
}

type ValidateStorageCredential struct {
	// The AWS IAM role configuration.
	AwsIamRole types.Object `tfsdk:"aws_iam_role"`
	// The Azure managed identity configuration.
	AzureManagedIdentity types.Object `tfsdk:"azure_managed_identity"`
	// The Azure service principal configuration.
	AzureServicePrincipal types.Object `tfsdk:"azure_service_principal"`
	// The Cloudflare API token configuration.
	CloudflareApiToken types.Object `tfsdk:"cloudflare_api_token"`
	// The Databricks created GCP service account configuration.
	DatabricksGcpServiceAccount types.Object `tfsdk:"databricks_gcp_service_account"`
	// The name of an existing external location to validate.
	ExternalLocationName types.String `tfsdk:"external_location_name"`
	// Whether the storage credential is only usable for read operations.
	ReadOnly types.Bool `tfsdk:"read_only"`
	// Required. The name of an existing credential or long-lived cloud
	// credential to validate.
	StorageCredentialName types.String `tfsdk:"storage_credential_name"`
	// The external location url to validate.
	Url types.String `tfsdk:"url"`
}

func (toState *ValidateStorageCredential) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ValidateStorageCredential) {
	if !fromPlan.AwsIamRole.IsNull() && !fromPlan.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromPlanAwsIamRole, ok := fromPlan.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromPlan.AzureManagedIdentity.IsNull() && !fromPlan.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromPlanAzureManagedIdentity, ok := fromPlan.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromPlan.AzureServicePrincipal.IsNull() && !fromPlan.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromPlanAzureServicePrincipal, ok := fromPlan.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromPlan.CloudflareApiToken.IsNull() && !fromPlan.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromPlanCloudflareApiToken, ok := fromPlan.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromPlan.DatabricksGcpServiceAccount.IsNull() && !fromPlan.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromPlanDatabricksGcpServiceAccount, ok := fromPlan.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (toState *ValidateStorageCredential) SyncFieldsDuringRead(ctx context.Context, fromState ValidateStorageCredential) {
	if !fromState.AwsIamRole.IsNull() && !fromState.AwsIamRole.IsUnknown() {
		if toStateAwsIamRole, ok := toState.GetAwsIamRole(ctx); ok {
			if fromStateAwsIamRole, ok := fromState.GetAwsIamRole(ctx); ok {
				toStateAwsIamRole.SyncFieldsDuringRead(ctx, fromStateAwsIamRole)
				toState.SetAwsIamRole(ctx, toStateAwsIamRole)
			}
		}
	}
	if !fromState.AzureManagedIdentity.IsNull() && !fromState.AzureManagedIdentity.IsUnknown() {
		if toStateAzureManagedIdentity, ok := toState.GetAzureManagedIdentity(ctx); ok {
			if fromStateAzureManagedIdentity, ok := fromState.GetAzureManagedIdentity(ctx); ok {
				toStateAzureManagedIdentity.SyncFieldsDuringRead(ctx, fromStateAzureManagedIdentity)
				toState.SetAzureManagedIdentity(ctx, toStateAzureManagedIdentity)
			}
		}
	}
	if !fromState.AzureServicePrincipal.IsNull() && !fromState.AzureServicePrincipal.IsUnknown() {
		if toStateAzureServicePrincipal, ok := toState.GetAzureServicePrincipal(ctx); ok {
			if fromStateAzureServicePrincipal, ok := fromState.GetAzureServicePrincipal(ctx); ok {
				toStateAzureServicePrincipal.SyncFieldsDuringRead(ctx, fromStateAzureServicePrincipal)
				toState.SetAzureServicePrincipal(ctx, toStateAzureServicePrincipal)
			}
		}
	}
	if !fromState.CloudflareApiToken.IsNull() && !fromState.CloudflareApiToken.IsUnknown() {
		if toStateCloudflareApiToken, ok := toState.GetCloudflareApiToken(ctx); ok {
			if fromStateCloudflareApiToken, ok := fromState.GetCloudflareApiToken(ctx); ok {
				toStateCloudflareApiToken.SyncFieldsDuringRead(ctx, fromStateCloudflareApiToken)
				toState.SetCloudflareApiToken(ctx, toStateCloudflareApiToken)
			}
		}
	}
	if !fromState.DatabricksGcpServiceAccount.IsNull() && !fromState.DatabricksGcpServiceAccount.IsUnknown() {
		if toStateDatabricksGcpServiceAccount, ok := toState.GetDatabricksGcpServiceAccount(ctx); ok {
			if fromStateDatabricksGcpServiceAccount, ok := fromState.GetDatabricksGcpServiceAccount(ctx); ok {
				toStateDatabricksGcpServiceAccount.SyncFieldsDuringRead(ctx, fromStateDatabricksGcpServiceAccount)
				toState.SetDatabricksGcpServiceAccount(ctx, toStateDatabricksGcpServiceAccount)
			}
		}
	}
}

func (c ValidateStorageCredential) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["aws_iam_role"] = attrs["aws_iam_role"].SetOptional()
	attrs["azure_managed_identity"] = attrs["azure_managed_identity"].SetOptional()
	attrs["azure_service_principal"] = attrs["azure_service_principal"].SetOptional()
	attrs["cloudflare_api_token"] = attrs["cloudflare_api_token"].SetOptional()
	attrs["databricks_gcp_service_account"] = attrs["databricks_gcp_service_account"].SetOptional()
	attrs["external_location_name"] = attrs["external_location_name"].SetOptional()
	attrs["read_only"] = attrs["read_only"].SetOptional()
	attrs["storage_credential_name"] = attrs["storage_credential_name"].SetOptional()
	attrs["url"] = attrs["url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateStorageCredential.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ValidateStorageCredential) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"aws_iam_role":                   reflect.TypeOf(AwsIamRoleRequest{}),
		"azure_managed_identity":         reflect.TypeOf(AzureManagedIdentityRequest{}),
		"azure_service_principal":        reflect.TypeOf(AzureServicePrincipal{}),
		"cloudflare_api_token":           reflect.TypeOf(CloudflareApiToken{}),
		"databricks_gcp_service_account": reflect.TypeOf(DatabricksGcpServiceAccountRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateStorageCredential
// only implements ToObjectValue() and Type().
func (o ValidateStorageCredential) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"aws_iam_role":                   o.AwsIamRole,
			"azure_managed_identity":         o.AzureManagedIdentity,
			"azure_service_principal":        o.AzureServicePrincipal,
			"cloudflare_api_token":           o.CloudflareApiToken,
			"databricks_gcp_service_account": o.DatabricksGcpServiceAccount,
			"external_location_name":         o.ExternalLocationName,
			"read_only":                      o.ReadOnly,
			"storage_credential_name":        o.StorageCredentialName,
			"url":                            o.Url,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ValidateStorageCredential) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"aws_iam_role":                   AwsIamRoleRequest{}.Type(ctx),
			"azure_managed_identity":         AzureManagedIdentityRequest{}.Type(ctx),
			"azure_service_principal":        AzureServicePrincipal{}.Type(ctx),
			"cloudflare_api_token":           CloudflareApiToken{}.Type(ctx),
			"databricks_gcp_service_account": DatabricksGcpServiceAccountRequest{}.Type(ctx),
			"external_location_name":         types.StringType,
			"read_only":                      types.BoolType,
			"storage_credential_name":        types.StringType,
			"url":                            types.StringType,
		},
	}
}

// GetAwsIamRole returns the value of the AwsIamRole field in ValidateStorageCredential as
// a AwsIamRoleRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateStorageCredential) GetAwsIamRole(ctx context.Context) (AwsIamRoleRequest, bool) {
	var e AwsIamRoleRequest
	if o.AwsIamRole.IsNull() || o.AwsIamRole.IsUnknown() {
		return e, false
	}
	var v AwsIamRoleRequest
	d := o.AwsIamRole.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAwsIamRole sets the value of the AwsIamRole field in ValidateStorageCredential.
func (o *ValidateStorageCredential) SetAwsIamRole(ctx context.Context, v AwsIamRoleRequest) {
	vs := v.ToObjectValue(ctx)
	o.AwsIamRole = vs
}

// GetAzureManagedIdentity returns the value of the AzureManagedIdentity field in ValidateStorageCredential as
// a AzureManagedIdentityRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateStorageCredential) GetAzureManagedIdentity(ctx context.Context) (AzureManagedIdentityRequest, bool) {
	var e AzureManagedIdentityRequest
	if o.AzureManagedIdentity.IsNull() || o.AzureManagedIdentity.IsUnknown() {
		return e, false
	}
	var v AzureManagedIdentityRequest
	d := o.AzureManagedIdentity.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureManagedIdentity sets the value of the AzureManagedIdentity field in ValidateStorageCredential.
func (o *ValidateStorageCredential) SetAzureManagedIdentity(ctx context.Context, v AzureManagedIdentityRequest) {
	vs := v.ToObjectValue(ctx)
	o.AzureManagedIdentity = vs
}

// GetAzureServicePrincipal returns the value of the AzureServicePrincipal field in ValidateStorageCredential as
// a AzureServicePrincipal value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateStorageCredential) GetAzureServicePrincipal(ctx context.Context) (AzureServicePrincipal, bool) {
	var e AzureServicePrincipal
	if o.AzureServicePrincipal.IsNull() || o.AzureServicePrincipal.IsUnknown() {
		return e, false
	}
	var v AzureServicePrincipal
	d := o.AzureServicePrincipal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAzureServicePrincipal sets the value of the AzureServicePrincipal field in ValidateStorageCredential.
func (o *ValidateStorageCredential) SetAzureServicePrincipal(ctx context.Context, v AzureServicePrincipal) {
	vs := v.ToObjectValue(ctx)
	o.AzureServicePrincipal = vs
}

// GetCloudflareApiToken returns the value of the CloudflareApiToken field in ValidateStorageCredential as
// a CloudflareApiToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateStorageCredential) GetCloudflareApiToken(ctx context.Context) (CloudflareApiToken, bool) {
	var e CloudflareApiToken
	if o.CloudflareApiToken.IsNull() || o.CloudflareApiToken.IsUnknown() {
		return e, false
	}
	var v CloudflareApiToken
	d := o.CloudflareApiToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCloudflareApiToken sets the value of the CloudflareApiToken field in ValidateStorageCredential.
func (o *ValidateStorageCredential) SetCloudflareApiToken(ctx context.Context, v CloudflareApiToken) {
	vs := v.ToObjectValue(ctx)
	o.CloudflareApiToken = vs
}

// GetDatabricksGcpServiceAccount returns the value of the DatabricksGcpServiceAccount field in ValidateStorageCredential as
// a DatabricksGcpServiceAccountRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateStorageCredential) GetDatabricksGcpServiceAccount(ctx context.Context) (DatabricksGcpServiceAccountRequest, bool) {
	var e DatabricksGcpServiceAccountRequest
	if o.DatabricksGcpServiceAccount.IsNull() || o.DatabricksGcpServiceAccount.IsUnknown() {
		return e, false
	}
	var v DatabricksGcpServiceAccountRequest
	d := o.DatabricksGcpServiceAccount.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDatabricksGcpServiceAccount sets the value of the DatabricksGcpServiceAccount field in ValidateStorageCredential.
func (o *ValidateStorageCredential) SetDatabricksGcpServiceAccount(ctx context.Context, v DatabricksGcpServiceAccountRequest) {
	vs := v.ToObjectValue(ctx)
	o.DatabricksGcpServiceAccount = vs
}

type ValidateStorageCredentialResponse struct {
	// Whether the tested location is a directory in cloud storage.
	IsDir types.Bool `tfsdk:"is_dir"`
	// The results of the validation check.
	Results types.List `tfsdk:"results"`
}

func (toState *ValidateStorageCredentialResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ValidateStorageCredentialResponse) {
}

func (toState *ValidateStorageCredentialResponse) SyncFieldsDuringRead(ctx context.Context, fromState ValidateStorageCredentialResponse) {
}

func (c ValidateStorageCredentialResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_dir"] = attrs["is_dir"].SetOptional()
	attrs["results"] = attrs["results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidateStorageCredentialResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ValidateStorageCredentialResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"results": reflect.TypeOf(ValidationResult{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidateStorageCredentialResponse
// only implements ToObjectValue() and Type().
func (o ValidateStorageCredentialResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_dir":  o.IsDir,
			"results": o.Results,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ValidateStorageCredentialResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_dir": types.BoolType,
			"results": basetypes.ListType{
				ElemType: ValidationResult{}.Type(ctx),
			},
		},
	}
}

// GetResults returns the value of the Results field in ValidateStorageCredentialResponse as
// a slice of ValidationResult values.
// If the field is unknown or null, the boolean return value is false.
func (o *ValidateStorageCredentialResponse) GetResults(ctx context.Context) ([]ValidationResult, bool) {
	if o.Results.IsNull() || o.Results.IsUnknown() {
		return nil, false
	}
	var v []ValidationResult
	d := o.Results.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResults sets the value of the Results field in ValidateStorageCredentialResponse.
func (o *ValidateStorageCredentialResponse) SetResults(ctx context.Context, v []ValidationResult) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["results"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Results = types.ListValueMust(t, vs)
}

type ValidationResult struct {
	// Error message would exist when the result does not equal to **PASS**.
	Message types.String `tfsdk:"message"`
	// The operation tested.
	Operation types.String `tfsdk:"operation"`
	// The results of the tested operation.
	Result types.String `tfsdk:"result"`
}

func (toState *ValidationResult) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan ValidationResult) {
}

func (toState *ValidationResult) SyncFieldsDuringRead(ctx context.Context, fromState ValidationResult) {
}

func (c ValidationResult) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetOptional()
	attrs["operation"] = attrs["operation"].SetOptional()
	attrs["result"] = attrs["result"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidationResult.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ValidationResult) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidationResult
// only implements ToObjectValue() and Type().
func (o ValidationResult) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message":   o.Message,
			"operation": o.Operation,
			"result":    o.Result,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ValidationResult) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message":   types.StringType,
			"operation": types.StringType,
			"result":    types.StringType,
		},
	}
}

type VolumeInfo struct {
	// The AWS access point to use when accesing s3 for this external location.
	AccessPoint types.String `tfsdk:"access_point"`
	// Indicates whether the principal is limited to retrieving metadata for the
	// associated object through the BROWSE privilege when include_browse is
	// enabled in the request.
	BrowseOnly types.Bool `tfsdk:"browse_only"`
	// The name of the catalog where the schema and the volume are
	CatalogName types.String `tfsdk:"catalog_name"`
	// The comment attached to the volume
	Comment types.String `tfsdk:"comment"`

	CreatedAt types.Int64 `tfsdk:"created_at"`
	// The identifier of the user who created the volume
	CreatedBy types.String `tfsdk:"created_by"`

	EncryptionDetails types.Object `tfsdk:"encryption_details"`
	// The three-level (fully qualified) name of the volume
	FullName types.String `tfsdk:"full_name"`
	// The unique identifier of the metastore
	MetastoreId types.String `tfsdk:"metastore_id"`
	// The name of the volume
	Name types.String `tfsdk:"name"`
	// The identifier of the user who owns the volume
	Owner types.String `tfsdk:"owner"`
	// The name of the schema where the volume is
	SchemaName types.String `tfsdk:"schema_name"`
	// The storage location on the cloud
	StorageLocation types.String `tfsdk:"storage_location"`

	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// The identifier of the user who updated the volume last time
	UpdatedBy types.String `tfsdk:"updated_by"`
	// The unique identifier of the volume
	VolumeId types.String `tfsdk:"volume_id"`

	VolumeType types.String `tfsdk:"volume_type"`
}

func (toState *VolumeInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan VolumeInfo) {
	if !fromPlan.EncryptionDetails.IsNull() && !fromPlan.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromPlanEncryptionDetails, ok := fromPlan.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromPlanEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
}

func (toState *VolumeInfo) SyncFieldsDuringRead(ctx context.Context, fromState VolumeInfo) {
	if !fromState.EncryptionDetails.IsNull() && !fromState.EncryptionDetails.IsUnknown() {
		if toStateEncryptionDetails, ok := toState.GetEncryptionDetails(ctx); ok {
			if fromStateEncryptionDetails, ok := fromState.GetEncryptionDetails(ctx); ok {
				toStateEncryptionDetails.SyncFieldsDuringRead(ctx, fromStateEncryptionDetails)
				toState.SetEncryptionDetails(ctx, toStateEncryptionDetails)
			}
		}
	}
}

func (c VolumeInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_point"] = attrs["access_point"].SetOptional()
	attrs["browse_only"] = attrs["browse_only"].SetOptional()
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["comment"] = attrs["comment"].SetOptional()
	attrs["created_at"] = attrs["created_at"].SetOptional()
	attrs["created_by"] = attrs["created_by"].SetOptional()
	attrs["encryption_details"] = attrs["encryption_details"].SetOptional()
	attrs["full_name"] = attrs["full_name"].SetOptional()
	attrs["metastore_id"] = attrs["metastore_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["owner"] = attrs["owner"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()
	attrs["storage_location"] = attrs["storage_location"].SetOptional()
	attrs["updated_at"] = attrs["updated_at"].SetOptional()
	attrs["updated_by"] = attrs["updated_by"].SetOptional()
	attrs["volume_id"] = attrs["volume_id"].SetOptional()
	attrs["volume_type"] = attrs["volume_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in VolumeInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a VolumeInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"encryption_details": reflect.TypeOf(EncryptionDetails{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, VolumeInfo
// only implements ToObjectValue() and Type().
func (o VolumeInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_point":       o.AccessPoint,
			"browse_only":        o.BrowseOnly,
			"catalog_name":       o.CatalogName,
			"comment":            o.Comment,
			"created_at":         o.CreatedAt,
			"created_by":         o.CreatedBy,
			"encryption_details": o.EncryptionDetails,
			"full_name":          o.FullName,
			"metastore_id":       o.MetastoreId,
			"name":               o.Name,
			"owner":              o.Owner,
			"schema_name":        o.SchemaName,
			"storage_location":   o.StorageLocation,
			"updated_at":         o.UpdatedAt,
			"updated_by":         o.UpdatedBy,
			"volume_id":          o.VolumeId,
			"volume_type":        o.VolumeType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o VolumeInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_point":       types.StringType,
			"browse_only":        types.BoolType,
			"catalog_name":       types.StringType,
			"comment":            types.StringType,
			"created_at":         types.Int64Type,
			"created_by":         types.StringType,
			"encryption_details": EncryptionDetails{}.Type(ctx),
			"full_name":          types.StringType,
			"metastore_id":       types.StringType,
			"name":               types.StringType,
			"owner":              types.StringType,
			"schema_name":        types.StringType,
			"storage_location":   types.StringType,
			"updated_at":         types.Int64Type,
			"updated_by":         types.StringType,
			"volume_id":          types.StringType,
			"volume_type":        types.StringType,
		},
	}
}

// GetEncryptionDetails returns the value of the EncryptionDetails field in VolumeInfo as
// a EncryptionDetails value.
// If the field is unknown or null, the boolean return value is false.
func (o *VolumeInfo) GetEncryptionDetails(ctx context.Context) (EncryptionDetails, bool) {
	var e EncryptionDetails
	if o.EncryptionDetails.IsNull() || o.EncryptionDetails.IsUnknown() {
		return e, false
	}
	var v EncryptionDetails
	d := o.EncryptionDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEncryptionDetails sets the value of the EncryptionDetails field in VolumeInfo.
func (o *VolumeInfo) SetEncryptionDetails(ctx context.Context, v EncryptionDetails) {
	vs := v.ToObjectValue(ctx)
	o.EncryptionDetails = vs
}

type WorkspaceBinding struct {
	// One of READ_WRITE/READ_ONLY. Default is READ_WRITE.
	BindingType types.String `tfsdk:"binding_type"`
	// Required
	WorkspaceId types.Int64 `tfsdk:"workspace_id"`
}

func (toState *WorkspaceBinding) SyncFieldsDuringCreateOrUpdate(ctx context.Context, fromPlan WorkspaceBinding) {
}

func (toState *WorkspaceBinding) SyncFieldsDuringRead(ctx context.Context, fromState WorkspaceBinding) {
}

func (c WorkspaceBinding) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["binding_type"] = attrs["binding_type"].SetOptional()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WorkspaceBinding.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a WorkspaceBinding) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WorkspaceBinding
// only implements ToObjectValue() and Type().
func (o WorkspaceBinding) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"binding_type": o.BindingType,
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o WorkspaceBinding) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"binding_type": types.StringType,
			"workspace_id": types.Int64Type,
		},
	}
}
