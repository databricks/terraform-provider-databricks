// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package dashboards_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/databricks/terraform-provider-databricks/internal/service/sql_tf" // .tmpl
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type AuthorizationDetails struct {
	// Represents downscoped permission rules with specific access rights. This
	// field is specific to `workspace_rule_set` constraint.
	GrantRules types.List `tfsdk:"grant_rules"`
	// The acl path of the tree store resource resource.
	ResourceLegacyAclPath types.String `tfsdk:"resource_legacy_acl_path"`
	// The resource name to which the authorization rule applies. This field is
	// specific to `workspace_rule_set` constraint. Format:
	// `workspaces/{workspace_id}/dashboards/{dashboard_id}`
	ResourceName types.String `tfsdk:"resource_name"`
	// The type of authorization downscoping policy. Ex: `workspace_rule_set`
	// defines access rules for a specific workspace resource
	Type_ types.String `tfsdk:"type"`
}

func (to *AuthorizationDetails) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AuthorizationDetails) {
	if !from.GrantRules.IsNull() && !from.GrantRules.IsUnknown() && to.GrantRules.IsNull() && len(from.GrantRules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for GrantRules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.GrantRules = from.GrantRules
	}
}

func (to *AuthorizationDetails) SyncFieldsDuringRead(ctx context.Context, from AuthorizationDetails) {
	if !from.GrantRules.IsNull() && !from.GrantRules.IsUnknown() && to.GrantRules.IsNull() && len(from.GrantRules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for GrantRules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.GrantRules = from.GrantRules
	}
}

func (m AuthorizationDetails) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["grant_rules"] = attrs["grant_rules"].SetOptional()
	attrs["resource_legacy_acl_path"] = attrs["resource_legacy_acl_path"].SetOptional()
	attrs["resource_name"] = attrs["resource_name"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AuthorizationDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AuthorizationDetails) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"grant_rules": reflect.TypeOf(AuthorizationDetailsGrantRule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AuthorizationDetails
// only implements ToObjectValue() and Type().
func (m AuthorizationDetails) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"grant_rules":              m.GrantRules,
			"resource_legacy_acl_path": m.ResourceLegacyAclPath,
			"resource_name":            m.ResourceName,
			"type":                     m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AuthorizationDetails) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"grant_rules": basetypes.ListType{
				ElemType: AuthorizationDetailsGrantRule{}.Type(ctx),
			},
			"resource_legacy_acl_path": types.StringType,
			"resource_name":            types.StringType,
			"type":                     types.StringType,
		},
	}
}

// GetGrantRules returns the value of the GrantRules field in AuthorizationDetails as
// a slice of AuthorizationDetailsGrantRule values.
// If the field is unknown or null, the boolean return value is false.
func (m *AuthorizationDetails) GetGrantRules(ctx context.Context) ([]AuthorizationDetailsGrantRule, bool) {
	if m.GrantRules.IsNull() || m.GrantRules.IsUnknown() {
		return nil, false
	}
	var v []AuthorizationDetailsGrantRule
	d := m.GrantRules.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGrantRules sets the value of the GrantRules field in AuthorizationDetails.
func (m *AuthorizationDetails) SetGrantRules(ctx context.Context, v []AuthorizationDetailsGrantRule) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["grant_rules"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.GrantRules = types.ListValueMust(t, vs)
}

type AuthorizationDetailsGrantRule struct {
	// Permission sets for dashboard are defined in
	// iam-common/rbac-common/permission-sets/definitions/TreeStoreBasePermissionSets
	// Ex: `permissionSets/dashboard.runner`
	PermissionSet types.String `tfsdk:"permission_set"`
}

func (to *AuthorizationDetailsGrantRule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AuthorizationDetailsGrantRule) {
}

func (to *AuthorizationDetailsGrantRule) SyncFieldsDuringRead(ctx context.Context, from AuthorizationDetailsGrantRule) {
}

func (m AuthorizationDetailsGrantRule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permission_set"] = attrs["permission_set"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AuthorizationDetailsGrantRule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AuthorizationDetailsGrantRule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AuthorizationDetailsGrantRule
// only implements ToObjectValue() and Type().
func (m AuthorizationDetailsGrantRule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permission_set": m.PermissionSet,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AuthorizationDetailsGrantRule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permission_set": types.StringType,
		},
	}
}

type CreateDashboardRequest struct {
	Dashboard types.Object `tfsdk:"dashboard"`
}

func (to *CreateDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateDashboardRequest) {
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				// Recursively sync the fields of Dashboard
				toDashboard.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
}

func (to *CreateDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from CreateDashboardRequest) {
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				toDashboard.SyncFieldsDuringRead(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
}

func (m CreateDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard"] = attrs["dashboard"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dashboard": reflect.TypeOf(Dashboard{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateDashboardRequest
// only implements ToObjectValue() and Type().
func (m CreateDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard": m.Dashboard,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard": Dashboard{}.Type(ctx),
		},
	}
}

// GetDashboard returns the value of the Dashboard field in CreateDashboardRequest as
// a Dashboard value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateDashboardRequest) GetDashboard(ctx context.Context) (Dashboard, bool) {
	var e Dashboard
	if m.Dashboard.IsNull() || m.Dashboard.IsUnknown() {
		return e, false
	}
	var v Dashboard
	d := m.Dashboard.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboard sets the value of the Dashboard field in CreateDashboardRequest.
func (m *CreateDashboardRequest) SetDashboard(ctx context.Context, v Dashboard) {
	vs := v.ToObjectValue(ctx)
	m.Dashboard = vs
}

type CreateScheduleRequest struct {
	// UUID identifying the dashboard to which the schedule belongs.
	DashboardId types.String `tfsdk:"-"`
	// The schedule to create. A dashboard is limited to 10 schedules.
	Schedule types.Object `tfsdk:"schedule"`
}

func (to *CreateScheduleRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateScheduleRequest) {
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
}

func (to *CreateScheduleRequest) SyncFieldsDuringRead(ctx context.Context, from CreateScheduleRequest) {
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
}

func (m CreateScheduleRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["schedule"] = attrs["schedule"].SetRequired()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateScheduleRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateScheduleRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schedule": reflect.TypeOf(Schedule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateScheduleRequest
// only implements ToObjectValue() and Type().
func (m CreateScheduleRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"schedule":     m.Schedule,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateScheduleRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"schedule":     Schedule{}.Type(ctx),
		},
	}
}

// GetSchedule returns the value of the Schedule field in CreateScheduleRequest as
// a Schedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateScheduleRequest) GetSchedule(ctx context.Context) (Schedule, bool) {
	var e Schedule
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v Schedule
	d := m.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in CreateScheduleRequest.
func (m *CreateScheduleRequest) SetSchedule(ctx context.Context, v Schedule) {
	vs := v.ToObjectValue(ctx)
	m.Schedule = vs
}

type CreateSubscriptionRequest struct {
	// UUID identifying the dashboard to which the subscription belongs.
	DashboardId types.String `tfsdk:"-"`
	// UUID identifying the schedule to which the subscription belongs.
	ScheduleId types.String `tfsdk:"-"`
	// The subscription to create. A schedule is limited to 100 subscriptions.
	Subscription types.Object `tfsdk:"subscription"`
}

func (to *CreateSubscriptionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateSubscriptionRequest) {
	if !from.Subscription.IsNull() && !from.Subscription.IsUnknown() {
		if toSubscription, ok := to.GetSubscription(ctx); ok {
			if fromSubscription, ok := from.GetSubscription(ctx); ok {
				// Recursively sync the fields of Subscription
				toSubscription.SyncFieldsDuringCreateOrUpdate(ctx, fromSubscription)
				to.SetSubscription(ctx, toSubscription)
			}
		}
	}
}

func (to *CreateSubscriptionRequest) SyncFieldsDuringRead(ctx context.Context, from CreateSubscriptionRequest) {
	if !from.Subscription.IsNull() && !from.Subscription.IsUnknown() {
		if toSubscription, ok := to.GetSubscription(ctx); ok {
			if fromSubscription, ok := from.GetSubscription(ctx); ok {
				toSubscription.SyncFieldsDuringRead(ctx, fromSubscription)
				to.SetSubscription(ctx, toSubscription)
			}
		}
	}
}

func (m CreateSubscriptionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["subscription"] = attrs["subscription"].SetRequired()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["schedule_id"] = attrs["schedule_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateSubscriptionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateSubscriptionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscription": reflect.TypeOf(Subscription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateSubscriptionRequest
// only implements ToObjectValue() and Type().
func (m CreateSubscriptionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"schedule_id":  m.ScheduleId,
			"subscription": m.Subscription,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateSubscriptionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"schedule_id":  types.StringType,
			"subscription": Subscription{}.Type(ctx),
		},
	}
}

// GetSubscription returns the value of the Subscription field in CreateSubscriptionRequest as
// a Subscription value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateSubscriptionRequest) GetSubscription(ctx context.Context) (Subscription, bool) {
	var e Subscription
	if m.Subscription.IsNull() || m.Subscription.IsUnknown() {
		return e, false
	}
	var v Subscription
	d := m.Subscription.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscription sets the value of the Subscription field in CreateSubscriptionRequest.
func (m *CreateSubscriptionRequest) SetSubscription(ctx context.Context, v Subscription) {
	vs := v.ToObjectValue(ctx)
	m.Subscription = vs
}

type CronSchedule struct {
	// A cron expression using quartz syntax. EX: `0 0 8 * * ?` represents
	// everyday at 8am. See [Cron Trigger] for details.
	//
	// [Cron Trigger]: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html
	QuartzCronExpression types.String `tfsdk:"quartz_cron_expression"`
	// A Java timezone id. The schedule will be resolved with respect to this
	// timezone. See [Java TimeZone] for details.
	//
	// [Java TimeZone]: https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html
	TimezoneId types.String `tfsdk:"timezone_id"`
}

func (to *CronSchedule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CronSchedule) {
}

func (to *CronSchedule) SyncFieldsDuringRead(ctx context.Context, from CronSchedule) {
}

func (m CronSchedule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["quartz_cron_expression"] = attrs["quartz_cron_expression"].SetRequired()
	attrs["timezone_id"] = attrs["timezone_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CronSchedule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CronSchedule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CronSchedule
// only implements ToObjectValue() and Type().
func (m CronSchedule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"quartz_cron_expression": m.QuartzCronExpression,
			"timezone_id":            m.TimezoneId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CronSchedule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"quartz_cron_expression": types.StringType,
			"timezone_id":            types.StringType,
		},
	}
}

type Dashboard struct {
	// The timestamp of when the dashboard was created.
	CreateTime types.String `tfsdk:"create_time"`
	// UUID identifying the dashboard.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// The display name of the dashboard.
	DisplayName types.String `tfsdk:"display_name"`
	// The etag for the dashboard. Can be optionally provided on updates to
	// ensure that the dashboard has not been modified since the last read. This
	// field is excluded in List Dashboards responses.
	Etag types.String `tfsdk:"etag"`
	// The state of the dashboard resource. Used for tracking trashed status.
	LifecycleState types.String `tfsdk:"lifecycle_state"`
	// The workspace path of the folder containing the dashboard. Includes
	// leading slash and no trailing slash. This field is excluded in List
	// Dashboards responses.
	ParentPath types.String `tfsdk:"parent_path"`
	// The workspace path of the dashboard asset, including the file name.
	// Exported dashboards always have the file extension `.lvdash.json`. This
	// field is excluded in List Dashboards responses.
	Path types.String `tfsdk:"path"`
	// The contents of the dashboard in serialized string form. This field is
	// excluded in List Dashboards responses. Use the [get dashboard API] to
	// retrieve an example response, which includes the `serialized_dashboard`
	// field. This field provides the structure of the JSON string that
	// represents the dashboard's layout and components.
	//
	// [get dashboard API]: https://docs.databricks.com/api/workspace/lakeview/get
	SerializedDashboard types.String `tfsdk:"serialized_dashboard"`
	// The timestamp of when the dashboard was last updated by the user. This
	// field is excluded in List Dashboards responses.
	UpdateTime types.String `tfsdk:"update_time"`
	// The warehouse ID used to run the dashboard.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *Dashboard) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Dashboard) {
}

func (to *Dashboard) SyncFieldsDuringRead(ctx context.Context, from Dashboard) {
}

func (m Dashboard) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["create_time"] = attrs["create_time"].SetComputed()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["etag"] = attrs["etag"].SetComputed()
	attrs["lifecycle_state"] = attrs["lifecycle_state"].SetComputed()
	attrs["parent_path"] = attrs["parent_path"].SetComputed()
	attrs["parent_path"] = attrs["parent_path"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["path"] = attrs["path"].SetComputed()
	attrs["serialized_dashboard"] = attrs["serialized_dashboard"].SetOptional()
	attrs["update_time"] = attrs["update_time"].SetComputed()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Dashboard.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Dashboard) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Dashboard
// only implements ToObjectValue() and Type().
func (m Dashboard) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"create_time":          m.CreateTime,
			"dashboard_id":         m.DashboardId,
			"display_name":         m.DisplayName,
			"etag":                 m.Etag,
			"lifecycle_state":      m.LifecycleState,
			"parent_path":          m.ParentPath,
			"path":                 m.Path,
			"serialized_dashboard": m.SerializedDashboard,
			"update_time":          m.UpdateTime,
			"warehouse_id":         m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Dashboard) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"create_time":          types.StringType,
			"dashboard_id":         types.StringType,
			"display_name":         types.StringType,
			"etag":                 types.StringType,
			"lifecycle_state":      types.StringType,
			"parent_path":          types.StringType,
			"path":                 types.StringType,
			"serialized_dashboard": types.StringType,
			"update_time":          types.StringType,
			"warehouse_id":         types.StringType,
		},
	}
}

type DeleteScheduleRequest struct {
	// UUID identifying the dashboard to which the schedule belongs.
	DashboardId types.String `tfsdk:"-"`
	// The etag for the schedule. Optionally, it can be provided to verify that
	// the schedule has not been modified from its last retrieval.
	Etag types.String `tfsdk:"-"`
	// UUID identifying the schedule.
	ScheduleId types.String `tfsdk:"-"`
}

func (to *DeleteScheduleRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteScheduleRequest) {
}

func (to *DeleteScheduleRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteScheduleRequest) {
}

func (m DeleteScheduleRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["schedule_id"] = attrs["schedule_id"].SetRequired()
	attrs["etag"] = attrs["etag"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteScheduleRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteScheduleRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteScheduleRequest
// only implements ToObjectValue() and Type().
func (m DeleteScheduleRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"etag":         m.Etag,
			"schedule_id":  m.ScheduleId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteScheduleRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"etag":         types.StringType,
			"schedule_id":  types.StringType,
		},
	}
}

type DeleteSubscriptionRequest struct {
	// UUID identifying the dashboard which the subscription belongs.
	DashboardId types.String `tfsdk:"-"`
	// The etag for the subscription. Can be optionally provided to ensure that
	// the subscription has not been modified since the last read.
	Etag types.String `tfsdk:"-"`
	// UUID identifying the schedule which the subscription belongs.
	ScheduleId types.String `tfsdk:"-"`
	// UUID identifying the subscription.
	SubscriptionId types.String `tfsdk:"-"`
}

func (to *DeleteSubscriptionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteSubscriptionRequest) {
}

func (to *DeleteSubscriptionRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteSubscriptionRequest) {
}

func (m DeleteSubscriptionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["schedule_id"] = attrs["schedule_id"].SetRequired()
	attrs["subscription_id"] = attrs["subscription_id"].SetRequired()
	attrs["etag"] = attrs["etag"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteSubscriptionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteSubscriptionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteSubscriptionRequest
// only implements ToObjectValue() and Type().
func (m DeleteSubscriptionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id":    m.DashboardId,
			"etag":            m.Etag,
			"schedule_id":     m.ScheduleId,
			"subscription_id": m.SubscriptionId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteSubscriptionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id":    types.StringType,
			"etag":            types.StringType,
			"schedule_id":     types.StringType,
			"subscription_id": types.StringType,
		},
	}
}

// Genie AI Response
type GenieAttachment struct {
	// Attachment ID
	AttachmentId types.String `tfsdk:"attachment_id"`
	// Query Attachment if Genie responds with a SQL query
	Query types.Object `tfsdk:"query"`
	// Follow-up questions suggested by Genie
	SuggestedQuestions types.Object `tfsdk:"suggested_questions"`
	// Text Attachment if Genie responds with text
	Text types.Object `tfsdk:"text"`
}

func (to *GenieAttachment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieAttachment) {
	if !from.Query.IsNull() && !from.Query.IsUnknown() {
		if toQuery, ok := to.GetQuery(ctx); ok {
			if fromQuery, ok := from.GetQuery(ctx); ok {
				// Recursively sync the fields of Query
				toQuery.SyncFieldsDuringCreateOrUpdate(ctx, fromQuery)
				to.SetQuery(ctx, toQuery)
			}
		}
	}
	if !from.SuggestedQuestions.IsNull() && !from.SuggestedQuestions.IsUnknown() {
		if toSuggestedQuestions, ok := to.GetSuggestedQuestions(ctx); ok {
			if fromSuggestedQuestions, ok := from.GetSuggestedQuestions(ctx); ok {
				// Recursively sync the fields of SuggestedQuestions
				toSuggestedQuestions.SyncFieldsDuringCreateOrUpdate(ctx, fromSuggestedQuestions)
				to.SetSuggestedQuestions(ctx, toSuggestedQuestions)
			}
		}
	}
	if !from.Text.IsNull() && !from.Text.IsUnknown() {
		if toText, ok := to.GetText(ctx); ok {
			if fromText, ok := from.GetText(ctx); ok {
				// Recursively sync the fields of Text
				toText.SyncFieldsDuringCreateOrUpdate(ctx, fromText)
				to.SetText(ctx, toText)
			}
		}
	}
}

func (to *GenieAttachment) SyncFieldsDuringRead(ctx context.Context, from GenieAttachment) {
	if !from.Query.IsNull() && !from.Query.IsUnknown() {
		if toQuery, ok := to.GetQuery(ctx); ok {
			if fromQuery, ok := from.GetQuery(ctx); ok {
				toQuery.SyncFieldsDuringRead(ctx, fromQuery)
				to.SetQuery(ctx, toQuery)
			}
		}
	}
	if !from.SuggestedQuestions.IsNull() && !from.SuggestedQuestions.IsUnknown() {
		if toSuggestedQuestions, ok := to.GetSuggestedQuestions(ctx); ok {
			if fromSuggestedQuestions, ok := from.GetSuggestedQuestions(ctx); ok {
				toSuggestedQuestions.SyncFieldsDuringRead(ctx, fromSuggestedQuestions)
				to.SetSuggestedQuestions(ctx, toSuggestedQuestions)
			}
		}
	}
	if !from.Text.IsNull() && !from.Text.IsUnknown() {
		if toText, ok := to.GetText(ctx); ok {
			if fromText, ok := from.GetText(ctx); ok {
				toText.SyncFieldsDuringRead(ctx, fromText)
				to.SetText(ctx, toText)
			}
		}
	}
}

func (m GenieAttachment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attachment_id"] = attrs["attachment_id"].SetOptional()
	attrs["query"] = attrs["query"].SetOptional()
	attrs["suggested_questions"] = attrs["suggested_questions"].SetOptional()
	attrs["text"] = attrs["text"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieAttachment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieAttachment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"query":               reflect.TypeOf(GenieQueryAttachment{}),
		"suggested_questions": reflect.TypeOf(GenieSuggestedQuestionsAttachment{}),
		"text":                reflect.TypeOf(TextAttachment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieAttachment
// only implements ToObjectValue() and Type().
func (m GenieAttachment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attachment_id":       m.AttachmentId,
			"query":               m.Query,
			"suggested_questions": m.SuggestedQuestions,
			"text":                m.Text,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieAttachment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attachment_id":       types.StringType,
			"query":               GenieQueryAttachment{}.Type(ctx),
			"suggested_questions": GenieSuggestedQuestionsAttachment{}.Type(ctx),
			"text":                TextAttachment{}.Type(ctx),
		},
	}
}

// GetQuery returns the value of the Query field in GenieAttachment as
// a GenieQueryAttachment value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieAttachment) GetQuery(ctx context.Context) (GenieQueryAttachment, bool) {
	var e GenieQueryAttachment
	if m.Query.IsNull() || m.Query.IsUnknown() {
		return e, false
	}
	var v GenieQueryAttachment
	d := m.Query.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQuery sets the value of the Query field in GenieAttachment.
func (m *GenieAttachment) SetQuery(ctx context.Context, v GenieQueryAttachment) {
	vs := v.ToObjectValue(ctx)
	m.Query = vs
}

// GetSuggestedQuestions returns the value of the SuggestedQuestions field in GenieAttachment as
// a GenieSuggestedQuestionsAttachment value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieAttachment) GetSuggestedQuestions(ctx context.Context) (GenieSuggestedQuestionsAttachment, bool) {
	var e GenieSuggestedQuestionsAttachment
	if m.SuggestedQuestions.IsNull() || m.SuggestedQuestions.IsUnknown() {
		return e, false
	}
	var v GenieSuggestedQuestionsAttachment
	d := m.SuggestedQuestions.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSuggestedQuestions sets the value of the SuggestedQuestions field in GenieAttachment.
func (m *GenieAttachment) SetSuggestedQuestions(ctx context.Context, v GenieSuggestedQuestionsAttachment) {
	vs := v.ToObjectValue(ctx)
	m.SuggestedQuestions = vs
}

// GetText returns the value of the Text field in GenieAttachment as
// a TextAttachment value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieAttachment) GetText(ctx context.Context) (TextAttachment, bool) {
	var e TextAttachment
	if m.Text.IsNull() || m.Text.IsUnknown() {
		return e, false
	}
	var v TextAttachment
	d := m.Text.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetText sets the value of the Text field in GenieAttachment.
func (m *GenieAttachment) SetText(ctx context.Context, v TextAttachment) {
	vs := v.ToObjectValue(ctx)
	m.Text = vs
}

type GenieConversation struct {
	// Conversation ID
	ConversationId types.String `tfsdk:"conversation_id"`
	// Timestamp when the message was created
	CreatedTimestamp types.Int64 `tfsdk:"created_timestamp"`
	// Conversation ID. Legacy identifier, use conversation_id instead
	Id types.String `tfsdk:"id"`
	// Timestamp when the message was last updated
	LastUpdatedTimestamp types.Int64 `tfsdk:"last_updated_timestamp"`
	// Genie space ID
	SpaceId types.String `tfsdk:"space_id"`
	// Conversation title
	Title types.String `tfsdk:"title"`
	// ID of the user who created the conversation
	UserId types.Int64 `tfsdk:"user_id"`
}

func (to *GenieConversation) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieConversation) {
}

func (to *GenieConversation) SyncFieldsDuringRead(ctx context.Context, from GenieConversation) {
}

func (m GenieConversation) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["created_timestamp"] = attrs["created_timestamp"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()
	attrs["last_updated_timestamp"] = attrs["last_updated_timestamp"].SetOptional()
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["title"] = attrs["title"].SetRequired()
	attrs["user_id"] = attrs["user_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieConversation.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieConversation) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieConversation
// only implements ToObjectValue() and Type().
func (m GenieConversation) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id":        m.ConversationId,
			"created_timestamp":      m.CreatedTimestamp,
			"id":                     m.Id,
			"last_updated_timestamp": m.LastUpdatedTimestamp,
			"space_id":               m.SpaceId,
			"title":                  m.Title,
			"user_id":                m.UserId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieConversation) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id":        types.StringType,
			"created_timestamp":      types.Int64Type,
			"id":                     types.StringType,
			"last_updated_timestamp": types.Int64Type,
			"space_id":               types.StringType,
			"title":                  types.StringType,
			"user_id":                types.Int64Type,
		},
	}
}

type GenieConversationSummary struct {
	ConversationId types.String `tfsdk:"conversation_id"`

	CreatedTimestamp types.Int64 `tfsdk:"created_timestamp"`

	Title types.String `tfsdk:"title"`
}

func (to *GenieConversationSummary) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieConversationSummary) {
}

func (to *GenieConversationSummary) SyncFieldsDuringRead(ctx context.Context, from GenieConversationSummary) {
}

func (m GenieConversationSummary) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["created_timestamp"] = attrs["created_timestamp"].SetRequired()
	attrs["title"] = attrs["title"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieConversationSummary.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieConversationSummary) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieConversationSummary
// only implements ToObjectValue() and Type().
func (m GenieConversationSummary) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id":   m.ConversationId,
			"created_timestamp": m.CreatedTimestamp,
			"title":             m.Title,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieConversationSummary) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id":   types.StringType,
			"created_timestamp": types.Int64Type,
			"title":             types.StringType,
		},
	}
}

type GenieCreateConversationMessageRequest struct {
	// User message content.
	Content types.String `tfsdk:"content"`
	// The ID associated with the conversation.
	ConversationId types.String `tfsdk:"-"`
	// The ID associated with the Genie space where the conversation is started.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieCreateConversationMessageRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieCreateConversationMessageRequest) {
}

func (to *GenieCreateConversationMessageRequest) SyncFieldsDuringRead(ctx context.Context, from GenieCreateConversationMessageRequest) {
}

func (m GenieCreateConversationMessageRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["content"] = attrs["content"].SetRequired()
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieCreateConversationMessageRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieCreateConversationMessageRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieCreateConversationMessageRequest
// only implements ToObjectValue() and Type().
func (m GenieCreateConversationMessageRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"content":         m.Content,
			"conversation_id": m.ConversationId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieCreateConversationMessageRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"content":         types.StringType,
			"conversation_id": types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieDeleteConversationMessageRequest struct {
	// The ID associated with the conversation.
	ConversationId types.String `tfsdk:"-"`
	// The ID associated with the message to delete.
	MessageId types.String `tfsdk:"-"`
	// The ID associated with the Genie space where the message is located.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieDeleteConversationMessageRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieDeleteConversationMessageRequest) {
}

func (to *GenieDeleteConversationMessageRequest) SyncFieldsDuringRead(ctx context.Context, from GenieDeleteConversationMessageRequest) {
}

func (m GenieDeleteConversationMessageRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieDeleteConversationMessageRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieDeleteConversationMessageRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieDeleteConversationMessageRequest
// only implements ToObjectValue() and Type().
func (m GenieDeleteConversationMessageRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieDeleteConversationMessageRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieDeleteConversationRequest struct {
	// The ID of the conversation to delete.
	ConversationId types.String `tfsdk:"-"`
	// The ID associated with the Genie space where the conversation is located.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieDeleteConversationRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieDeleteConversationRequest) {
}

func (to *GenieDeleteConversationRequest) SyncFieldsDuringRead(ctx context.Context, from GenieDeleteConversationRequest) {
}

func (m GenieDeleteConversationRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieDeleteConversationRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieDeleteConversationRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieDeleteConversationRequest
// only implements ToObjectValue() and Type().
func (m GenieDeleteConversationRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieDeleteConversationRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieExecuteMessageAttachmentQueryRequest struct {
	// Attachment ID
	AttachmentId types.String `tfsdk:"-"`
	// Conversation ID
	ConversationId types.String `tfsdk:"-"`
	// Message ID
	MessageId types.String `tfsdk:"-"`
	// Genie space ID
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieExecuteMessageAttachmentQueryRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieExecuteMessageAttachmentQueryRequest) {
}

func (to *GenieExecuteMessageAttachmentQueryRequest) SyncFieldsDuringRead(ctx context.Context, from GenieExecuteMessageAttachmentQueryRequest) {
}

func (m GenieExecuteMessageAttachmentQueryRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()
	attrs["attachment_id"] = attrs["attachment_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieExecuteMessageAttachmentQueryRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieExecuteMessageAttachmentQueryRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieExecuteMessageAttachmentQueryRequest
// only implements ToObjectValue() and Type().
func (m GenieExecuteMessageAttachmentQueryRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attachment_id":   m.AttachmentId,
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieExecuteMessageAttachmentQueryRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attachment_id":   types.StringType,
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieExecuteMessageQueryRequest struct {
	// Conversation ID
	ConversationId types.String `tfsdk:"-"`
	// Message ID
	MessageId types.String `tfsdk:"-"`
	// Genie space ID
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieExecuteMessageQueryRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieExecuteMessageQueryRequest) {
}

func (to *GenieExecuteMessageQueryRequest) SyncFieldsDuringRead(ctx context.Context, from GenieExecuteMessageQueryRequest) {
}

func (m GenieExecuteMessageQueryRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieExecuteMessageQueryRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieExecuteMessageQueryRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieExecuteMessageQueryRequest
// only implements ToObjectValue() and Type().
func (m GenieExecuteMessageQueryRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieExecuteMessageQueryRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

// Feedback containing rating and optional comment
type GenieFeedback struct {
	// The feedback rating
	Rating types.String `tfsdk:"rating"`
}

func (to *GenieFeedback) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieFeedback) {
}

func (to *GenieFeedback) SyncFieldsDuringRead(ctx context.Context, from GenieFeedback) {
}

func (m GenieFeedback) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["rating"] = attrs["rating"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieFeedback.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieFeedback) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieFeedback
// only implements ToObjectValue() and Type().
func (m GenieFeedback) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"rating": m.Rating,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieFeedback) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"rating": types.StringType,
		},
	}
}

type GenieGetConversationMessageRequest struct {
	// The ID associated with the target conversation.
	ConversationId types.String `tfsdk:"-"`
	// The ID associated with the target message from the identified
	// conversation.
	MessageId types.String `tfsdk:"-"`
	// The ID associated with the Genie space where the target conversation is
	// located.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieGetConversationMessageRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieGetConversationMessageRequest) {
}

func (to *GenieGetConversationMessageRequest) SyncFieldsDuringRead(ctx context.Context, from GenieGetConversationMessageRequest) {
}

func (m GenieGetConversationMessageRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieGetConversationMessageRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieGetConversationMessageRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieGetConversationMessageRequest
// only implements ToObjectValue() and Type().
func (m GenieGetConversationMessageRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieGetConversationMessageRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieGetMessageAttachmentQueryResultRequest struct {
	// Attachment ID
	AttachmentId types.String `tfsdk:"-"`
	// Conversation ID
	ConversationId types.String `tfsdk:"-"`
	// Message ID
	MessageId types.String `tfsdk:"-"`
	// Genie space ID
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieGetMessageAttachmentQueryResultRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieGetMessageAttachmentQueryResultRequest) {
}

func (to *GenieGetMessageAttachmentQueryResultRequest) SyncFieldsDuringRead(ctx context.Context, from GenieGetMessageAttachmentQueryResultRequest) {
}

func (m GenieGetMessageAttachmentQueryResultRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()
	attrs["attachment_id"] = attrs["attachment_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieGetMessageAttachmentQueryResultRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieGetMessageAttachmentQueryResultRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieGetMessageAttachmentQueryResultRequest
// only implements ToObjectValue() and Type().
func (m GenieGetMessageAttachmentQueryResultRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attachment_id":   m.AttachmentId,
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieGetMessageAttachmentQueryResultRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attachment_id":   types.StringType,
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieGetMessageQueryResultRequest struct {
	// Conversation ID
	ConversationId types.String `tfsdk:"-"`
	// Message ID
	MessageId types.String `tfsdk:"-"`
	// Genie space ID
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieGetMessageQueryResultRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieGetMessageQueryResultRequest) {
}

func (to *GenieGetMessageQueryResultRequest) SyncFieldsDuringRead(ctx context.Context, from GenieGetMessageQueryResultRequest) {
}

func (m GenieGetMessageQueryResultRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieGetMessageQueryResultRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieGetMessageQueryResultRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieGetMessageQueryResultRequest
// only implements ToObjectValue() and Type().
func (m GenieGetMessageQueryResultRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieGetMessageQueryResultRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieGetMessageQueryResultResponse struct {
	// SQL Statement Execution response. See [Get status, manifest, and result
	// first chunk](:method:statementexecution/getstatement) for more details.
	StatementResponse types.Object `tfsdk:"statement_response"`
}

func (to *GenieGetMessageQueryResultResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieGetMessageQueryResultResponse) {
	if !from.StatementResponse.IsNull() && !from.StatementResponse.IsUnknown() {
		if toStatementResponse, ok := to.GetStatementResponse(ctx); ok {
			if fromStatementResponse, ok := from.GetStatementResponse(ctx); ok {
				// Recursively sync the fields of StatementResponse
				toStatementResponse.SyncFieldsDuringCreateOrUpdate(ctx, fromStatementResponse)
				to.SetStatementResponse(ctx, toStatementResponse)
			}
		}
	}
}

func (to *GenieGetMessageQueryResultResponse) SyncFieldsDuringRead(ctx context.Context, from GenieGetMessageQueryResultResponse) {
	if !from.StatementResponse.IsNull() && !from.StatementResponse.IsUnknown() {
		if toStatementResponse, ok := to.GetStatementResponse(ctx); ok {
			if fromStatementResponse, ok := from.GetStatementResponse(ctx); ok {
				toStatementResponse.SyncFieldsDuringRead(ctx, fromStatementResponse)
				to.SetStatementResponse(ctx, toStatementResponse)
			}
		}
	}
}

func (m GenieGetMessageQueryResultResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["statement_response"] = attrs["statement_response"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieGetMessageQueryResultResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieGetMessageQueryResultResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"statement_response": reflect.TypeOf(sql_tf.StatementResponse{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieGetMessageQueryResultResponse
// only implements ToObjectValue() and Type().
func (m GenieGetMessageQueryResultResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"statement_response": m.StatementResponse,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieGetMessageQueryResultResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"statement_response": sql_tf.StatementResponse{}.Type(ctx),
		},
	}
}

// GetStatementResponse returns the value of the StatementResponse field in GenieGetMessageQueryResultResponse as
// a sql_tf.StatementResponse value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieGetMessageQueryResultResponse) GetStatementResponse(ctx context.Context) (sql_tf.StatementResponse, bool) {
	var e sql_tf.StatementResponse
	if m.StatementResponse.IsNull() || m.StatementResponse.IsUnknown() {
		return e, false
	}
	var v sql_tf.StatementResponse
	d := m.StatementResponse.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStatementResponse sets the value of the StatementResponse field in GenieGetMessageQueryResultResponse.
func (m *GenieGetMessageQueryResultResponse) SetStatementResponse(ctx context.Context, v sql_tf.StatementResponse) {
	vs := v.ToObjectValue(ctx)
	m.StatementResponse = vs
}

type GenieGetQueryResultByAttachmentRequest struct {
	// Attachment ID
	AttachmentId types.String `tfsdk:"-"`
	// Conversation ID
	ConversationId types.String `tfsdk:"-"`
	// Message ID
	MessageId types.String `tfsdk:"-"`
	// Genie space ID
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieGetQueryResultByAttachmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieGetQueryResultByAttachmentRequest) {
}

func (to *GenieGetQueryResultByAttachmentRequest) SyncFieldsDuringRead(ctx context.Context, from GenieGetQueryResultByAttachmentRequest) {
}

func (m GenieGetQueryResultByAttachmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()
	attrs["attachment_id"] = attrs["attachment_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieGetQueryResultByAttachmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieGetQueryResultByAttachmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieGetQueryResultByAttachmentRequest
// only implements ToObjectValue() and Type().
func (m GenieGetQueryResultByAttachmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attachment_id":   m.AttachmentId,
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieGetQueryResultByAttachmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attachment_id":   types.StringType,
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieGetSpaceRequest struct {
	// The ID associated with the Genie space
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieGetSpaceRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieGetSpaceRequest) {
}

func (to *GenieGetSpaceRequest) SyncFieldsDuringRead(ctx context.Context, from GenieGetSpaceRequest) {
}

func (m GenieGetSpaceRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieGetSpaceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieGetSpaceRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieGetSpaceRequest
// only implements ToObjectValue() and Type().
func (m GenieGetSpaceRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"space_id": m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieGetSpaceRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"space_id": types.StringType,
		},
	}
}

type GenieListConversationMessagesRequest struct {
	// The ID of the conversation to list messages from
	ConversationId types.String `tfsdk:"-"`
	// Maximum number of messages to return per page
	PageSize types.Int64 `tfsdk:"-"`
	// Token to get the next page of results
	PageToken types.String `tfsdk:"-"`
	// The ID associated with the Genie space where the conversation is located
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieListConversationMessagesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieListConversationMessagesRequest) {
}

func (to *GenieListConversationMessagesRequest) SyncFieldsDuringRead(ctx context.Context, from GenieListConversationMessagesRequest) {
}

func (m GenieListConversationMessagesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieListConversationMessagesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieListConversationMessagesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieListConversationMessagesRequest
// only implements ToObjectValue() and Type().
func (m GenieListConversationMessagesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"page_size":       m.PageSize,
			"page_token":      m.PageToken,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieListConversationMessagesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"page_size":       types.Int64Type,
			"page_token":      types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieListConversationMessagesResponse struct {
	// List of messages in the conversation.
	Messages types.List `tfsdk:"messages"`
	// The token to use for retrieving the next page of results.
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *GenieListConversationMessagesResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieListConversationMessagesResponse) {
	if !from.Messages.IsNull() && !from.Messages.IsUnknown() && to.Messages.IsNull() && len(from.Messages.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Messages, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Messages = from.Messages
	}
}

func (to *GenieListConversationMessagesResponse) SyncFieldsDuringRead(ctx context.Context, from GenieListConversationMessagesResponse) {
	if !from.Messages.IsNull() && !from.Messages.IsUnknown() && to.Messages.IsNull() && len(from.Messages.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Messages, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Messages = from.Messages
	}
}

func (m GenieListConversationMessagesResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["messages"] = attrs["messages"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieListConversationMessagesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieListConversationMessagesResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"messages": reflect.TypeOf(GenieMessage{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieListConversationMessagesResponse
// only implements ToObjectValue() and Type().
func (m GenieListConversationMessagesResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"messages":        m.Messages,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieListConversationMessagesResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"messages": basetypes.ListType{
				ElemType: GenieMessage{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetMessages returns the value of the Messages field in GenieListConversationMessagesResponse as
// a slice of GenieMessage values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieListConversationMessagesResponse) GetMessages(ctx context.Context) ([]GenieMessage, bool) {
	if m.Messages.IsNull() || m.Messages.IsUnknown() {
		return nil, false
	}
	var v []GenieMessage
	d := m.Messages.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMessages sets the value of the Messages field in GenieListConversationMessagesResponse.
func (m *GenieListConversationMessagesResponse) SetMessages(ctx context.Context, v []GenieMessage) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["messages"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Messages = types.ListValueMust(t, vs)
}

type GenieListConversationsRequest struct {
	// Include all conversations in the space across all users. Requires at
	// least CAN MANAGE permission on the space.
	IncludeAll types.Bool `tfsdk:"-"`
	// Maximum number of conversations to return per page
	PageSize types.Int64 `tfsdk:"-"`
	// Token to get the next page of results
	PageToken types.String `tfsdk:"-"`
	// The ID of the Genie space to retrieve conversations from.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieListConversationsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieListConversationsRequest) {
}

func (to *GenieListConversationsRequest) SyncFieldsDuringRead(ctx context.Context, from GenieListConversationsRequest) {
}

func (m GenieListConversationsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["include_all"] = attrs["include_all"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieListConversationsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieListConversationsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieListConversationsRequest
// only implements ToObjectValue() and Type().
func (m GenieListConversationsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_all": m.IncludeAll,
			"page_size":   m.PageSize,
			"page_token":  m.PageToken,
			"space_id":    m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieListConversationsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_all": types.BoolType,
			"page_size":   types.Int64Type,
			"page_token":  types.StringType,
			"space_id":    types.StringType,
		},
	}
}

type GenieListConversationsResponse struct {
	// List of conversations in the Genie space
	Conversations types.List `tfsdk:"conversations"`
	// Token to get the next page of results
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *GenieListConversationsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieListConversationsResponse) {
	if !from.Conversations.IsNull() && !from.Conversations.IsUnknown() && to.Conversations.IsNull() && len(from.Conversations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Conversations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Conversations = from.Conversations
	}
}

func (to *GenieListConversationsResponse) SyncFieldsDuringRead(ctx context.Context, from GenieListConversationsResponse) {
	if !from.Conversations.IsNull() && !from.Conversations.IsUnknown() && to.Conversations.IsNull() && len(from.Conversations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Conversations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Conversations = from.Conversations
	}
}

func (m GenieListConversationsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["conversations"] = attrs["conversations"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieListConversationsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieListConversationsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"conversations": reflect.TypeOf(GenieConversationSummary{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieListConversationsResponse
// only implements ToObjectValue() and Type().
func (m GenieListConversationsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversations":   m.Conversations,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieListConversationsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversations": basetypes.ListType{
				ElemType: GenieConversationSummary{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetConversations returns the value of the Conversations field in GenieListConversationsResponse as
// a slice of GenieConversationSummary values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieListConversationsResponse) GetConversations(ctx context.Context) ([]GenieConversationSummary, bool) {
	if m.Conversations.IsNull() || m.Conversations.IsUnknown() {
		return nil, false
	}
	var v []GenieConversationSummary
	d := m.Conversations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConversations sets the value of the Conversations field in GenieListConversationsResponse.
func (m *GenieListConversationsResponse) SetConversations(ctx context.Context, v []GenieConversationSummary) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["conversations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Conversations = types.ListValueMust(t, vs)
}

type GenieListSpacesRequest struct {
	// Maximum number of spaces to return per page
	PageSize types.Int64 `tfsdk:"-"`
	// Pagination token for getting the next page of results
	PageToken types.String `tfsdk:"-"`
}

func (to *GenieListSpacesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieListSpacesRequest) {
}

func (to *GenieListSpacesRequest) SyncFieldsDuringRead(ctx context.Context, from GenieListSpacesRequest) {
}

func (m GenieListSpacesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieListSpacesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieListSpacesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieListSpacesRequest
// only implements ToObjectValue() and Type().
func (m GenieListSpacesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":  m.PageSize,
			"page_token": m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieListSpacesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

type GenieListSpacesResponse struct {
	// Token to get the next page of results
	NextPageToken types.String `tfsdk:"next_page_token"`
	// List of Genie spaces
	Spaces types.List `tfsdk:"spaces"`
}

func (to *GenieListSpacesResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieListSpacesResponse) {
	if !from.Spaces.IsNull() && !from.Spaces.IsUnknown() && to.Spaces.IsNull() && len(from.Spaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Spaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Spaces = from.Spaces
	}
}

func (to *GenieListSpacesResponse) SyncFieldsDuringRead(ctx context.Context, from GenieListSpacesResponse) {
	if !from.Spaces.IsNull() && !from.Spaces.IsUnknown() && to.Spaces.IsNull() && len(from.Spaces.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Spaces, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Spaces = from.Spaces
	}
}

func (m GenieListSpacesResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["spaces"] = attrs["spaces"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieListSpacesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieListSpacesResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"spaces": reflect.TypeOf(GenieSpace{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieListSpacesResponse
// only implements ToObjectValue() and Type().
func (m GenieListSpacesResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"spaces":          m.Spaces,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieListSpacesResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"spaces": basetypes.ListType{
				ElemType: GenieSpace{}.Type(ctx),
			},
		},
	}
}

// GetSpaces returns the value of the Spaces field in GenieListSpacesResponse as
// a slice of GenieSpace values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieListSpacesResponse) GetSpaces(ctx context.Context) ([]GenieSpace, bool) {
	if m.Spaces.IsNull() || m.Spaces.IsUnknown() {
		return nil, false
	}
	var v []GenieSpace
	d := m.Spaces.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSpaces sets the value of the Spaces field in GenieListSpacesResponse.
func (m *GenieListSpacesResponse) SetSpaces(ctx context.Context, v []GenieSpace) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spaces"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Spaces = types.ListValueMust(t, vs)
}

type GenieMessage struct {
	// AI-generated response to the message
	Attachments types.List `tfsdk:"attachments"`
	// User message content
	Content types.String `tfsdk:"content"`
	// Conversation ID
	ConversationId types.String `tfsdk:"conversation_id"`
	// Timestamp when the message was created
	CreatedTimestamp types.Int64 `tfsdk:"created_timestamp"`
	// Error message if Genie failed to respond to the message
	Error types.Object `tfsdk:"error"`
	// User feedback for the message if provided
	Feedback types.Object `tfsdk:"feedback"`
	// Message ID. Legacy identifier, use message_id instead
	Id types.String `tfsdk:"id"`
	// Timestamp when the message was last updated
	LastUpdatedTimestamp types.Int64 `tfsdk:"last_updated_timestamp"`
	// Message ID
	MessageId types.String `tfsdk:"message_id"`
	// The result of SQL query if the message includes a query attachment.
	// Deprecated. Use `query_result_metadata` in `GenieQueryAttachment`
	// instead.
	QueryResult types.Object `tfsdk:"query_result"`
	// Genie space ID
	SpaceId types.String `tfsdk:"space_id"`

	Status types.String `tfsdk:"status"`
	// ID of the user who created the message
	UserId types.Int64 `tfsdk:"user_id"`
}

func (to *GenieMessage) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieMessage) {
	if !from.Attachments.IsNull() && !from.Attachments.IsUnknown() && to.Attachments.IsNull() && len(from.Attachments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Attachments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Attachments = from.Attachments
	}
	if !from.Error.IsNull() && !from.Error.IsUnknown() {
		if toError, ok := to.GetError(ctx); ok {
			if fromError, ok := from.GetError(ctx); ok {
				// Recursively sync the fields of Error
				toError.SyncFieldsDuringCreateOrUpdate(ctx, fromError)
				to.SetError(ctx, toError)
			}
		}
	}
	if !from.Feedback.IsNull() && !from.Feedback.IsUnknown() {
		if toFeedback, ok := to.GetFeedback(ctx); ok {
			if fromFeedback, ok := from.GetFeedback(ctx); ok {
				// Recursively sync the fields of Feedback
				toFeedback.SyncFieldsDuringCreateOrUpdate(ctx, fromFeedback)
				to.SetFeedback(ctx, toFeedback)
			}
		}
	}
	if !from.QueryResult.IsNull() && !from.QueryResult.IsUnknown() {
		if toQueryResult, ok := to.GetQueryResult(ctx); ok {
			if fromQueryResult, ok := from.GetQueryResult(ctx); ok {
				// Recursively sync the fields of QueryResult
				toQueryResult.SyncFieldsDuringCreateOrUpdate(ctx, fromQueryResult)
				to.SetQueryResult(ctx, toQueryResult)
			}
		}
	}
}

func (to *GenieMessage) SyncFieldsDuringRead(ctx context.Context, from GenieMessage) {
	if !from.Attachments.IsNull() && !from.Attachments.IsUnknown() && to.Attachments.IsNull() && len(from.Attachments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Attachments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Attachments = from.Attachments
	}
	if !from.Error.IsNull() && !from.Error.IsUnknown() {
		if toError, ok := to.GetError(ctx); ok {
			if fromError, ok := from.GetError(ctx); ok {
				toError.SyncFieldsDuringRead(ctx, fromError)
				to.SetError(ctx, toError)
			}
		}
	}
	if !from.Feedback.IsNull() && !from.Feedback.IsUnknown() {
		if toFeedback, ok := to.GetFeedback(ctx); ok {
			if fromFeedback, ok := from.GetFeedback(ctx); ok {
				toFeedback.SyncFieldsDuringRead(ctx, fromFeedback)
				to.SetFeedback(ctx, toFeedback)
			}
		}
	}
	if !from.QueryResult.IsNull() && !from.QueryResult.IsUnknown() {
		if toQueryResult, ok := to.GetQueryResult(ctx); ok {
			if fromQueryResult, ok := from.GetQueryResult(ctx); ok {
				toQueryResult.SyncFieldsDuringRead(ctx, fromQueryResult)
				to.SetQueryResult(ctx, toQueryResult)
			}
		}
	}
}

func (m GenieMessage) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attachments"] = attrs["attachments"].SetOptional()
	attrs["content"] = attrs["content"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["created_timestamp"] = attrs["created_timestamp"].SetOptional()
	attrs["error"] = attrs["error"].SetOptional()
	attrs["feedback"] = attrs["feedback"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()
	attrs["last_updated_timestamp"] = attrs["last_updated_timestamp"].SetOptional()
	attrs["message_id"] = attrs["message_id"].SetRequired()
	attrs["query_result"] = attrs["query_result"].SetOptional()
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["user_id"] = attrs["user_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieMessage.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieMessage) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"attachments":  reflect.TypeOf(GenieAttachment{}),
		"error":        reflect.TypeOf(MessageError{}),
		"feedback":     reflect.TypeOf(GenieFeedback{}),
		"query_result": reflect.TypeOf(Result{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieMessage
// only implements ToObjectValue() and Type().
func (m GenieMessage) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attachments":            m.Attachments,
			"content":                m.Content,
			"conversation_id":        m.ConversationId,
			"created_timestamp":      m.CreatedTimestamp,
			"error":                  m.Error,
			"feedback":               m.Feedback,
			"id":                     m.Id,
			"last_updated_timestamp": m.LastUpdatedTimestamp,
			"message_id":             m.MessageId,
			"query_result":           m.QueryResult,
			"space_id":               m.SpaceId,
			"status":                 m.Status,
			"user_id":                m.UserId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieMessage) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attachments": basetypes.ListType{
				ElemType: GenieAttachment{}.Type(ctx),
			},
			"content":                types.StringType,
			"conversation_id":        types.StringType,
			"created_timestamp":      types.Int64Type,
			"error":                  MessageError{}.Type(ctx),
			"feedback":               GenieFeedback{}.Type(ctx),
			"id":                     types.StringType,
			"last_updated_timestamp": types.Int64Type,
			"message_id":             types.StringType,
			"query_result":           Result{}.Type(ctx),
			"space_id":               types.StringType,
			"status":                 types.StringType,
			"user_id":                types.Int64Type,
		},
	}
}

// GetAttachments returns the value of the Attachments field in GenieMessage as
// a slice of GenieAttachment values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieMessage) GetAttachments(ctx context.Context) ([]GenieAttachment, bool) {
	if m.Attachments.IsNull() || m.Attachments.IsUnknown() {
		return nil, false
	}
	var v []GenieAttachment
	d := m.Attachments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAttachments sets the value of the Attachments field in GenieMessage.
func (m *GenieMessage) SetAttachments(ctx context.Context, v []GenieAttachment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["attachments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Attachments = types.ListValueMust(t, vs)
}

// GetError returns the value of the Error field in GenieMessage as
// a MessageError value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieMessage) GetError(ctx context.Context) (MessageError, bool) {
	var e MessageError
	if m.Error.IsNull() || m.Error.IsUnknown() {
		return e, false
	}
	var v MessageError
	d := m.Error.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetError sets the value of the Error field in GenieMessage.
func (m *GenieMessage) SetError(ctx context.Context, v MessageError) {
	vs := v.ToObjectValue(ctx)
	m.Error = vs
}

// GetFeedback returns the value of the Feedback field in GenieMessage as
// a GenieFeedback value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieMessage) GetFeedback(ctx context.Context) (GenieFeedback, bool) {
	var e GenieFeedback
	if m.Feedback.IsNull() || m.Feedback.IsUnknown() {
		return e, false
	}
	var v GenieFeedback
	d := m.Feedback.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFeedback sets the value of the Feedback field in GenieMessage.
func (m *GenieMessage) SetFeedback(ctx context.Context, v GenieFeedback) {
	vs := v.ToObjectValue(ctx)
	m.Feedback = vs
}

// GetQueryResult returns the value of the QueryResult field in GenieMessage as
// a Result value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieMessage) GetQueryResult(ctx context.Context) (Result, bool) {
	var e Result
	if m.QueryResult.IsNull() || m.QueryResult.IsUnknown() {
		return e, false
	}
	var v Result
	d := m.QueryResult.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueryResult sets the value of the QueryResult field in GenieMessage.
func (m *GenieMessage) SetQueryResult(ctx context.Context, v Result) {
	vs := v.ToObjectValue(ctx)
	m.QueryResult = vs
}

type GenieQueryAttachment struct {
	// Description of the query
	Description types.String `tfsdk:"description"`

	Id types.String `tfsdk:"id"`
	// Time when the user updated the query last
	LastUpdatedTimestamp types.Int64 `tfsdk:"last_updated_timestamp"`
	// AI generated SQL query
	Query types.String `tfsdk:"query"`
	// Metadata associated with the query result.
	QueryResultMetadata types.Object `tfsdk:"query_result_metadata"`
	// Statement Execution API statement id. Use [Get status, manifest, and
	// result first chunk](:method:statementexecution/getstatement) to get the
	// full result data.
	StatementId types.String `tfsdk:"statement_id"`
	// Name of the query
	Title types.String `tfsdk:"title"`
}

func (to *GenieQueryAttachment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieQueryAttachment) {
	if !from.QueryResultMetadata.IsNull() && !from.QueryResultMetadata.IsUnknown() {
		if toQueryResultMetadata, ok := to.GetQueryResultMetadata(ctx); ok {
			if fromQueryResultMetadata, ok := from.GetQueryResultMetadata(ctx); ok {
				// Recursively sync the fields of QueryResultMetadata
				toQueryResultMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromQueryResultMetadata)
				to.SetQueryResultMetadata(ctx, toQueryResultMetadata)
			}
		}
	}
}

func (to *GenieQueryAttachment) SyncFieldsDuringRead(ctx context.Context, from GenieQueryAttachment) {
	if !from.QueryResultMetadata.IsNull() && !from.QueryResultMetadata.IsUnknown() {
		if toQueryResultMetadata, ok := to.GetQueryResultMetadata(ctx); ok {
			if fromQueryResultMetadata, ok := from.GetQueryResultMetadata(ctx); ok {
				toQueryResultMetadata.SyncFieldsDuringRead(ctx, fromQueryResultMetadata)
				to.SetQueryResultMetadata(ctx, toQueryResultMetadata)
			}
		}
	}
}

func (m GenieQueryAttachment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["last_updated_timestamp"] = attrs["last_updated_timestamp"].SetOptional()
	attrs["query"] = attrs["query"].SetOptional()
	attrs["query_result_metadata"] = attrs["query_result_metadata"].SetOptional()
	attrs["statement_id"] = attrs["statement_id"].SetOptional()
	attrs["title"] = attrs["title"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieQueryAttachment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieQueryAttachment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"query_result_metadata": reflect.TypeOf(GenieResultMetadata{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieQueryAttachment
// only implements ToObjectValue() and Type().
func (m GenieQueryAttachment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":            m.Description,
			"id":                     m.Id,
			"last_updated_timestamp": m.LastUpdatedTimestamp,
			"query":                  m.Query,
			"query_result_metadata":  m.QueryResultMetadata,
			"statement_id":           m.StatementId,
			"title":                  m.Title,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieQueryAttachment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":            types.StringType,
			"id":                     types.StringType,
			"last_updated_timestamp": types.Int64Type,
			"query":                  types.StringType,
			"query_result_metadata":  GenieResultMetadata{}.Type(ctx),
			"statement_id":           types.StringType,
			"title":                  types.StringType,
		},
	}
}

// GetQueryResultMetadata returns the value of the QueryResultMetadata field in GenieQueryAttachment as
// a GenieResultMetadata value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieQueryAttachment) GetQueryResultMetadata(ctx context.Context) (GenieResultMetadata, bool) {
	var e GenieResultMetadata
	if m.QueryResultMetadata.IsNull() || m.QueryResultMetadata.IsUnknown() {
		return e, false
	}
	var v GenieResultMetadata
	d := m.QueryResultMetadata.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueryResultMetadata sets the value of the QueryResultMetadata field in GenieQueryAttachment.
func (m *GenieQueryAttachment) SetQueryResultMetadata(ctx context.Context, v GenieResultMetadata) {
	vs := v.ToObjectValue(ctx)
	m.QueryResultMetadata = vs
}

type GenieResultMetadata struct {
	// Indicates whether the result set is truncated.
	IsTruncated types.Bool `tfsdk:"is_truncated"`
	// The number of rows in the result set.
	RowCount types.Int64 `tfsdk:"row_count"`
}

func (to *GenieResultMetadata) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieResultMetadata) {
}

func (to *GenieResultMetadata) SyncFieldsDuringRead(ctx context.Context, from GenieResultMetadata) {
}

func (m GenieResultMetadata) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_truncated"] = attrs["is_truncated"].SetOptional()
	attrs["row_count"] = attrs["row_count"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieResultMetadata.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieResultMetadata) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieResultMetadata
// only implements ToObjectValue() and Type().
func (m GenieResultMetadata) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_truncated": m.IsTruncated,
			"row_count":    m.RowCount,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieResultMetadata) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_truncated": types.BoolType,
			"row_count":    types.Int64Type,
		},
	}
}

type GenieSendMessageFeedbackRequest struct {
	// The ID associated with the conversation.
	ConversationId types.String `tfsdk:"-"`
	// The ID associated with the message to provide feedback for.
	MessageId types.String `tfsdk:"-"`
	// The rating (POSITIVE, NEGATIVE, or NONE).
	Rating types.String `tfsdk:"rating"`
	// The ID associated with the Genie space where the message is located.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieSendMessageFeedbackRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieSendMessageFeedbackRequest) {
}

func (to *GenieSendMessageFeedbackRequest) SyncFieldsDuringRead(ctx context.Context, from GenieSendMessageFeedbackRequest) {
}

func (m GenieSendMessageFeedbackRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["rating"] = attrs["rating"].SetRequired()
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message_id"] = attrs["message_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieSendMessageFeedbackRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieSendMessageFeedbackRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieSendMessageFeedbackRequest
// only implements ToObjectValue() and Type().
func (m GenieSendMessageFeedbackRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation_id": m.ConversationId,
			"message_id":      m.MessageId,
			"rating":          m.Rating,
			"space_id":        m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieSendMessageFeedbackRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation_id": types.StringType,
			"message_id":      types.StringType,
			"rating":          types.StringType,
			"space_id":        types.StringType,
		},
	}
}

type GenieSpace struct {
	// Description of the Genie Space
	Description types.String `tfsdk:"description"`
	// Genie space ID
	SpaceId types.String `tfsdk:"space_id"`
	// Title of the Genie Space
	Title types.String `tfsdk:"title"`
	// Warehouse associated with the Genie Space
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *GenieSpace) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieSpace) {
}

func (to *GenieSpace) SyncFieldsDuringRead(ctx context.Context, from GenieSpace) {
}

func (m GenieSpace) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["space_id"] = attrs["space_id"].SetRequired()
	attrs["title"] = attrs["title"].SetRequired()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieSpace.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieSpace) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieSpace
// only implements ToObjectValue() and Type().
func (m GenieSpace) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":  m.Description,
			"space_id":     m.SpaceId,
			"title":        m.Title,
			"warehouse_id": m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieSpace) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":  types.StringType,
			"space_id":     types.StringType,
			"title":        types.StringType,
			"warehouse_id": types.StringType,
		},
	}
}

type GenieStartConversationMessageRequest struct {
	// The text of the message that starts the conversation.
	Content types.String `tfsdk:"content"`
	// The ID associated with the Genie space where you want to start a
	// conversation.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieStartConversationMessageRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieStartConversationMessageRequest) {
}

func (to *GenieStartConversationMessageRequest) SyncFieldsDuringRead(ctx context.Context, from GenieStartConversationMessageRequest) {
}

func (m GenieStartConversationMessageRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["content"] = attrs["content"].SetRequired()
	attrs["space_id"] = attrs["space_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieStartConversationMessageRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieStartConversationMessageRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieStartConversationMessageRequest
// only implements ToObjectValue() and Type().
func (m GenieStartConversationMessageRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"content":  m.Content,
			"space_id": m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieStartConversationMessageRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"content":  types.StringType,
			"space_id": types.StringType,
		},
	}
}

type GenieStartConversationResponse struct {
	Conversation types.Object `tfsdk:"conversation"`
	// Conversation ID
	ConversationId types.String `tfsdk:"conversation_id"`

	Message types.Object `tfsdk:"message"`
	// Message ID
	MessageId types.String `tfsdk:"message_id"`
}

func (to *GenieStartConversationResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieStartConversationResponse) {
	if !from.Conversation.IsNull() && !from.Conversation.IsUnknown() {
		if toConversation, ok := to.GetConversation(ctx); ok {
			if fromConversation, ok := from.GetConversation(ctx); ok {
				// Recursively sync the fields of Conversation
				toConversation.SyncFieldsDuringCreateOrUpdate(ctx, fromConversation)
				to.SetConversation(ctx, toConversation)
			}
		}
	}
	if !from.Message.IsNull() && !from.Message.IsUnknown() {
		if toMessage, ok := to.GetMessage(ctx); ok {
			if fromMessage, ok := from.GetMessage(ctx); ok {
				// Recursively sync the fields of Message
				toMessage.SyncFieldsDuringCreateOrUpdate(ctx, fromMessage)
				to.SetMessage(ctx, toMessage)
			}
		}
	}
}

func (to *GenieStartConversationResponse) SyncFieldsDuringRead(ctx context.Context, from GenieStartConversationResponse) {
	if !from.Conversation.IsNull() && !from.Conversation.IsUnknown() {
		if toConversation, ok := to.GetConversation(ctx); ok {
			if fromConversation, ok := from.GetConversation(ctx); ok {
				toConversation.SyncFieldsDuringRead(ctx, fromConversation)
				to.SetConversation(ctx, toConversation)
			}
		}
	}
	if !from.Message.IsNull() && !from.Message.IsUnknown() {
		if toMessage, ok := to.GetMessage(ctx); ok {
			if fromMessage, ok := from.GetMessage(ctx); ok {
				toMessage.SyncFieldsDuringRead(ctx, fromMessage)
				to.SetMessage(ctx, toMessage)
			}
		}
	}
}

func (m GenieStartConversationResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["conversation"] = attrs["conversation"].SetOptional()
	attrs["conversation_id"] = attrs["conversation_id"].SetRequired()
	attrs["message"] = attrs["message"].SetOptional()
	attrs["message_id"] = attrs["message_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieStartConversationResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieStartConversationResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"conversation": reflect.TypeOf(GenieConversation{}),
		"message":      reflect.TypeOf(GenieMessage{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieStartConversationResponse
// only implements ToObjectValue() and Type().
func (m GenieStartConversationResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"conversation":    m.Conversation,
			"conversation_id": m.ConversationId,
			"message":         m.Message,
			"message_id":      m.MessageId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieStartConversationResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"conversation":    GenieConversation{}.Type(ctx),
			"conversation_id": types.StringType,
			"message":         GenieMessage{}.Type(ctx),
			"message_id":      types.StringType,
		},
	}
}

// GetConversation returns the value of the Conversation field in GenieStartConversationResponse as
// a GenieConversation value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieStartConversationResponse) GetConversation(ctx context.Context) (GenieConversation, bool) {
	var e GenieConversation
	if m.Conversation.IsNull() || m.Conversation.IsUnknown() {
		return e, false
	}
	var v GenieConversation
	d := m.Conversation.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConversation sets the value of the Conversation field in GenieStartConversationResponse.
func (m *GenieStartConversationResponse) SetConversation(ctx context.Context, v GenieConversation) {
	vs := v.ToObjectValue(ctx)
	m.Conversation = vs
}

// GetMessage returns the value of the Message field in GenieStartConversationResponse as
// a GenieMessage value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieStartConversationResponse) GetMessage(ctx context.Context) (GenieMessage, bool) {
	var e GenieMessage
	if m.Message.IsNull() || m.Message.IsUnknown() {
		return e, false
	}
	var v GenieMessage
	d := m.Message.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMessage sets the value of the Message field in GenieStartConversationResponse.
func (m *GenieStartConversationResponse) SetMessage(ctx context.Context, v GenieMessage) {
	vs := v.ToObjectValue(ctx)
	m.Message = vs
}

// Follow-up questions suggested by Genie
type GenieSuggestedQuestionsAttachment struct {
	// The suggested follow-up questions
	Questions types.List `tfsdk:"questions"`
}

func (to *GenieSuggestedQuestionsAttachment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieSuggestedQuestionsAttachment) {
	if !from.Questions.IsNull() && !from.Questions.IsUnknown() && to.Questions.IsNull() && len(from.Questions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Questions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Questions = from.Questions
	}
}

func (to *GenieSuggestedQuestionsAttachment) SyncFieldsDuringRead(ctx context.Context, from GenieSuggestedQuestionsAttachment) {
	if !from.Questions.IsNull() && !from.Questions.IsUnknown() && to.Questions.IsNull() && len(from.Questions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Questions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Questions = from.Questions
	}
}

func (m GenieSuggestedQuestionsAttachment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["questions"] = attrs["questions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieSuggestedQuestionsAttachment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieSuggestedQuestionsAttachment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"questions": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieSuggestedQuestionsAttachment
// only implements ToObjectValue() and Type().
func (m GenieSuggestedQuestionsAttachment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"questions": m.Questions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieSuggestedQuestionsAttachment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"questions": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetQuestions returns the value of the Questions field in GenieSuggestedQuestionsAttachment as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *GenieSuggestedQuestionsAttachment) GetQuestions(ctx context.Context) ([]types.String, bool) {
	if m.Questions.IsNull() || m.Questions.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Questions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQuestions sets the value of the Questions field in GenieSuggestedQuestionsAttachment.
func (m *GenieSuggestedQuestionsAttachment) SetQuestions(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["questions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Questions = types.ListValueMust(t, vs)
}

type GenieTrashSpaceRequest struct {
	// The ID associated with the Genie space to be sent to the trash.
	SpaceId types.String `tfsdk:"-"`
}

func (to *GenieTrashSpaceRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenieTrashSpaceRequest) {
}

func (to *GenieTrashSpaceRequest) SyncFieldsDuringRead(ctx context.Context, from GenieTrashSpaceRequest) {
}

func (m GenieTrashSpaceRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["space_id"] = attrs["space_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenieTrashSpaceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenieTrashSpaceRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenieTrashSpaceRequest
// only implements ToObjectValue() and Type().
func (m GenieTrashSpaceRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"space_id": m.SpaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenieTrashSpaceRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"space_id": types.StringType,
		},
	}
}

type GetDashboardRequest struct {
	// UUID identifying the dashboard.
	DashboardId types.String `tfsdk:"-"`
}

func (to *GetDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetDashboardRequest) {
}

func (to *GetDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from GetDashboardRequest) {
}

func (m GetDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetDashboardRequest
// only implements ToObjectValue() and Type().
func (m GetDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
		},
	}
}

type GetPublishedDashboardRequest struct {
	// UUID identifying the published dashboard.
	DashboardId types.String `tfsdk:"-"`
}

func (to *GetPublishedDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPublishedDashboardRequest) {
}

func (to *GetPublishedDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from GetPublishedDashboardRequest) {
}

func (m GetPublishedDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPublishedDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPublishedDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPublishedDashboardRequest
// only implements ToObjectValue() and Type().
func (m GetPublishedDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPublishedDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
		},
	}
}

type GetPublishedDashboardTokenInfoRequest struct {
	// UUID identifying the published dashboard.
	DashboardId types.String `tfsdk:"-"`
	// Provided external value to be included in the custom claim.
	ExternalValue types.String `tfsdk:"-"`
	// Provided external viewer id to be included in the custom claim.
	ExternalViewerId types.String `tfsdk:"-"`
}

func (to *GetPublishedDashboardTokenInfoRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPublishedDashboardTokenInfoRequest) {
}

func (to *GetPublishedDashboardTokenInfoRequest) SyncFieldsDuringRead(ctx context.Context, from GetPublishedDashboardTokenInfoRequest) {
}

func (m GetPublishedDashboardTokenInfoRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["external_value"] = attrs["external_value"].SetOptional()
	attrs["external_viewer_id"] = attrs["external_viewer_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPublishedDashboardTokenInfoRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPublishedDashboardTokenInfoRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPublishedDashboardTokenInfoRequest
// only implements ToObjectValue() and Type().
func (m GetPublishedDashboardTokenInfoRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id":       m.DashboardId,
			"external_value":     m.ExternalValue,
			"external_viewer_id": m.ExternalViewerId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPublishedDashboardTokenInfoRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id":       types.StringType,
			"external_value":     types.StringType,
			"external_viewer_id": types.StringType,
		},
	}
}

type GetPublishedDashboardTokenInfoResponse struct {
	// Authorization constraints for accessing the published dashboard.
	// Currently includes `workspace_rule_set` and could be enriched with
	// `unity_catalog_privileges` before oAuth token generation.
	AuthorizationDetails types.List `tfsdk:"authorization_details"`
	// Custom claim generated from external_value and external_viewer_id.
	// Format:
	// `urn:aibi:external_data:<external_value>:<external_viewer_id>:<dashboard_id>`
	CustomClaim types.String `tfsdk:"custom_claim"`
	// Scope defining access permissions.
	Scope types.String `tfsdk:"scope"`
}

func (to *GetPublishedDashboardTokenInfoResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPublishedDashboardTokenInfoResponse) {
	if !from.AuthorizationDetails.IsNull() && !from.AuthorizationDetails.IsUnknown() && to.AuthorizationDetails.IsNull() && len(from.AuthorizationDetails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AuthorizationDetails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AuthorizationDetails = from.AuthorizationDetails
	}
}

func (to *GetPublishedDashboardTokenInfoResponse) SyncFieldsDuringRead(ctx context.Context, from GetPublishedDashboardTokenInfoResponse) {
	if !from.AuthorizationDetails.IsNull() && !from.AuthorizationDetails.IsUnknown() && to.AuthorizationDetails.IsNull() && len(from.AuthorizationDetails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AuthorizationDetails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AuthorizationDetails = from.AuthorizationDetails
	}
}

func (m GetPublishedDashboardTokenInfoResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["authorization_details"] = attrs["authorization_details"].SetOptional()
	attrs["custom_claim"] = attrs["custom_claim"].SetOptional()
	attrs["scope"] = attrs["scope"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPublishedDashboardTokenInfoResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPublishedDashboardTokenInfoResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"authorization_details": reflect.TypeOf(AuthorizationDetails{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPublishedDashboardTokenInfoResponse
// only implements ToObjectValue() and Type().
func (m GetPublishedDashboardTokenInfoResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"authorization_details": m.AuthorizationDetails,
			"custom_claim":          m.CustomClaim,
			"scope":                 m.Scope,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPublishedDashboardTokenInfoResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"authorization_details": basetypes.ListType{
				ElemType: AuthorizationDetails{}.Type(ctx),
			},
			"custom_claim": types.StringType,
			"scope":        types.StringType,
		},
	}
}

// GetAuthorizationDetails returns the value of the AuthorizationDetails field in GetPublishedDashboardTokenInfoResponse as
// a slice of AuthorizationDetails values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetPublishedDashboardTokenInfoResponse) GetAuthorizationDetails(ctx context.Context) ([]AuthorizationDetails, bool) {
	if m.AuthorizationDetails.IsNull() || m.AuthorizationDetails.IsUnknown() {
		return nil, false
	}
	var v []AuthorizationDetails
	d := m.AuthorizationDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAuthorizationDetails sets the value of the AuthorizationDetails field in GetPublishedDashboardTokenInfoResponse.
func (m *GetPublishedDashboardTokenInfoResponse) SetAuthorizationDetails(ctx context.Context, v []AuthorizationDetails) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["authorization_details"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AuthorizationDetails = types.ListValueMust(t, vs)
}

type GetScheduleRequest struct {
	// UUID identifying the dashboard to which the schedule belongs.
	DashboardId types.String `tfsdk:"-"`
	// UUID identifying the schedule.
	ScheduleId types.String `tfsdk:"-"`
}

func (to *GetScheduleRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetScheduleRequest) {
}

func (to *GetScheduleRequest) SyncFieldsDuringRead(ctx context.Context, from GetScheduleRequest) {
}

func (m GetScheduleRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["schedule_id"] = attrs["schedule_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetScheduleRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetScheduleRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetScheduleRequest
// only implements ToObjectValue() and Type().
func (m GetScheduleRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"schedule_id":  m.ScheduleId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetScheduleRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"schedule_id":  types.StringType,
		},
	}
}

type GetSubscriptionRequest struct {
	// UUID identifying the dashboard which the subscription belongs.
	DashboardId types.String `tfsdk:"-"`
	// UUID identifying the schedule which the subscription belongs.
	ScheduleId types.String `tfsdk:"-"`
	// UUID identifying the subscription.
	SubscriptionId types.String `tfsdk:"-"`
}

func (to *GetSubscriptionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetSubscriptionRequest) {
}

func (to *GetSubscriptionRequest) SyncFieldsDuringRead(ctx context.Context, from GetSubscriptionRequest) {
}

func (m GetSubscriptionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["schedule_id"] = attrs["schedule_id"].SetRequired()
	attrs["subscription_id"] = attrs["subscription_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetSubscriptionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetSubscriptionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetSubscriptionRequest
// only implements ToObjectValue() and Type().
func (m GetSubscriptionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id":    m.DashboardId,
			"schedule_id":     m.ScheduleId,
			"subscription_id": m.SubscriptionId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetSubscriptionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id":    types.StringType,
			"schedule_id":     types.StringType,
			"subscription_id": types.StringType,
		},
	}
}

type ListDashboardsRequest struct {
	// The number of dashboards to return per page.
	PageSize types.Int64 `tfsdk:"-"`
	// A page token, received from a previous `ListDashboards` call. This token
	// can be used to retrieve the subsequent page.
	PageToken types.String `tfsdk:"-"`
	// The flag to include dashboards located in the trash. If unspecified, only
	// active dashboards will be returned.
	ShowTrashed types.Bool `tfsdk:"-"`
	// `DASHBOARD_VIEW_BASIC`only includes summary metadata from the dashboard.
	View types.String `tfsdk:"-"`
}

func (to *ListDashboardsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListDashboardsRequest) {
}

func (to *ListDashboardsRequest) SyncFieldsDuringRead(ctx context.Context, from ListDashboardsRequest) {
}

func (m ListDashboardsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["show_trashed"] = attrs["show_trashed"].SetOptional()
	attrs["view"] = attrs["view"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListDashboardsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListDashboardsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListDashboardsRequest
// only implements ToObjectValue() and Type().
func (m ListDashboardsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":    m.PageSize,
			"page_token":   m.PageToken,
			"show_trashed": m.ShowTrashed,
			"view":         m.View,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListDashboardsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":    types.Int64Type,
			"page_token":   types.StringType,
			"show_trashed": types.BoolType,
			"view":         types.StringType,
		},
	}
}

type ListDashboardsResponse struct {
	Dashboards types.List `tfsdk:"dashboards"`
	// A token, which can be sent as `page_token` to retrieve the next page. If
	// this field is omitted, there are no subsequent dashboards.
	NextPageToken types.String `tfsdk:"next_page_token"`
}

func (to *ListDashboardsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListDashboardsResponse) {
	if !from.Dashboards.IsNull() && !from.Dashboards.IsUnknown() && to.Dashboards.IsNull() && len(from.Dashboards.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Dashboards, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Dashboards = from.Dashboards
	}
}

func (to *ListDashboardsResponse) SyncFieldsDuringRead(ctx context.Context, from ListDashboardsResponse) {
	if !from.Dashboards.IsNull() && !from.Dashboards.IsUnknown() && to.Dashboards.IsNull() && len(from.Dashboards.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Dashboards, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Dashboards = from.Dashboards
	}
}

func (m ListDashboardsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboards"] = attrs["dashboards"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListDashboardsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListDashboardsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dashboards": reflect.TypeOf(Dashboard{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListDashboardsResponse
// only implements ToObjectValue() and Type().
func (m ListDashboardsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboards":      m.Dashboards,
			"next_page_token": m.NextPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListDashboardsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboards": basetypes.ListType{
				ElemType: Dashboard{}.Type(ctx),
			},
			"next_page_token": types.StringType,
		},
	}
}

// GetDashboards returns the value of the Dashboards field in ListDashboardsResponse as
// a slice of Dashboard values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListDashboardsResponse) GetDashboards(ctx context.Context) ([]Dashboard, bool) {
	if m.Dashboards.IsNull() || m.Dashboards.IsUnknown() {
		return nil, false
	}
	var v []Dashboard
	d := m.Dashboards.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboards sets the value of the Dashboards field in ListDashboardsResponse.
func (m *ListDashboardsResponse) SetDashboards(ctx context.Context, v []Dashboard) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dashboards"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Dashboards = types.ListValueMust(t, vs)
}

type ListSchedulesRequest struct {
	// UUID identifying the dashboard to which the schedules belongs.
	DashboardId types.String `tfsdk:"-"`
	// The number of schedules to return per page.
	PageSize types.Int64 `tfsdk:"-"`
	// A page token, received from a previous `ListSchedules` call. Use this to
	// retrieve the subsequent page.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListSchedulesRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSchedulesRequest) {
}

func (to *ListSchedulesRequest) SyncFieldsDuringRead(ctx context.Context, from ListSchedulesRequest) {
}

func (m ListSchedulesRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSchedulesRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSchedulesRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSchedulesRequest
// only implements ToObjectValue() and Type().
func (m ListSchedulesRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"page_size":    m.PageSize,
			"page_token":   m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSchedulesRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"page_size":    types.Int64Type,
			"page_token":   types.StringType,
		},
	}
}

type ListSchedulesResponse struct {
	// A token that can be used as a `page_token` in subsequent requests to
	// retrieve the next page of results. If this field is omitted, there are no
	// subsequent schedules.
	NextPageToken types.String `tfsdk:"next_page_token"`

	Schedules types.List `tfsdk:"schedules"`
}

func (to *ListSchedulesResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSchedulesResponse) {
	if !from.Schedules.IsNull() && !from.Schedules.IsUnknown() && to.Schedules.IsNull() && len(from.Schedules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schedules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schedules = from.Schedules
	}
}

func (to *ListSchedulesResponse) SyncFieldsDuringRead(ctx context.Context, from ListSchedulesResponse) {
	if !from.Schedules.IsNull() && !from.Schedules.IsUnknown() && to.Schedules.IsNull() && len(from.Schedules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schedules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schedules = from.Schedules
	}
}

func (m ListSchedulesResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetComputed()
	attrs["schedules"] = attrs["schedules"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSchedulesResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSchedulesResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schedules": reflect.TypeOf(Schedule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSchedulesResponse
// only implements ToObjectValue() and Type().
func (m ListSchedulesResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"schedules":       m.Schedules,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSchedulesResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"schedules": basetypes.ListType{
				ElemType: Schedule{}.Type(ctx),
			},
		},
	}
}

// GetSchedules returns the value of the Schedules field in ListSchedulesResponse as
// a slice of Schedule values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListSchedulesResponse) GetSchedules(ctx context.Context) ([]Schedule, bool) {
	if m.Schedules.IsNull() || m.Schedules.IsUnknown() {
		return nil, false
	}
	var v []Schedule
	d := m.Schedules.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedules sets the value of the Schedules field in ListSchedulesResponse.
func (m *ListSchedulesResponse) SetSchedules(ctx context.Context, v []Schedule) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["schedules"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Schedules = types.ListValueMust(t, vs)
}

type ListSubscriptionsRequest struct {
	// UUID identifying the dashboard which the subscriptions belongs.
	DashboardId types.String `tfsdk:"-"`
	// The number of subscriptions to return per page.
	PageSize types.Int64 `tfsdk:"-"`
	// A page token, received from a previous `ListSubscriptions` call. Use this
	// to retrieve the subsequent page.
	PageToken types.String `tfsdk:"-"`
	// UUID identifying the schedule which the subscriptions belongs.
	ScheduleId types.String `tfsdk:"-"`
}

func (to *ListSubscriptionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSubscriptionsRequest) {
}

func (to *ListSubscriptionsRequest) SyncFieldsDuringRead(ctx context.Context, from ListSubscriptionsRequest) {
}

func (m ListSubscriptionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["schedule_id"] = attrs["schedule_id"].SetRequired()
	attrs["page_size"] = attrs["page_size"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSubscriptionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSubscriptionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSubscriptionsRequest
// only implements ToObjectValue() and Type().
func (m ListSubscriptionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"page_size":    m.PageSize,
			"page_token":   m.PageToken,
			"schedule_id":  m.ScheduleId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSubscriptionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"page_size":    types.Int64Type,
			"page_token":   types.StringType,
			"schedule_id":  types.StringType,
		},
	}
}

type ListSubscriptionsResponse struct {
	// A token that can be used as a `page_token` in subsequent requests to
	// retrieve the next page of results. If this field is omitted, there are no
	// subsequent subscriptions.
	NextPageToken types.String `tfsdk:"next_page_token"`

	Subscriptions types.List `tfsdk:"subscriptions"`
}

func (to *ListSubscriptionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListSubscriptionsResponse) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (to *ListSubscriptionsResponse) SyncFieldsDuringRead(ctx context.Context, from ListSubscriptionsResponse) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (m ListSubscriptionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetComputed()
	attrs["subscriptions"] = attrs["subscriptions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListSubscriptionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListSubscriptionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscriptions": reflect.TypeOf(Subscription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListSubscriptionsResponse
// only implements ToObjectValue() and Type().
func (m ListSubscriptionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token": m.NextPageToken,
			"subscriptions":   m.Subscriptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListSubscriptionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"subscriptions": basetypes.ListType{
				ElemType: Subscription{}.Type(ctx),
			},
		},
	}
}

// GetSubscriptions returns the value of the Subscriptions field in ListSubscriptionsResponse as
// a slice of Subscription values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListSubscriptionsResponse) GetSubscriptions(ctx context.Context) ([]Subscription, bool) {
	if m.Subscriptions.IsNull() || m.Subscriptions.IsUnknown() {
		return nil, false
	}
	var v []Subscription
	d := m.Subscriptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscriptions sets the value of the Subscriptions field in ListSubscriptionsResponse.
func (m *ListSubscriptionsResponse) SetSubscriptions(ctx context.Context, v []Subscription) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscriptions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscriptions = types.ListValueMust(t, vs)
}

type MessageError struct {
	Error types.String `tfsdk:"error"`

	Type_ types.String `tfsdk:"type"`
}

func (to *MessageError) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MessageError) {
}

func (to *MessageError) SyncFieldsDuringRead(ctx context.Context, from MessageError) {
}

func (m MessageError) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["error"] = attrs["error"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MessageError.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MessageError) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MessageError
// only implements ToObjectValue() and Type().
func (m MessageError) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"error": m.Error,
			"type":  m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MessageError) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"error": types.StringType,
			"type":  types.StringType,
		},
	}
}

type MigrateDashboardRequest struct {
	// Display name for the new Lakeview dashboard.
	DisplayName types.String `tfsdk:"display_name"`
	// The workspace path of the folder to contain the migrated Lakeview
	// dashboard.
	ParentPath types.String `tfsdk:"parent_path"`
	// UUID of the dashboard to be migrated.
	SourceDashboardId types.String `tfsdk:"source_dashboard_id"`
	// Flag to indicate if mustache parameter syntax ({{ param }}) should be
	// auto-updated to named syntax (:param) when converting datasets in the
	// dashboard.
	UpdateParameterSyntax types.Bool `tfsdk:"update_parameter_syntax"`
}

func (to *MigrateDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MigrateDashboardRequest) {
}

func (to *MigrateDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from MigrateDashboardRequest) {
}

func (m MigrateDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["parent_path"] = attrs["parent_path"].SetOptional()
	attrs["source_dashboard_id"] = attrs["source_dashboard_id"].SetRequired()
	attrs["update_parameter_syntax"] = attrs["update_parameter_syntax"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MigrateDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m MigrateDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MigrateDashboardRequest
// only implements ToObjectValue() and Type().
func (m MigrateDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name":            m.DisplayName,
			"parent_path":             m.ParentPath,
			"source_dashboard_id":     m.SourceDashboardId,
			"update_parameter_syntax": m.UpdateParameterSyntax,
		})
}

// Type implements basetypes.ObjectValuable.
func (m MigrateDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name":            types.StringType,
			"parent_path":             types.StringType,
			"source_dashboard_id":     types.StringType,
			"update_parameter_syntax": types.BoolType,
		},
	}
}

type PublishRequest struct {
	// UUID identifying the dashboard to be published.
	DashboardId types.String `tfsdk:"-"`
	// Flag to indicate if the publisher's credentials should be embedded in the
	// published dashboard. These embedded credentials will be used to execute
	// the published dashboard's queries.
	EmbedCredentials types.Bool `tfsdk:"embed_credentials"`
	// The ID of the warehouse that can be used to override the warehouse which
	// was set in the draft.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *PublishRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PublishRequest) {
}

func (to *PublishRequest) SyncFieldsDuringRead(ctx context.Context, from PublishRequest) {
}

func (m PublishRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["embed_credentials"] = attrs["embed_credentials"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PublishRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PublishRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PublishRequest
// only implements ToObjectValue() and Type().
func (m PublishRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id":      m.DashboardId,
			"embed_credentials": m.EmbedCredentials,
			"warehouse_id":      m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PublishRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id":      types.StringType,
			"embed_credentials": types.BoolType,
			"warehouse_id":      types.StringType,
		},
	}
}

type PublishedDashboard struct {
	// The display name of the published dashboard.
	DisplayName types.String `tfsdk:"display_name"`
	// Indicates whether credentials are embedded in the published dashboard.
	EmbedCredentials types.Bool `tfsdk:"embed_credentials"`
	// The timestamp of when the published dashboard was last revised.
	RevisionCreateTime types.String `tfsdk:"revision_create_time"`
	// The warehouse ID used to run the published dashboard.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *PublishedDashboard) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PublishedDashboard) {
}

func (to *PublishedDashboard) SyncFieldsDuringRead(ctx context.Context, from PublishedDashboard) {
}

func (m PublishedDashboard) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetComputed()
	attrs["embed_credentials"] = attrs["embed_credentials"].SetOptional()
	attrs["revision_create_time"] = attrs["revision_create_time"].SetComputed()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PublishedDashboard.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PublishedDashboard) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PublishedDashboard
// only implements ToObjectValue() and Type().
func (m PublishedDashboard) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name":         m.DisplayName,
			"embed_credentials":    m.EmbedCredentials,
			"revision_create_time": m.RevisionCreateTime,
			"warehouse_id":         m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PublishedDashboard) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name":         types.StringType,
			"embed_credentials":    types.BoolType,
			"revision_create_time": types.StringType,
			"warehouse_id":         types.StringType,
		},
	}
}

type Result struct {
	// If result is truncated
	IsTruncated types.Bool `tfsdk:"is_truncated"`
	// Row count of the result
	RowCount types.Int64 `tfsdk:"row_count"`
	// Statement Execution API statement id. Use [Get status, manifest, and
	// result first chunk](:method:statementexecution/getstatement) to get the
	// full result data.
	StatementId types.String `tfsdk:"statement_id"`
	// JWT corresponding to the statement contained in this result
	StatementIdSignature types.String `tfsdk:"statement_id_signature"`
}

func (to *Result) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Result) {
}

func (to *Result) SyncFieldsDuringRead(ctx context.Context, from Result) {
}

func (m Result) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_truncated"] = attrs["is_truncated"].SetOptional()
	attrs["row_count"] = attrs["row_count"].SetOptional()
	attrs["statement_id"] = attrs["statement_id"].SetOptional()
	attrs["statement_id_signature"] = attrs["statement_id_signature"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Result.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Result) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Result
// only implements ToObjectValue() and Type().
func (m Result) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_truncated":           m.IsTruncated,
			"row_count":              m.RowCount,
			"statement_id":           m.StatementId,
			"statement_id_signature": m.StatementIdSignature,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Result) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_truncated":           types.BoolType,
			"row_count":              types.Int64Type,
			"statement_id":           types.StringType,
			"statement_id_signature": types.StringType,
		},
	}
}

type Schedule struct {
	// A timestamp indicating when the schedule was created.
	CreateTime types.String `tfsdk:"create_time"`
	// The cron expression describing the frequency of the periodic refresh for
	// this schedule.
	CronSchedule types.Object `tfsdk:"cron_schedule"`
	// UUID identifying the dashboard to which the schedule belongs.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// The display name for schedule.
	DisplayName types.String `tfsdk:"display_name"`
	// The etag for the schedule. Must be left empty on create, must be provided
	// on updates to ensure that the schedule has not been modified since the
	// last read, and can be optionally provided on delete.
	Etag types.String `tfsdk:"etag"`
	// The status indicates whether this schedule is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// UUID identifying the schedule.
	ScheduleId types.String `tfsdk:"schedule_id"`
	// A timestamp indicating when the schedule was last updated.
	UpdateTime types.String `tfsdk:"update_time"`
	// The warehouse id to run the dashboard with for the schedule.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *Schedule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Schedule) {
	if !from.CronSchedule.IsNull() && !from.CronSchedule.IsUnknown() {
		if toCronSchedule, ok := to.GetCronSchedule(ctx); ok {
			if fromCronSchedule, ok := from.GetCronSchedule(ctx); ok {
				// Recursively sync the fields of CronSchedule
				toCronSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromCronSchedule)
				to.SetCronSchedule(ctx, toCronSchedule)
			}
		}
	}
}

func (to *Schedule) SyncFieldsDuringRead(ctx context.Context, from Schedule) {
	if !from.CronSchedule.IsNull() && !from.CronSchedule.IsUnknown() {
		if toCronSchedule, ok := to.GetCronSchedule(ctx); ok {
			if fromCronSchedule, ok := from.GetCronSchedule(ctx); ok {
				toCronSchedule.SyncFieldsDuringRead(ctx, fromCronSchedule)
				to.SetCronSchedule(ctx, toCronSchedule)
			}
		}
	}
}

func (m Schedule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["create_time"] = attrs["create_time"].SetComputed()
	attrs["cron_schedule"] = attrs["cron_schedule"].SetRequired()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["etag"] = attrs["etag"].SetComputed()
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["schedule_id"] = attrs["schedule_id"].SetComputed()
	attrs["update_time"] = attrs["update_time"].SetComputed()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Schedule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Schedule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"cron_schedule": reflect.TypeOf(CronSchedule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Schedule
// only implements ToObjectValue() and Type().
func (m Schedule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"create_time":   m.CreateTime,
			"cron_schedule": m.CronSchedule,
			"dashboard_id":  m.DashboardId,
			"display_name":  m.DisplayName,
			"etag":          m.Etag,
			"pause_status":  m.PauseStatus,
			"schedule_id":   m.ScheduleId,
			"update_time":   m.UpdateTime,
			"warehouse_id":  m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Schedule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"create_time":   types.StringType,
			"cron_schedule": CronSchedule{}.Type(ctx),
			"dashboard_id":  types.StringType,
			"display_name":  types.StringType,
			"etag":          types.StringType,
			"pause_status":  types.StringType,
			"schedule_id":   types.StringType,
			"update_time":   types.StringType,
			"warehouse_id":  types.StringType,
		},
	}
}

// GetCronSchedule returns the value of the CronSchedule field in Schedule as
// a CronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *Schedule) GetCronSchedule(ctx context.Context) (CronSchedule, bool) {
	var e CronSchedule
	if m.CronSchedule.IsNull() || m.CronSchedule.IsUnknown() {
		return e, false
	}
	var v CronSchedule
	d := m.CronSchedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCronSchedule sets the value of the CronSchedule field in Schedule.
func (m *Schedule) SetCronSchedule(ctx context.Context, v CronSchedule) {
	vs := v.ToObjectValue(ctx)
	m.CronSchedule = vs
}

type Subscriber struct {
	// The destination to receive the subscription email. This parameter is
	// mutually exclusive with `user_subscriber`.
	DestinationSubscriber types.Object `tfsdk:"destination_subscriber"`
	// The user to receive the subscription email. This parameter is mutually
	// exclusive with `destination_subscriber`.
	UserSubscriber types.Object `tfsdk:"user_subscriber"`
}

func (to *Subscriber) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Subscriber) {
	if !from.DestinationSubscriber.IsNull() && !from.DestinationSubscriber.IsUnknown() {
		if toDestinationSubscriber, ok := to.GetDestinationSubscriber(ctx); ok {
			if fromDestinationSubscriber, ok := from.GetDestinationSubscriber(ctx); ok {
				// Recursively sync the fields of DestinationSubscriber
				toDestinationSubscriber.SyncFieldsDuringCreateOrUpdate(ctx, fromDestinationSubscriber)
				to.SetDestinationSubscriber(ctx, toDestinationSubscriber)
			}
		}
	}
	if !from.UserSubscriber.IsNull() && !from.UserSubscriber.IsUnknown() {
		if toUserSubscriber, ok := to.GetUserSubscriber(ctx); ok {
			if fromUserSubscriber, ok := from.GetUserSubscriber(ctx); ok {
				// Recursively sync the fields of UserSubscriber
				toUserSubscriber.SyncFieldsDuringCreateOrUpdate(ctx, fromUserSubscriber)
				to.SetUserSubscriber(ctx, toUserSubscriber)
			}
		}
	}
}

func (to *Subscriber) SyncFieldsDuringRead(ctx context.Context, from Subscriber) {
	if !from.DestinationSubscriber.IsNull() && !from.DestinationSubscriber.IsUnknown() {
		if toDestinationSubscriber, ok := to.GetDestinationSubscriber(ctx); ok {
			if fromDestinationSubscriber, ok := from.GetDestinationSubscriber(ctx); ok {
				toDestinationSubscriber.SyncFieldsDuringRead(ctx, fromDestinationSubscriber)
				to.SetDestinationSubscriber(ctx, toDestinationSubscriber)
			}
		}
	}
	if !from.UserSubscriber.IsNull() && !from.UserSubscriber.IsUnknown() {
		if toUserSubscriber, ok := to.GetUserSubscriber(ctx); ok {
			if fromUserSubscriber, ok := from.GetUserSubscriber(ctx); ok {
				toUserSubscriber.SyncFieldsDuringRead(ctx, fromUserSubscriber)
				to.SetUserSubscriber(ctx, toUserSubscriber)
			}
		}
	}
}

func (m Subscriber) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_subscriber"] = attrs["destination_subscriber"].SetOptional()
	attrs["user_subscriber"] = attrs["user_subscriber"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Subscriber.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Subscriber) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"destination_subscriber": reflect.TypeOf(SubscriptionSubscriberDestination{}),
		"user_subscriber":        reflect.TypeOf(SubscriptionSubscriberUser{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Subscriber
// only implements ToObjectValue() and Type().
func (m Subscriber) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_subscriber": m.DestinationSubscriber,
			"user_subscriber":        m.UserSubscriber,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Subscriber) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_subscriber": SubscriptionSubscriberDestination{}.Type(ctx),
			"user_subscriber":        SubscriptionSubscriberUser{}.Type(ctx),
		},
	}
}

// GetDestinationSubscriber returns the value of the DestinationSubscriber field in Subscriber as
// a SubscriptionSubscriberDestination value.
// If the field is unknown or null, the boolean return value is false.
func (m *Subscriber) GetDestinationSubscriber(ctx context.Context) (SubscriptionSubscriberDestination, bool) {
	var e SubscriptionSubscriberDestination
	if m.DestinationSubscriber.IsNull() || m.DestinationSubscriber.IsUnknown() {
		return e, false
	}
	var v SubscriptionSubscriberDestination
	d := m.DestinationSubscriber.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDestinationSubscriber sets the value of the DestinationSubscriber field in Subscriber.
func (m *Subscriber) SetDestinationSubscriber(ctx context.Context, v SubscriptionSubscriberDestination) {
	vs := v.ToObjectValue(ctx)
	m.DestinationSubscriber = vs
}

// GetUserSubscriber returns the value of the UserSubscriber field in Subscriber as
// a SubscriptionSubscriberUser value.
// If the field is unknown or null, the boolean return value is false.
func (m *Subscriber) GetUserSubscriber(ctx context.Context) (SubscriptionSubscriberUser, bool) {
	var e SubscriptionSubscriberUser
	if m.UserSubscriber.IsNull() || m.UserSubscriber.IsUnknown() {
		return e, false
	}
	var v SubscriptionSubscriberUser
	d := m.UserSubscriber.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetUserSubscriber sets the value of the UserSubscriber field in Subscriber.
func (m *Subscriber) SetUserSubscriber(ctx context.Context, v SubscriptionSubscriberUser) {
	vs := v.ToObjectValue(ctx)
	m.UserSubscriber = vs
}

type Subscription struct {
	// A timestamp indicating when the subscription was created.
	CreateTime types.String `tfsdk:"create_time"`
	// UserId of the user who adds subscribers (users or notification
	// destinations) to the dashboard's schedule.
	CreatedByUserId types.Int64 `tfsdk:"created_by_user_id"`
	// UUID identifying the dashboard to which the subscription belongs.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// The etag for the subscription. Must be left empty on create, can be
	// optionally provided on delete to ensure that the subscription has not
	// been deleted since the last read.
	Etag types.String `tfsdk:"etag"`
	// UUID identifying the schedule to which the subscription belongs.
	ScheduleId types.String `tfsdk:"schedule_id"`
	// Subscriber details for users and destinations to be added as subscribers
	// to the schedule.
	Subscriber types.Object `tfsdk:"subscriber"`
	// UUID identifying the subscription.
	SubscriptionId types.String `tfsdk:"subscription_id"`
	// A timestamp indicating when the subscription was last updated.
	UpdateTime types.String `tfsdk:"update_time"`
}

func (to *Subscription) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Subscription) {
	if !from.Subscriber.IsNull() && !from.Subscriber.IsUnknown() {
		if toSubscriber, ok := to.GetSubscriber(ctx); ok {
			if fromSubscriber, ok := from.GetSubscriber(ctx); ok {
				// Recursively sync the fields of Subscriber
				toSubscriber.SyncFieldsDuringCreateOrUpdate(ctx, fromSubscriber)
				to.SetSubscriber(ctx, toSubscriber)
			}
		}
	}
}

func (to *Subscription) SyncFieldsDuringRead(ctx context.Context, from Subscription) {
	if !from.Subscriber.IsNull() && !from.Subscriber.IsUnknown() {
		if toSubscriber, ok := to.GetSubscriber(ctx); ok {
			if fromSubscriber, ok := from.GetSubscriber(ctx); ok {
				toSubscriber.SyncFieldsDuringRead(ctx, fromSubscriber)
				to.SetSubscriber(ctx, toSubscriber)
			}
		}
	}
}

func (m Subscription) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["create_time"] = attrs["create_time"].SetComputed()
	attrs["created_by_user_id"] = attrs["created_by_user_id"].SetComputed()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["etag"] = attrs["etag"].SetComputed()
	attrs["schedule_id"] = attrs["schedule_id"].SetComputed()
	attrs["subscriber"] = attrs["subscriber"].SetRequired()
	attrs["subscription_id"] = attrs["subscription_id"].SetComputed()
	attrs["update_time"] = attrs["update_time"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Subscription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Subscription) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscriber": reflect.TypeOf(Subscriber{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Subscription
// only implements ToObjectValue() and Type().
func (m Subscription) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"create_time":        m.CreateTime,
			"created_by_user_id": m.CreatedByUserId,
			"dashboard_id":       m.DashboardId,
			"etag":               m.Etag,
			"schedule_id":        m.ScheduleId,
			"subscriber":         m.Subscriber,
			"subscription_id":    m.SubscriptionId,
			"update_time":        m.UpdateTime,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Subscription) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"create_time":        types.StringType,
			"created_by_user_id": types.Int64Type,
			"dashboard_id":       types.StringType,
			"etag":               types.StringType,
			"schedule_id":        types.StringType,
			"subscriber":         Subscriber{}.Type(ctx),
			"subscription_id":    types.StringType,
			"update_time":        types.StringType,
		},
	}
}

// GetSubscriber returns the value of the Subscriber field in Subscription as
// a Subscriber value.
// If the field is unknown or null, the boolean return value is false.
func (m *Subscription) GetSubscriber(ctx context.Context) (Subscriber, bool) {
	var e Subscriber
	if m.Subscriber.IsNull() || m.Subscriber.IsUnknown() {
		return e, false
	}
	var v Subscriber
	d := m.Subscriber.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscriber sets the value of the Subscriber field in Subscription.
func (m *Subscription) SetSubscriber(ctx context.Context, v Subscriber) {
	vs := v.ToObjectValue(ctx)
	m.Subscriber = vs
}

type SubscriptionSubscriberDestination struct {
	// The canonical identifier of the destination to receive email
	// notification.
	DestinationId types.String `tfsdk:"destination_id"`
}

func (to *SubscriptionSubscriberDestination) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubscriptionSubscriberDestination) {
}

func (to *SubscriptionSubscriberDestination) SyncFieldsDuringRead(ctx context.Context, from SubscriptionSubscriberDestination) {
}

func (m SubscriptionSubscriberDestination) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubscriptionSubscriberDestination.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubscriptionSubscriberDestination) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubscriptionSubscriberDestination
// only implements ToObjectValue() and Type().
func (m SubscriptionSubscriberDestination) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id": m.DestinationId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubscriptionSubscriberDestination) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id": types.StringType,
		},
	}
}

type SubscriptionSubscriberUser struct {
	// UserId of the subscriber.
	UserId types.Int64 `tfsdk:"user_id"`
}

func (to *SubscriptionSubscriberUser) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubscriptionSubscriberUser) {
}

func (to *SubscriptionSubscriberUser) SyncFieldsDuringRead(ctx context.Context, from SubscriptionSubscriberUser) {
}

func (m SubscriptionSubscriberUser) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["user_id"] = attrs["user_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubscriptionSubscriberUser.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubscriptionSubscriberUser) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubscriptionSubscriberUser
// only implements ToObjectValue() and Type().
func (m SubscriptionSubscriberUser) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"user_id": m.UserId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubscriptionSubscriberUser) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"user_id": types.Int64Type,
		},
	}
}

type TextAttachment struct {
	// AI generated message
	Content types.String `tfsdk:"content"`

	Id types.String `tfsdk:"id"`
}

func (to *TextAttachment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TextAttachment) {
}

func (to *TextAttachment) SyncFieldsDuringRead(ctx context.Context, from TextAttachment) {
}

func (m TextAttachment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["content"] = attrs["content"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TextAttachment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TextAttachment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TextAttachment
// only implements ToObjectValue() and Type().
func (m TextAttachment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"content": m.Content,
			"id":      m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TextAttachment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"content": types.StringType,
			"id":      types.StringType,
		},
	}
}

type TrashDashboardRequest struct {
	// UUID identifying the dashboard.
	DashboardId types.String `tfsdk:"-"`
}

func (to *TrashDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TrashDashboardRequest) {
}

func (to *TrashDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from TrashDashboardRequest) {
}

func (m TrashDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TrashDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TrashDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TrashDashboardRequest
// only implements ToObjectValue() and Type().
func (m TrashDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TrashDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
		},
	}
}

type TrashDashboardResponse struct {
}

func (to *TrashDashboardResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TrashDashboardResponse) {
}

func (to *TrashDashboardResponse) SyncFieldsDuringRead(ctx context.Context, from TrashDashboardResponse) {
}

func (m TrashDashboardResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TrashDashboardResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TrashDashboardResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TrashDashboardResponse
// only implements ToObjectValue() and Type().
func (m TrashDashboardResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m TrashDashboardResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UnpublishDashboardRequest struct {
	// UUID identifying the published dashboard.
	DashboardId types.String `tfsdk:"-"`
}

func (to *UnpublishDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UnpublishDashboardRequest) {
}

func (to *UnpublishDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from UnpublishDashboardRequest) {
}

func (m UnpublishDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UnpublishDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UnpublishDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UnpublishDashboardRequest
// only implements ToObjectValue() and Type().
func (m UnpublishDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UnpublishDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
		},
	}
}

type UnpublishDashboardResponse struct {
}

func (to *UnpublishDashboardResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UnpublishDashboardResponse) {
}

func (to *UnpublishDashboardResponse) SyncFieldsDuringRead(ctx context.Context, from UnpublishDashboardResponse) {
}

func (m UnpublishDashboardResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UnpublishDashboardResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UnpublishDashboardResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UnpublishDashboardResponse
// only implements ToObjectValue() and Type().
func (m UnpublishDashboardResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (m UnpublishDashboardResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type UpdateDashboardRequest struct {
	Dashboard types.Object `tfsdk:"dashboard"`
	// UUID identifying the dashboard.
	DashboardId types.String `tfsdk:"-"`
}

func (to *UpdateDashboardRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateDashboardRequest) {
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				// Recursively sync the fields of Dashboard
				toDashboard.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
}

func (to *UpdateDashboardRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateDashboardRequest) {
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				toDashboard.SyncFieldsDuringRead(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
}

func (m UpdateDashboardRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard"] = attrs["dashboard"].SetRequired()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateDashboardRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateDashboardRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dashboard": reflect.TypeOf(Dashboard{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateDashboardRequest
// only implements ToObjectValue() and Type().
func (m UpdateDashboardRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard":    m.Dashboard,
			"dashboard_id": m.DashboardId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateDashboardRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard":    Dashboard{}.Type(ctx),
			"dashboard_id": types.StringType,
		},
	}
}

// GetDashboard returns the value of the Dashboard field in UpdateDashboardRequest as
// a Dashboard value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateDashboardRequest) GetDashboard(ctx context.Context) (Dashboard, bool) {
	var e Dashboard
	if m.Dashboard.IsNull() || m.Dashboard.IsUnknown() {
		return e, false
	}
	var v Dashboard
	d := m.Dashboard.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboard sets the value of the Dashboard field in UpdateDashboardRequest.
func (m *UpdateDashboardRequest) SetDashboard(ctx context.Context, v Dashboard) {
	vs := v.ToObjectValue(ctx)
	m.Dashboard = vs
}

type UpdateScheduleRequest struct {
	// UUID identifying the dashboard to which the schedule belongs.
	DashboardId types.String `tfsdk:"-"`
	// The schedule to update.
	Schedule types.Object `tfsdk:"schedule"`
	// UUID identifying the schedule.
	ScheduleId types.String `tfsdk:"-"`
}

func (to *UpdateScheduleRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateScheduleRequest) {
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
}

func (to *UpdateScheduleRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateScheduleRequest) {
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
}

func (m UpdateScheduleRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["schedule"] = attrs["schedule"].SetRequired()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["schedule_id"] = attrs["schedule_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateScheduleRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateScheduleRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"schedule": reflect.TypeOf(Schedule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateScheduleRequest
// only implements ToObjectValue() and Type().
func (m UpdateScheduleRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"schedule":     m.Schedule,
			"schedule_id":  m.ScheduleId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateScheduleRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"schedule":     Schedule{}.Type(ctx),
			"schedule_id":  types.StringType,
		},
	}
}

// GetSchedule returns the value of the Schedule field in UpdateScheduleRequest as
// a Schedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateScheduleRequest) GetSchedule(ctx context.Context) (Schedule, bool) {
	var e Schedule
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v Schedule
	d := m.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in UpdateScheduleRequest.
func (m *UpdateScheduleRequest) SetSchedule(ctx context.Context, v Schedule) {
	vs := v.ToObjectValue(ctx)
	m.Schedule = vs
}
