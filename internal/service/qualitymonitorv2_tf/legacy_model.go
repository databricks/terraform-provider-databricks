// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package qualitymonitorv2_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type AnomalyDetectionConfig_SdkV2 struct {
	// List of fully qualified table names to exclude from anomaly detection.
	ExcludedTableFullNames types.List `tfsdk:"excluded_table_full_names"`
	// Run id of the last run of the workflow
	LastRunId types.String `tfsdk:"last_run_id"`
	// The status of the last run of the workflow.
	LatestRunStatus types.String `tfsdk:"latest_run_status"`
}

func (to *AnomalyDetectionConfig_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AnomalyDetectionConfig_SdkV2) {
	if !from.ExcludedTableFullNames.IsNull() && !from.ExcludedTableFullNames.IsUnknown() && to.ExcludedTableFullNames.IsNull() && len(from.ExcludedTableFullNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExcludedTableFullNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExcludedTableFullNames = from.ExcludedTableFullNames
	}
}

func (to *AnomalyDetectionConfig_SdkV2) SyncFieldsDuringRead(ctx context.Context, from AnomalyDetectionConfig_SdkV2) {
	if !from.ExcludedTableFullNames.IsNull() && !from.ExcludedTableFullNames.IsUnknown() && to.ExcludedTableFullNames.IsNull() && len(from.ExcludedTableFullNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ExcludedTableFullNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ExcludedTableFullNames = from.ExcludedTableFullNames
	}
}

func (m AnomalyDetectionConfig_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["excluded_table_full_names"] = attrs["excluded_table_full_names"].SetOptional()
	attrs["last_run_id"] = attrs["last_run_id"].SetComputed()
	attrs["latest_run_status"] = attrs["latest_run_status"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AnomalyDetectionConfig.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m AnomalyDetectionConfig_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"excluded_table_full_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AnomalyDetectionConfig_SdkV2
// only implements ToObjectValue() and Type().
func (m AnomalyDetectionConfig_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"excluded_table_full_names": m.ExcludedTableFullNames,
			"last_run_id":               m.LastRunId,
			"latest_run_status":         m.LatestRunStatus,
		})
}

// Type implements basetypes.ObjectValuable.
func (m AnomalyDetectionConfig_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"excluded_table_full_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"last_run_id":       types.StringType,
			"latest_run_status": types.StringType,
		},
	}
}

// GetExcludedTableFullNames returns the value of the ExcludedTableFullNames field in AnomalyDetectionConfig_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *AnomalyDetectionConfig_SdkV2) GetExcludedTableFullNames(ctx context.Context) ([]types.String, bool) {
	if m.ExcludedTableFullNames.IsNull() || m.ExcludedTableFullNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ExcludedTableFullNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetExcludedTableFullNames sets the value of the ExcludedTableFullNames field in AnomalyDetectionConfig_SdkV2.
func (m *AnomalyDetectionConfig_SdkV2) SetExcludedTableFullNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["excluded_table_full_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ExcludedTableFullNames = types.ListValueMust(t, vs)
}

type CreateQualityMonitorRequest_SdkV2 struct {
	QualityMonitor types.List `tfsdk:"quality_monitor"`
}

func (to *CreateQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateQualityMonitorRequest_SdkV2) {
	if !from.QualityMonitor.IsNull() && !from.QualityMonitor.IsUnknown() {
		if toQualityMonitor, ok := to.GetQualityMonitor(ctx); ok {
			if fromQualityMonitor, ok := from.GetQualityMonitor(ctx); ok {
				// Recursively sync the fields of QualityMonitor
				toQualityMonitor.SyncFieldsDuringCreateOrUpdate(ctx, fromQualityMonitor)
				to.SetQualityMonitor(ctx, toQualityMonitor)
			}
		}
	}
}

func (to *CreateQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from CreateQualityMonitorRequest_SdkV2) {
	if !from.QualityMonitor.IsNull() && !from.QualityMonitor.IsUnknown() {
		if toQualityMonitor, ok := to.GetQualityMonitor(ctx); ok {
			if fromQualityMonitor, ok := from.GetQualityMonitor(ctx); ok {
				toQualityMonitor.SyncFieldsDuringRead(ctx, fromQualityMonitor)
				to.SetQualityMonitor(ctx, toQualityMonitor)
			}
		}
	}
}

func (m CreateQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["quality_monitor"] = attrs["quality_monitor"].SetRequired()
	attrs["quality_monitor"] = attrs["quality_monitor"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quality_monitor": reflect.TypeOf(QualityMonitor_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m CreateQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"quality_monitor": m.QualityMonitor,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"quality_monitor": basetypes.ListType{
				ElemType: QualityMonitor_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetQualityMonitor returns the value of the QualityMonitor field in CreateQualityMonitorRequest_SdkV2 as
// a QualityMonitor_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateQualityMonitorRequest_SdkV2) GetQualityMonitor(ctx context.Context) (QualityMonitor_SdkV2, bool) {
	var e QualityMonitor_SdkV2
	if m.QualityMonitor.IsNull() || m.QualityMonitor.IsUnknown() {
		return e, false
	}
	var v []QualityMonitor_SdkV2
	d := m.QualityMonitor.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQualityMonitor sets the value of the QualityMonitor field in CreateQualityMonitorRequest_SdkV2.
func (m *CreateQualityMonitorRequest_SdkV2) SetQualityMonitor(ctx context.Context, v QualityMonitor_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["quality_monitor"]
	m.QualityMonitor = types.ListValueMust(t, vs)
}

type DeleteQualityMonitorRequest_SdkV2 struct {
	// The uuid of the request object. For example, schema id.
	ObjectId types.String `tfsdk:"-"`
	// The type of the monitored object. Can be one of the following: schema.
	ObjectType types.String `tfsdk:"-"`
}

func (to *DeleteQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteQualityMonitorRequest_SdkV2) {
}

func (to *DeleteQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from DeleteQualityMonitorRequest_SdkV2) {
}

func (m DeleteQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["object_type"] = attrs["object_type"].SetRequired()
	attrs["object_id"] = attrs["object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m DeleteQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"object_id":   m.ObjectId,
			"object_type": m.ObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"object_id":   types.StringType,
			"object_type": types.StringType,
		},
	}
}

type GetQualityMonitorRequest_SdkV2 struct {
	// The uuid of the request object. For example, schema id.
	ObjectId types.String `tfsdk:"-"`
	// The type of the monitored object. Can be one of the following: schema.
	ObjectType types.String `tfsdk:"-"`
}

func (to *GetQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetQualityMonitorRequest_SdkV2) {
}

func (to *GetQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from GetQualityMonitorRequest_SdkV2) {
}

func (m GetQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["object_type"] = attrs["object_type"].SetRequired()
	attrs["object_id"] = attrs["object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m GetQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"object_id":   m.ObjectId,
			"object_type": m.ObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"object_id":   types.StringType,
			"object_type": types.StringType,
		},
	}
}

type ListQualityMonitorRequest_SdkV2 struct {
	PageSize types.Int64 `tfsdk:"-"`

	PageToken types.String `tfsdk:"-"`
}

func (to *ListQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListQualityMonitorRequest_SdkV2) {
}

func (to *ListQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListQualityMonitorRequest_SdkV2) {
}

func (m ListQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["page_size"] = attrs["page_size"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m ListQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":  m.PageSize,
			"page_token": m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

type ListQualityMonitorResponse_SdkV2 struct {
	NextPageToken types.String `tfsdk:"next_page_token"`

	QualityMonitors types.List `tfsdk:"quality_monitors"`
}

func (to *ListQualityMonitorResponse_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListQualityMonitorResponse_SdkV2) {
	if !from.QualityMonitors.IsNull() && !from.QualityMonitors.IsUnknown() && to.QualityMonitors.IsNull() && len(from.QualityMonitors.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for QualityMonitors, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.QualityMonitors = from.QualityMonitors
	}
}

func (to *ListQualityMonitorResponse_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ListQualityMonitorResponse_SdkV2) {
	if !from.QualityMonitors.IsNull() && !from.QualityMonitors.IsUnknown() && to.QualityMonitors.IsNull() && len(from.QualityMonitors.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for QualityMonitors, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.QualityMonitors = from.QualityMonitors
	}
}

func (m ListQualityMonitorResponse_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["quality_monitors"] = attrs["quality_monitors"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListQualityMonitorResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListQualityMonitorResponse_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quality_monitors": reflect.TypeOf(QualityMonitor_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListQualityMonitorResponse_SdkV2
// only implements ToObjectValue() and Type().
func (m ListQualityMonitorResponse_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"next_page_token":  m.NextPageToken,
			"quality_monitors": m.QualityMonitors,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListQualityMonitorResponse_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"next_page_token": types.StringType,
			"quality_monitors": basetypes.ListType{
				ElemType: QualityMonitor_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetQualityMonitors returns the value of the QualityMonitors field in ListQualityMonitorResponse_SdkV2 as
// a slice of QualityMonitor_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListQualityMonitorResponse_SdkV2) GetQualityMonitors(ctx context.Context) ([]QualityMonitor_SdkV2, bool) {
	if m.QualityMonitors.IsNull() || m.QualityMonitors.IsUnknown() {
		return nil, false
	}
	var v []QualityMonitor_SdkV2
	d := m.QualityMonitors.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQualityMonitors sets the value of the QualityMonitors field in ListQualityMonitorResponse_SdkV2.
func (m *ListQualityMonitorResponse_SdkV2) SetQualityMonitors(ctx context.Context, v []QualityMonitor_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["quality_monitors"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.QualityMonitors = types.ListValueMust(t, vs)
}

type PercentNullValidityCheck_SdkV2 struct {
	// List of column names to check for null percentage
	ColumnNames types.List `tfsdk:"column_names"`
	// Optional upper bound; we should use auto determined bounds for now
	UpperBound types.Float64 `tfsdk:"upper_bound"`
}

func (to *PercentNullValidityCheck_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PercentNullValidityCheck_SdkV2) {
	if !from.ColumnNames.IsNull() && !from.ColumnNames.IsUnknown() && to.ColumnNames.IsNull() && len(from.ColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ColumnNames = from.ColumnNames
	}
}

func (to *PercentNullValidityCheck_SdkV2) SyncFieldsDuringRead(ctx context.Context, from PercentNullValidityCheck_SdkV2) {
	if !from.ColumnNames.IsNull() && !from.ColumnNames.IsUnknown() && to.ColumnNames.IsNull() && len(from.ColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ColumnNames = from.ColumnNames
	}
}

func (m PercentNullValidityCheck_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["column_names"] = attrs["column_names"].SetOptional()
	attrs["upper_bound"] = attrs["upper_bound"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PercentNullValidityCheck.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PercentNullValidityCheck_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PercentNullValidityCheck_SdkV2
// only implements ToObjectValue() and Type().
func (m PercentNullValidityCheck_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"column_names": m.ColumnNames,
			"upper_bound":  m.UpperBound,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PercentNullValidityCheck_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"upper_bound": types.Float64Type,
		},
	}
}

// GetColumnNames returns the value of the ColumnNames field in PercentNullValidityCheck_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PercentNullValidityCheck_SdkV2) GetColumnNames(ctx context.Context) ([]types.String, bool) {
	if m.ColumnNames.IsNull() || m.ColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumnNames sets the value of the ColumnNames field in PercentNullValidityCheck_SdkV2.
func (m *PercentNullValidityCheck_SdkV2) SetColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ColumnNames = types.ListValueMust(t, vs)
}

type QualityMonitor_SdkV2 struct {
	AnomalyDetectionConfig types.List `tfsdk:"anomaly_detection_config"`
	// The uuid of the request object. For example, schema id.
	ObjectId types.String `tfsdk:"object_id"`
	// The type of the monitored object. Can be one of the following: schema.
	ObjectType types.String `tfsdk:"object_type"`
	// Validity check configurations for anomaly detection.
	ValidityCheckConfigurations types.List `tfsdk:"validity_check_configurations"`
}

func (to *QualityMonitor_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from QualityMonitor_SdkV2) {
	if !from.AnomalyDetectionConfig.IsNull() && !from.AnomalyDetectionConfig.IsUnknown() {
		if toAnomalyDetectionConfig, ok := to.GetAnomalyDetectionConfig(ctx); ok {
			if fromAnomalyDetectionConfig, ok := from.GetAnomalyDetectionConfig(ctx); ok {
				// Recursively sync the fields of AnomalyDetectionConfig
				toAnomalyDetectionConfig.SyncFieldsDuringCreateOrUpdate(ctx, fromAnomalyDetectionConfig)
				to.SetAnomalyDetectionConfig(ctx, toAnomalyDetectionConfig)
			}
		}
	}
	if !from.ValidityCheckConfigurations.IsUnknown() && !from.ValidityCheckConfigurations.IsNull() {
		// ValidityCheckConfigurations is an input only field and not returned by the service, so we keep the value from the prior state.
		to.ValidityCheckConfigurations = from.ValidityCheckConfigurations
	}
	if !from.ValidityCheckConfigurations.IsNull() && !from.ValidityCheckConfigurations.IsUnknown() && to.ValidityCheckConfigurations.IsNull() && len(from.ValidityCheckConfigurations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ValidityCheckConfigurations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ValidityCheckConfigurations = from.ValidityCheckConfigurations
	}
}

func (to *QualityMonitor_SdkV2) SyncFieldsDuringRead(ctx context.Context, from QualityMonitor_SdkV2) {
	if !from.AnomalyDetectionConfig.IsNull() && !from.AnomalyDetectionConfig.IsUnknown() {
		if toAnomalyDetectionConfig, ok := to.GetAnomalyDetectionConfig(ctx); ok {
			if fromAnomalyDetectionConfig, ok := from.GetAnomalyDetectionConfig(ctx); ok {
				toAnomalyDetectionConfig.SyncFieldsDuringRead(ctx, fromAnomalyDetectionConfig)
				to.SetAnomalyDetectionConfig(ctx, toAnomalyDetectionConfig)
			}
		}
	}
	if !from.ValidityCheckConfigurations.IsUnknown() && !from.ValidityCheckConfigurations.IsNull() {
		// ValidityCheckConfigurations is an input only field and not returned by the service, so we keep the value from the prior state.
		to.ValidityCheckConfigurations = from.ValidityCheckConfigurations
	}
	if !from.ValidityCheckConfigurations.IsNull() && !from.ValidityCheckConfigurations.IsUnknown() && to.ValidityCheckConfigurations.IsNull() && len(from.ValidityCheckConfigurations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ValidityCheckConfigurations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ValidityCheckConfigurations = from.ValidityCheckConfigurations
	}
}

func (m QualityMonitor_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["anomaly_detection_config"] = attrs["anomaly_detection_config"].SetComputed()
	attrs["anomaly_detection_config"] = attrs["anomaly_detection_config"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["object_id"] = attrs["object_id"].SetRequired()
	attrs["object_type"] = attrs["object_type"].SetRequired()
	attrs["validity_check_configurations"] = attrs["validity_check_configurations"].SetOptional()
	attrs["validity_check_configurations"] = attrs["validity_check_configurations"].SetComputed()
	attrs["validity_check_configurations"] = attrs["validity_check_configurations"].(tfschema.ListNestedAttributeBuilder).AddPlanModifier(listplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QualityMonitor.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m QualityMonitor_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"anomaly_detection_config":      reflect.TypeOf(AnomalyDetectionConfig_SdkV2{}),
		"validity_check_configurations": reflect.TypeOf(ValidityCheckConfiguration_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QualityMonitor_SdkV2
// only implements ToObjectValue() and Type().
func (m QualityMonitor_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"anomaly_detection_config":      m.AnomalyDetectionConfig,
			"object_id":                     m.ObjectId,
			"object_type":                   m.ObjectType,
			"validity_check_configurations": m.ValidityCheckConfigurations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m QualityMonitor_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"anomaly_detection_config": basetypes.ListType{
				ElemType: AnomalyDetectionConfig_SdkV2{}.Type(ctx),
			},
			"object_id":   types.StringType,
			"object_type": types.StringType,
			"validity_check_configurations": basetypes.ListType{
				ElemType: ValidityCheckConfiguration_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetAnomalyDetectionConfig returns the value of the AnomalyDetectionConfig field in QualityMonitor_SdkV2 as
// a AnomalyDetectionConfig_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *QualityMonitor_SdkV2) GetAnomalyDetectionConfig(ctx context.Context) (AnomalyDetectionConfig_SdkV2, bool) {
	var e AnomalyDetectionConfig_SdkV2
	if m.AnomalyDetectionConfig.IsNull() || m.AnomalyDetectionConfig.IsUnknown() {
		return e, false
	}
	var v []AnomalyDetectionConfig_SdkV2
	d := m.AnomalyDetectionConfig.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetAnomalyDetectionConfig sets the value of the AnomalyDetectionConfig field in QualityMonitor_SdkV2.
func (m *QualityMonitor_SdkV2) SetAnomalyDetectionConfig(ctx context.Context, v AnomalyDetectionConfig_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["anomaly_detection_config"]
	m.AnomalyDetectionConfig = types.ListValueMust(t, vs)
}

// GetValidityCheckConfigurations returns the value of the ValidityCheckConfigurations field in QualityMonitor_SdkV2 as
// a slice of ValidityCheckConfiguration_SdkV2 values.
// If the field is unknown or null, the boolean return value is false.
func (m *QualityMonitor_SdkV2) GetValidityCheckConfigurations(ctx context.Context) ([]ValidityCheckConfiguration_SdkV2, bool) {
	if m.ValidityCheckConfigurations.IsNull() || m.ValidityCheckConfigurations.IsUnknown() {
		return nil, false
	}
	var v []ValidityCheckConfiguration_SdkV2
	d := m.ValidityCheckConfigurations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetValidityCheckConfigurations sets the value of the ValidityCheckConfigurations field in QualityMonitor_SdkV2.
func (m *QualityMonitor_SdkV2) SetValidityCheckConfigurations(ctx context.Context, v []ValidityCheckConfiguration_SdkV2) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["validity_check_configurations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ValidityCheckConfigurations = types.ListValueMust(t, vs)
}

type RangeValidityCheck_SdkV2 struct {
	// List of column names to check for range validity
	ColumnNames types.List `tfsdk:"column_names"`
	// Lower bound for the range
	LowerBound types.Float64 `tfsdk:"lower_bound"`
	// Upper bound for the range
	UpperBound types.Float64 `tfsdk:"upper_bound"`
}

func (to *RangeValidityCheck_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RangeValidityCheck_SdkV2) {
	if !from.ColumnNames.IsNull() && !from.ColumnNames.IsUnknown() && to.ColumnNames.IsNull() && len(from.ColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ColumnNames = from.ColumnNames
	}
}

func (to *RangeValidityCheck_SdkV2) SyncFieldsDuringRead(ctx context.Context, from RangeValidityCheck_SdkV2) {
	if !from.ColumnNames.IsNull() && !from.ColumnNames.IsUnknown() && to.ColumnNames.IsNull() && len(from.ColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ColumnNames = from.ColumnNames
	}
}

func (m RangeValidityCheck_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["column_names"] = attrs["column_names"].SetOptional()
	attrs["lower_bound"] = attrs["lower_bound"].SetOptional()
	attrs["upper_bound"] = attrs["upper_bound"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RangeValidityCheck.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RangeValidityCheck_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RangeValidityCheck_SdkV2
// only implements ToObjectValue() and Type().
func (m RangeValidityCheck_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"column_names": m.ColumnNames,
			"lower_bound":  m.LowerBound,
			"upper_bound":  m.UpperBound,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RangeValidityCheck_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"lower_bound": types.Float64Type,
			"upper_bound": types.Float64Type,
		},
	}
}

// GetColumnNames returns the value of the ColumnNames field in RangeValidityCheck_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RangeValidityCheck_SdkV2) GetColumnNames(ctx context.Context) ([]types.String, bool) {
	if m.ColumnNames.IsNull() || m.ColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumnNames sets the value of the ColumnNames field in RangeValidityCheck_SdkV2.
func (m *RangeValidityCheck_SdkV2) SetColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ColumnNames = types.ListValueMust(t, vs)
}

type UniquenessValidityCheck_SdkV2 struct {
	// List of column names to check for uniqueness
	ColumnNames types.List `tfsdk:"column_names"`
}

func (to *UniquenessValidityCheck_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UniquenessValidityCheck_SdkV2) {
	if !from.ColumnNames.IsNull() && !from.ColumnNames.IsUnknown() && to.ColumnNames.IsNull() && len(from.ColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ColumnNames = from.ColumnNames
	}
}

func (to *UniquenessValidityCheck_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UniquenessValidityCheck_SdkV2) {
	if !from.ColumnNames.IsNull() && !from.ColumnNames.IsUnknown() && to.ColumnNames.IsNull() && len(from.ColumnNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ColumnNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ColumnNames = from.ColumnNames
	}
}

func (m UniquenessValidityCheck_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["column_names"] = attrs["column_names"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UniquenessValidityCheck.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UniquenessValidityCheck_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"column_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UniquenessValidityCheck_SdkV2
// only implements ToObjectValue() and Type().
func (m UniquenessValidityCheck_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"column_names": m.ColumnNames,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UniquenessValidityCheck_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"column_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetColumnNames returns the value of the ColumnNames field in UniquenessValidityCheck_SdkV2 as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UniquenessValidityCheck_SdkV2) GetColumnNames(ctx context.Context) ([]types.String, bool) {
	if m.ColumnNames.IsNull() || m.ColumnNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.ColumnNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetColumnNames sets the value of the ColumnNames field in UniquenessValidityCheck_SdkV2.
func (m *UniquenessValidityCheck_SdkV2) SetColumnNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["column_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ColumnNames = types.ListValueMust(t, vs)
}

type UpdateQualityMonitorRequest_SdkV2 struct {
	// The uuid of the request object. For example, schema id.
	ObjectId types.String `tfsdk:"-"`
	// The type of the monitored object. Can be one of the following: schema.
	ObjectType types.String `tfsdk:"-"`

	QualityMonitor types.List `tfsdk:"quality_monitor"`
}

func (to *UpdateQualityMonitorRequest_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateQualityMonitorRequest_SdkV2) {
	if !from.QualityMonitor.IsNull() && !from.QualityMonitor.IsUnknown() {
		if toQualityMonitor, ok := to.GetQualityMonitor(ctx); ok {
			if fromQualityMonitor, ok := from.GetQualityMonitor(ctx); ok {
				// Recursively sync the fields of QualityMonitor
				toQualityMonitor.SyncFieldsDuringCreateOrUpdate(ctx, fromQualityMonitor)
				to.SetQualityMonitor(ctx, toQualityMonitor)
			}
		}
	}
}

func (to *UpdateQualityMonitorRequest_SdkV2) SyncFieldsDuringRead(ctx context.Context, from UpdateQualityMonitorRequest_SdkV2) {
	if !from.QualityMonitor.IsNull() && !from.QualityMonitor.IsUnknown() {
		if toQualityMonitor, ok := to.GetQualityMonitor(ctx); ok {
			if fromQualityMonitor, ok := from.GetQualityMonitor(ctx); ok {
				toQualityMonitor.SyncFieldsDuringRead(ctx, fromQualityMonitor)
				to.SetQualityMonitor(ctx, toQualityMonitor)
			}
		}
	}
}

func (m UpdateQualityMonitorRequest_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["quality_monitor"] = attrs["quality_monitor"].SetRequired()
	attrs["quality_monitor"] = attrs["quality_monitor"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["object_type"] = attrs["object_type"].SetRequired()
	attrs["object_id"] = attrs["object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateQualityMonitorRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateQualityMonitorRequest_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"quality_monitor": reflect.TypeOf(QualityMonitor_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateQualityMonitorRequest_SdkV2
// only implements ToObjectValue() and Type().
func (m UpdateQualityMonitorRequest_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"object_id":       m.ObjectId,
			"object_type":     m.ObjectType,
			"quality_monitor": m.QualityMonitor,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateQualityMonitorRequest_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"object_id":   types.StringType,
			"object_type": types.StringType,
			"quality_monitor": basetypes.ListType{
				ElemType: QualityMonitor_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetQualityMonitor returns the value of the QualityMonitor field in UpdateQualityMonitorRequest_SdkV2 as
// a QualityMonitor_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateQualityMonitorRequest_SdkV2) GetQualityMonitor(ctx context.Context) (QualityMonitor_SdkV2, bool) {
	var e QualityMonitor_SdkV2
	if m.QualityMonitor.IsNull() || m.QualityMonitor.IsUnknown() {
		return e, false
	}
	var v []QualityMonitor_SdkV2
	d := m.QualityMonitor.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetQualityMonitor sets the value of the QualityMonitor field in UpdateQualityMonitorRequest_SdkV2.
func (m *UpdateQualityMonitorRequest_SdkV2) SetQualityMonitor(ctx context.Context, v QualityMonitor_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["quality_monitor"]
	m.QualityMonitor = types.ListValueMust(t, vs)
}

type ValidityCheckConfiguration_SdkV2 struct {
	// Can be set by system. Does not need to be user facing.
	Name types.String `tfsdk:"name"`

	PercentNullValidityCheck types.List `tfsdk:"percent_null_validity_check"`

	RangeValidityCheck types.List `tfsdk:"range_validity_check"`

	UniquenessValidityCheck types.List `tfsdk:"uniqueness_validity_check"`
}

func (to *ValidityCheckConfiguration_SdkV2) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ValidityCheckConfiguration_SdkV2) {
	if !from.PercentNullValidityCheck.IsNull() && !from.PercentNullValidityCheck.IsUnknown() {
		if toPercentNullValidityCheck, ok := to.GetPercentNullValidityCheck(ctx); ok {
			if fromPercentNullValidityCheck, ok := from.GetPercentNullValidityCheck(ctx); ok {
				// Recursively sync the fields of PercentNullValidityCheck
				toPercentNullValidityCheck.SyncFieldsDuringCreateOrUpdate(ctx, fromPercentNullValidityCheck)
				to.SetPercentNullValidityCheck(ctx, toPercentNullValidityCheck)
			}
		}
	}
	if !from.RangeValidityCheck.IsNull() && !from.RangeValidityCheck.IsUnknown() {
		if toRangeValidityCheck, ok := to.GetRangeValidityCheck(ctx); ok {
			if fromRangeValidityCheck, ok := from.GetRangeValidityCheck(ctx); ok {
				// Recursively sync the fields of RangeValidityCheck
				toRangeValidityCheck.SyncFieldsDuringCreateOrUpdate(ctx, fromRangeValidityCheck)
				to.SetRangeValidityCheck(ctx, toRangeValidityCheck)
			}
		}
	}
	if !from.UniquenessValidityCheck.IsNull() && !from.UniquenessValidityCheck.IsUnknown() {
		if toUniquenessValidityCheck, ok := to.GetUniquenessValidityCheck(ctx); ok {
			if fromUniquenessValidityCheck, ok := from.GetUniquenessValidityCheck(ctx); ok {
				// Recursively sync the fields of UniquenessValidityCheck
				toUniquenessValidityCheck.SyncFieldsDuringCreateOrUpdate(ctx, fromUniquenessValidityCheck)
				to.SetUniquenessValidityCheck(ctx, toUniquenessValidityCheck)
			}
		}
	}
}

func (to *ValidityCheckConfiguration_SdkV2) SyncFieldsDuringRead(ctx context.Context, from ValidityCheckConfiguration_SdkV2) {
	if !from.PercentNullValidityCheck.IsNull() && !from.PercentNullValidityCheck.IsUnknown() {
		if toPercentNullValidityCheck, ok := to.GetPercentNullValidityCheck(ctx); ok {
			if fromPercentNullValidityCheck, ok := from.GetPercentNullValidityCheck(ctx); ok {
				toPercentNullValidityCheck.SyncFieldsDuringRead(ctx, fromPercentNullValidityCheck)
				to.SetPercentNullValidityCheck(ctx, toPercentNullValidityCheck)
			}
		}
	}
	if !from.RangeValidityCheck.IsNull() && !from.RangeValidityCheck.IsUnknown() {
		if toRangeValidityCheck, ok := to.GetRangeValidityCheck(ctx); ok {
			if fromRangeValidityCheck, ok := from.GetRangeValidityCheck(ctx); ok {
				toRangeValidityCheck.SyncFieldsDuringRead(ctx, fromRangeValidityCheck)
				to.SetRangeValidityCheck(ctx, toRangeValidityCheck)
			}
		}
	}
	if !from.UniquenessValidityCheck.IsNull() && !from.UniquenessValidityCheck.IsUnknown() {
		if toUniquenessValidityCheck, ok := to.GetUniquenessValidityCheck(ctx); ok {
			if fromUniquenessValidityCheck, ok := from.GetUniquenessValidityCheck(ctx); ok {
				toUniquenessValidityCheck.SyncFieldsDuringRead(ctx, fromUniquenessValidityCheck)
				to.SetUniquenessValidityCheck(ctx, toUniquenessValidityCheck)
			}
		}
	}
}

func (m ValidityCheckConfiguration_SdkV2) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetOptional()
	attrs["percent_null_validity_check"] = attrs["percent_null_validity_check"].SetOptional()
	attrs["percent_null_validity_check"] = attrs["percent_null_validity_check"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["range_validity_check"] = attrs["range_validity_check"].SetOptional()
	attrs["range_validity_check"] = attrs["range_validity_check"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)
	attrs["uniqueness_validity_check"] = attrs["uniqueness_validity_check"].SetOptional()
	attrs["uniqueness_validity_check"] = attrs["uniqueness_validity_check"].(tfschema.ListNestedAttributeBuilder).AddValidator(listvalidator.SizeAtMost(1)).(tfschema.AttributeBuilder)

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ValidityCheckConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ValidityCheckConfiguration_SdkV2) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"percent_null_validity_check": reflect.TypeOf(PercentNullValidityCheck_SdkV2{}),
		"range_validity_check":        reflect.TypeOf(RangeValidityCheck_SdkV2{}),
		"uniqueness_validity_check":   reflect.TypeOf(UniquenessValidityCheck_SdkV2{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ValidityCheckConfiguration_SdkV2
// only implements ToObjectValue() and Type().
func (m ValidityCheckConfiguration_SdkV2) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":                        m.Name,
			"percent_null_validity_check": m.PercentNullValidityCheck,
			"range_validity_check":        m.RangeValidityCheck,
			"uniqueness_validity_check":   m.UniquenessValidityCheck,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ValidityCheckConfiguration_SdkV2) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
			"percent_null_validity_check": basetypes.ListType{
				ElemType: PercentNullValidityCheck_SdkV2{}.Type(ctx),
			},
			"range_validity_check": basetypes.ListType{
				ElemType: RangeValidityCheck_SdkV2{}.Type(ctx),
			},
			"uniqueness_validity_check": basetypes.ListType{
				ElemType: UniquenessValidityCheck_SdkV2{}.Type(ctx),
			},
		},
	}
}

// GetPercentNullValidityCheck returns the value of the PercentNullValidityCheck field in ValidityCheckConfiguration_SdkV2 as
// a PercentNullValidityCheck_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidityCheckConfiguration_SdkV2) GetPercentNullValidityCheck(ctx context.Context) (PercentNullValidityCheck_SdkV2, bool) {
	var e PercentNullValidityCheck_SdkV2
	if m.PercentNullValidityCheck.IsNull() || m.PercentNullValidityCheck.IsUnknown() {
		return e, false
	}
	var v []PercentNullValidityCheck_SdkV2
	d := m.PercentNullValidityCheck.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetPercentNullValidityCheck sets the value of the PercentNullValidityCheck field in ValidityCheckConfiguration_SdkV2.
func (m *ValidityCheckConfiguration_SdkV2) SetPercentNullValidityCheck(ctx context.Context, v PercentNullValidityCheck_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["percent_null_validity_check"]
	m.PercentNullValidityCheck = types.ListValueMust(t, vs)
}

// GetRangeValidityCheck returns the value of the RangeValidityCheck field in ValidityCheckConfiguration_SdkV2 as
// a RangeValidityCheck_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidityCheckConfiguration_SdkV2) GetRangeValidityCheck(ctx context.Context) (RangeValidityCheck_SdkV2, bool) {
	var e RangeValidityCheck_SdkV2
	if m.RangeValidityCheck.IsNull() || m.RangeValidityCheck.IsUnknown() {
		return e, false
	}
	var v []RangeValidityCheck_SdkV2
	d := m.RangeValidityCheck.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetRangeValidityCheck sets the value of the RangeValidityCheck field in ValidityCheckConfiguration_SdkV2.
func (m *ValidityCheckConfiguration_SdkV2) SetRangeValidityCheck(ctx context.Context, v RangeValidityCheck_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["range_validity_check"]
	m.RangeValidityCheck = types.ListValueMust(t, vs)
}

// GetUniquenessValidityCheck returns the value of the UniquenessValidityCheck field in ValidityCheckConfiguration_SdkV2 as
// a UniquenessValidityCheck_SdkV2 value.
// If the field is unknown or null, the boolean return value is false.
func (m *ValidityCheckConfiguration_SdkV2) GetUniquenessValidityCheck(ctx context.Context) (UniquenessValidityCheck_SdkV2, bool) {
	var e UniquenessValidityCheck_SdkV2
	if m.UniquenessValidityCheck.IsNull() || m.UniquenessValidityCheck.IsUnknown() {
		return e, false
	}
	var v []UniquenessValidityCheck_SdkV2
	d := m.UniquenessValidityCheck.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	if len(v) == 0 {
		return e, false
	}
	return v[0], true
}

// SetUniquenessValidityCheck sets the value of the UniquenessValidityCheck field in ValidityCheckConfiguration_SdkV2.
func (m *ValidityCheckConfiguration_SdkV2) SetUniquenessValidityCheck(ctx context.Context, v UniquenessValidityCheck_SdkV2) {
	vs := []attr.Value{v.ToObjectValue(ctx)}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["uniqueness_validity_check"]
	m.UniquenessValidityCheck = types.ListValueMust(t, vs)
}
