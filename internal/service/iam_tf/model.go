// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package iam_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type AccessControlRequest struct {
	// name of the group
	GroupName types.String `tfsdk:"group_name"`

	PermissionLevel types.String `tfsdk:"permission_level"`
	// application ID of a service principal
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *AccessControlRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccessControlRequest) {
}

func (to *AccessControlRequest) SyncFieldsDuringRead(ctx context.Context, from AccessControlRequest) {
}

func (c AccessControlRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccessControlRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccessControlRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccessControlRequest
// only implements ToObjectValue() and Type().
func (o AccessControlRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"group_name":             o.GroupName,
			"permission_level":       o.PermissionLevel,
			"service_principal_name": o.ServicePrincipalName,
			"user_name":              o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccessControlRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"group_name":             types.StringType,
			"permission_level":       types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type AccessControlResponse struct {
	// All permissions.
	AllPermissions types.List `tfsdk:"all_permissions"`
	// Display name of the user or service principal.
	DisplayName types.String `tfsdk:"display_name"`
	// name of the group
	GroupName types.String `tfsdk:"group_name"`
	// Name of the service principal.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *AccessControlResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccessControlResponse) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (to *AccessControlResponse) SyncFieldsDuringRead(ctx context.Context, from AccessControlResponse) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (c AccessControlResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["all_permissions"] = attrs["all_permissions"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccessControlResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccessControlResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"all_permissions": reflect.TypeOf(Permission{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccessControlResponse
// only implements ToObjectValue() and Type().
func (o AccessControlResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"all_permissions":        o.AllPermissions,
			"display_name":           o.DisplayName,
			"group_name":             o.GroupName,
			"service_principal_name": o.ServicePrincipalName,
			"user_name":              o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccessControlResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"all_permissions": basetypes.ListType{
				ElemType: Permission{}.Type(ctx),
			},
			"display_name":           types.StringType,
			"group_name":             types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

// GetAllPermissions returns the value of the AllPermissions field in AccessControlResponse as
// a slice of Permission values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccessControlResponse) GetAllPermissions(ctx context.Context) ([]Permission, bool) {
	if o.AllPermissions.IsNull() || o.AllPermissions.IsUnknown() {
		return nil, false
	}
	var v []Permission
	d := o.AllPermissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAllPermissions sets the value of the AllPermissions field in AccessControlResponse.
func (o *AccessControlResponse) SetAllPermissions(ctx context.Context, v []Permission) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["all_permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AllPermissions = types.ListValueMust(t, vs)
}

type AccountGroup struct {
	// Databricks account ID
	AccountId types.String `tfsdk:"account_id"`
	// String that represents a human-readable group name
	DisplayName types.String `tfsdk:"display_name"`
	// external_id should be unique for identifying groups
	ExternalId types.String `tfsdk:"external_id"`
	// Databricks group ID
	Id types.String `tfsdk:"id"`

	Members types.List `tfsdk:"members"`
	// Container for the group identifier. Workspace local versus account.
	Meta types.Object `tfsdk:"meta"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
}

func (to *AccountGroup) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountGroup) {
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				// Recursively sync the fields of Meta
				toMeta.SyncFieldsDuringCreateOrUpdate(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *AccountGroup) SyncFieldsDuringRead(ctx context.Context, from AccountGroup) {
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				toMeta.SyncFieldsDuringRead(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c AccountGroup) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["members"] = attrs["members"].SetOptional()
	attrs["meta"] = attrs["meta"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountGroup.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountGroup) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"members": reflect.TypeOf(ComplexValue{}),
		"meta":    reflect.TypeOf(ResourceMeta{}),
		"roles":   reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountGroup
// only implements ToObjectValue() and Type().
func (o AccountGroup) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"account_id":   o.AccountId,
			"display_name": o.DisplayName,
			"external_id":  o.ExternalId,
			"id":           o.Id,
			"members":      o.Members,
			"meta":         o.Meta,
			"roles":        o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountGroup) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"account_id":   types.StringType,
			"display_name": types.StringType,
			"external_id":  types.StringType,
			"id":           types.StringType,
			"members": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"meta": ResourceMeta{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
		},
	}
}

// GetMembers returns the value of the Members field in AccountGroup as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountGroup) GetMembers(ctx context.Context) ([]ComplexValue, bool) {
	if o.Members.IsNull() || o.Members.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Members.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMembers sets the value of the Members field in AccountGroup.
func (o *AccountGroup) SetMembers(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["members"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Members = types.ListValueMust(t, vs)
}

// GetMeta returns the value of the Meta field in AccountGroup as
// a ResourceMeta value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountGroup) GetMeta(ctx context.Context) (ResourceMeta, bool) {
	var e ResourceMeta
	if o.Meta.IsNull() || o.Meta.IsUnknown() {
		return e, false
	}
	var v ResourceMeta
	d := o.Meta.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMeta sets the value of the Meta field in AccountGroup.
func (o *AccountGroup) SetMeta(ctx context.Context, v ResourceMeta) {
	vs := v.ToObjectValue(ctx)
	o.Meta = vs
}

// GetRoles returns the value of the Roles field in AccountGroup as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountGroup) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in AccountGroup.
func (o *AccountGroup) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type AccountServicePrincipal struct {
	// Databricks account ID
	AccountId types.String `tfsdk:"account_id"`
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// UUID relating to the service principal
	ApplicationId types.String `tfsdk:"application_id"`
	// String that represents a concatenation of given and family names.
	DisplayName types.String `tfsdk:"display_name"`

	ExternalId types.String `tfsdk:"external_id"`
	// Databricks service principal ID.
	Id types.String `tfsdk:"id"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
}

func (to *AccountServicePrincipal) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountServicePrincipal) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *AccountServicePrincipal) SyncFieldsDuringRead(ctx context.Context, from AccountServicePrincipal) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c AccountServicePrincipal) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetOptional()
	attrs["active"] = attrs["active"].SetOptional()
	attrs["application_id"] = attrs["application_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountServicePrincipal.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountServicePrincipal) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"roles": reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountServicePrincipal
// only implements ToObjectValue() and Type().
func (o AccountServicePrincipal) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"account_id":     o.AccountId,
			"active":         o.Active,
			"application_id": o.ApplicationId,
			"display_name":   o.DisplayName,
			"external_id":    o.ExternalId,
			"id":             o.Id,
			"roles":          o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountServicePrincipal) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"account_id":     types.StringType,
			"active":         types.BoolType,
			"application_id": types.StringType,
			"display_name":   types.StringType,
			"external_id":    types.StringType,
			"id":             types.StringType,
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
		},
	}
}

// GetRoles returns the value of the Roles field in AccountServicePrincipal as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountServicePrincipal) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in AccountServicePrincipal.
func (o *AccountServicePrincipal) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type AccountUser struct {
	// Databricks account ID
	AccountId types.String `tfsdk:"account_id"`
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// String that represents a concatenation of given and family names. For
	// example `John Smith`.
	DisplayName types.String `tfsdk:"display_name"`
	// All the emails associated with the Databricks user.
	Emails types.List `tfsdk:"emails"`
	// External ID is not currently supported. It is reserved for future use.
	ExternalId types.String `tfsdk:"external_id"`
	// Databricks user ID.
	Id types.String `tfsdk:"id"`

	Name types.Object `tfsdk:"name"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
	// Email address of the Databricks user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *AccountUser) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from AccountUser) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				// Recursively sync the fields of Name
				toName.SyncFieldsDuringCreateOrUpdate(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *AccountUser) SyncFieldsDuringRead(ctx context.Context, from AccountUser) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				toName.SyncFieldsDuringRead(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c AccountUser) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetOptional()
	attrs["active"] = attrs["active"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["emails"] = attrs["emails"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in AccountUser.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a AccountUser) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"emails": reflect.TypeOf(ComplexValue{}),
		"name":   reflect.TypeOf(Name{}),
		"roles":  reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, AccountUser
// only implements ToObjectValue() and Type().
func (o AccountUser) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"account_id":   o.AccountId,
			"active":       o.Active,
			"display_name": o.DisplayName,
			"emails":       o.Emails,
			"external_id":  o.ExternalId,
			"id":           o.Id,
			"name":         o.Name,
			"roles":        o.Roles,
			"user_name":    o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o AccountUser) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"account_id":   types.StringType,
			"active":       types.BoolType,
			"display_name": types.StringType,
			"emails": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"id":          types.StringType,
			"name":        Name{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"user_name": types.StringType,
		},
	}
}

// GetEmails returns the value of the Emails field in AccountUser as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountUser) GetEmails(ctx context.Context) ([]ComplexValue, bool) {
	if o.Emails.IsNull() || o.Emails.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Emails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmails sets the value of the Emails field in AccountUser.
func (o *AccountUser) SetEmails(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["emails"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Emails = types.ListValueMust(t, vs)
}

// GetName returns the value of the Name field in AccountUser as
// a Name value.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountUser) GetName(ctx context.Context) (Name, bool) {
	var e Name
	if o.Name.IsNull() || o.Name.IsUnknown() {
		return e, false
	}
	var v Name
	d := o.Name.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetName sets the value of the Name field in AccountUser.
func (o *AccountUser) SetName(ctx context.Context, v Name) {
	vs := v.ToObjectValue(ctx)
	o.Name = vs
}

// GetRoles returns the value of the Roles field in AccountUser as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *AccountUser) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in AccountUser.
func (o *AccountUser) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// represents an identity trying to access a resource - user or a service
// principal group can be a principal of a permission set assignment but an
// actor is always a user or a service principal
type Actor struct {
	ActorId types.Int64 `tfsdk:"actor_id"`
}

func (to *Actor) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Actor) {
}

func (to *Actor) SyncFieldsDuringRead(ctx context.Context, from Actor) {
}

func (c Actor) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["actor_id"] = attrs["actor_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Actor.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Actor) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Actor
// only implements ToObjectValue() and Type().
func (o Actor) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"actor_id": o.ActorId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Actor) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"actor_id": types.Int64Type,
		},
	}
}

type CheckPolicyResponse struct {
	ConsistencyToken types.Object `tfsdk:"consistency_token"`

	IsPermitted types.Bool `tfsdk:"is_permitted"`
}

func (to *CheckPolicyResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CheckPolicyResponse) {
	if !from.ConsistencyToken.IsNull() && !from.ConsistencyToken.IsUnknown() {
		if toConsistencyToken, ok := to.GetConsistencyToken(ctx); ok {
			if fromConsistencyToken, ok := from.GetConsistencyToken(ctx); ok {
				// Recursively sync the fields of ConsistencyToken
				toConsistencyToken.SyncFieldsDuringCreateOrUpdate(ctx, fromConsistencyToken)
				to.SetConsistencyToken(ctx, toConsistencyToken)
			}
		}
	}
}

func (to *CheckPolicyResponse) SyncFieldsDuringRead(ctx context.Context, from CheckPolicyResponse) {
	if !from.ConsistencyToken.IsNull() && !from.ConsistencyToken.IsUnknown() {
		if toConsistencyToken, ok := to.GetConsistencyToken(ctx); ok {
			if fromConsistencyToken, ok := from.GetConsistencyToken(ctx); ok {
				toConsistencyToken.SyncFieldsDuringRead(ctx, fromConsistencyToken)
				to.SetConsistencyToken(ctx, toConsistencyToken)
			}
		}
	}
}

func (c CheckPolicyResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["consistency_token"] = attrs["consistency_token"].SetRequired()
	attrs["is_permitted"] = attrs["is_permitted"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CheckPolicyResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CheckPolicyResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"consistency_token": reflect.TypeOf(ConsistencyToken{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CheckPolicyResponse
// only implements ToObjectValue() and Type().
func (o CheckPolicyResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"consistency_token": o.ConsistencyToken,
			"is_permitted":      o.IsPermitted,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CheckPolicyResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"consistency_token": ConsistencyToken{}.Type(ctx),
			"is_permitted":      types.BoolType,
		},
	}
}

// GetConsistencyToken returns the value of the ConsistencyToken field in CheckPolicyResponse as
// a ConsistencyToken value.
// If the field is unknown or null, the boolean return value is false.
func (o *CheckPolicyResponse) GetConsistencyToken(ctx context.Context) (ConsistencyToken, bool) {
	var e ConsistencyToken
	if o.ConsistencyToken.IsNull() || o.ConsistencyToken.IsUnknown() {
		return e, false
	}
	var v ConsistencyToken
	d := o.ConsistencyToken.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConsistencyToken sets the value of the ConsistencyToken field in CheckPolicyResponse.
func (o *CheckPolicyResponse) SetConsistencyToken(ctx context.Context, v ConsistencyToken) {
	vs := v.ToObjectValue(ctx)
	o.ConsistencyToken = vs
}

type ComplexValue struct {
	Display types.String `tfsdk:"display"`

	Primary types.Bool `tfsdk:"primary"`

	Ref types.String `tfsdk:"ref"`

	Type_ types.String `tfsdk:"type"`

	Value types.String `tfsdk:"value"`
}

func (to *ComplexValue) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ComplexValue) {
}

func (to *ComplexValue) SyncFieldsDuringRead(ctx context.Context, from ComplexValue) {
}

func (c ComplexValue) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["ref"] = attrs["ref"].SetOptional()
	attrs["display"] = attrs["display"].SetOptional()
	attrs["primary"] = attrs["primary"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()
	attrs["value"] = attrs["value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ComplexValue.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ComplexValue) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ComplexValue
// only implements ToObjectValue() and Type().
func (o ComplexValue) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display": o.Display,
			"primary": o.Primary,
			"ref":     o.Ref,
			"type":    o.Type_,
			"value":   o.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ComplexValue) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display": types.StringType,
			"primary": types.BoolType,
			"ref":     types.StringType,
			"type":    types.StringType,
			"value":   types.StringType,
		},
	}
}

type ConsistencyToken struct {
	Value types.String `tfsdk:"value"`
}

func (to *ConsistencyToken) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ConsistencyToken) {
}

func (to *ConsistencyToken) SyncFieldsDuringRead(ctx context.Context, from ConsistencyToken) {
}

func (c ConsistencyToken) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["value"] = attrs["value"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConsistencyToken.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ConsistencyToken) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConsistencyToken
// only implements ToObjectValue() and Type().
func (o ConsistencyToken) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"value": o.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ConsistencyToken) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"value": types.StringType,
		},
	}
}

type CreateAccountGroupRequest struct {
	// String that represents a human-readable group name
	DisplayName types.String `tfsdk:"display_name"`

	ExternalId types.String `tfsdk:"external_id"`
	// Databricks group ID
	Id types.String `tfsdk:"id"`

	Members types.List `tfsdk:"members"`
	// Container for the group identifier. Workspace local versus account.
	Meta types.Object `tfsdk:"meta"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
}

func (to *CreateAccountGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccountGroupRequest) {
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				// Recursively sync the fields of Meta
				toMeta.SyncFieldsDuringCreateOrUpdate(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *CreateAccountGroupRequest) SyncFieldsDuringRead(ctx context.Context, from CreateAccountGroupRequest) {
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				toMeta.SyncFieldsDuringRead(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c CreateAccountGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["members"] = attrs["members"].SetOptional()
	attrs["meta"] = attrs["meta"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccountGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateAccountGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"members": reflect.TypeOf(ComplexValue{}),
		"meta":    reflect.TypeOf(ResourceMeta{}),
		"roles":   reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccountGroupRequest
// only implements ToObjectValue() and Type().
func (o CreateAccountGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name": o.DisplayName,
			"external_id":  o.ExternalId,
			"id":           o.Id,
			"members":      o.Members,
			"meta":         o.Meta,
			"roles":        o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateAccountGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name": types.StringType,
			"external_id":  types.StringType,
			"id":           types.StringType,
			"members": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"meta": ResourceMeta{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
		},
	}
}

// GetMembers returns the value of the Members field in CreateAccountGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountGroupRequest) GetMembers(ctx context.Context) ([]ComplexValue, bool) {
	if o.Members.IsNull() || o.Members.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Members.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMembers sets the value of the Members field in CreateAccountGroupRequest.
func (o *CreateAccountGroupRequest) SetMembers(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["members"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Members = types.ListValueMust(t, vs)
}

// GetMeta returns the value of the Meta field in CreateAccountGroupRequest as
// a ResourceMeta value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountGroupRequest) GetMeta(ctx context.Context) (ResourceMeta, bool) {
	var e ResourceMeta
	if o.Meta.IsNull() || o.Meta.IsUnknown() {
		return e, false
	}
	var v ResourceMeta
	d := o.Meta.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMeta sets the value of the Meta field in CreateAccountGroupRequest.
func (o *CreateAccountGroupRequest) SetMeta(ctx context.Context, v ResourceMeta) {
	vs := v.ToObjectValue(ctx)
	o.Meta = vs
}

// GetRoles returns the value of the Roles field in CreateAccountGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountGroupRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in CreateAccountGroupRequest.
func (o *CreateAccountGroupRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type CreateAccountServicePrincipalRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// UUID relating to the service principal
	ApplicationId types.String `tfsdk:"application_id"`
	// String that represents a concatenation of given and family names.
	DisplayName types.String `tfsdk:"display_name"`

	ExternalId types.String `tfsdk:"external_id"`
	// Databricks service principal ID.
	Id types.String `tfsdk:"id"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
}

func (to *CreateAccountServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccountServicePrincipalRequest) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *CreateAccountServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from CreateAccountServicePrincipalRequest) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c CreateAccountServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["application_id"] = attrs["application_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccountServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateAccountServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"roles": reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccountServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o CreateAccountServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":         o.Active,
			"application_id": o.ApplicationId,
			"display_name":   o.DisplayName,
			"external_id":    o.ExternalId,
			"id":             o.Id,
			"roles":          o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateAccountServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":         types.BoolType,
			"application_id": types.StringType,
			"display_name":   types.StringType,
			"external_id":    types.StringType,
			"id":             types.StringType,
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
		},
	}
}

// GetRoles returns the value of the Roles field in CreateAccountServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountServicePrincipalRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in CreateAccountServicePrincipalRequest.
func (o *CreateAccountServicePrincipalRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type CreateAccountUserRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// String that represents a concatenation of given and family names. For
	// example `John Smith`.
	DisplayName types.String `tfsdk:"display_name"`
	// All the emails associated with the Databricks user.
	Emails types.List `tfsdk:"emails"`
	// External ID is not currently supported. It is reserved for future use.
	ExternalId types.String `tfsdk:"external_id"`
	// Databricks user ID.
	Id types.String `tfsdk:"id"`

	Name types.Object `tfsdk:"name"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
	// Email address of the Databricks user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *CreateAccountUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateAccountUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				// Recursively sync the fields of Name
				toName.SyncFieldsDuringCreateOrUpdate(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *CreateAccountUserRequest) SyncFieldsDuringRead(ctx context.Context, from CreateAccountUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				toName.SyncFieldsDuringRead(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c CreateAccountUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["emails"] = attrs["emails"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateAccountUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateAccountUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"emails": reflect.TypeOf(ComplexValue{}),
		"name":   reflect.TypeOf(Name{}),
		"roles":  reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateAccountUserRequest
// only implements ToObjectValue() and Type().
func (o CreateAccountUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":       o.Active,
			"display_name": o.DisplayName,
			"emails":       o.Emails,
			"external_id":  o.ExternalId,
			"id":           o.Id,
			"name":         o.Name,
			"roles":        o.Roles,
			"user_name":    o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateAccountUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":       types.BoolType,
			"display_name": types.StringType,
			"emails": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"id":          types.StringType,
			"name":        Name{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"user_name": types.StringType,
		},
	}
}

// GetEmails returns the value of the Emails field in CreateAccountUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountUserRequest) GetEmails(ctx context.Context) ([]ComplexValue, bool) {
	if o.Emails.IsNull() || o.Emails.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Emails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmails sets the value of the Emails field in CreateAccountUserRequest.
func (o *CreateAccountUserRequest) SetEmails(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["emails"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Emails = types.ListValueMust(t, vs)
}

// GetName returns the value of the Name field in CreateAccountUserRequest as
// a Name value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountUserRequest) GetName(ctx context.Context) (Name, bool) {
	var e Name
	if o.Name.IsNull() || o.Name.IsUnknown() {
		return e, false
	}
	var v Name
	d := o.Name.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetName sets the value of the Name field in CreateAccountUserRequest.
func (o *CreateAccountUserRequest) SetName(ctx context.Context, v Name) {
	vs := v.ToObjectValue(ctx)
	o.Name = vs
}

// GetRoles returns the value of the Roles field in CreateAccountUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateAccountUserRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in CreateAccountUserRequest.
func (o *CreateAccountUserRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type CreateGroupRequest struct {
	// String that represents a human-readable group name
	DisplayName types.String `tfsdk:"display_name"`
	// Entitlements assigned to the group. See [assigning entitlements] for a
	// full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`

	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks group ID
	Id types.String `tfsdk:"id"`

	Members types.List `tfsdk:"members"`
	// Container for the group identifier. Workspace local versus account.
	Meta types.Object `tfsdk:"meta"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the group.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *CreateGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateGroupRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				// Recursively sync the fields of Meta
				toMeta.SyncFieldsDuringCreateOrUpdate(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *CreateGroupRequest) SyncFieldsDuringRead(ctx context.Context, from CreateGroupRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				toMeta.SyncFieldsDuringRead(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c CreateGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["members"] = attrs["members"].SetOptional()
	attrs["meta"] = attrs["meta"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"members":      reflect.TypeOf(ComplexValue{}),
		"meta":         reflect.TypeOf(ResourceMeta{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateGroupRequest
// only implements ToObjectValue() and Type().
func (o CreateGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name": o.DisplayName,
			"entitlements": o.Entitlements,
			"external_id":  o.ExternalId,
			"groups":       o.Groups,
			"id":           o.Id,
			"members":      o.Members,
			"meta":         o.Meta,
			"roles":        o.Roles,
			"schemas":      o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name": types.StringType,
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id": types.StringType,
			"members": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"meta": ResourceMeta{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEntitlements returns the value of the Entitlements field in CreateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateGroupRequest) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in CreateGroupRequest.
func (o *CreateGroupRequest) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in CreateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateGroupRequest) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in CreateGroupRequest.
func (o *CreateGroupRequest) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetMembers returns the value of the Members field in CreateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateGroupRequest) GetMembers(ctx context.Context) ([]ComplexValue, bool) {
	if o.Members.IsNull() || o.Members.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Members.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMembers sets the value of the Members field in CreateGroupRequest.
func (o *CreateGroupRequest) SetMembers(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["members"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Members = types.ListValueMust(t, vs)
}

// GetMeta returns the value of the Meta field in CreateGroupRequest as
// a ResourceMeta value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateGroupRequest) GetMeta(ctx context.Context) (ResourceMeta, bool) {
	var e ResourceMeta
	if o.Meta.IsNull() || o.Meta.IsUnknown() {
		return e, false
	}
	var v ResourceMeta
	d := o.Meta.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMeta sets the value of the Meta field in CreateGroupRequest.
func (o *CreateGroupRequest) SetMeta(ctx context.Context, v ResourceMeta) {
	vs := v.ToObjectValue(ctx)
	o.Meta = vs
}

// GetRoles returns the value of the Roles field in CreateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateGroupRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in CreateGroupRequest.
func (o *CreateGroupRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in CreateGroupRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateGroupRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in CreateGroupRequest.
func (o *CreateGroupRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type CreateServicePrincipalRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// UUID relating to the service principal
	ApplicationId types.String `tfsdk:"application_id"`
	// String that represents a concatenation of given and family names.
	DisplayName types.String `tfsdk:"display_name"`
	// Entitlements assigned to the service principal. See [assigning
	// entitlements] for a full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`

	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks service principal ID.
	Id types.String `tfsdk:"id"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the List response.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *CreateServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateServicePrincipalRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *CreateServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from CreateServicePrincipalRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c CreateServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["application_id"] = attrs["application_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o CreateServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":         o.Active,
			"application_id": o.ApplicationId,
			"display_name":   o.DisplayName,
			"entitlements":   o.Entitlements,
			"external_id":    o.ExternalId,
			"groups":         o.Groups,
			"id":             o.Id,
			"roles":          o.Roles,
			"schemas":        o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":         types.BoolType,
			"application_id": types.StringType,
			"display_name":   types.StringType,
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id": types.StringType,
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEntitlements returns the value of the Entitlements field in CreateServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateServicePrincipalRequest) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in CreateServicePrincipalRequest.
func (o *CreateServicePrincipalRequest) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in CreateServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateServicePrincipalRequest) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in CreateServicePrincipalRequest.
func (o *CreateServicePrincipalRequest) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetRoles returns the value of the Roles field in CreateServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateServicePrincipalRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in CreateServicePrincipalRequest.
func (o *CreateServicePrincipalRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in CreateServicePrincipalRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateServicePrincipalRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in CreateServicePrincipalRequest.
func (o *CreateServicePrincipalRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type CreateUserRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// String that represents a concatenation of given and family names. For
	// example `John Smith`. This field cannot be updated through the Workspace
	// SCIM APIs when [identity federation is enabled]. Use Account SCIM APIs to
	// update `displayName`.
	//
	// [identity federation is enabled]: https://docs.databricks.com/administration-guide/users-groups/best-practices.html#enable-identity-federation
	DisplayName types.String `tfsdk:"display_name"`
	// All the emails associated with the Databricks user.
	Emails types.List `tfsdk:"emails"`
	// Entitlements assigned to the user. See [assigning entitlements] for a
	// full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`
	// External ID is not currently supported. It is reserved for future use.
	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks user ID.
	Id types.String `tfsdk:"id"`

	Name types.Object `tfsdk:"name"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the user.
	Schemas types.List `tfsdk:"schemas"`
	// Email address of the Databricks user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *CreateUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				// Recursively sync the fields of Name
				toName.SyncFieldsDuringCreateOrUpdate(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *CreateUserRequest) SyncFieldsDuringRead(ctx context.Context, from CreateUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				toName.SyncFieldsDuringRead(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c CreateUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["emails"] = attrs["emails"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a CreateUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"emails":       reflect.TypeOf(ComplexValue{}),
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"name":         reflect.TypeOf(Name{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateUserRequest
// only implements ToObjectValue() and Type().
func (o CreateUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":       o.Active,
			"display_name": o.DisplayName,
			"emails":       o.Emails,
			"entitlements": o.Entitlements,
			"external_id":  o.ExternalId,
			"groups":       o.Groups,
			"id":           o.Id,
			"name":         o.Name,
			"roles":        o.Roles,
			"schemas":      o.Schemas,
			"user_name":    o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o CreateUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":       types.BoolType,
			"display_name": types.StringType,
			"emails": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id":   types.StringType,
			"name": Name{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
			"user_name": types.StringType,
		},
	}
}

// GetEmails returns the value of the Emails field in CreateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateUserRequest) GetEmails(ctx context.Context) ([]ComplexValue, bool) {
	if o.Emails.IsNull() || o.Emails.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Emails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmails sets the value of the Emails field in CreateUserRequest.
func (o *CreateUserRequest) SetEmails(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["emails"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Emails = types.ListValueMust(t, vs)
}

// GetEntitlements returns the value of the Entitlements field in CreateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateUserRequest) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in CreateUserRequest.
func (o *CreateUserRequest) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in CreateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateUserRequest) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in CreateUserRequest.
func (o *CreateUserRequest) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetName returns the value of the Name field in CreateUserRequest as
// a Name value.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateUserRequest) GetName(ctx context.Context) (Name, bool) {
	var e Name
	if o.Name.IsNull() || o.Name.IsUnknown() {
		return e, false
	}
	var v Name
	d := o.Name.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetName sets the value of the Name field in CreateUserRequest.
func (o *CreateUserRequest) SetName(ctx context.Context, v Name) {
	vs := v.ToObjectValue(ctx)
	o.Name = vs
}

// GetRoles returns the value of the Roles field in CreateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateUserRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in CreateUserRequest.
func (o *CreateUserRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in CreateUserRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *CreateUserRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in CreateUserRequest.
func (o *CreateUserRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type DeleteAccountGroupRequest struct {
	// Unique ID for a group in the Databricks account.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteAccountGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAccountGroupRequest) {
}

func (to *DeleteAccountGroupRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteAccountGroupRequest) {
}

func (c DeleteAccountGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAccountGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountGroupRequest
// only implements ToObjectValue() and Type().
func (o DeleteAccountGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAccountGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type DeleteAccountServicePrincipalRequest struct {
	// Unique ID for a service principal in the Databricks account.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteAccountServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAccountServicePrincipalRequest) {
}

func (to *DeleteAccountServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteAccountServicePrincipalRequest) {
}

func (c DeleteAccountServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAccountServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o DeleteAccountServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAccountServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type DeleteAccountUserRequest struct {
	// Unique ID for a user in the Databricks account.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteAccountUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteAccountUserRequest) {
}

func (to *DeleteAccountUserRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteAccountUserRequest) {
}

func (c DeleteAccountUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteAccountUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteAccountUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteAccountUserRequest
// only implements ToObjectValue() and Type().
func (o DeleteAccountUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteAccountUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type DeleteGroupRequest struct {
	// Unique ID for a group in the Databricks workspace.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteGroupRequest) {
}

func (to *DeleteGroupRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteGroupRequest) {
}

func (c DeleteGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteGroupRequest
// only implements ToObjectValue() and Type().
func (o DeleteGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type DeleteServicePrincipalRequest struct {
	// Unique ID for a service principal in the Databricks workspace.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteServicePrincipalRequest) {
}

func (to *DeleteServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteServicePrincipalRequest) {
}

func (c DeleteServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o DeleteServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type DeleteUserRequest struct {
	// Unique ID for a user in the Databricks workspace.
	Id types.String `tfsdk:"-"`
}

func (to *DeleteUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteUserRequest) {
}

func (to *DeleteUserRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteUserRequest) {
}

func (c DeleteUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteUserRequest
// only implements ToObjectValue() and Type().
func (o DeleteUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type DeleteWorkspaceAssignmentRequest struct {
	// The ID of the user, service principal, or group.
	PrincipalId types.Int64 `tfsdk:"-"`
	// The workspace ID for the account.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *DeleteWorkspaceAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteWorkspaceAssignmentRequest) {
}

func (to *DeleteWorkspaceAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, from DeleteWorkspaceAssignmentRequest) {
}

func (c DeleteWorkspaceAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["principal_id"] = attrs["principal_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteWorkspaceAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteWorkspaceAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteWorkspaceAssignmentRequest
// only implements ToObjectValue() and Type().
func (o DeleteWorkspaceAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"principal_id": o.PrincipalId,
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteWorkspaceAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"principal_id": types.Int64Type,
			"workspace_id": types.Int64Type,
		},
	}
}

type DeleteWorkspacePermissionAssignmentResponse struct {
}

func (to *DeleteWorkspacePermissionAssignmentResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteWorkspacePermissionAssignmentResponse) {
}

func (to *DeleteWorkspacePermissionAssignmentResponse) SyncFieldsDuringRead(ctx context.Context, from DeleteWorkspacePermissionAssignmentResponse) {
}

func (c DeleteWorkspacePermissionAssignmentResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteWorkspacePermissionAssignmentResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a DeleteWorkspacePermissionAssignmentResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteWorkspacePermissionAssignmentResponse
// only implements ToObjectValue() and Type().
func (o DeleteWorkspacePermissionAssignmentResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o DeleteWorkspacePermissionAssignmentResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type GetAccountGroupRequest struct {
	// Unique ID for a group in the Databricks account.
	Id types.String `tfsdk:"-"`
}

func (to *GetAccountGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccountGroupRequest) {
}

func (to *GetAccountGroupRequest) SyncFieldsDuringRead(ctx context.Context, from GetAccountGroupRequest) {
}

func (c GetAccountGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccountGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountGroupRequest
// only implements ToObjectValue() and Type().
func (o GetAccountGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccountGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetAccountServicePrincipalRequest struct {
	// Unique ID for a service principal in the Databricks account.
	Id types.String `tfsdk:"-"`
}

func (to *GetAccountServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccountServicePrincipalRequest) {
}

func (to *GetAccountServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from GetAccountServicePrincipalRequest) {
}

func (c GetAccountServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccountServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o GetAccountServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccountServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetAccountUserRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page. Default is 10000.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Unique ID for a user in the Databricks account.
	Id types.String `tfsdk:"-"`
	// Attribute to sort the results. Multi-part paths are supported. For
	// example, `userName`, `name.givenName`, and `emails`.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *GetAccountUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAccountUserRequest) {
}

func (to *GetAccountUserRequest) SyncFieldsDuringRead(ctx context.Context, from GetAccountUserRequest) {
}

func (c GetAccountUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAccountUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAccountUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAccountUserRequest
// only implements ToObjectValue() and Type().
func (o GetAccountUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"id":                  o.Id,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAccountUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"id":                  types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type GetAssignableRolesForResourceRequest struct {
	// The resource name for which assignable roles will be listed.
	//
	// Examples | Summary :--- | :--- `resource=accounts/<ACCOUNT_ID>` | A
	// resource name for the account.
	// `resource=accounts/<ACCOUNT_ID>/groups/<GROUP_ID>` | A resource name for
	// the group. `resource=accounts/<ACCOUNT_ID>/servicePrincipals/<SP_ID>` | A
	// resource name for the service principal.
	// `resource=accounts/<ACCOUNT_ID>/tagPolicies/<TAG_POLICY_ID>` | A resource
	// name for the tag policy.
	Resource types.String `tfsdk:"-"`
}

func (to *GetAssignableRolesForResourceRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAssignableRolesForResourceRequest) {
}

func (to *GetAssignableRolesForResourceRequest) SyncFieldsDuringRead(ctx context.Context, from GetAssignableRolesForResourceRequest) {
}

func (c GetAssignableRolesForResourceRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["resource"] = attrs["resource"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAssignableRolesForResourceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAssignableRolesForResourceRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAssignableRolesForResourceRequest
// only implements ToObjectValue() and Type().
func (o GetAssignableRolesForResourceRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"resource": o.Resource,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAssignableRolesForResourceRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"resource": types.StringType,
		},
	}
}

type GetAssignableRolesForResourceResponse struct {
	Roles types.List `tfsdk:"roles"`
}

func (to *GetAssignableRolesForResourceResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetAssignableRolesForResourceResponse) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *GetAssignableRolesForResourceResponse) SyncFieldsDuringRead(ctx context.Context, from GetAssignableRolesForResourceResponse) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c GetAssignableRolesForResourceResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["roles"] = attrs["roles"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetAssignableRolesForResourceResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetAssignableRolesForResourceResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"roles": reflect.TypeOf(Role{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetAssignableRolesForResourceResponse
// only implements ToObjectValue() and Type().
func (o GetAssignableRolesForResourceResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"roles": o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetAssignableRolesForResourceResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"roles": basetypes.ListType{
				ElemType: Role{}.Type(ctx),
			},
		},
	}
}

// GetRoles returns the value of the Roles field in GetAssignableRolesForResourceResponse as
// a slice of Role values.
// If the field is unknown or null, the boolean return value is false.
func (o *GetAssignableRolesForResourceResponse) GetRoles(ctx context.Context) ([]Role, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []Role
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in GetAssignableRolesForResourceResponse.
func (o *GetAssignableRolesForResourceResponse) SetRoles(ctx context.Context, v []Role) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type GetGroupRequest struct {
	// Unique ID for a group in the Databricks workspace.
	Id types.String `tfsdk:"-"`
}

func (to *GetGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetGroupRequest) {
}

func (to *GetGroupRequest) SyncFieldsDuringRead(ctx context.Context, from GetGroupRequest) {
}

func (c GetGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetGroupRequest
// only implements ToObjectValue() and Type().
func (o GetGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetPasswordPermissionLevelsRequest struct {
}

func (to *GetPasswordPermissionLevelsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPasswordPermissionLevelsRequest) {
}

func (to *GetPasswordPermissionLevelsRequest) SyncFieldsDuringRead(ctx context.Context, from GetPasswordPermissionLevelsRequest) {
}

func (c GetPasswordPermissionLevelsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPasswordPermissionLevelsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPasswordPermissionLevelsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPasswordPermissionLevelsRequest
// only implements ToObjectValue() and Type().
func (o GetPasswordPermissionLevelsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o GetPasswordPermissionLevelsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type GetPasswordPermissionLevelsResponse struct {
	// Specific permission levels
	PermissionLevels types.List `tfsdk:"permission_levels"`
}

func (to *GetPasswordPermissionLevelsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPasswordPermissionLevelsResponse) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (to *GetPasswordPermissionLevelsResponse) SyncFieldsDuringRead(ctx context.Context, from GetPasswordPermissionLevelsResponse) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (c GetPasswordPermissionLevelsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permission_levels"] = attrs["permission_levels"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPasswordPermissionLevelsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPasswordPermissionLevelsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permission_levels": reflect.TypeOf(PasswordPermissionsDescription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPasswordPermissionLevelsResponse
// only implements ToObjectValue() and Type().
func (o GetPasswordPermissionLevelsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permission_levels": o.PermissionLevels,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetPasswordPermissionLevelsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permission_levels": basetypes.ListType{
				ElemType: PasswordPermissionsDescription{}.Type(ctx),
			},
		},
	}
}

// GetPermissionLevels returns the value of the PermissionLevels field in GetPasswordPermissionLevelsResponse as
// a slice of PasswordPermissionsDescription values.
// If the field is unknown or null, the boolean return value is false.
func (o *GetPasswordPermissionLevelsResponse) GetPermissionLevels(ctx context.Context) ([]PasswordPermissionsDescription, bool) {
	if o.PermissionLevels.IsNull() || o.PermissionLevels.IsUnknown() {
		return nil, false
	}
	var v []PasswordPermissionsDescription
	d := o.PermissionLevels.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissionLevels sets the value of the PermissionLevels field in GetPasswordPermissionLevelsResponse.
func (o *GetPasswordPermissionLevelsResponse) SetPermissionLevels(ctx context.Context, v []PasswordPermissionsDescription) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permission_levels"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PermissionLevels = types.ListValueMust(t, vs)
}

type GetPasswordPermissionsRequest struct {
}

func (to *GetPasswordPermissionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPasswordPermissionsRequest) {
}

func (to *GetPasswordPermissionsRequest) SyncFieldsDuringRead(ctx context.Context, from GetPasswordPermissionsRequest) {
}

func (c GetPasswordPermissionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPasswordPermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPasswordPermissionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPasswordPermissionsRequest
// only implements ToObjectValue() and Type().
func (o GetPasswordPermissionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o GetPasswordPermissionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type GetPermissionLevelsRequest struct {
	RequestObjectId types.String `tfsdk:"-"`
	// The type of the request object. Can be one of the following: alerts,
	// alertsv2, authorization, clusters, cluster-policies, dashboards,
	// dbsql-dashboards, directories, experiments, files, genie, instance-pools,
	// jobs, notebooks, pipelines, queries, registered-models, repos,
	// serving-endpoints, or warehouses.
	RequestObjectType types.String `tfsdk:"-"`
}

func (to *GetPermissionLevelsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPermissionLevelsRequest) {
}

func (to *GetPermissionLevelsRequest) SyncFieldsDuringRead(ctx context.Context, from GetPermissionLevelsRequest) {
}

func (c GetPermissionLevelsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["request_object_type"] = attrs["request_object_type"].SetRequired()
	attrs["request_object_id"] = attrs["request_object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPermissionLevelsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPermissionLevelsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPermissionLevelsRequest
// only implements ToObjectValue() and Type().
func (o GetPermissionLevelsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"request_object_id":   o.RequestObjectId,
			"request_object_type": o.RequestObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetPermissionLevelsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"request_object_id":   types.StringType,
			"request_object_type": types.StringType,
		},
	}
}

type GetPermissionLevelsResponse struct {
	// Specific permission levels
	PermissionLevels types.List `tfsdk:"permission_levels"`
}

func (to *GetPermissionLevelsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPermissionLevelsResponse) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (to *GetPermissionLevelsResponse) SyncFieldsDuringRead(ctx context.Context, from GetPermissionLevelsResponse) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (c GetPermissionLevelsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permission_levels"] = attrs["permission_levels"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPermissionLevelsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPermissionLevelsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permission_levels": reflect.TypeOf(PermissionsDescription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPermissionLevelsResponse
// only implements ToObjectValue() and Type().
func (o GetPermissionLevelsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permission_levels": o.PermissionLevels,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetPermissionLevelsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permission_levels": basetypes.ListType{
				ElemType: PermissionsDescription{}.Type(ctx),
			},
		},
	}
}

// GetPermissionLevels returns the value of the PermissionLevels field in GetPermissionLevelsResponse as
// a slice of PermissionsDescription values.
// If the field is unknown or null, the boolean return value is false.
func (o *GetPermissionLevelsResponse) GetPermissionLevels(ctx context.Context) ([]PermissionsDescription, bool) {
	if o.PermissionLevels.IsNull() || o.PermissionLevels.IsUnknown() {
		return nil, false
	}
	var v []PermissionsDescription
	d := o.PermissionLevels.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissionLevels sets the value of the PermissionLevels field in GetPermissionLevelsResponse.
func (o *GetPermissionLevelsResponse) SetPermissionLevels(ctx context.Context, v []PermissionsDescription) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permission_levels"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PermissionLevels = types.ListValueMust(t, vs)
}

type GetPermissionRequest struct {
	// The id of the request object.
	RequestObjectId types.String `tfsdk:"-"`
	// The type of the request object. Can be one of the following: alerts,
	// alertsv2, authorization, clusters, cluster-policies, dashboards,
	// dbsql-dashboards, directories, experiments, files, genie, instance-pools,
	// jobs, notebooks, pipelines, queries, registered-models, repos,
	// serving-endpoints, or warehouses.
	RequestObjectType types.String `tfsdk:"-"`
}

func (to *GetPermissionRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPermissionRequest) {
}

func (to *GetPermissionRequest) SyncFieldsDuringRead(ctx context.Context, from GetPermissionRequest) {
}

func (c GetPermissionRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["request_object_type"] = attrs["request_object_type"].SetRequired()
	attrs["request_object_id"] = attrs["request_object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPermissionRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetPermissionRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPermissionRequest
// only implements ToObjectValue() and Type().
func (o GetPermissionRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"request_object_id":   o.RequestObjectId,
			"request_object_type": o.RequestObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetPermissionRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"request_object_id":   types.StringType,
			"request_object_type": types.StringType,
		},
	}
}

type GetRuleSetRequest struct {
	// Etag used for versioning. The response is at least as fresh as the eTag
	// provided. Etag is used for optimistic concurrency control as a way to
	// help prevent simultaneous updates of a rule set from overwriting each
	// other. It is strongly suggested that systems make use of the etag in the
	// read -> modify -> write pattern to perform rule set updates in order to
	// avoid race conditions that is get an etag from a GET rule set request,
	// and pass it with the PUT update request to identify the rule set version
	// you are updating.
	//
	// Examples | Summary :--- | :--- `etag=` | An empty etag can only be used
	// in GET to indicate no freshness requirements.
	// `etag=RENUAAABhSweA4NvVmmUYdiU717H3Tgy0UJdor3gE4a+mq/oj9NjAf8ZsQ==` | An
	// etag encoded a specific version of the rule set to get or to be updated.
	Etag types.String `tfsdk:"-"`
	// The ruleset name associated with the request.
	//
	// Examples | Summary :--- | :---
	// `name=accounts/<ACCOUNT_ID>/ruleSets/default` | A name for a rule set on
	// the account.
	// `name=accounts/<ACCOUNT_ID>/groups/<GROUP_ID>/ruleSets/default` | A name
	// for a rule set on the group.
	// `name=accounts/<ACCOUNT_ID>/servicePrincipals/<SERVICE_PRINCIPAL_APPLICATION_ID>/ruleSets/default`
	// | A name for a rule set on the service principal.
	// `name=accounts/<ACCOUNT_ID>/tagPolicies/<TAG_POLICY_ID>/ruleSets/default`
	// | A name for a rule set on the tag policy.
	Name types.String `tfsdk:"-"`
}

func (to *GetRuleSetRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRuleSetRequest) {
}

func (to *GetRuleSetRequest) SyncFieldsDuringRead(ctx context.Context, from GetRuleSetRequest) {
}

func (c GetRuleSetRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()
	attrs["etag"] = attrs["etag"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRuleSetRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetRuleSetRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRuleSetRequest
// only implements ToObjectValue() and Type().
func (o GetRuleSetRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"etag": o.Etag,
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetRuleSetRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"etag": types.StringType,
			"name": types.StringType,
		},
	}
}

type GetServicePrincipalRequest struct {
	// Unique ID for a service principal in the Databricks workspace.
	Id types.String `tfsdk:"-"`
}

func (to *GetServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetServicePrincipalRequest) {
}

func (to *GetServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from GetServicePrincipalRequest) {
}

func (c GetServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o GetServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": o.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type GetUserRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Unique ID for a user in the Databricks workspace.
	Id types.String `tfsdk:"-"`
	// Attribute to sort the results. Multi-part paths are supported. For
	// example, `userName`, `name.givenName`, and `emails`.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *GetUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetUserRequest) {
}

func (to *GetUserRequest) SyncFieldsDuringRead(ctx context.Context, from GetUserRequest) {
}

func (c GetUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetUserRequest
// only implements ToObjectValue() and Type().
func (o GetUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"id":                  o.Id,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"id":                  types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type GetWorkspaceAssignmentRequest struct {
	// The workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *GetWorkspaceAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetWorkspaceAssignmentRequest) {
}

func (to *GetWorkspaceAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, from GetWorkspaceAssignmentRequest) {
}

func (c GetWorkspaceAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetWorkspaceAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GetWorkspaceAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetWorkspaceAssignmentRequest
// only implements ToObjectValue() and Type().
func (o GetWorkspaceAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GetWorkspaceAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspace_id": types.Int64Type,
		},
	}
}

type GrantRule struct {
	// Principals this grant rule applies to. A principal can be a user (for end
	// users), a service principal (for applications and compute workloads), or
	// an account group. Each principal has its own identifier format: *
	// users/<USERNAME> * groups/<GROUP_NAME> *
	// servicePrincipals/<SERVICE_PRINCIPAL_APPLICATION_ID>
	Principals types.List `tfsdk:"principals"`
	// Role that is assigned to the list of principals.
	Role types.String `tfsdk:"role"`
}

func (to *GrantRule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GrantRule) {
	if !from.Principals.IsNull() && !from.Principals.IsUnknown() && to.Principals.IsNull() && len(from.Principals.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Principals, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Principals = from.Principals
	}
}

func (to *GrantRule) SyncFieldsDuringRead(ctx context.Context, from GrantRule) {
	if !from.Principals.IsNull() && !from.Principals.IsUnknown() && to.Principals.IsNull() && len(from.Principals.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Principals, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Principals = from.Principals
	}
}

func (c GrantRule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["principals"] = attrs["principals"].SetOptional()
	attrs["role"] = attrs["role"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GrantRule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a GrantRule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"principals": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GrantRule
// only implements ToObjectValue() and Type().
func (o GrantRule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"principals": o.Principals,
			"role":       o.Role,
		})
}

// Type implements basetypes.ObjectValuable.
func (o GrantRule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"principals": basetypes.ListType{
				ElemType: types.StringType,
			},
			"role": types.StringType,
		},
	}
}

// GetPrincipals returns the value of the Principals field in GrantRule as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *GrantRule) GetPrincipals(ctx context.Context) ([]types.String, bool) {
	if o.Principals.IsNull() || o.Principals.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Principals.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrincipals sets the value of the Principals field in GrantRule.
func (o *GrantRule) SetPrincipals(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["principals"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Principals = types.ListValueMust(t, vs)
}

type Group struct {
	// String that represents a human-readable group name
	DisplayName types.String `tfsdk:"display_name"`
	// Entitlements assigned to the group. See [assigning entitlements] for a
	// full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`
	// external_id should be unique for identifying groups
	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks group ID
	Id types.String `tfsdk:"id"`

	Members types.List `tfsdk:"members"`
	// Container for the group identifier. Workspace local versus account.
	Meta types.Object `tfsdk:"meta"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the group.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *Group) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Group) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				// Recursively sync the fields of Meta
				toMeta.SyncFieldsDuringCreateOrUpdate(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *Group) SyncFieldsDuringRead(ctx context.Context, from Group) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				toMeta.SyncFieldsDuringRead(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c Group) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["members"] = attrs["members"].SetOptional()
	attrs["meta"] = attrs["meta"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Group.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Group) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"members":      reflect.TypeOf(ComplexValue{}),
		"meta":         reflect.TypeOf(ResourceMeta{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Group
// only implements ToObjectValue() and Type().
func (o Group) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name": o.DisplayName,
			"entitlements": o.Entitlements,
			"external_id":  o.ExternalId,
			"groups":       o.Groups,
			"id":           o.Id,
			"members":      o.Members,
			"meta":         o.Meta,
			"roles":        o.Roles,
			"schemas":      o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Group) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name": types.StringType,
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id": types.StringType,
			"members": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"meta": ResourceMeta{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEntitlements returns the value of the Entitlements field in Group as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *Group) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in Group.
func (o *Group) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in Group as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *Group) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in Group.
func (o *Group) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetMembers returns the value of the Members field in Group as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *Group) GetMembers(ctx context.Context) ([]ComplexValue, bool) {
	if o.Members.IsNull() || o.Members.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Members.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMembers sets the value of the Members field in Group.
func (o *Group) SetMembers(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["members"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Members = types.ListValueMust(t, vs)
}

// GetMeta returns the value of the Meta field in Group as
// a ResourceMeta value.
// If the field is unknown or null, the boolean return value is false.
func (o *Group) GetMeta(ctx context.Context) (ResourceMeta, bool) {
	var e ResourceMeta
	if o.Meta.IsNull() || o.Meta.IsUnknown() {
		return e, false
	}
	var v ResourceMeta
	d := o.Meta.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMeta sets the value of the Meta field in Group.
func (o *Group) SetMeta(ctx context.Context, v ResourceMeta) {
	vs := v.ToObjectValue(ctx)
	o.Meta = vs
}

// GetRoles returns the value of the Roles field in Group as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *Group) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in Group.
func (o *Group) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in Group as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *Group) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in Group.
func (o *Group) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type ListAccountGroupsRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page. Default is 10000.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Attribute to sort the results.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *ListAccountGroupsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountGroupsRequest) {
}

func (to *ListAccountGroupsRequest) SyncFieldsDuringRead(ctx context.Context, from ListAccountGroupsRequest) {
}

func (c ListAccountGroupsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountGroupsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountGroupsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountGroupsRequest
// only implements ToObjectValue() and Type().
func (o ListAccountGroupsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountGroupsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type ListAccountGroupsResponse struct {
	// Total results returned in the response.
	ItemsPerPage types.Int64 `tfsdk:"items_per_page"`
	// User objects returned in the response.
	Resources types.List `tfsdk:"resources"`
	// Starting index of all the results that matched the request filters. First
	// item is number 1.
	StartIndex types.Int64 `tfsdk:"start_index"`
	// Total results that match the request filters.
	TotalResults types.Int64 `tfsdk:"total_results"`
}

func (to *ListAccountGroupsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountGroupsResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (to *ListAccountGroupsResponse) SyncFieldsDuringRead(ctx context.Context, from ListAccountGroupsResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (c ListAccountGroupsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()
	attrs["items_per_page"] = attrs["items_per_page"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["total_results"] = attrs["total_results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountGroupsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountGroupsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(AccountGroup{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountGroupsResponse
// only implements ToObjectValue() and Type().
func (o ListAccountGroupsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"items_per_page": o.ItemsPerPage,
			"resources":      o.Resources,
			"start_index":    o.StartIndex,
			"total_results":  o.TotalResults,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountGroupsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"items_per_page": types.Int64Type,
			"resources": basetypes.ListType{
				ElemType: AccountGroup{}.Type(ctx),
			},
			"start_index":   types.Int64Type,
			"total_results": types.Int64Type,
		},
	}
}

// GetResources returns the value of the Resources field in ListAccountGroupsResponse as
// a slice of AccountGroup values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListAccountGroupsResponse) GetResources(ctx context.Context) ([]AccountGroup, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []AccountGroup
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in ListAccountGroupsResponse.
func (o *ListAccountGroupsResponse) SetResources(ctx context.Context, v []AccountGroup) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

type ListAccountServicePrincipalsRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page. Default is 10000.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Attribute to sort the results.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *ListAccountServicePrincipalsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountServicePrincipalsRequest) {
}

func (to *ListAccountServicePrincipalsRequest) SyncFieldsDuringRead(ctx context.Context, from ListAccountServicePrincipalsRequest) {
}

func (c ListAccountServicePrincipalsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountServicePrincipalsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountServicePrincipalsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountServicePrincipalsRequest
// only implements ToObjectValue() and Type().
func (o ListAccountServicePrincipalsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountServicePrincipalsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type ListAccountServicePrincipalsResponse struct {
	// Total results returned in the response.
	ItemsPerPage types.Int64 `tfsdk:"items_per_page"`
	// User objects returned in the response.
	Resources types.List `tfsdk:"resources"`
	// Starting index of all the results that matched the request filters. First
	// item is number 1.
	StartIndex types.Int64 `tfsdk:"start_index"`
	// Total results that match the request filters.
	TotalResults types.Int64 `tfsdk:"total_results"`
}

func (to *ListAccountServicePrincipalsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountServicePrincipalsResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (to *ListAccountServicePrincipalsResponse) SyncFieldsDuringRead(ctx context.Context, from ListAccountServicePrincipalsResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (c ListAccountServicePrincipalsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()
	attrs["items_per_page"] = attrs["items_per_page"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["total_results"] = attrs["total_results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountServicePrincipalsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountServicePrincipalsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(AccountServicePrincipal{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountServicePrincipalsResponse
// only implements ToObjectValue() and Type().
func (o ListAccountServicePrincipalsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"items_per_page": o.ItemsPerPage,
			"resources":      o.Resources,
			"start_index":    o.StartIndex,
			"total_results":  o.TotalResults,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountServicePrincipalsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"items_per_page": types.Int64Type,
			"resources": basetypes.ListType{
				ElemType: AccountServicePrincipal{}.Type(ctx),
			},
			"start_index":   types.Int64Type,
			"total_results": types.Int64Type,
		},
	}
}

// GetResources returns the value of the Resources field in ListAccountServicePrincipalsResponse as
// a slice of AccountServicePrincipal values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListAccountServicePrincipalsResponse) GetResources(ctx context.Context) ([]AccountServicePrincipal, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []AccountServicePrincipal
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in ListAccountServicePrincipalsResponse.
func (o *ListAccountServicePrincipalsResponse) SetResources(ctx context.Context, v []AccountServicePrincipal) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

type ListAccountUsersRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page. Default is 10000.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Attribute to sort the results. Multi-part paths are supported. For
	// example, `userName`, `name.givenName`, and `emails`.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *ListAccountUsersRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountUsersRequest) {
}

func (to *ListAccountUsersRequest) SyncFieldsDuringRead(ctx context.Context, from ListAccountUsersRequest) {
}

func (c ListAccountUsersRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountUsersRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountUsersRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountUsersRequest
// only implements ToObjectValue() and Type().
func (o ListAccountUsersRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountUsersRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type ListAccountUsersResponse struct {
	// Total results returned in the response.
	ItemsPerPage types.Int64 `tfsdk:"items_per_page"`
	// User objects returned in the response.
	Resources types.List `tfsdk:"resources"`
	// Starting index of all the results that matched the request filters. First
	// item is number 1.
	StartIndex types.Int64 `tfsdk:"start_index"`
	// Total results that match the request filters.
	TotalResults types.Int64 `tfsdk:"total_results"`
}

func (to *ListAccountUsersResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListAccountUsersResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (to *ListAccountUsersResponse) SyncFieldsDuringRead(ctx context.Context, from ListAccountUsersResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
}

func (c ListAccountUsersResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()
	attrs["items_per_page"] = attrs["items_per_page"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["total_results"] = attrs["total_results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListAccountUsersResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListAccountUsersResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(AccountUser{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListAccountUsersResponse
// only implements ToObjectValue() and Type().
func (o ListAccountUsersResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"items_per_page": o.ItemsPerPage,
			"resources":      o.Resources,
			"start_index":    o.StartIndex,
			"total_results":  o.TotalResults,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListAccountUsersResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"items_per_page": types.Int64Type,
			"resources": basetypes.ListType{
				ElemType: AccountUser{}.Type(ctx),
			},
			"start_index":   types.Int64Type,
			"total_results": types.Int64Type,
		},
	}
}

// GetResources returns the value of the Resources field in ListAccountUsersResponse as
// a slice of AccountUser values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListAccountUsersResponse) GetResources(ctx context.Context) ([]AccountUser, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []AccountUser
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in ListAccountUsersResponse.
func (o *ListAccountUsersResponse) SetResources(ctx context.Context, v []AccountUser) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

type ListGroupsRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Attribute to sort the results.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *ListGroupsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListGroupsRequest) {
}

func (to *ListGroupsRequest) SyncFieldsDuringRead(ctx context.Context, from ListGroupsRequest) {
}

func (c ListGroupsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListGroupsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListGroupsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListGroupsRequest
// only implements ToObjectValue() and Type().
func (o ListGroupsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListGroupsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type ListGroupsResponse struct {
	// Total results returned in the response.
	ItemsPerPage types.Int64 `tfsdk:"items_per_page"`
	// User objects returned in the response.
	Resources types.List `tfsdk:"resources"`
	// The schema of the service principal.
	Schemas types.List `tfsdk:"schemas"`
	// Starting index of all the results that matched the request filters. First
	// item is number 1.
	StartIndex types.Int64 `tfsdk:"start_index"`
	// Total results that match the request filters.
	TotalResults types.Int64 `tfsdk:"total_results"`
}

func (to *ListGroupsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListGroupsResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *ListGroupsResponse) SyncFieldsDuringRead(ctx context.Context, from ListGroupsResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c ListGroupsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()
	attrs["items_per_page"] = attrs["items_per_page"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["total_results"] = attrs["total_results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListGroupsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListGroupsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(Group{}),
		"schemas":   reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListGroupsResponse
// only implements ToObjectValue() and Type().
func (o ListGroupsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"items_per_page": o.ItemsPerPage,
			"resources":      o.Resources,
			"schemas":        o.Schemas,
			"start_index":    o.StartIndex,
			"total_results":  o.TotalResults,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListGroupsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"items_per_page": types.Int64Type,
			"resources": basetypes.ListType{
				ElemType: Group{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
			"start_index":   types.Int64Type,
			"total_results": types.Int64Type,
		},
	}
}

// GetResources returns the value of the Resources field in ListGroupsResponse as
// a slice of Group values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListGroupsResponse) GetResources(ctx context.Context) ([]Group, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []Group
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in ListGroupsResponse.
func (o *ListGroupsResponse) SetResources(ctx context.Context, v []Group) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in ListGroupsResponse as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListGroupsResponse) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListGroupsResponse.
func (o *ListGroupsResponse) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type ListServicePrincipalResponse struct {
	// Total results returned in the response.
	ItemsPerPage types.Int64 `tfsdk:"items_per_page"`
	// User objects returned in the response.
	Resources types.List `tfsdk:"resources"`
	// The schema of the List response.
	Schemas types.List `tfsdk:"schemas"`
	// Starting index of all the results that matched the request filters. First
	// item is number 1.
	StartIndex types.Int64 `tfsdk:"start_index"`
	// Total results that match the request filters.
	TotalResults types.Int64 `tfsdk:"total_results"`
}

func (to *ListServicePrincipalResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListServicePrincipalResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *ListServicePrincipalResponse) SyncFieldsDuringRead(ctx context.Context, from ListServicePrincipalResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c ListServicePrincipalResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()
	attrs["items_per_page"] = attrs["items_per_page"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["total_results"] = attrs["total_results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListServicePrincipalResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListServicePrincipalResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(ServicePrincipal{}),
		"schemas":   reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListServicePrincipalResponse
// only implements ToObjectValue() and Type().
func (o ListServicePrincipalResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"items_per_page": o.ItemsPerPage,
			"resources":      o.Resources,
			"schemas":        o.Schemas,
			"start_index":    o.StartIndex,
			"total_results":  o.TotalResults,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListServicePrincipalResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"items_per_page": types.Int64Type,
			"resources": basetypes.ListType{
				ElemType: ServicePrincipal{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
			"start_index":   types.Int64Type,
			"total_results": types.Int64Type,
		},
	}
}

// GetResources returns the value of the Resources field in ListServicePrincipalResponse as
// a slice of ServicePrincipal values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListServicePrincipalResponse) GetResources(ctx context.Context) ([]ServicePrincipal, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []ServicePrincipal
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in ListServicePrincipalResponse.
func (o *ListServicePrincipalResponse) SetResources(ctx context.Context, v []ServicePrincipal) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in ListServicePrincipalResponse as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListServicePrincipalResponse) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListServicePrincipalResponse.
func (o *ListServicePrincipalResponse) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type ListServicePrincipalsRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Attribute to sort the results.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *ListServicePrincipalsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListServicePrincipalsRequest) {
}

func (to *ListServicePrincipalsRequest) SyncFieldsDuringRead(ctx context.Context, from ListServicePrincipalsRequest) {
}

func (c ListServicePrincipalsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListServicePrincipalsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListServicePrincipalsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListServicePrincipalsRequest
// only implements ToObjectValue() and Type().
func (o ListServicePrincipalsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListServicePrincipalsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type ListUsersRequest struct {
	// Comma-separated list of attributes to return in response.
	Attributes types.String `tfsdk:"-"`
	// Desired number of results per page.
	Count types.Int64 `tfsdk:"-"`
	// Comma-separated list of attributes to exclude in response.
	ExcludedAttributes types.String `tfsdk:"-"`
	// Query by which the results have to be filtered. Supported operators are
	// equals(`eq`), contains(`co`), starts with(`sw`) and not equals(`ne`).
	// Additionally, simple expressions can be formed using logical operators -
	// `and` and `or`. The [SCIM RFC] has more details but we currently only
	// support simple expressions.
	//
	// [SCIM RFC]: https://tools.ietf.org/html/rfc7644#section-3.4.2.2
	Filter types.String `tfsdk:"-"`
	// Attribute to sort the results. Multi-part paths are supported. For
	// example, `userName`, `name.givenName`, and `emails`.
	SortBy types.String `tfsdk:"-"`
	// The order to sort the results.
	SortOrder types.String `tfsdk:"-"`
	// Specifies the index of the first result. First item is number 1.
	StartIndex types.Int64 `tfsdk:"-"`
}

func (to *ListUsersRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListUsersRequest) {
}

func (to *ListUsersRequest) SyncFieldsDuringRead(ctx context.Context, from ListUsersRequest) {
}

func (c ListUsersRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attributes"] = attrs["attributes"].SetOptional()
	attrs["count"] = attrs["count"].SetOptional()
	attrs["excluded_attributes"] = attrs["excluded_attributes"].SetOptional()
	attrs["filter"] = attrs["filter"].SetOptional()
	attrs["sort_by"] = attrs["sort_by"].SetOptional()
	attrs["sort_order"] = attrs["sort_order"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListUsersRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListUsersRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListUsersRequest
// only implements ToObjectValue() and Type().
func (o ListUsersRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attributes":          o.Attributes,
			"count":               o.Count,
			"excluded_attributes": o.ExcludedAttributes,
			"filter":              o.Filter,
			"sort_by":             o.SortBy,
			"sort_order":          o.SortOrder,
			"start_index":         o.StartIndex,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListUsersRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attributes":          types.StringType,
			"count":               types.Int64Type,
			"excluded_attributes": types.StringType,
			"filter":              types.StringType,
			"sort_by":             types.StringType,
			"sort_order":          types.StringType,
			"start_index":         types.Int64Type,
		},
	}
}

type ListUsersResponse struct {
	// Total results returned in the response.
	ItemsPerPage types.Int64 `tfsdk:"items_per_page"`
	// User objects returned in the response.
	Resources types.List `tfsdk:"resources"`
	// The schema of the List response.
	Schemas types.List `tfsdk:"schemas"`
	// Starting index of all the results that matched the request filters. First
	// item is number 1.
	StartIndex types.Int64 `tfsdk:"start_index"`
	// Total results that match the request filters.
	TotalResults types.Int64 `tfsdk:"total_results"`
}

func (to *ListUsersResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListUsersResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *ListUsersResponse) SyncFieldsDuringRead(ctx context.Context, from ListUsersResponse) {
	if !from.Resources.IsNull() && !from.Resources.IsUnknown() && to.Resources.IsNull() && len(from.Resources.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Resources, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Resources = from.Resources
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c ListUsersResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resources"] = attrs["resources"].SetOptional()
	attrs["items_per_page"] = attrs["items_per_page"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["start_index"] = attrs["start_index"].SetOptional()
	attrs["total_results"] = attrs["total_results"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListUsersResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListUsersResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"resources": reflect.TypeOf(User{}),
		"schemas":   reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListUsersResponse
// only implements ToObjectValue() and Type().
func (o ListUsersResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"items_per_page": o.ItemsPerPage,
			"resources":      o.Resources,
			"schemas":        o.Schemas,
			"start_index":    o.StartIndex,
			"total_results":  o.TotalResults,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListUsersResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"items_per_page": types.Int64Type,
			"resources": basetypes.ListType{
				ElemType: User{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
			"start_index":   types.Int64Type,
			"total_results": types.Int64Type,
		},
	}
}

// GetResources returns the value of the Resources field in ListUsersResponse as
// a slice of User values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListUsersResponse) GetResources(ctx context.Context) ([]User, bool) {
	if o.Resources.IsNull() || o.Resources.IsUnknown() {
		return nil, false
	}
	var v []User
	d := o.Resources.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResources sets the value of the Resources field in ListUsersResponse.
func (o *ListUsersResponse) SetResources(ctx context.Context, v []User) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["resources"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Resources = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in ListUsersResponse as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ListUsersResponse) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ListUsersResponse.
func (o *ListUsersResponse) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type ListWorkspaceAssignmentRequest struct {
	// The workspace ID for the account.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *ListWorkspaceAssignmentRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListWorkspaceAssignmentRequest) {
}

func (to *ListWorkspaceAssignmentRequest) SyncFieldsDuringRead(ctx context.Context, from ListWorkspaceAssignmentRequest) {
}

func (c ListWorkspaceAssignmentRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListWorkspaceAssignmentRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ListWorkspaceAssignmentRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListWorkspaceAssignmentRequest
// only implements ToObjectValue() and Type().
func (o ListWorkspaceAssignmentRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ListWorkspaceAssignmentRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"workspace_id": types.Int64Type,
		},
	}
}

type MeRequest struct {
}

func (to *MeRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MeRequest) {
}

func (to *MeRequest) SyncFieldsDuringRead(ctx context.Context, from MeRequest) {
}

func (c MeRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MeRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MeRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MeRequest
// only implements ToObjectValue() and Type().
func (o MeRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{})
}

// Type implements basetypes.ObjectValuable.
func (o MeRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{},
	}
}

type MigratePermissionsRequest struct {
	// The name of the workspace group that permissions will be migrated from.
	FromWorkspaceGroupName types.String `tfsdk:"from_workspace_group_name"`
	// The maximum number of permissions that will be migrated.
	Size types.Int64 `tfsdk:"size"`
	// The name of the account group that permissions will be migrated to.
	ToAccountGroupName types.String `tfsdk:"to_account_group_name"`
	// WorkspaceId of the associated workspace where the permission migration
	// will occur.
	WorkspaceId types.Int64 `tfsdk:"workspace_id"`
}

func (to *MigratePermissionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MigratePermissionsRequest) {
}

func (to *MigratePermissionsRequest) SyncFieldsDuringRead(ctx context.Context, from MigratePermissionsRequest) {
}

func (c MigratePermissionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["from_workspace_group_name"] = attrs["from_workspace_group_name"].SetRequired()
	attrs["size"] = attrs["size"].SetOptional()
	attrs["to_account_group_name"] = attrs["to_account_group_name"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MigratePermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MigratePermissionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MigratePermissionsRequest
// only implements ToObjectValue() and Type().
func (o MigratePermissionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"from_workspace_group_name": o.FromWorkspaceGroupName,
			"size":                      o.Size,
			"to_account_group_name":     o.ToAccountGroupName,
			"workspace_id":              o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MigratePermissionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"from_workspace_group_name": types.StringType,
			"size":                      types.Int64Type,
			"to_account_group_name":     types.StringType,
			"workspace_id":              types.Int64Type,
		},
	}
}

type MigratePermissionsResponse struct {
	// Number of permissions migrated.
	PermissionsMigrated types.Int64 `tfsdk:"permissions_migrated"`
}

func (to *MigratePermissionsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from MigratePermissionsResponse) {
}

func (to *MigratePermissionsResponse) SyncFieldsDuringRead(ctx context.Context, from MigratePermissionsResponse) {
}

func (c MigratePermissionsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permissions_migrated"] = attrs["permissions_migrated"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in MigratePermissionsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a MigratePermissionsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, MigratePermissionsResponse
// only implements ToObjectValue() and Type().
func (o MigratePermissionsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permissions_migrated": o.PermissionsMigrated,
		})
}

// Type implements basetypes.ObjectValuable.
func (o MigratePermissionsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permissions_migrated": types.Int64Type,
		},
	}
}

type Name struct {
	// Family name of the Databricks user.
	FamilyName types.String `tfsdk:"family_name"`
	// Given name of the Databricks user.
	GivenName types.String `tfsdk:"given_name"`
}

func (to *Name) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Name) {
}

func (to *Name) SyncFieldsDuringRead(ctx context.Context, from Name) {
}

func (c Name) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["family_name"] = attrs["family_name"].SetOptional()
	attrs["given_name"] = attrs["given_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Name.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Name) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Name
// only implements ToObjectValue() and Type().
func (o Name) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"family_name": o.FamilyName,
			"given_name":  o.GivenName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Name) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"family_name": types.StringType,
			"given_name":  types.StringType,
		},
	}
}

type ObjectPermissions struct {
	AccessControlList types.List `tfsdk:"access_control_list"`

	ObjectId types.String `tfsdk:"object_id"`

	ObjectType types.String `tfsdk:"object_type"`
}

func (to *ObjectPermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ObjectPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *ObjectPermissions) SyncFieldsDuringRead(ctx context.Context, from ObjectPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (c ObjectPermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["object_id"] = attrs["object_id"].SetOptional()
	attrs["object_type"] = attrs["object_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ObjectPermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ObjectPermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(AccessControlResponse{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ObjectPermissions
// only implements ToObjectValue() and Type().
func (o ObjectPermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": o.AccessControlList,
			"object_id":           o.ObjectId,
			"object_type":         o.ObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ObjectPermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: AccessControlResponse{}.Type(ctx),
			},
			"object_id":   types.StringType,
			"object_type": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in ObjectPermissions as
// a slice of AccessControlResponse values.
// If the field is unknown or null, the boolean return value is false.
func (o *ObjectPermissions) GetAccessControlList(ctx context.Context) ([]AccessControlResponse, bool) {
	if o.AccessControlList.IsNull() || o.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []AccessControlResponse
	d := o.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in ObjectPermissions.
func (o *ObjectPermissions) SetAccessControlList(ctx context.Context, v []AccessControlResponse) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AccessControlList = types.ListValueMust(t, vs)
}

type PasswordAccessControlRequest struct {
	// name of the group
	GroupName types.String `tfsdk:"group_name"`
	// Permission level
	PermissionLevel types.String `tfsdk:"permission_level"`
	// application ID of a service principal
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *PasswordAccessControlRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PasswordAccessControlRequest) {
}

func (to *PasswordAccessControlRequest) SyncFieldsDuringRead(ctx context.Context, from PasswordAccessControlRequest) {
}

func (c PasswordAccessControlRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PasswordAccessControlRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PasswordAccessControlRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PasswordAccessControlRequest
// only implements ToObjectValue() and Type().
func (o PasswordAccessControlRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"group_name":             o.GroupName,
			"permission_level":       o.PermissionLevel,
			"service_principal_name": o.ServicePrincipalName,
			"user_name":              o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PasswordAccessControlRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"group_name":             types.StringType,
			"permission_level":       types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type PasswordAccessControlResponse struct {
	// All permissions.
	AllPermissions types.List `tfsdk:"all_permissions"`
	// Display name of the user or service principal.
	DisplayName types.String `tfsdk:"display_name"`
	// name of the group
	GroupName types.String `tfsdk:"group_name"`
	// Name of the service principal.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *PasswordAccessControlResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PasswordAccessControlResponse) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (to *PasswordAccessControlResponse) SyncFieldsDuringRead(ctx context.Context, from PasswordAccessControlResponse) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (c PasswordAccessControlResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["all_permissions"] = attrs["all_permissions"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PasswordAccessControlResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PasswordAccessControlResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"all_permissions": reflect.TypeOf(PasswordPermission{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PasswordAccessControlResponse
// only implements ToObjectValue() and Type().
func (o PasswordAccessControlResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"all_permissions":        o.AllPermissions,
			"display_name":           o.DisplayName,
			"group_name":             o.GroupName,
			"service_principal_name": o.ServicePrincipalName,
			"user_name":              o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PasswordAccessControlResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"all_permissions": basetypes.ListType{
				ElemType: PasswordPermission{}.Type(ctx),
			},
			"display_name":           types.StringType,
			"group_name":             types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

// GetAllPermissions returns the value of the AllPermissions field in PasswordAccessControlResponse as
// a slice of PasswordPermission values.
// If the field is unknown or null, the boolean return value is false.
func (o *PasswordAccessControlResponse) GetAllPermissions(ctx context.Context) ([]PasswordPermission, bool) {
	if o.AllPermissions.IsNull() || o.AllPermissions.IsUnknown() {
		return nil, false
	}
	var v []PasswordPermission
	d := o.AllPermissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAllPermissions sets the value of the AllPermissions field in PasswordAccessControlResponse.
func (o *PasswordAccessControlResponse) SetAllPermissions(ctx context.Context, v []PasswordPermission) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["all_permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AllPermissions = types.ListValueMust(t, vs)
}

type PasswordPermission struct {
	Inherited types.Bool `tfsdk:"inherited"`

	InheritedFromObject types.List `tfsdk:"inherited_from_object"`
	// Permission level
	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *PasswordPermission) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PasswordPermission) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (to *PasswordPermission) SyncFieldsDuringRead(ctx context.Context, from PasswordPermission) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (c PasswordPermission) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited"] = attrs["inherited"].SetOptional()
	attrs["inherited_from_object"] = attrs["inherited_from_object"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PasswordPermission.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PasswordPermission) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"inherited_from_object": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PasswordPermission
// only implements ToObjectValue() and Type().
func (o PasswordPermission) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited":             o.Inherited,
			"inherited_from_object": o.InheritedFromObject,
			"permission_level":      o.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PasswordPermission) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited": types.BoolType,
			"inherited_from_object": basetypes.ListType{
				ElemType: types.StringType,
			},
			"permission_level": types.StringType,
		},
	}
}

// GetInheritedFromObject returns the value of the InheritedFromObject field in PasswordPermission as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PasswordPermission) GetInheritedFromObject(ctx context.Context) ([]types.String, bool) {
	if o.InheritedFromObject.IsNull() || o.InheritedFromObject.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.InheritedFromObject.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInheritedFromObject sets the value of the InheritedFromObject field in PasswordPermission.
func (o *PasswordPermission) SetInheritedFromObject(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["inherited_from_object"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.InheritedFromObject = types.ListValueMust(t, vs)
}

type PasswordPermissions struct {
	AccessControlList types.List `tfsdk:"access_control_list"`

	ObjectId types.String `tfsdk:"object_id"`

	ObjectType types.String `tfsdk:"object_type"`
}

func (to *PasswordPermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PasswordPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *PasswordPermissions) SyncFieldsDuringRead(ctx context.Context, from PasswordPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (c PasswordPermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["object_id"] = attrs["object_id"].SetOptional()
	attrs["object_type"] = attrs["object_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PasswordPermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PasswordPermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(PasswordAccessControlResponse{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PasswordPermissions
// only implements ToObjectValue() and Type().
func (o PasswordPermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": o.AccessControlList,
			"object_id":           o.ObjectId,
			"object_type":         o.ObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PasswordPermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: PasswordAccessControlResponse{}.Type(ctx),
			},
			"object_id":   types.StringType,
			"object_type": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in PasswordPermissions as
// a slice of PasswordAccessControlResponse values.
// If the field is unknown or null, the boolean return value is false.
func (o *PasswordPermissions) GetAccessControlList(ctx context.Context) ([]PasswordAccessControlResponse, bool) {
	if o.AccessControlList.IsNull() || o.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []PasswordAccessControlResponse
	d := o.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in PasswordPermissions.
func (o *PasswordPermissions) SetAccessControlList(ctx context.Context, v []PasswordAccessControlResponse) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AccessControlList = types.ListValueMust(t, vs)
}

type PasswordPermissionsDescription struct {
	Description types.String `tfsdk:"description"`
	// Permission level
	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *PasswordPermissionsDescription) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PasswordPermissionsDescription) {
}

func (to *PasswordPermissionsDescription) SyncFieldsDuringRead(ctx context.Context, from PasswordPermissionsDescription) {
}

func (c PasswordPermissionsDescription) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PasswordPermissionsDescription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PasswordPermissionsDescription) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PasswordPermissionsDescription
// only implements ToObjectValue() and Type().
func (o PasswordPermissionsDescription) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":      o.Description,
			"permission_level": o.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PasswordPermissionsDescription) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":      types.StringType,
			"permission_level": types.StringType,
		},
	}
}

type PasswordPermissionsRequest struct {
	AccessControlList types.List `tfsdk:"access_control_list"`
}

func (to *PasswordPermissionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PasswordPermissionsRequest) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *PasswordPermissionsRequest) SyncFieldsDuringRead(ctx context.Context, from PasswordPermissionsRequest) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (c PasswordPermissionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PasswordPermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PasswordPermissionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(PasswordAccessControlRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PasswordPermissionsRequest
// only implements ToObjectValue() and Type().
func (o PasswordPermissionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": o.AccessControlList,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PasswordPermissionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: PasswordAccessControlRequest{}.Type(ctx),
			},
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in PasswordPermissionsRequest as
// a slice of PasswordAccessControlRequest values.
// If the field is unknown or null, the boolean return value is false.
func (o *PasswordPermissionsRequest) GetAccessControlList(ctx context.Context) ([]PasswordAccessControlRequest, bool) {
	if o.AccessControlList.IsNull() || o.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []PasswordAccessControlRequest
	d := o.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in PasswordPermissionsRequest.
func (o *PasswordPermissionsRequest) SetAccessControlList(ctx context.Context, v []PasswordAccessControlRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AccessControlList = types.ListValueMust(t, vs)
}

type Patch struct {
	// Type of patch operation.
	Op types.String `tfsdk:"op"`
	// Selection of patch operation
	Path types.String `tfsdk:"path"`
	// Value to modify
	Value types.Object `tfsdk:"value"`
}

func (to *Patch) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Patch) {
}

func (to *Patch) SyncFieldsDuringRead(ctx context.Context, from Patch) {
}

func (c Patch) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["op"] = attrs["op"].SetOptional()
	attrs["path"] = attrs["path"].SetOptional()
	attrs["value"] = attrs["value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Patch.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Patch) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Patch
// only implements ToObjectValue() and Type().
func (o Patch) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"op":    o.Op,
			"path":  o.Path,
			"value": o.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Patch) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"op":    types.StringType,
			"path":  types.StringType,
			"value": types.ObjectType{},
		},
	}
}

type PatchAccountGroupRequest struct {
	// Unique ID in the Databricks workspace.
	Id types.String `tfsdk:"-"`

	Operations types.List `tfsdk:"operations"`
	// The schema of the patch request. Must be
	// ["urn:ietf:params:scim:api:messages:2.0:PatchOp"].
	Schemas types.List `tfsdk:"schemas"`
}

func (to *PatchAccountGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PatchAccountGroupRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *PatchAccountGroupRequest) SyncFieldsDuringRead(ctx context.Context, from PatchAccountGroupRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c PatchAccountGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operations"] = attrs["operations"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PatchAccountGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PatchAccountGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"operations": reflect.TypeOf(Patch{}),
		"schemas":    reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PatchAccountGroupRequest
// only implements ToObjectValue() and Type().
func (o PatchAccountGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":         o.Id,
			"operations": o.Operations,
			"schemas":    o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PatchAccountGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"operations": basetypes.ListType{
				ElemType: Patch{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOperations returns the value of the Operations field in PatchAccountGroupRequest as
// a slice of Patch values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchAccountGroupRequest) GetOperations(ctx context.Context) ([]Patch, bool) {
	if o.Operations.IsNull() || o.Operations.IsUnknown() {
		return nil, false
	}
	var v []Patch
	d := o.Operations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOperations sets the value of the Operations field in PatchAccountGroupRequest.
func (o *PatchAccountGroupRequest) SetOperations(ctx context.Context, v []Patch) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["operations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Operations = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in PatchAccountGroupRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchAccountGroupRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in PatchAccountGroupRequest.
func (o *PatchAccountGroupRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type PatchAccountServicePrincipalRequest struct {
	// Unique ID in the Databricks workspace.
	Id types.String `tfsdk:"-"`

	Operations types.List `tfsdk:"operations"`
	// The schema of the patch request. Must be
	// ["urn:ietf:params:scim:api:messages:2.0:PatchOp"].
	Schemas types.List `tfsdk:"schemas"`
}

func (to *PatchAccountServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PatchAccountServicePrincipalRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *PatchAccountServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from PatchAccountServicePrincipalRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c PatchAccountServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operations"] = attrs["operations"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PatchAccountServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PatchAccountServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"operations": reflect.TypeOf(Patch{}),
		"schemas":    reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PatchAccountServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o PatchAccountServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":         o.Id,
			"operations": o.Operations,
			"schemas":    o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PatchAccountServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"operations": basetypes.ListType{
				ElemType: Patch{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOperations returns the value of the Operations field in PatchAccountServicePrincipalRequest as
// a slice of Patch values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchAccountServicePrincipalRequest) GetOperations(ctx context.Context) ([]Patch, bool) {
	if o.Operations.IsNull() || o.Operations.IsUnknown() {
		return nil, false
	}
	var v []Patch
	d := o.Operations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOperations sets the value of the Operations field in PatchAccountServicePrincipalRequest.
func (o *PatchAccountServicePrincipalRequest) SetOperations(ctx context.Context, v []Patch) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["operations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Operations = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in PatchAccountServicePrincipalRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchAccountServicePrincipalRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in PatchAccountServicePrincipalRequest.
func (o *PatchAccountServicePrincipalRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type PatchAccountUserRequest struct {
	// Unique ID in the Databricks workspace.
	Id types.String `tfsdk:"-"`

	Operations types.List `tfsdk:"operations"`
	// The schema of the patch request. Must be
	// ["urn:ietf:params:scim:api:messages:2.0:PatchOp"].
	Schemas types.List `tfsdk:"schemas"`
}

func (to *PatchAccountUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PatchAccountUserRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *PatchAccountUserRequest) SyncFieldsDuringRead(ctx context.Context, from PatchAccountUserRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c PatchAccountUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operations"] = attrs["operations"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PatchAccountUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PatchAccountUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"operations": reflect.TypeOf(Patch{}),
		"schemas":    reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PatchAccountUserRequest
// only implements ToObjectValue() and Type().
func (o PatchAccountUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":         o.Id,
			"operations": o.Operations,
			"schemas":    o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PatchAccountUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"operations": basetypes.ListType{
				ElemType: Patch{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOperations returns the value of the Operations field in PatchAccountUserRequest as
// a slice of Patch values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchAccountUserRequest) GetOperations(ctx context.Context) ([]Patch, bool) {
	if o.Operations.IsNull() || o.Operations.IsUnknown() {
		return nil, false
	}
	var v []Patch
	d := o.Operations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOperations sets the value of the Operations field in PatchAccountUserRequest.
func (o *PatchAccountUserRequest) SetOperations(ctx context.Context, v []Patch) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["operations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Operations = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in PatchAccountUserRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchAccountUserRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in PatchAccountUserRequest.
func (o *PatchAccountUserRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type PatchGroupRequest struct {
	// Unique ID in the Databricks workspace.
	Id types.String `tfsdk:"-"`

	Operations types.List `tfsdk:"operations"`
	// The schema of the patch request. Must be
	// ["urn:ietf:params:scim:api:messages:2.0:PatchOp"].
	Schemas types.List `tfsdk:"schemas"`
}

func (to *PatchGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PatchGroupRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *PatchGroupRequest) SyncFieldsDuringRead(ctx context.Context, from PatchGroupRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c PatchGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operations"] = attrs["operations"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PatchGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PatchGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"operations": reflect.TypeOf(Patch{}),
		"schemas":    reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PatchGroupRequest
// only implements ToObjectValue() and Type().
func (o PatchGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":         o.Id,
			"operations": o.Operations,
			"schemas":    o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PatchGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"operations": basetypes.ListType{
				ElemType: Patch{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOperations returns the value of the Operations field in PatchGroupRequest as
// a slice of Patch values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchGroupRequest) GetOperations(ctx context.Context) ([]Patch, bool) {
	if o.Operations.IsNull() || o.Operations.IsUnknown() {
		return nil, false
	}
	var v []Patch
	d := o.Operations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOperations sets the value of the Operations field in PatchGroupRequest.
func (o *PatchGroupRequest) SetOperations(ctx context.Context, v []Patch) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["operations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Operations = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in PatchGroupRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchGroupRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in PatchGroupRequest.
func (o *PatchGroupRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type PatchServicePrincipalRequest struct {
	// Unique ID in the Databricks workspace.
	Id types.String `tfsdk:"-"`

	Operations types.List `tfsdk:"operations"`
	// The schema of the patch request. Must be
	// ["urn:ietf:params:scim:api:messages:2.0:PatchOp"].
	Schemas types.List `tfsdk:"schemas"`
}

func (to *PatchServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PatchServicePrincipalRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *PatchServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from PatchServicePrincipalRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c PatchServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operations"] = attrs["operations"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PatchServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PatchServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"operations": reflect.TypeOf(Patch{}),
		"schemas":    reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PatchServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o PatchServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":         o.Id,
			"operations": o.Operations,
			"schemas":    o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PatchServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"operations": basetypes.ListType{
				ElemType: Patch{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOperations returns the value of the Operations field in PatchServicePrincipalRequest as
// a slice of Patch values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchServicePrincipalRequest) GetOperations(ctx context.Context) ([]Patch, bool) {
	if o.Operations.IsNull() || o.Operations.IsUnknown() {
		return nil, false
	}
	var v []Patch
	d := o.Operations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOperations sets the value of the Operations field in PatchServicePrincipalRequest.
func (o *PatchServicePrincipalRequest) SetOperations(ctx context.Context, v []Patch) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["operations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Operations = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in PatchServicePrincipalRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchServicePrincipalRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in PatchServicePrincipalRequest.
func (o *PatchServicePrincipalRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type PatchUserRequest struct {
	// Unique ID in the Databricks workspace.
	Id types.String `tfsdk:"-"`

	Operations types.List `tfsdk:"operations"`
	// The schema of the patch request. Must be
	// ["urn:ietf:params:scim:api:messages:2.0:PatchOp"].
	Schemas types.List `tfsdk:"schemas"`
}

func (to *PatchUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PatchUserRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *PatchUserRequest) SyncFieldsDuringRead(ctx context.Context, from PatchUserRequest) {
	if !from.Operations.IsNull() && !from.Operations.IsUnknown() && to.Operations.IsNull() && len(from.Operations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Operations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Operations = from.Operations
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c PatchUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["operations"] = attrs["operations"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PatchUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PatchUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"operations": reflect.TypeOf(Patch{}),
		"schemas":    reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PatchUserRequest
// only implements ToObjectValue() and Type().
func (o PatchUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id":         o.Id,
			"operations": o.Operations,
			"schemas":    o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PatchUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
			"operations": basetypes.ListType{
				ElemType: Patch{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOperations returns the value of the Operations field in PatchUserRequest as
// a slice of Patch values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchUserRequest) GetOperations(ctx context.Context) ([]Patch, bool) {
	if o.Operations.IsNull() || o.Operations.IsUnknown() {
		return nil, false
	}
	var v []Patch
	d := o.Operations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOperations sets the value of the Operations field in PatchUserRequest.
func (o *PatchUserRequest) SetOperations(ctx context.Context, v []Patch) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["operations"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Operations = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in PatchUserRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PatchUserRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in PatchUserRequest.
func (o *PatchUserRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type Permission struct {
	Inherited types.Bool `tfsdk:"inherited"`

	InheritedFromObject types.List `tfsdk:"inherited_from_object"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *Permission) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Permission) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (to *Permission) SyncFieldsDuringRead(ctx context.Context, from Permission) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (c Permission) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited"] = attrs["inherited"].SetOptional()
	attrs["inherited_from_object"] = attrs["inherited_from_object"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Permission.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Permission) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"inherited_from_object": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Permission
// only implements ToObjectValue() and Type().
func (o Permission) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited":             o.Inherited,
			"inherited_from_object": o.InheritedFromObject,
			"permission_level":      o.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Permission) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited": types.BoolType,
			"inherited_from_object": basetypes.ListType{
				ElemType: types.StringType,
			},
			"permission_level": types.StringType,
		},
	}
}

// GetInheritedFromObject returns the value of the InheritedFromObject field in Permission as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *Permission) GetInheritedFromObject(ctx context.Context) ([]types.String, bool) {
	if o.InheritedFromObject.IsNull() || o.InheritedFromObject.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.InheritedFromObject.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInheritedFromObject sets the value of the InheritedFromObject field in Permission.
func (o *Permission) SetInheritedFromObject(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["inherited_from_object"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.InheritedFromObject = types.ListValueMust(t, vs)
}

// The output format for existing workspace PermissionAssignment records, which
// contains some info for user consumption.
type PermissionAssignment struct {
	// Error response associated with a workspace permission assignment, if any.
	Error types.String `tfsdk:"error"`
	// The permissions level of the principal.
	Permissions types.List `tfsdk:"permissions"`
	// Information about the principal assigned to the workspace.
	Principal types.Object `tfsdk:"principal"`
}

func (to *PermissionAssignment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PermissionAssignment) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
	if !from.Principal.IsNull() && !from.Principal.IsUnknown() {
		if toPrincipal, ok := to.GetPrincipal(ctx); ok {
			if fromPrincipal, ok := from.GetPrincipal(ctx); ok {
				// Recursively sync the fields of Principal
				toPrincipal.SyncFieldsDuringCreateOrUpdate(ctx, fromPrincipal)
				to.SetPrincipal(ctx, toPrincipal)
			}
		}
	}
}

func (to *PermissionAssignment) SyncFieldsDuringRead(ctx context.Context, from PermissionAssignment) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
	if !from.Principal.IsNull() && !from.Principal.IsUnknown() {
		if toPrincipal, ok := to.GetPrincipal(ctx); ok {
			if fromPrincipal, ok := from.GetPrincipal(ctx); ok {
				toPrincipal.SyncFieldsDuringRead(ctx, fromPrincipal)
				to.SetPrincipal(ctx, toPrincipal)
			}
		}
	}
}

func (c PermissionAssignment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["error"] = attrs["error"].SetOptional()
	attrs["permissions"] = attrs["permissions"].SetOptional()
	attrs["principal"] = attrs["principal"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PermissionAssignment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PermissionAssignment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permissions": reflect.TypeOf(types.String{}),
		"principal":   reflect.TypeOf(PrincipalOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PermissionAssignment
// only implements ToObjectValue() and Type().
func (o PermissionAssignment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"error":       o.Error,
			"permissions": o.Permissions,
			"principal":   o.Principal,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PermissionAssignment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"error": types.StringType,
			"permissions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"principal": PrincipalOutput{}.Type(ctx),
		},
	}
}

// GetPermissions returns the value of the Permissions field in PermissionAssignment as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *PermissionAssignment) GetPermissions(ctx context.Context) ([]types.String, bool) {
	if o.Permissions.IsNull() || o.Permissions.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Permissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissions sets the value of the Permissions field in PermissionAssignment.
func (o *PermissionAssignment) SetPermissions(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Permissions = types.ListValueMust(t, vs)
}

// GetPrincipal returns the value of the Principal field in PermissionAssignment as
// a PrincipalOutput value.
// If the field is unknown or null, the boolean return value is false.
func (o *PermissionAssignment) GetPrincipal(ctx context.Context) (PrincipalOutput, bool) {
	var e PrincipalOutput
	if o.Principal.IsNull() || o.Principal.IsUnknown() {
		return e, false
	}
	var v PrincipalOutput
	d := o.Principal.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPrincipal sets the value of the Principal field in PermissionAssignment.
func (o *PermissionAssignment) SetPrincipal(ctx context.Context, v PrincipalOutput) {
	vs := v.ToObjectValue(ctx)
	o.Principal = vs
}

type PermissionAssignments struct {
	// Array of permissions assignments defined for a workspace.
	PermissionAssignments types.List `tfsdk:"permission_assignments"`
}

func (to *PermissionAssignments) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PermissionAssignments) {
	if !from.PermissionAssignments.IsNull() && !from.PermissionAssignments.IsUnknown() && to.PermissionAssignments.IsNull() && len(from.PermissionAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionAssignments = from.PermissionAssignments
	}
}

func (to *PermissionAssignments) SyncFieldsDuringRead(ctx context.Context, from PermissionAssignments) {
	if !from.PermissionAssignments.IsNull() && !from.PermissionAssignments.IsUnknown() && to.PermissionAssignments.IsNull() && len(from.PermissionAssignments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionAssignments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionAssignments = from.PermissionAssignments
	}
}

func (c PermissionAssignments) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permission_assignments"] = attrs["permission_assignments"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PermissionAssignments.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PermissionAssignments) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permission_assignments": reflect.TypeOf(PermissionAssignment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PermissionAssignments
// only implements ToObjectValue() and Type().
func (o PermissionAssignments) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permission_assignments": o.PermissionAssignments,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PermissionAssignments) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permission_assignments": basetypes.ListType{
				ElemType: PermissionAssignment{}.Type(ctx),
			},
		},
	}
}

// GetPermissionAssignments returns the value of the PermissionAssignments field in PermissionAssignments as
// a slice of PermissionAssignment values.
// If the field is unknown or null, the boolean return value is false.
func (o *PermissionAssignments) GetPermissionAssignments(ctx context.Context) ([]PermissionAssignment, bool) {
	if o.PermissionAssignments.IsNull() || o.PermissionAssignments.IsUnknown() {
		return nil, false
	}
	var v []PermissionAssignment
	d := o.PermissionAssignments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissionAssignments sets the value of the PermissionAssignments field in PermissionAssignments.
func (o *PermissionAssignments) SetPermissionAssignments(ctx context.Context, v []PermissionAssignment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permission_assignments"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.PermissionAssignments = types.ListValueMust(t, vs)
}

type PermissionOutput struct {
	// The results of a permissions query.
	Description types.String `tfsdk:"description"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *PermissionOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PermissionOutput) {
}

func (to *PermissionOutput) SyncFieldsDuringRead(ctx context.Context, from PermissionOutput) {
}

func (c PermissionOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PermissionOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PermissionOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PermissionOutput
// only implements ToObjectValue() and Type().
func (o PermissionOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":      o.Description,
			"permission_level": o.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PermissionOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":      types.StringType,
			"permission_level": types.StringType,
		},
	}
}

type PermissionsDescription struct {
	Description types.String `tfsdk:"description"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *PermissionsDescription) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PermissionsDescription) {
}

func (to *PermissionsDescription) SyncFieldsDuringRead(ctx context.Context, from PermissionsDescription) {
}

func (c PermissionsDescription) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PermissionsDescription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PermissionsDescription) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PermissionsDescription
// only implements ToObjectValue() and Type().
func (o PermissionsDescription) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":      o.Description,
			"permission_level": o.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PermissionsDescription) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":      types.StringType,
			"permission_level": types.StringType,
		},
	}
}

// Information about the principal assigned to the workspace.
type PrincipalOutput struct {
	// The display name of the principal.
	DisplayName types.String `tfsdk:"display_name"`
	// The group name of the group. Present only if the principal is a group.
	GroupName types.String `tfsdk:"group_name"`
	// The unique, opaque id of the principal.
	PrincipalId types.Int64 `tfsdk:"principal_id"`
	// The name of the service principal. Present only if the principal is a
	// service principal.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// The username of the user. Present only if the principal is a user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *PrincipalOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PrincipalOutput) {
}

func (to *PrincipalOutput) SyncFieldsDuringRead(ctx context.Context, from PrincipalOutput) {
}

func (c PrincipalOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["principal_id"] = attrs["principal_id"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PrincipalOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a PrincipalOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PrincipalOutput
// only implements ToObjectValue() and Type().
func (o PrincipalOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name":           o.DisplayName,
			"group_name":             o.GroupName,
			"principal_id":           o.PrincipalId,
			"service_principal_name": o.ServicePrincipalName,
			"user_name":              o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o PrincipalOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name":           types.StringType,
			"group_name":             types.StringType,
			"principal_id":           types.Int64Type,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type ResourceMeta struct {
	// Identifier for group type. Can be local workspace group
	// (`WorkspaceGroup`) or account group (`Group`).
	ResourceType types.String `tfsdk:"resource_type"`
}

func (to *ResourceMeta) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResourceMeta) {
}

func (to *ResourceMeta) SyncFieldsDuringRead(ctx context.Context, from ResourceMeta) {
}

func (c ResourceMeta) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["resource_type"] = attrs["resource_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResourceMeta.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ResourceMeta) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResourceMeta
// only implements ToObjectValue() and Type().
func (o ResourceMeta) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"resource_type": o.ResourceType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ResourceMeta) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"resource_type": types.StringType,
		},
	}
}

type Role struct {
	// Role to assign to a principal or a list of principals on a resource.
	Name types.String `tfsdk:"name"`
}

func (to *Role) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Role) {
}

func (to *Role) SyncFieldsDuringRead(ctx context.Context, from Role) {
}

func (c Role) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Role.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a Role) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Role
// only implements ToObjectValue() and Type().
func (o Role) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name": o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o Role) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name": types.StringType,
		},
	}
}

type RuleSetResponse struct {
	// Identifies the version of the rule set returned. Etag used for
	// versioning. The response is at least as fresh as the eTag provided. Etag
	// is used for optimistic concurrency control as a way to help prevent
	// simultaneous updates of a rule set from overwriting each other. It is
	// strongly suggested that systems make use of the etag in the read ->
	// modify -> write pattern to perform rule set updates in order to avoid
	// race conditions that is get an etag from a GET rule set request, and pass
	// it with the PUT update request to identify the rule set version you are
	// updating.
	Etag types.String `tfsdk:"etag"`

	GrantRules types.List `tfsdk:"grant_rules"`
	// Name of the rule set.
	Name types.String `tfsdk:"name"`
}

func (to *RuleSetResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RuleSetResponse) {
	if !from.GrantRules.IsNull() && !from.GrantRules.IsUnknown() && to.GrantRules.IsNull() && len(from.GrantRules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for GrantRules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.GrantRules = from.GrantRules
	}
}

func (to *RuleSetResponse) SyncFieldsDuringRead(ctx context.Context, from RuleSetResponse) {
	if !from.GrantRules.IsNull() && !from.GrantRules.IsUnknown() && to.GrantRules.IsNull() && len(from.GrantRules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for GrantRules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.GrantRules = from.GrantRules
	}
}

func (c RuleSetResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["etag"] = attrs["etag"].SetRequired()
	attrs["grant_rules"] = attrs["grant_rules"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RuleSetResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RuleSetResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"grant_rules": reflect.TypeOf(GrantRule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RuleSetResponse
// only implements ToObjectValue() and Type().
func (o RuleSetResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"etag":        o.Etag,
			"grant_rules": o.GrantRules,
			"name":        o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RuleSetResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"etag": types.StringType,
			"grant_rules": basetypes.ListType{
				ElemType: GrantRule{}.Type(ctx),
			},
			"name": types.StringType,
		},
	}
}

// GetGrantRules returns the value of the GrantRules field in RuleSetResponse as
// a slice of GrantRule values.
// If the field is unknown or null, the boolean return value is false.
func (o *RuleSetResponse) GetGrantRules(ctx context.Context) ([]GrantRule, bool) {
	if o.GrantRules.IsNull() || o.GrantRules.IsUnknown() {
		return nil, false
	}
	var v []GrantRule
	d := o.GrantRules.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGrantRules sets the value of the GrantRules field in RuleSetResponse.
func (o *RuleSetResponse) SetGrantRules(ctx context.Context, v []GrantRule) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["grant_rules"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.GrantRules = types.ListValueMust(t, vs)
}

type RuleSetUpdateRequest struct {
	// Identifies the version of the rule set returned. Etag used for
	// versioning. The response is at least as fresh as the eTag provided. Etag
	// is used for optimistic concurrency control as a way to help prevent
	// simultaneous updates of a rule set from overwriting each other. It is
	// strongly suggested that systems make use of the etag in the read ->
	// modify -> write pattern to perform rule set updates in order to avoid
	// race conditions that is get an etag from a GET rule set request, and pass
	// it with the PUT update request to identify the rule set version you are
	// updating.
	Etag types.String `tfsdk:"etag"`

	GrantRules types.List `tfsdk:"grant_rules"`
	// Name of the rule set.
	Name types.String `tfsdk:"name"`
}

func (to *RuleSetUpdateRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RuleSetUpdateRequest) {
	if !from.GrantRules.IsNull() && !from.GrantRules.IsUnknown() && to.GrantRules.IsNull() && len(from.GrantRules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for GrantRules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.GrantRules = from.GrantRules
	}
}

func (to *RuleSetUpdateRequest) SyncFieldsDuringRead(ctx context.Context, from RuleSetUpdateRequest) {
	if !from.GrantRules.IsNull() && !from.GrantRules.IsUnknown() && to.GrantRules.IsNull() && len(from.GrantRules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for GrantRules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.GrantRules = from.GrantRules
	}
}

func (c RuleSetUpdateRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["etag"] = attrs["etag"].SetRequired()
	attrs["grant_rules"] = attrs["grant_rules"].SetOptional()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RuleSetUpdateRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a RuleSetUpdateRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"grant_rules": reflect.TypeOf(GrantRule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RuleSetUpdateRequest
// only implements ToObjectValue() and Type().
func (o RuleSetUpdateRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"etag":        o.Etag,
			"grant_rules": o.GrantRules,
			"name":        o.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (o RuleSetUpdateRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"etag": types.StringType,
			"grant_rules": basetypes.ListType{
				ElemType: GrantRule{}.Type(ctx),
			},
			"name": types.StringType,
		},
	}
}

// GetGrantRules returns the value of the GrantRules field in RuleSetUpdateRequest as
// a slice of GrantRule values.
// If the field is unknown or null, the boolean return value is false.
func (o *RuleSetUpdateRequest) GetGrantRules(ctx context.Context) ([]GrantRule, bool) {
	if o.GrantRules.IsNull() || o.GrantRules.IsUnknown() {
		return nil, false
	}
	var v []GrantRule
	d := o.GrantRules.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGrantRules sets the value of the GrantRules field in RuleSetUpdateRequest.
func (o *RuleSetUpdateRequest) SetGrantRules(ctx context.Context, v []GrantRule) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["grant_rules"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.GrantRules = types.ListValueMust(t, vs)
}

type ServicePrincipal struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// UUID relating to the service principal
	ApplicationId types.String `tfsdk:"application_id"`
	// String that represents a concatenation of given and family names.
	DisplayName types.String `tfsdk:"display_name"`
	// Entitlements assigned to the service principal. See [assigning
	// entitlements] for a full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`

	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks service principal ID.
	Id types.String `tfsdk:"id"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the List response.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *ServicePrincipal) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ServicePrincipal) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *ServicePrincipal) SyncFieldsDuringRead(ctx context.Context, from ServicePrincipal) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c ServicePrincipal) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["application_id"] = attrs["application_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ServicePrincipal.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a ServicePrincipal) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ServicePrincipal
// only implements ToObjectValue() and Type().
func (o ServicePrincipal) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":         o.Active,
			"application_id": o.ApplicationId,
			"display_name":   o.DisplayName,
			"entitlements":   o.Entitlements,
			"external_id":    o.ExternalId,
			"groups":         o.Groups,
			"id":             o.Id,
			"roles":          o.Roles,
			"schemas":        o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o ServicePrincipal) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":         types.BoolType,
			"application_id": types.StringType,
			"display_name":   types.StringType,
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id": types.StringType,
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEntitlements returns the value of the Entitlements field in ServicePrincipal as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *ServicePrincipal) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in ServicePrincipal.
func (o *ServicePrincipal) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in ServicePrincipal as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *ServicePrincipal) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in ServicePrincipal.
func (o *ServicePrincipal) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetRoles returns the value of the Roles field in ServicePrincipal as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *ServicePrincipal) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in ServicePrincipal.
func (o *ServicePrincipal) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in ServicePrincipal as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *ServicePrincipal) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in ServicePrincipal.
func (o *ServicePrincipal) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type SetObjectPermissions struct {
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The id of the request object.
	RequestObjectId types.String `tfsdk:"-"`
	// The type of the request object. Can be one of the following: alerts,
	// alertsv2, authorization, clusters, cluster-policies, dashboards,
	// dbsql-dashboards, directories, experiments, files, genie, instance-pools,
	// jobs, notebooks, pipelines, queries, registered-models, repos,
	// serving-endpoints, or warehouses.
	RequestObjectType types.String `tfsdk:"-"`
}

func (to *SetObjectPermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SetObjectPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *SetObjectPermissions) SyncFieldsDuringRead(ctx context.Context, from SetObjectPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (c SetObjectPermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["request_object_type"] = attrs["request_object_type"].SetRequired()
	attrs["request_object_id"] = attrs["request_object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SetObjectPermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a SetObjectPermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(AccessControlRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SetObjectPermissions
// only implements ToObjectValue() and Type().
func (o SetObjectPermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": o.AccessControlList,
			"request_object_id":   o.RequestObjectId,
			"request_object_type": o.RequestObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o SetObjectPermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: AccessControlRequest{}.Type(ctx),
			},
			"request_object_id":   types.StringType,
			"request_object_type": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in SetObjectPermissions as
// a slice of AccessControlRequest values.
// If the field is unknown or null, the boolean return value is false.
func (o *SetObjectPermissions) GetAccessControlList(ctx context.Context) ([]AccessControlRequest, bool) {
	if o.AccessControlList.IsNull() || o.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []AccessControlRequest
	d := o.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in SetObjectPermissions.
func (o *SetObjectPermissions) SetAccessControlList(ctx context.Context, v []AccessControlRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AccessControlList = types.ListValueMust(t, vs)
}

type UpdateAccountGroupRequest struct {
	// String that represents a human-readable group name
	DisplayName types.String `tfsdk:"display_name"`

	ExternalId types.String `tfsdk:"external_id"`
	// Databricks group ID
	Id types.String `tfsdk:"-"`

	Members types.List `tfsdk:"members"`
	// Container for the group identifier. Workspace local versus account.
	Meta types.Object `tfsdk:"meta"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
}

func (to *UpdateAccountGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAccountGroupRequest) {
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				// Recursively sync the fields of Meta
				toMeta.SyncFieldsDuringCreateOrUpdate(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *UpdateAccountGroupRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateAccountGroupRequest) {
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				toMeta.SyncFieldsDuringRead(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c UpdateAccountGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["members"] = attrs["members"].SetOptional()
	attrs["meta"] = attrs["meta"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccountGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateAccountGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"members": reflect.TypeOf(ComplexValue{}),
		"meta":    reflect.TypeOf(ResourceMeta{}),
		"roles":   reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccountGroupRequest
// only implements ToObjectValue() and Type().
func (o UpdateAccountGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name": o.DisplayName,
			"external_id":  o.ExternalId,
			"id":           o.Id,
			"members":      o.Members,
			"meta":         o.Meta,
			"roles":        o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateAccountGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name": types.StringType,
			"external_id":  types.StringType,
			"id":           types.StringType,
			"members": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"meta": ResourceMeta{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
		},
	}
}

// GetMembers returns the value of the Members field in UpdateAccountGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountGroupRequest) GetMembers(ctx context.Context) ([]ComplexValue, bool) {
	if o.Members.IsNull() || o.Members.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Members.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMembers sets the value of the Members field in UpdateAccountGroupRequest.
func (o *UpdateAccountGroupRequest) SetMembers(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["members"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Members = types.ListValueMust(t, vs)
}

// GetMeta returns the value of the Meta field in UpdateAccountGroupRequest as
// a ResourceMeta value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountGroupRequest) GetMeta(ctx context.Context) (ResourceMeta, bool) {
	var e ResourceMeta
	if o.Meta.IsNull() || o.Meta.IsUnknown() {
		return e, false
	}
	var v ResourceMeta
	d := o.Meta.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMeta sets the value of the Meta field in UpdateAccountGroupRequest.
func (o *UpdateAccountGroupRequest) SetMeta(ctx context.Context, v ResourceMeta) {
	vs := v.ToObjectValue(ctx)
	o.Meta = vs
}

// GetRoles returns the value of the Roles field in UpdateAccountGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountGroupRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in UpdateAccountGroupRequest.
func (o *UpdateAccountGroupRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type UpdateAccountServicePrincipalRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// UUID relating to the service principal
	ApplicationId types.String `tfsdk:"application_id"`
	// String that represents a concatenation of given and family names.
	DisplayName types.String `tfsdk:"display_name"`

	ExternalId types.String `tfsdk:"external_id"`
	// Databricks service principal ID.
	Id types.String `tfsdk:"-"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
}

func (to *UpdateAccountServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAccountServicePrincipalRequest) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *UpdateAccountServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateAccountServicePrincipalRequest) {
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c UpdateAccountServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["application_id"] = attrs["application_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccountServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateAccountServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"roles": reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccountServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o UpdateAccountServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":         o.Active,
			"application_id": o.ApplicationId,
			"display_name":   o.DisplayName,
			"external_id":    o.ExternalId,
			"id":             o.Id,
			"roles":          o.Roles,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateAccountServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":         types.BoolType,
			"application_id": types.StringType,
			"display_name":   types.StringType,
			"external_id":    types.StringType,
			"id":             types.StringType,
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
		},
	}
}

// GetRoles returns the value of the Roles field in UpdateAccountServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountServicePrincipalRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in UpdateAccountServicePrincipalRequest.
func (o *UpdateAccountServicePrincipalRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type UpdateAccountUserRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// String that represents a concatenation of given and family names. For
	// example `John Smith`.
	DisplayName types.String `tfsdk:"display_name"`
	// All the emails associated with the Databricks user.
	Emails types.List `tfsdk:"emails"`
	// External ID is not currently supported. It is reserved for future use.
	ExternalId types.String `tfsdk:"external_id"`
	// Databricks user ID.
	Id types.String `tfsdk:"-"`

	Name types.Object `tfsdk:"name"`
	// Indicates if the group has the admin role.
	Roles types.List `tfsdk:"roles"`
	// Email address of the Databricks user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *UpdateAccountUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateAccountUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				// Recursively sync the fields of Name
				toName.SyncFieldsDuringCreateOrUpdate(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (to *UpdateAccountUserRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateAccountUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				toName.SyncFieldsDuringRead(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
}

func (c UpdateAccountUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["emails"] = attrs["emails"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateAccountUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateAccountUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"emails": reflect.TypeOf(ComplexValue{}),
		"name":   reflect.TypeOf(Name{}),
		"roles":  reflect.TypeOf(ComplexValue{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateAccountUserRequest
// only implements ToObjectValue() and Type().
func (o UpdateAccountUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":       o.Active,
			"display_name": o.DisplayName,
			"emails":       o.Emails,
			"external_id":  o.ExternalId,
			"id":           o.Id,
			"name":         o.Name,
			"roles":        o.Roles,
			"user_name":    o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateAccountUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":       types.BoolType,
			"display_name": types.StringType,
			"emails": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"id":          types.StringType,
			"name":        Name{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"user_name": types.StringType,
		},
	}
}

// GetEmails returns the value of the Emails field in UpdateAccountUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountUserRequest) GetEmails(ctx context.Context) ([]ComplexValue, bool) {
	if o.Emails.IsNull() || o.Emails.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Emails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmails sets the value of the Emails field in UpdateAccountUserRequest.
func (o *UpdateAccountUserRequest) SetEmails(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["emails"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Emails = types.ListValueMust(t, vs)
}

// GetName returns the value of the Name field in UpdateAccountUserRequest as
// a Name value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountUserRequest) GetName(ctx context.Context) (Name, bool) {
	var e Name
	if o.Name.IsNull() || o.Name.IsUnknown() {
		return e, false
	}
	var v Name
	d := o.Name.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetName sets the value of the Name field in UpdateAccountUserRequest.
func (o *UpdateAccountUserRequest) SetName(ctx context.Context, v Name) {
	vs := v.ToObjectValue(ctx)
	o.Name = vs
}

// GetRoles returns the value of the Roles field in UpdateAccountUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateAccountUserRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in UpdateAccountUserRequest.
func (o *UpdateAccountUserRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

type UpdateGroupRequest struct {
	// String that represents a human-readable group name
	DisplayName types.String `tfsdk:"display_name"`
	// Entitlements assigned to the group. See [assigning entitlements] for a
	// full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`

	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks group ID
	Id types.String `tfsdk:"-"`

	Members types.List `tfsdk:"members"`
	// Container for the group identifier. Workspace local versus account.
	Meta types.Object `tfsdk:"meta"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the group.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *UpdateGroupRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateGroupRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				// Recursively sync the fields of Meta
				toMeta.SyncFieldsDuringCreateOrUpdate(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *UpdateGroupRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateGroupRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Members.IsNull() && !from.Members.IsUnknown() && to.Members.IsNull() && len(from.Members.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Members, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Members = from.Members
	}
	if !from.Meta.IsNull() && !from.Meta.IsUnknown() {
		if toMeta, ok := to.GetMeta(ctx); ok {
			if fromMeta, ok := from.GetMeta(ctx); ok {
				toMeta.SyncFieldsDuringRead(ctx, fromMeta)
				to.SetMeta(ctx, toMeta)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c UpdateGroupRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["members"] = attrs["members"].SetOptional()
	attrs["meta"] = attrs["meta"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateGroupRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateGroupRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"members":      reflect.TypeOf(ComplexValue{}),
		"meta":         reflect.TypeOf(ResourceMeta{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateGroupRequest
// only implements ToObjectValue() and Type().
func (o UpdateGroupRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"display_name": o.DisplayName,
			"entitlements": o.Entitlements,
			"external_id":  o.ExternalId,
			"groups":       o.Groups,
			"id":           o.Id,
			"members":      o.Members,
			"meta":         o.Meta,
			"roles":        o.Roles,
			"schemas":      o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateGroupRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"display_name": types.StringType,
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id": types.StringType,
			"members": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"meta": ResourceMeta{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEntitlements returns the value of the Entitlements field in UpdateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateGroupRequest) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in UpdateGroupRequest.
func (o *UpdateGroupRequest) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in UpdateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateGroupRequest) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in UpdateGroupRequest.
func (o *UpdateGroupRequest) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetMembers returns the value of the Members field in UpdateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateGroupRequest) GetMembers(ctx context.Context) ([]ComplexValue, bool) {
	if o.Members.IsNull() || o.Members.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Members.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMembers sets the value of the Members field in UpdateGroupRequest.
func (o *UpdateGroupRequest) SetMembers(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["members"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Members = types.ListValueMust(t, vs)
}

// GetMeta returns the value of the Meta field in UpdateGroupRequest as
// a ResourceMeta value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateGroupRequest) GetMeta(ctx context.Context) (ResourceMeta, bool) {
	var e ResourceMeta
	if o.Meta.IsNull() || o.Meta.IsUnknown() {
		return e, false
	}
	var v ResourceMeta
	d := o.Meta.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMeta sets the value of the Meta field in UpdateGroupRequest.
func (o *UpdateGroupRequest) SetMeta(ctx context.Context, v ResourceMeta) {
	vs := v.ToObjectValue(ctx)
	o.Meta = vs
}

// GetRoles returns the value of the Roles field in UpdateGroupRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateGroupRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in UpdateGroupRequest.
func (o *UpdateGroupRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in UpdateGroupRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateGroupRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in UpdateGroupRequest.
func (o *UpdateGroupRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type UpdateObjectPermissions struct {
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The id of the request object.
	RequestObjectId types.String `tfsdk:"-"`
	// The type of the request object. Can be one of the following: alerts,
	// alertsv2, authorization, clusters, cluster-policies, dashboards,
	// dbsql-dashboards, directories, experiments, files, genie, instance-pools,
	// jobs, notebooks, pipelines, queries, registered-models, repos,
	// serving-endpoints, or warehouses.
	RequestObjectType types.String `tfsdk:"-"`
}

func (to *UpdateObjectPermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateObjectPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *UpdateObjectPermissions) SyncFieldsDuringRead(ctx context.Context, from UpdateObjectPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (c UpdateObjectPermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["request_object_type"] = attrs["request_object_type"].SetRequired()
	attrs["request_object_id"] = attrs["request_object_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateObjectPermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateObjectPermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(AccessControlRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateObjectPermissions
// only implements ToObjectValue() and Type().
func (o UpdateObjectPermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": o.AccessControlList,
			"request_object_id":   o.RequestObjectId,
			"request_object_type": o.RequestObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateObjectPermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: AccessControlRequest{}.Type(ctx),
			},
			"request_object_id":   types.StringType,
			"request_object_type": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in UpdateObjectPermissions as
// a slice of AccessControlRequest values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateObjectPermissions) GetAccessControlList(ctx context.Context) ([]AccessControlRequest, bool) {
	if o.AccessControlList.IsNull() || o.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []AccessControlRequest
	d := o.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in UpdateObjectPermissions.
func (o *UpdateObjectPermissions) SetAccessControlList(ctx context.Context, v []AccessControlRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.AccessControlList = types.ListValueMust(t, vs)
}

type UpdateRuleSetRequest struct {
	// Name of the rule set.
	Name types.String `tfsdk:"name"`

	RuleSet types.Object `tfsdk:"rule_set"`
}

func (to *UpdateRuleSetRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateRuleSetRequest) {
	if !from.RuleSet.IsNull() && !from.RuleSet.IsUnknown() {
		if toRuleSet, ok := to.GetRuleSet(ctx); ok {
			if fromRuleSet, ok := from.GetRuleSet(ctx); ok {
				// Recursively sync the fields of RuleSet
				toRuleSet.SyncFieldsDuringCreateOrUpdate(ctx, fromRuleSet)
				to.SetRuleSet(ctx, toRuleSet)
			}
		}
	}
}

func (to *UpdateRuleSetRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateRuleSetRequest) {
	if !from.RuleSet.IsNull() && !from.RuleSet.IsUnknown() {
		if toRuleSet, ok := to.GetRuleSet(ctx); ok {
			if fromRuleSet, ok := from.GetRuleSet(ctx); ok {
				toRuleSet.SyncFieldsDuringRead(ctx, fromRuleSet)
				to.SetRuleSet(ctx, toRuleSet)
			}
		}
	}
}

func (c UpdateRuleSetRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["name"] = attrs["name"].SetRequired()
	attrs["rule_set"] = attrs["rule_set"].SetRequired()
	attrs["account_id"] = attrs["account_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateRuleSetRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateRuleSetRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"rule_set": reflect.TypeOf(RuleSetUpdateRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateRuleSetRequest
// only implements ToObjectValue() and Type().
func (o UpdateRuleSetRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"name":     o.Name,
			"rule_set": o.RuleSet,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateRuleSetRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"name":     types.StringType,
			"rule_set": RuleSetUpdateRequest{}.Type(ctx),
		},
	}
}

// GetRuleSet returns the value of the RuleSet field in UpdateRuleSetRequest as
// a RuleSetUpdateRequest value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateRuleSetRequest) GetRuleSet(ctx context.Context) (RuleSetUpdateRequest, bool) {
	var e RuleSetUpdateRequest
	if o.RuleSet.IsNull() || o.RuleSet.IsUnknown() {
		return e, false
	}
	var v RuleSetUpdateRequest
	d := o.RuleSet.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRuleSet sets the value of the RuleSet field in UpdateRuleSetRequest.
func (o *UpdateRuleSetRequest) SetRuleSet(ctx context.Context, v RuleSetUpdateRequest) {
	vs := v.ToObjectValue(ctx)
	o.RuleSet = vs
}

type UpdateServicePrincipalRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// UUID relating to the service principal
	ApplicationId types.String `tfsdk:"application_id"`
	// String that represents a concatenation of given and family names.
	DisplayName types.String `tfsdk:"display_name"`
	// Entitlements assigned to the service principal. See [assigning
	// entitlements] for a full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`

	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks service principal ID.
	Id types.String `tfsdk:"-"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the List response.
	Schemas types.List `tfsdk:"schemas"`
}

func (to *UpdateServicePrincipalRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateServicePrincipalRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *UpdateServicePrincipalRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateServicePrincipalRequest) {
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c UpdateServicePrincipalRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["application_id"] = attrs["application_id"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateServicePrincipalRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateServicePrincipalRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateServicePrincipalRequest
// only implements ToObjectValue() and Type().
func (o UpdateServicePrincipalRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":         o.Active,
			"application_id": o.ApplicationId,
			"display_name":   o.DisplayName,
			"entitlements":   o.Entitlements,
			"external_id":    o.ExternalId,
			"groups":         o.Groups,
			"id":             o.Id,
			"roles":          o.Roles,
			"schemas":        o.Schemas,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateServicePrincipalRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":         types.BoolType,
			"application_id": types.StringType,
			"display_name":   types.StringType,
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id": types.StringType,
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetEntitlements returns the value of the Entitlements field in UpdateServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateServicePrincipalRequest) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in UpdateServicePrincipalRequest.
func (o *UpdateServicePrincipalRequest) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in UpdateServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateServicePrincipalRequest) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in UpdateServicePrincipalRequest.
func (o *UpdateServicePrincipalRequest) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetRoles returns the value of the Roles field in UpdateServicePrincipalRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateServicePrincipalRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in UpdateServicePrincipalRequest.
func (o *UpdateServicePrincipalRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in UpdateServicePrincipalRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateServicePrincipalRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in UpdateServicePrincipalRequest.
func (o *UpdateServicePrincipalRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type UpdateUserRequest struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// String that represents a concatenation of given and family names. For
	// example `John Smith`. This field cannot be updated through the Workspace
	// SCIM APIs when [identity federation is enabled]. Use Account SCIM APIs to
	// update `displayName`.
	//
	// [identity federation is enabled]: https://docs.databricks.com/administration-guide/users-groups/best-practices.html#enable-identity-federation
	DisplayName types.String `tfsdk:"display_name"`
	// All the emails associated with the Databricks user.
	Emails types.List `tfsdk:"emails"`
	// Entitlements assigned to the user. See [assigning entitlements] for a
	// full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`
	// External ID is not currently supported. It is reserved for future use.
	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks user ID.
	Id types.String `tfsdk:"-"`

	Name types.Object `tfsdk:"name"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the user.
	Schemas types.List `tfsdk:"schemas"`
	// Email address of the Databricks user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *UpdateUserRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				// Recursively sync the fields of Name
				toName.SyncFieldsDuringCreateOrUpdate(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *UpdateUserRequest) SyncFieldsDuringRead(ctx context.Context, from UpdateUserRequest) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				toName.SyncFieldsDuringRead(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c UpdateUserRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["emails"] = attrs["emails"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateUserRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateUserRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"emails":       reflect.TypeOf(ComplexValue{}),
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"name":         reflect.TypeOf(Name{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateUserRequest
// only implements ToObjectValue() and Type().
func (o UpdateUserRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":       o.Active,
			"display_name": o.DisplayName,
			"emails":       o.Emails,
			"entitlements": o.Entitlements,
			"external_id":  o.ExternalId,
			"groups":       o.Groups,
			"id":           o.Id,
			"name":         o.Name,
			"roles":        o.Roles,
			"schemas":      o.Schemas,
			"user_name":    o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateUserRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":       types.BoolType,
			"display_name": types.StringType,
			"emails": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id":   types.StringType,
			"name": Name{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
			"user_name": types.StringType,
		},
	}
}

// GetEmails returns the value of the Emails field in UpdateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateUserRequest) GetEmails(ctx context.Context) ([]ComplexValue, bool) {
	if o.Emails.IsNull() || o.Emails.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Emails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmails sets the value of the Emails field in UpdateUserRequest.
func (o *UpdateUserRequest) SetEmails(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["emails"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Emails = types.ListValueMust(t, vs)
}

// GetEntitlements returns the value of the Entitlements field in UpdateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateUserRequest) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in UpdateUserRequest.
func (o *UpdateUserRequest) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in UpdateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateUserRequest) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in UpdateUserRequest.
func (o *UpdateUserRequest) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetName returns the value of the Name field in UpdateUserRequest as
// a Name value.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateUserRequest) GetName(ctx context.Context) (Name, bool) {
	var e Name
	if o.Name.IsNull() || o.Name.IsUnknown() {
		return e, false
	}
	var v Name
	d := o.Name.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetName sets the value of the Name field in UpdateUserRequest.
func (o *UpdateUserRequest) SetName(ctx context.Context, v Name) {
	vs := v.ToObjectValue(ctx)
	o.Name = vs
}

// GetRoles returns the value of the Roles field in UpdateUserRequest as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateUserRequest) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in UpdateUserRequest.
func (o *UpdateUserRequest) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in UpdateUserRequest as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateUserRequest) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in UpdateUserRequest.
func (o *UpdateUserRequest) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type UpdateWorkspaceAssignments struct {
	// Array of permissions assignments to update on the workspace. Valid values
	// are "USER" and "ADMIN" (case-sensitive). If both "USER" and "ADMIN" are
	// provided, "ADMIN" takes precedence. Other values will be ignored. Note
	// that excluding this field, or providing unsupported values, will have the
	// same effect as providing an empty list, which will result in the deletion
	// of all permissions for the principal.
	Permissions types.List `tfsdk:"permissions"`
	// The ID of the user, service principal, or group.
	PrincipalId types.Int64 `tfsdk:"-"`
	// The workspace ID.
	WorkspaceId types.Int64 `tfsdk:"-"`
}

func (to *UpdateWorkspaceAssignments) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateWorkspaceAssignments) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
}

func (to *UpdateWorkspaceAssignments) SyncFieldsDuringRead(ctx context.Context, from UpdateWorkspaceAssignments) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
}

func (c UpdateWorkspaceAssignments) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permissions"] = attrs["permissions"].SetOptional()
	attrs["account_id"] = attrs["account_id"].SetRequired()
	attrs["workspace_id"] = attrs["workspace_id"].SetRequired()
	attrs["principal_id"] = attrs["principal_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateWorkspaceAssignments.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a UpdateWorkspaceAssignments) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permissions": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateWorkspaceAssignments
// only implements ToObjectValue() and Type().
func (o UpdateWorkspaceAssignments) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permissions":  o.Permissions,
			"principal_id": o.PrincipalId,
			"workspace_id": o.WorkspaceId,
		})
}

// Type implements basetypes.ObjectValuable.
func (o UpdateWorkspaceAssignments) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permissions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"principal_id": types.Int64Type,
			"workspace_id": types.Int64Type,
		},
	}
}

// GetPermissions returns the value of the Permissions field in UpdateWorkspaceAssignments as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *UpdateWorkspaceAssignments) GetPermissions(ctx context.Context) ([]types.String, bool) {
	if o.Permissions.IsNull() || o.Permissions.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Permissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissions sets the value of the Permissions field in UpdateWorkspaceAssignments.
func (o *UpdateWorkspaceAssignments) SetPermissions(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Permissions = types.ListValueMust(t, vs)
}

type User struct {
	// If this user is active
	Active types.Bool `tfsdk:"active"`
	// String that represents a concatenation of given and family names. For
	// example `John Smith`. This field cannot be updated through the Workspace
	// SCIM APIs when [identity federation is enabled]. Use Account SCIM APIs to
	// update `displayName`.
	//
	// [identity federation is enabled]: https://docs.databricks.com/administration-guide/users-groups/best-practices.html#enable-identity-federation
	DisplayName types.String `tfsdk:"display_name"`
	// All the emails associated with the Databricks user.
	Emails types.List `tfsdk:"emails"`
	// Entitlements assigned to the user. See [assigning entitlements] for a
	// full list of supported values.
	//
	// [assigning entitlements]: https://docs.databricks.com/administration-guide/users-groups/index.html#assigning-entitlements
	Entitlements types.List `tfsdk:"entitlements"`
	// External ID is not currently supported. It is reserved for future use.
	ExternalId types.String `tfsdk:"external_id"`

	Groups types.List `tfsdk:"groups"`
	// Databricks user ID.
	Id types.String `tfsdk:"id"`

	Name types.Object `tfsdk:"name"`
	// Corresponds to AWS instance profile/arn role.
	Roles types.List `tfsdk:"roles"`
	// The schema of the user.
	Schemas types.List `tfsdk:"schemas"`
	// Email address of the Databricks user.
	UserName types.String `tfsdk:"user_name"`
}

func (to *User) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from User) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				// Recursively sync the fields of Name
				toName.SyncFieldsDuringCreateOrUpdate(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (to *User) SyncFieldsDuringRead(ctx context.Context, from User) {
	if !from.Emails.IsNull() && !from.Emails.IsUnknown() && to.Emails.IsNull() && len(from.Emails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Emails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Emails = from.Emails
	}
	if !from.Entitlements.IsNull() && !from.Entitlements.IsUnknown() && to.Entitlements.IsNull() && len(from.Entitlements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Entitlements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Entitlements = from.Entitlements
	}
	if !from.Groups.IsNull() && !from.Groups.IsUnknown() && to.Groups.IsNull() && len(from.Groups.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Groups, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Groups = from.Groups
	}
	if !from.Name.IsNull() && !from.Name.IsUnknown() {
		if toName, ok := to.GetName(ctx); ok {
			if fromName, ok := from.GetName(ctx); ok {
				toName.SyncFieldsDuringRead(ctx, fromName)
				to.SetName(ctx, toName)
			}
		}
	}
	if !from.Roles.IsNull() && !from.Roles.IsUnknown() && to.Roles.IsNull() && len(from.Roles.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Roles, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Roles = from.Roles
	}
	if !from.Schemas.IsNull() && !from.Schemas.IsUnknown() && to.Schemas.IsNull() && len(from.Schemas.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Schemas, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Schemas = from.Schemas
	}
}

func (c User) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active"] = attrs["active"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["emails"] = attrs["emails"].SetOptional()
	attrs["entitlements"] = attrs["entitlements"].SetOptional()
	attrs["external_id"] = attrs["external_id"].SetOptional()
	attrs["groups"] = attrs["groups"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["roles"] = attrs["roles"].SetOptional()
	attrs["schemas"] = attrs["schemas"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in User.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a User) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"emails":       reflect.TypeOf(ComplexValue{}),
		"entitlements": reflect.TypeOf(ComplexValue{}),
		"groups":       reflect.TypeOf(ComplexValue{}),
		"name":         reflect.TypeOf(Name{}),
		"roles":        reflect.TypeOf(ComplexValue{}),
		"schemas":      reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, User
// only implements ToObjectValue() and Type().
func (o User) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active":       o.Active,
			"display_name": o.DisplayName,
			"emails":       o.Emails,
			"entitlements": o.Entitlements,
			"external_id":  o.ExternalId,
			"groups":       o.Groups,
			"id":           o.Id,
			"name":         o.Name,
			"roles":        o.Roles,
			"schemas":      o.Schemas,
			"user_name":    o.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (o User) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active":       types.BoolType,
			"display_name": types.StringType,
			"emails": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"entitlements": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"external_id": types.StringType,
			"groups": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"id":   types.StringType,
			"name": Name{}.Type(ctx),
			"roles": basetypes.ListType{
				ElemType: ComplexValue{}.Type(ctx),
			},
			"schemas": basetypes.ListType{
				ElemType: types.StringType,
			},
			"user_name": types.StringType,
		},
	}
}

// GetEmails returns the value of the Emails field in User as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *User) GetEmails(ctx context.Context) ([]ComplexValue, bool) {
	if o.Emails.IsNull() || o.Emails.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Emails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmails sets the value of the Emails field in User.
func (o *User) SetEmails(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["emails"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Emails = types.ListValueMust(t, vs)
}

// GetEntitlements returns the value of the Entitlements field in User as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *User) GetEntitlements(ctx context.Context) ([]ComplexValue, bool) {
	if o.Entitlements.IsNull() || o.Entitlements.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Entitlements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEntitlements sets the value of the Entitlements field in User.
func (o *User) SetEntitlements(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["entitlements"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Entitlements = types.ListValueMust(t, vs)
}

// GetGroups returns the value of the Groups field in User as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *User) GetGroups(ctx context.Context) ([]ComplexValue, bool) {
	if o.Groups.IsNull() || o.Groups.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Groups.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGroups sets the value of the Groups field in User.
func (o *User) SetGroups(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["groups"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Groups = types.ListValueMust(t, vs)
}

// GetName returns the value of the Name field in User as
// a Name value.
// If the field is unknown or null, the boolean return value is false.
func (o *User) GetName(ctx context.Context) (Name, bool) {
	var e Name
	if o.Name.IsNull() || o.Name.IsUnknown() {
		return e, false
	}
	var v Name
	d := o.Name.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetName sets the value of the Name field in User.
func (o *User) SetName(ctx context.Context, v Name) {
	vs := v.ToObjectValue(ctx)
	o.Name = vs
}

// GetRoles returns the value of the Roles field in User as
// a slice of ComplexValue values.
// If the field is unknown or null, the boolean return value is false.
func (o *User) GetRoles(ctx context.Context) ([]ComplexValue, bool) {
	if o.Roles.IsNull() || o.Roles.IsUnknown() {
		return nil, false
	}
	var v []ComplexValue
	d := o.Roles.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRoles sets the value of the Roles field in User.
func (o *User) SetRoles(ctx context.Context, v []ComplexValue) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["roles"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Roles = types.ListValueMust(t, vs)
}

// GetSchemas returns the value of the Schemas field in User as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (o *User) GetSchemas(ctx context.Context) ([]types.String, bool) {
	if o.Schemas.IsNull() || o.Schemas.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := o.Schemas.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchemas sets the value of the Schemas field in User.
func (o *User) SetSchemas(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["schemas"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Schemas = types.ListValueMust(t, vs)
}

type WorkspacePermissions struct {
	// Array of permissions defined for a workspace.
	Permissions types.List `tfsdk:"permissions"`
}

func (to *WorkspacePermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from WorkspacePermissions) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
}

func (to *WorkspacePermissions) SyncFieldsDuringRead(ctx context.Context, from WorkspacePermissions) {
	if !from.Permissions.IsNull() && !from.Permissions.IsUnknown() && to.Permissions.IsNull() && len(from.Permissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Permissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Permissions = from.Permissions
	}
}

func (c WorkspacePermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permissions"] = attrs["permissions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WorkspacePermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (a WorkspacePermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permissions": reflect.TypeOf(PermissionOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WorkspacePermissions
// only implements ToObjectValue() and Type().
func (o WorkspacePermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		o.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permissions": o.Permissions,
		})
}

// Type implements basetypes.ObjectValuable.
func (o WorkspacePermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permissions": basetypes.ListType{
				ElemType: PermissionOutput{}.Type(ctx),
			},
		},
	}
}

// GetPermissions returns the value of the Permissions field in WorkspacePermissions as
// a slice of PermissionOutput values.
// If the field is unknown or null, the boolean return value is false.
func (o *WorkspacePermissions) GetPermissions(ctx context.Context) ([]PermissionOutput, bool) {
	if o.Permissions.IsNull() || o.Permissions.IsUnknown() {
		return nil, false
	}
	var v []PermissionOutput
	d := o.Permissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissions sets the value of the Permissions field in WorkspacePermissions.
func (o *WorkspacePermissions) SetPermissions(ctx context.Context, v []PermissionOutput) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := o.Type(ctx).(basetypes.ObjectType).AttrTypes["permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	o.Permissions = types.ListValueMust(t, vs)
}
