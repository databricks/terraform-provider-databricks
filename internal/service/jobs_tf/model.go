// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.
/*
These generated types are for terraform plugin framework to interact with the terraform state conveniently.

These types follow the same structure as the types in go-sdk.
The only difference is that the primitive types are no longer using the go-native types, but with tfsdk types.
Plus the json tags get converted into tfsdk tags.
We use go-native types for lists and maps intentionally for the ease for converting these types into the go-sdk types.
*/

package jobs_tf

import (
	"context"
	"reflect"

	pluginfwcommon "github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/common"
	"github.com/databricks/terraform-provider-databricks/internal/providers/pluginfw/tfschema"

	"github.com/databricks/terraform-provider-databricks/internal/service/compute_tf" // .tmpl
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type BaseJob struct {
	// The time at which this job was created in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC).
	CreatedTime types.Int64 `tfsdk:"created_time"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// The id of the budget policy used by this job for cost attribution
	// purposes. This may be set through (in order of precedence): 1. Budget
	// admins through the account or workspace console 2. Jobs UI in the job
	// details page and Jobs API using `budget_policy_id` 3. Inferred default
	// based on accessible budget policies of the run_as identity on job
	// creation or modification.
	EffectiveBudgetPolicyId types.String `tfsdk:"effective_budget_policy_id"`
	// The id of the usage policy used by this job for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// Indicates if the job has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/get endpoint.
	// It is only relevant for API 2.2 :method:jobs/list requests with
	// `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// The canonical identifier for this job.
	JobId types.Int64 `tfsdk:"job_id"`
	// Settings for this job and all of its runs. These settings can be updated
	// using the `resetJob` method.
	Settings types.Object `tfsdk:"settings"`
	// State of the trigger associated with the job.
	TriggerState types.Object `tfsdk:"trigger_state"`
}

func (to *BaseJob) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from BaseJob) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				// Recursively sync the fields of Settings
				toSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				// Recursively sync the fields of TriggerState
				toTriggerState.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (to *BaseJob) SyncFieldsDuringRead(ctx context.Context, from BaseJob) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				toSettings.SyncFieldsDuringRead(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				toTriggerState.SyncFieldsDuringRead(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (m BaseJob) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["created_time"] = attrs["created_time"].SetOptional()
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["effective_budget_policy_id"] = attrs["effective_budget_policy_id"].SetComputed()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["settings"] = attrs["settings"].SetOptional()
	attrs["trigger_state"] = attrs["trigger_state"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BaseJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m BaseJob) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"settings":      reflect.TypeOf(JobSettings{}),
		"trigger_state": reflect.TypeOf(TriggerStateProto{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BaseJob
// only implements ToObjectValue() and Type().
func (m BaseJob) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"created_time":               m.CreatedTime,
			"creator_user_name":          m.CreatorUserName,
			"effective_budget_policy_id": m.EffectiveBudgetPolicyId,
			"effective_usage_policy_id":  m.EffectiveUsagePolicyId,
			"has_more":                   m.HasMore,
			"job_id":                     m.JobId,
			"settings":                   m.Settings,
			"trigger_state":              m.TriggerState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m BaseJob) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"created_time":               types.Int64Type,
			"creator_user_name":          types.StringType,
			"effective_budget_policy_id": types.StringType,
			"effective_usage_policy_id":  types.StringType,
			"has_more":                   types.BoolType,
			"job_id":                     types.Int64Type,
			"settings":                   JobSettings{}.Type(ctx),
			"trigger_state":              TriggerStateProto{}.Type(ctx),
		},
	}
}

// GetSettings returns the value of the Settings field in BaseJob as
// a JobSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseJob) GetSettings(ctx context.Context) (JobSettings, bool) {
	var e JobSettings
	if m.Settings.IsNull() || m.Settings.IsUnknown() {
		return e, false
	}
	var v JobSettings
	d := m.Settings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSettings sets the value of the Settings field in BaseJob.
func (m *BaseJob) SetSettings(ctx context.Context, v JobSettings) {
	vs := v.ToObjectValue(ctx)
	m.Settings = vs
}

// GetTriggerState returns the value of the TriggerState field in BaseJob as
// a TriggerStateProto value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseJob) GetTriggerState(ctx context.Context) (TriggerStateProto, bool) {
	var e TriggerStateProto
	if m.TriggerState.IsNull() || m.TriggerState.IsUnknown() {
		return e, false
	}
	var v TriggerStateProto
	d := m.TriggerState.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTriggerState sets the value of the TriggerState field in BaseJob.
func (m *BaseJob) SetTriggerState(ctx context.Context, v TriggerStateProto) {
	vs := v.ToObjectValue(ctx)
	m.TriggerState = vs
}

type BaseRun struct {
	// The sequence number of this run attempt for a triggered job run. The
	// initial attempt of a run has an attempt_number of 0. If the initial run
	// attempt fails, and the job has a retry policy (`max_retries` > 0),
	// subsequent runs are created with an `original_attempt_run_id` of the
	// original attempt’s ID and an incrementing `attempt_number`. Runs are
	// retried only until they succeed, and the maximum `attempt_number` is the
	// same as the `max_retries` value for the job.
	AttemptNumber types.Int64 `tfsdk:"attempt_number"`
	// The time in milliseconds it took to terminate the cluster and clean up
	// any associated artifacts. The duration of a task run is the sum of the
	// `setup_duration`, `execution_duration`, and the `cleanup_duration`. The
	// `cleanup_duration` field is set to 0 for multitask job runs. The total
	// duration of a multitask job run is the value of the `run_duration` field.
	CleanupDuration types.Int64 `tfsdk:"cleanup_duration"`
	// The cluster used for this run. If the run is specified to use a new
	// cluster, this field is set once the Jobs service has requested a cluster
	// for the run.
	ClusterInstance types.Object `tfsdk:"cluster_instance"`
	// A snapshot of the job’s cluster specification when this run was
	// created.
	ClusterSpec types.Object `tfsdk:"cluster_spec"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// Description of the run
	Description types.String `tfsdk:"description"`
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// The id of the usage policy used by this run for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// The time at which this run ended in epoch milliseconds (milliseconds
	// since 1/1/1970 UTC). This field is set to 0 if the job is still running.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The time in milliseconds it took to execute the commands in the JAR or
	// notebook until they completed, failed, timed out, were cancelled, or
	// encountered an unexpected error. The duration of a task run is the sum of
	// the `setup_duration`, `execution_duration`, and the `cleanup_duration`.
	// The `execution_duration` field is set to 0 for multitask job runs. The
	// total duration of a multitask job run is the value of the `run_duration`
	// field.
	ExecutionDuration types.Int64 `tfsdk:"execution_duration"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.Object `tfsdk:"git_source"`
	// Indicates if the run has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/getrun
	// endpoint. It is only relevant for API 2.2 :method:jobs/listruns requests
	// with `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings. If more than 100
	// job clusters are available, you can paginate through them using
	// :method:jobs/getrun.
	JobClusters types.List `tfsdk:"job_clusters"`
	// The canonical identifier of the job that contains this run.
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used in the run
	JobParameters types.List `tfsdk:"job_parameters"`
	// ID of the job run that this run belongs to. For legacy and single-task
	// job runs the field is populated with the job run ID. For task runs, the
	// field is populated with the ID of the job run that the task run belongs
	// to.
	JobRunId types.Int64 `tfsdk:"job_run_id"`
	// A unique identifier for this job run. This is set to the same value as
	// `run_id`.
	NumberInJob types.Int64 `tfsdk:"number_in_job"`
	// If this run is a retry of a prior run attempt, this field contains the
	// run_id of the original attempt; otherwise, it is the same as the run_id.
	OriginalAttemptRunId types.Int64 `tfsdk:"original_attempt_run_id"`
	// The parameters used for this run.
	OverridingParameters types.Object `tfsdk:"overriding_parameters"`
	// The time in milliseconds that the run has spent in the queue.
	QueueDuration types.Int64 `tfsdk:"queue_duration"`
	// The repair history of the run.
	RepairHistory types.List `tfsdk:"repair_history"`
	// The time in milliseconds it took the job run and all of its repairs to
	// finish.
	RunDuration types.Int64 `tfsdk:"run_duration"`
	// The canonical identifier of the run. This ID is unique across all runs of
	// all jobs.
	RunId types.Int64 `tfsdk:"run_id"`
	// An optional name for the run. The maximum length is 4096 bytes in UTF-8
	// encoding.
	RunName types.String `tfsdk:"run_name"`
	// The URL to the detail page of the run.
	RunPageUrl types.String `tfsdk:"run_page_url"`

	RunType types.String `tfsdk:"run_type"`
	// The cron schedule that triggered this run if it was triggered by the
	// periodic scheduler.
	Schedule types.Object `tfsdk:"schedule"`
	// The time in milliseconds it took to set up the cluster. For runs that run
	// on new clusters this is the cluster creation time, for runs that run on
	// existing clusters this time should be very short. The duration of a task
	// run is the sum of the `setup_duration`, `execution_duration`, and the
	// `cleanup_duration`. The `setup_duration` field is set to 0 for multitask
	// job runs. The total duration of a multitask job run is the value of the
	// `run_duration` field.
	SetupDuration types.Int64 `tfsdk:"setup_duration"`
	// The time at which this run was started in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC). This may not be the time when the job
	// task starts executing, for example, if the job is scheduled to run on a
	// new cluster, this is the time the cluster creation call is issued.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.Object `tfsdk:"state"`

	Status types.Object `tfsdk:"status"`
	// The list of tasks performed by the run. Each task has its own `run_id`
	// which you can use to call `JobsGetOutput` to retrieve the run resutls. If
	// more than 100 tasks are available, you can paginate through them using
	// :method:jobs/getrun. Use the `next_page_token` field at the object root
	// to determine if more results are available.
	Tasks types.List `tfsdk:"tasks"`

	Trigger types.String `tfsdk:"trigger"`

	TriggerInfo types.Object `tfsdk:"trigger_info"`
}

func (to *BaseRun) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from BaseRun) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				// Recursively sync the fields of ClusterInstance
				toClusterInstance.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				// Recursively sync the fields of ClusterSpec
				toClusterSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				// Recursively sync the fields of OverridingParameters
				toOverridingParameters.SyncFieldsDuringCreateOrUpdate(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				// Recursively sync the fields of TriggerInfo
				toTriggerInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (to *BaseRun) SyncFieldsDuringRead(ctx context.Context, from BaseRun) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				toClusterInstance.SyncFieldsDuringRead(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				toClusterSpec.SyncFieldsDuringRead(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				toOverridingParameters.SyncFieldsDuringRead(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				toTriggerInfo.SyncFieldsDuringRead(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (m BaseRun) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attempt_number"] = attrs["attempt_number"].SetOptional()
	attrs["cleanup_duration"] = attrs["cleanup_duration"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].SetOptional()
	attrs["cluster_spec"] = attrs["cluster_spec"].SetOptional()
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetOptional()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["execution_duration"] = attrs["execution_duration"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["job_clusters"] = attrs["job_clusters"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["job_run_id"] = attrs["job_run_id"].SetOptional()
	attrs["number_in_job"] = attrs["number_in_job"].SetOptional()
	attrs["original_attempt_run_id"] = attrs["original_attempt_run_id"].SetOptional()
	attrs["overriding_parameters"] = attrs["overriding_parameters"].SetOptional()
	attrs["queue_duration"] = attrs["queue_duration"].SetOptional()
	attrs["repair_history"] = attrs["repair_history"].SetOptional()
	attrs["run_duration"] = attrs["run_duration"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_name"] = attrs["run_name"].SetOptional()
	attrs["run_page_url"] = attrs["run_page_url"].SetOptional()
	attrs["run_type"] = attrs["run_type"].SetOptional()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["setup_duration"] = attrs["setup_duration"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["tasks"] = attrs["tasks"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["trigger_info"] = attrs["trigger_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in BaseRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m BaseRun) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"cluster_instance":      reflect.TypeOf(ClusterInstance{}),
		"cluster_spec":          reflect.TypeOf(ClusterSpec{}),
		"git_source":            reflect.TypeOf(GitSource{}),
		"job_clusters":          reflect.TypeOf(JobCluster{}),
		"job_parameters":        reflect.TypeOf(JobParameter{}),
		"overriding_parameters": reflect.TypeOf(RunParameters{}),
		"repair_history":        reflect.TypeOf(RepairHistoryItem{}),
		"schedule":              reflect.TypeOf(CronSchedule{}),
		"state":                 reflect.TypeOf(RunState{}),
		"status":                reflect.TypeOf(RunStatus{}),
		"tasks":                 reflect.TypeOf(RunTask{}),
		"trigger_info":          reflect.TypeOf(TriggerInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, BaseRun
// only implements ToObjectValue() and Type().
func (m BaseRun) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attempt_number":               m.AttemptNumber,
			"cleanup_duration":             m.CleanupDuration,
			"cluster_instance":             m.ClusterInstance,
			"cluster_spec":                 m.ClusterSpec,
			"creator_user_name":            m.CreatorUserName,
			"description":                  m.Description,
			"effective_performance_target": m.EffectivePerformanceTarget,
			"effective_usage_policy_id":    m.EffectiveUsagePolicyId,
			"end_time":                     m.EndTime,
			"execution_duration":           m.ExecutionDuration,
			"git_source":                   m.GitSource,
			"has_more":                     m.HasMore,
			"job_clusters":                 m.JobClusters,
			"job_id":                       m.JobId,
			"job_parameters":               m.JobParameters,
			"job_run_id":                   m.JobRunId,
			"number_in_job":                m.NumberInJob,
			"original_attempt_run_id":      m.OriginalAttemptRunId,
			"overriding_parameters":        m.OverridingParameters,
			"queue_duration":               m.QueueDuration,
			"repair_history":               m.RepairHistory,
			"run_duration":                 m.RunDuration,
			"run_id":                       m.RunId,
			"run_name":                     m.RunName,
			"run_page_url":                 m.RunPageUrl,
			"run_type":                     m.RunType,
			"schedule":                     m.Schedule,
			"setup_duration":               m.SetupDuration,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"tasks":                        m.Tasks,
			"trigger":                      m.Trigger,
			"trigger_info":                 m.TriggerInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m BaseRun) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attempt_number":               types.Int64Type,
			"cleanup_duration":             types.Int64Type,
			"cluster_instance":             ClusterInstance{}.Type(ctx),
			"cluster_spec":                 ClusterSpec{}.Type(ctx),
			"creator_user_name":            types.StringType,
			"description":                  types.StringType,
			"effective_performance_target": types.StringType,
			"effective_usage_policy_id":    types.StringType,
			"end_time":                     types.Int64Type,
			"execution_duration":           types.Int64Type,
			"git_source":                   GitSource{}.Type(ctx),
			"has_more":                     types.BoolType,
			"job_clusters": basetypes.ListType{
				ElemType: JobCluster{}.Type(ctx),
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.ListType{
				ElemType: JobParameter{}.Type(ctx),
			},
			"job_run_id":              types.Int64Type,
			"number_in_job":           types.Int64Type,
			"original_attempt_run_id": types.Int64Type,
			"overriding_parameters":   RunParameters{}.Type(ctx),
			"queue_duration":          types.Int64Type,
			"repair_history": basetypes.ListType{
				ElemType: RepairHistoryItem{}.Type(ctx),
			},
			"run_duration":   types.Int64Type,
			"run_id":         types.Int64Type,
			"run_name":       types.StringType,
			"run_page_url":   types.StringType,
			"run_type":       types.StringType,
			"schedule":       CronSchedule{}.Type(ctx),
			"setup_duration": types.Int64Type,
			"start_time":     types.Int64Type,
			"state":          RunState{}.Type(ctx),
			"status":         RunStatus{}.Type(ctx),
			"tasks": basetypes.ListType{
				ElemType: RunTask{}.Type(ctx),
			},
			"trigger":      types.StringType,
			"trigger_info": TriggerInfo{}.Type(ctx),
		},
	}
}

// GetClusterInstance returns the value of the ClusterInstance field in BaseRun as
// a ClusterInstance value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetClusterInstance(ctx context.Context) (ClusterInstance, bool) {
	var e ClusterInstance
	if m.ClusterInstance.IsNull() || m.ClusterInstance.IsUnknown() {
		return e, false
	}
	var v ClusterInstance
	d := m.ClusterInstance.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetClusterInstance sets the value of the ClusterInstance field in BaseRun.
func (m *BaseRun) SetClusterInstance(ctx context.Context, v ClusterInstance) {
	vs := v.ToObjectValue(ctx)
	m.ClusterInstance = vs
}

// GetClusterSpec returns the value of the ClusterSpec field in BaseRun as
// a ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetClusterSpec(ctx context.Context) (ClusterSpec, bool) {
	var e ClusterSpec
	if m.ClusterSpec.IsNull() || m.ClusterSpec.IsUnknown() {
		return e, false
	}
	var v ClusterSpec
	d := m.ClusterSpec.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetClusterSpec sets the value of the ClusterSpec field in BaseRun.
func (m *BaseRun) SetClusterSpec(ctx context.Context, v ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.ClusterSpec = vs
}

// GetGitSource returns the value of the GitSource field in BaseRun as
// a GitSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetGitSource(ctx context.Context) (GitSource, bool) {
	var e GitSource
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v GitSource
	d := m.GitSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSource sets the value of the GitSource field in BaseRun.
func (m *BaseRun) SetGitSource(ctx context.Context, v GitSource) {
	vs := v.ToObjectValue(ctx)
	m.GitSource = vs
}

// GetJobClusters returns the value of the JobClusters field in BaseRun as
// a slice of JobCluster values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetJobClusters(ctx context.Context) ([]JobCluster, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in BaseRun.
func (m *BaseRun) SetJobClusters(ctx context.Context, v []JobCluster) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_clusters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in BaseRun as
// a slice of JobParameter values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetJobParameters(ctx context.Context) ([]JobParameter, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameter
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in BaseRun.
func (m *BaseRun) SetJobParameters(ctx context.Context, v []JobParameter) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.ListValueMust(t, vs)
}

// GetOverridingParameters returns the value of the OverridingParameters field in BaseRun as
// a RunParameters value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetOverridingParameters(ctx context.Context) (RunParameters, bool) {
	var e RunParameters
	if m.OverridingParameters.IsNull() || m.OverridingParameters.IsUnknown() {
		return e, false
	}
	var v RunParameters
	d := m.OverridingParameters.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOverridingParameters sets the value of the OverridingParameters field in BaseRun.
func (m *BaseRun) SetOverridingParameters(ctx context.Context, v RunParameters) {
	vs := v.ToObjectValue(ctx)
	m.OverridingParameters = vs
}

// GetRepairHistory returns the value of the RepairHistory field in BaseRun as
// a slice of RepairHistoryItem values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetRepairHistory(ctx context.Context) ([]RepairHistoryItem, bool) {
	if m.RepairHistory.IsNull() || m.RepairHistory.IsUnknown() {
		return nil, false
	}
	var v []RepairHistoryItem
	d := m.RepairHistory.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRepairHistory sets the value of the RepairHistory field in BaseRun.
func (m *BaseRun) SetRepairHistory(ctx context.Context, v []RepairHistoryItem) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["repair_history"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RepairHistory = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in BaseRun as
// a CronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetSchedule(ctx context.Context) (CronSchedule, bool) {
	var e CronSchedule
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v CronSchedule
	d := m.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in BaseRun.
func (m *BaseRun) SetSchedule(ctx context.Context, v CronSchedule) {
	vs := v.ToObjectValue(ctx)
	m.Schedule = vs
}

// GetState returns the value of the State field in BaseRun as
// a RunState value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetState(ctx context.Context) (RunState, bool) {
	var e RunState
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v RunState
	d := m.State.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetState sets the value of the State field in BaseRun.
func (m *BaseRun) SetState(ctx context.Context, v RunState) {
	vs := v.ToObjectValue(ctx)
	m.State = vs
}

// GetStatus returns the value of the Status field in BaseRun as
// a RunStatus value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetStatus(ctx context.Context) (RunStatus, bool) {
	var e RunStatus
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v RunStatus
	d := m.Status.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStatus sets the value of the Status field in BaseRun.
func (m *BaseRun) SetStatus(ctx context.Context, v RunStatus) {
	vs := v.ToObjectValue(ctx)
	m.Status = vs
}

// GetTasks returns the value of the Tasks field in BaseRun as
// a slice of RunTask values.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetTasks(ctx context.Context) ([]RunTask, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []RunTask
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in BaseRun.
func (m *BaseRun) SetTasks(ctx context.Context, v []RunTask) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTriggerInfo returns the value of the TriggerInfo field in BaseRun as
// a TriggerInfo value.
// If the field is unknown or null, the boolean return value is false.
func (m *BaseRun) GetTriggerInfo(ctx context.Context) (TriggerInfo, bool) {
	var e TriggerInfo
	if m.TriggerInfo.IsNull() || m.TriggerInfo.IsUnknown() {
		return e, false
	}
	var v TriggerInfo
	d := m.TriggerInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTriggerInfo sets the value of the TriggerInfo field in BaseRun.
func (m *BaseRun) SetTriggerInfo(ctx context.Context, v TriggerInfo) {
	vs := v.ToObjectValue(ctx)
	m.TriggerInfo = vs
}

type CancelAllRuns struct {
	// Optional boolean parameter to cancel all queued runs. If no job_id is
	// provided, all queued runs in the workspace are canceled.
	AllQueuedRuns types.Bool `tfsdk:"all_queued_runs"`
	// The canonical identifier of the job to cancel all runs of.
	JobId types.Int64 `tfsdk:"job_id"`
}

func (to *CancelAllRuns) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelAllRuns) {
}

func (to *CancelAllRuns) SyncFieldsDuringRead(ctx context.Context, from CancelAllRuns) {
}

func (m CancelAllRuns) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["all_queued_runs"] = attrs["all_queued_runs"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelAllRuns.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelAllRuns) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelAllRuns
// only implements ToObjectValue() and Type().
func (m CancelAllRuns) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"all_queued_runs": m.AllQueuedRuns,
			"job_id":          m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CancelAllRuns) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"all_queued_runs": types.BoolType,
			"job_id":          types.Int64Type,
		},
	}
}

type CancelRun struct {
	// This field is required.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *CancelRun) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CancelRun) {
}

func (to *CancelRun) SyncFieldsDuringRead(ctx context.Context, from CancelRun) {
}

func (m CancelRun) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CancelRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CancelRun) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CancelRun
// only implements ToObjectValue() and Type().
func (m CancelRun) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CancelRun) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

// Stores the run state of the clean rooms notebook task.
type CleanRoomTaskRunState struct {
	// A value indicating the run's current lifecycle state. This field is
	// always available in the response. Note: Additional states might be
	// introduced in future releases.
	LifeCycleState types.String `tfsdk:"life_cycle_state"`
	// A value indicating the run's result. This field is only available for
	// terminal lifecycle states. Note: Additional states might be introduced in
	// future releases.
	ResultState types.String `tfsdk:"result_state"`
}

func (to *CleanRoomTaskRunState) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CleanRoomTaskRunState) {
}

func (to *CleanRoomTaskRunState) SyncFieldsDuringRead(ctx context.Context, from CleanRoomTaskRunState) {
}

func (m CleanRoomTaskRunState) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["life_cycle_state"] = attrs["life_cycle_state"].SetOptional()
	attrs["result_state"] = attrs["result_state"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CleanRoomTaskRunState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CleanRoomTaskRunState) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CleanRoomTaskRunState
// only implements ToObjectValue() and Type().
func (m CleanRoomTaskRunState) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"life_cycle_state": m.LifeCycleState,
			"result_state":     m.ResultState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CleanRoomTaskRunState) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"life_cycle_state": types.StringType,
			"result_state":     types.StringType,
		},
	}
}

type CleanRoomsNotebookTask struct {
	// The clean room that the notebook belongs to.
	CleanRoomName types.String `tfsdk:"clean_room_name"`
	// Checksum to validate the freshness of the notebook resource (i.e. the
	// notebook being run is the latest version). It can be fetched by calling
	// the :method:cleanroomassets/get API.
	Etag types.String `tfsdk:"etag"`
	// Base parameters to be used for the clean room notebook job.
	NotebookBaseParameters types.Map `tfsdk:"notebook_base_parameters"`
	// Name of the notebook being run.
	NotebookName types.String `tfsdk:"notebook_name"`
}

func (to *CleanRoomsNotebookTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CleanRoomsNotebookTask) {
}

func (to *CleanRoomsNotebookTask) SyncFieldsDuringRead(ctx context.Context, from CleanRoomsNotebookTask) {
}

func (m CleanRoomsNotebookTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_room_name"] = attrs["clean_room_name"].SetRequired()
	attrs["etag"] = attrs["etag"].SetOptional()
	attrs["notebook_base_parameters"] = attrs["notebook_base_parameters"].SetOptional()
	attrs["notebook_name"] = attrs["notebook_name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CleanRoomsNotebookTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CleanRoomsNotebookTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"notebook_base_parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CleanRoomsNotebookTask
// only implements ToObjectValue() and Type().
func (m CleanRoomsNotebookTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_room_name":          m.CleanRoomName,
			"etag":                     m.Etag,
			"notebook_base_parameters": m.NotebookBaseParameters,
			"notebook_name":            m.NotebookName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CleanRoomsNotebookTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_room_name": types.StringType,
			"etag":            types.StringType,
			"notebook_base_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_name": types.StringType,
		},
	}
}

// GetNotebookBaseParameters returns the value of the NotebookBaseParameters field in CleanRoomsNotebookTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTask) GetNotebookBaseParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookBaseParameters.IsNull() || m.NotebookBaseParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookBaseParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookBaseParameters sets the value of the NotebookBaseParameters field in CleanRoomsNotebookTask.
func (m *CleanRoomsNotebookTask) SetNotebookBaseParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_base_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookBaseParameters = types.MapValueMust(t, vs)
}

type CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput struct {
	// The run state of the clean rooms notebook task.
	CleanRoomJobRunState types.Object `tfsdk:"clean_room_job_run_state"`
	// The notebook output for the clean room run
	NotebookOutput types.Object `tfsdk:"notebook_output"`
	// Information on how to access the output schema for the clean room run
	OutputSchemaInfo types.Object `tfsdk:"output_schema_info"`
}

func (to *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) {
	if !from.CleanRoomJobRunState.IsNull() && !from.CleanRoomJobRunState.IsUnknown() {
		if toCleanRoomJobRunState, ok := to.GetCleanRoomJobRunState(ctx); ok {
			if fromCleanRoomJobRunState, ok := from.GetCleanRoomJobRunState(ctx); ok {
				// Recursively sync the fields of CleanRoomJobRunState
				toCleanRoomJobRunState.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomJobRunState)
				to.SetCleanRoomJobRunState(ctx, toCleanRoomJobRunState)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				// Recursively sync the fields of NotebookOutput
				toNotebookOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.OutputSchemaInfo.IsNull() && !from.OutputSchemaInfo.IsUnknown() {
		if toOutputSchemaInfo, ok := to.GetOutputSchemaInfo(ctx); ok {
			if fromOutputSchemaInfo, ok := from.GetOutputSchemaInfo(ctx); ok {
				// Recursively sync the fields of OutputSchemaInfo
				toOutputSchemaInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromOutputSchemaInfo)
				to.SetOutputSchemaInfo(ctx, toOutputSchemaInfo)
			}
		}
	}
}

func (to *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) SyncFieldsDuringRead(ctx context.Context, from CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) {
	if !from.CleanRoomJobRunState.IsNull() && !from.CleanRoomJobRunState.IsUnknown() {
		if toCleanRoomJobRunState, ok := to.GetCleanRoomJobRunState(ctx); ok {
			if fromCleanRoomJobRunState, ok := from.GetCleanRoomJobRunState(ctx); ok {
				toCleanRoomJobRunState.SyncFieldsDuringRead(ctx, fromCleanRoomJobRunState)
				to.SetCleanRoomJobRunState(ctx, toCleanRoomJobRunState)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				toNotebookOutput.SyncFieldsDuringRead(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.OutputSchemaInfo.IsNull() && !from.OutputSchemaInfo.IsUnknown() {
		if toOutputSchemaInfo, ok := to.GetOutputSchemaInfo(ctx); ok {
			if fromOutputSchemaInfo, ok := from.GetOutputSchemaInfo(ctx); ok {
				toOutputSchemaInfo.SyncFieldsDuringRead(ctx, fromOutputSchemaInfo)
				to.SetOutputSchemaInfo(ctx, toOutputSchemaInfo)
			}
		}
	}
}

func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_room_job_run_state"] = attrs["clean_room_job_run_state"].SetOptional()
	attrs["notebook_output"] = attrs["notebook_output"].SetOptional()
	attrs["output_schema_info"] = attrs["output_schema_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_room_job_run_state": reflect.TypeOf(CleanRoomTaskRunState{}),
		"notebook_output":          reflect.TypeOf(NotebookOutput{}),
		"output_schema_info":       reflect.TypeOf(OutputSchemaInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput
// only implements ToObjectValue() and Type().
func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_room_job_run_state": m.CleanRoomJobRunState,
			"notebook_output":          m.NotebookOutput,
			"output_schema_info":       m.OutputSchemaInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_room_job_run_state": CleanRoomTaskRunState{}.Type(ctx),
			"notebook_output":          NotebookOutput{}.Type(ctx),
			"output_schema_info":       OutputSchemaInfo{}.Type(ctx),
		},
	}
}

// GetCleanRoomJobRunState returns the value of the CleanRoomJobRunState field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput as
// a CleanRoomTaskRunState value.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) GetCleanRoomJobRunState(ctx context.Context) (CleanRoomTaskRunState, bool) {
	var e CleanRoomTaskRunState
	if m.CleanRoomJobRunState.IsNull() || m.CleanRoomJobRunState.IsUnknown() {
		return e, false
	}
	var v CleanRoomTaskRunState
	d := m.CleanRoomJobRunState.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCleanRoomJobRunState sets the value of the CleanRoomJobRunState field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) SetCleanRoomJobRunState(ctx context.Context, v CleanRoomTaskRunState) {
	vs := v.ToObjectValue(ctx)
	m.CleanRoomJobRunState = vs
}

// GetNotebookOutput returns the value of the NotebookOutput field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput as
// a NotebookOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) GetNotebookOutput(ctx context.Context) (NotebookOutput, bool) {
	var e NotebookOutput
	if m.NotebookOutput.IsNull() || m.NotebookOutput.IsUnknown() {
		return e, false
	}
	var v NotebookOutput
	d := m.NotebookOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookOutput sets the value of the NotebookOutput field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) SetNotebookOutput(ctx context.Context, v NotebookOutput) {
	vs := v.ToObjectValue(ctx)
	m.NotebookOutput = vs
}

// GetOutputSchemaInfo returns the value of the OutputSchemaInfo field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput as
// a OutputSchemaInfo value.
// If the field is unknown or null, the boolean return value is false.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) GetOutputSchemaInfo(ctx context.Context) (OutputSchemaInfo, bool) {
	var e OutputSchemaInfo
	if m.OutputSchemaInfo.IsNull() || m.OutputSchemaInfo.IsUnknown() {
		return e, false
	}
	var v OutputSchemaInfo
	d := m.OutputSchemaInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOutputSchemaInfo sets the value of the OutputSchemaInfo field in CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput.
func (m *CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) SetOutputSchemaInfo(ctx context.Context, v OutputSchemaInfo) {
	vs := v.ToObjectValue(ctx)
	m.OutputSchemaInfo = vs
}

type ClusterInstance struct {
	// The canonical identifier for the cluster used by a run. This field is
	// always available for runs on existing clusters. For runs on new clusters,
	// it becomes available once the cluster is created. This value can be used
	// to view logs by browsing to `/#setting/sparkui/$cluster_id/driver-logs`.
	// The logs continue to be available after the run completes.
	//
	// The response won’t include this field if the identifier is not
	// available yet.
	ClusterId types.String `tfsdk:"cluster_id"`
	// The canonical identifier for the Spark context used by a run. This field
	// is filled in once the run begins execution. This value can be used to
	// view the Spark UI by browsing to
	// `/#setting/sparkui/$cluster_id/$spark_context_id`. The Spark UI continues
	// to be available after the run has completed.
	//
	// The response won’t include this field if the identifier is not
	// available yet.
	SparkContextId types.String `tfsdk:"spark_context_id"`
}

func (to *ClusterInstance) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ClusterInstance) {
}

func (to *ClusterInstance) SyncFieldsDuringRead(ctx context.Context, from ClusterInstance) {
}

func (m ClusterInstance) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["cluster_id"] = attrs["cluster_id"].SetOptional()
	attrs["spark_context_id"] = attrs["spark_context_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ClusterInstance.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ClusterInstance) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ClusterInstance
// only implements ToObjectValue() and Type().
func (m ClusterInstance) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"cluster_id":       m.ClusterId,
			"spark_context_id": m.SparkContextId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ClusterInstance) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"cluster_id":       types.StringType,
			"spark_context_id": types.StringType,
		},
	}
}

type ClusterSpec struct {
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// If job_cluster_key, this task is executed reusing the cluster specified
	// in `job.settings.job_clusters`.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.Object `tfsdk:"new_cluster"`
}

func (to *ClusterSpec) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ClusterSpec) {
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (to *ClusterSpec) SyncFieldsDuringRead(ctx context.Context, from ClusterSpec) {
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (m ClusterSpec) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ClusterSpec.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ClusterSpec) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"library":     reflect.TypeOf(compute_tf.Library{}),
		"new_cluster": reflect.TypeOf(compute_tf.ClusterSpec{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ClusterSpec
// only implements ToObjectValue() and Type().
func (m ClusterSpec) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"existing_cluster_id": m.ExistingClusterId,
			"job_cluster_key":     m.JobClusterKey,
			"library":             m.Libraries,
			"new_cluster":         m.NewCluster,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ClusterSpec) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"existing_cluster_id": types.StringType,
			"job_cluster_key":     types.StringType,
			"library": basetypes.ListType{
				ElemType: compute_tf.Library{}.Type(ctx),
			},
			"new_cluster": compute_tf.ClusterSpec{}.Type(ctx),
		},
	}
}

// GetLibraries returns the value of the Libraries field in ClusterSpec as
// a slice of compute_tf.Library values.
// If the field is unknown or null, the boolean return value is false.
func (m *ClusterSpec) GetLibraries(ctx context.Context) ([]compute_tf.Library, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in ClusterSpec.
func (m *ClusterSpec) SetLibraries(ctx context.Context, v []compute_tf.Library) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in ClusterSpec as
// a compute_tf.ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *ClusterSpec) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec, bool) {
	var e compute_tf.ClusterSpec
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v compute_tf.ClusterSpec
	d := m.NewCluster.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewCluster sets the value of the NewCluster field in ClusterSpec.
func (m *ClusterSpec) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.NewCluster = vs
}

type ComputeConfig struct {
	// IDof the GPU pool to use.
	GpuNodePoolId types.String `tfsdk:"gpu_node_pool_id"`
	// GPU type.
	GpuType types.String `tfsdk:"gpu_type"`
	// Number of GPUs.
	NumGpus types.Int64 `tfsdk:"num_gpus"`
}

func (to *ComputeConfig) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ComputeConfig) {
}

func (to *ComputeConfig) SyncFieldsDuringRead(ctx context.Context, from ComputeConfig) {
}

func (m ComputeConfig) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["gpu_node_pool_id"] = attrs["gpu_node_pool_id"].SetOptional()
	attrs["gpu_type"] = attrs["gpu_type"].SetOptional()
	attrs["num_gpus"] = attrs["num_gpus"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ComputeConfig.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ComputeConfig) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ComputeConfig
// only implements ToObjectValue() and Type().
func (m ComputeConfig) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"gpu_node_pool_id": m.GpuNodePoolId,
			"gpu_type":         m.GpuType,
			"num_gpus":         m.NumGpus,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ComputeConfig) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"gpu_node_pool_id": types.StringType,
			"gpu_type":         types.StringType,
			"num_gpus":         types.Int64Type,
		},
	}
}

type ConditionTask struct {
	// The left operand of the condition task. Can be either a string value or a
	// job state or parameter reference.
	Left types.String `tfsdk:"left"`
	// * `EQUAL_TO`, `NOT_EQUAL` operators perform string comparison of their
	// operands. This means that `“12.0” == “12”` will evaluate to
	// `false`. * `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`,
	// `LESS_THAN_OR_EQUAL` operators perform numeric comparison of their
	// operands. `“12.0” >= “12”` will evaluate to `true`, `“10.0”
	// >= “12”` will evaluate to `false`.
	//
	// The boolean comparison to task values can be implemented with operators
	// `EQUAL_TO`, `NOT_EQUAL`. If a task value was set to a boolean value, it
	// will be serialized to `“true”` or `“false”` for the comparison.
	Op types.String `tfsdk:"op"`
	// The right operand of the condition task. Can be either a string value or
	// a job state or parameter reference.
	Right types.String `tfsdk:"right"`
}

func (to *ConditionTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ConditionTask) {
}

func (to *ConditionTask) SyncFieldsDuringRead(ctx context.Context, from ConditionTask) {
}

func (m ConditionTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["left"] = attrs["left"].SetRequired()
	attrs["op"] = attrs["op"].SetRequired()
	attrs["right"] = attrs["right"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ConditionTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ConditionTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ConditionTask
// only implements ToObjectValue() and Type().
func (m ConditionTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"left":  m.Left,
			"op":    m.Op,
			"right": m.Right,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ConditionTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"left":  types.StringType,
			"op":    types.StringType,
			"right": types.StringType,
		},
	}
}

type Continuous struct {
	// Indicate whether the continuous execution of the job is paused or not.
	// Defaults to UNPAUSED.
	PauseStatus types.String `tfsdk:"pause_status"`
	// Indicate whether the continuous job is applying task level retries or
	// not. Defaults to NEVER.
	TaskRetryMode types.String `tfsdk:"task_retry_mode"`
}

func (to *Continuous) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Continuous) {
}

func (to *Continuous) SyncFieldsDuringRead(ctx context.Context, from Continuous) {
}

func (m Continuous) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["task_retry_mode"] = attrs["task_retry_mode"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Continuous.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Continuous) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Continuous
// only implements ToObjectValue() and Type().
func (m Continuous) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"pause_status":    m.PauseStatus,
			"task_retry_mode": m.TaskRetryMode,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Continuous) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"pause_status":    types.StringType,
			"task_retry_mode": types.StringType,
		},
	}
}

type CreateJob struct {
	// List of permissions to set on the job.
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The id of the user specified budget policy to use for this job. If not
	// specified, a default budget policy may be applied when creating or
	// modifying the job. See `effective_budget_policy_id` for the budget policy
	// used by this workload.
	BudgetPolicyId types.String `tfsdk:"budget_policy_id"`
	// An optional continuous property for this job. The continuous property
	// will ensure that there is always one run executing. Only one of
	// `schedule` and `continuous` can be used.
	Continuous types.Object `tfsdk:"continuous"`
	// Deployment information for jobs managed by external sources.
	Deployment types.Object `tfsdk:"deployment"`
	// An optional description for the job. The maximum length is 27700
	// characters in UTF-8 encoding.
	Description types.String `tfsdk:"description"`
	// Edit mode of the job.
	//
	// * `UI_LOCKED`: The job is in a locked UI state and cannot be modified. *
	// `EDITABLE`: The job is in an editable state and can be modified.
	EditMode types.String `tfsdk:"edit_mode"`
	// An optional set of email addresses that is notified when runs of this job
	// begin or complete as well as when this job is deleted.
	EmailNotifications types.Object `tfsdk:"email_notifications"`
	// A list of task execution environment specifications that can be
	// referenced by serverless tasks of this job. An environment is required to
	// be present for serverless tasks. For serverless notebook tasks, the
	// environment is accessible in the notebook environment panel. For other
	// serverless tasks, the task environment is required to be specified using
	// environment_key in the task settings.
	Environments types.List `tfsdk:"environment"`
	// Used to tell what is the format of the job. This field is ignored in
	// Create/Update/Reset calls. When using the Jobs API 2.1 this value is
	// always set to `"MULTI_TASK"`.
	Format types.String `tfsdk:"format"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.Object `tfsdk:"git_source"`

	Health types.Object `tfsdk:"health"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings.
	JobClusters types.List `tfsdk:"job_cluster"`
	// An optional maximum allowed number of concurrent runs of the job. Set
	// this value if you want to be able to execute multiple runs of the same
	// job concurrently. This is useful for example if you trigger your job on a
	// frequent schedule and want to allow consecutive runs to overlap with each
	// other, or if you want to trigger multiple runs which differ by their
	// input parameters. This setting affects only new runs. For example,
	// suppose the job’s concurrency is 4 and there are 4 concurrent active
	// runs. Then setting the concurrency to 3 won’t kill any of the active
	// runs. However, from then on, new runs are skipped unless there are fewer
	// than 3 active runs. This value cannot exceed 1000. Setting this value to
	// `0` causes all new runs to be skipped.
	MaxConcurrentRuns types.Int64 `tfsdk:"max_concurrent_runs"`
	// An optional name for the job. The maximum length is 4096 bytes in UTF-8
	// encoding.
	Name types.String `tfsdk:"name"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// job.
	NotificationSettings types.Object `tfsdk:"notification_settings"`
	// Job-level parameter definitions
	Parameters types.List `tfsdk:"parameter"`
	// The performance mode on a serverless job. This field determines the level
	// of compute performance or cost-efficiency for the run.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// The queue settings of the job.
	Queue types.Object `tfsdk:"queue"`
	// The user or service principal that the job runs as, if specified in the
	// request. This field indicates the explicit configuration of `run_as` for
	// the job. To find the value in all cases, explicit or implicit, use
	// `run_as_user_name`.
	RunAs types.Object `tfsdk:"run_as"`
	// An optional periodic schedule for this job. The default behavior is that
	// the job only runs when triggered by clicking “Run Now” in the Jobs UI
	// or sending an API request to `runNow`.
	Schedule types.Object `tfsdk:"schedule"`
	// A map of tags associated with the job. These are forwarded to the cluster
	// as cluster tags for jobs clusters, and are subject to the same
	// limitations as cluster tags. A maximum of 25 tags can be added to the
	// job.
	Tags types.Map `tfsdk:"tags"`
	// A list of task specifications to be executed by this job. It supports up
	// to 1000 elements in write endpoints (:method:jobs/create,
	// :method:jobs/reset, :method:jobs/update, :method:jobs/submit). Read
	// endpoints return only 100 tasks. If more than 100 tasks are available,
	// you can paginate through them using :method:jobs/get. Use the
	// `next_page_token` field at the object root to determine if more results
	// are available.
	Tasks types.List `tfsdk:"task"`
	// An optional timeout applied to each run of this job. A value of `0` means
	// no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A configuration to trigger a run when certain conditions are met. The
	// default behavior is that the job runs only when triggered by clicking
	// “Run Now” in the Jobs UI or sending an API request to `runNow`.
	Trigger types.Object `tfsdk:"trigger"`
	// The id of the user specified usage policy to use for this job. If not
	// specified, a default usage policy may be applied when creating or
	// modifying the job. See `effective_usage_policy_id` for the usage policy
	// used by this workload.
	UsagePolicyId types.String `tfsdk:"usage_policy_id"`
	// A collection of system notification IDs to notify when runs of this job
	// begin or complete.
	WebhookNotifications types.Object `tfsdk:"webhook_notifications"`
}

func (to *CreateJob) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateJob) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				// Recursively sync the fields of Continuous
				toContinuous.SyncFieldsDuringCreateOrUpdate(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				// Recursively sync the fields of Deployment
				toDeployment.SyncFieldsDuringCreateOrUpdate(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				// Recursively sync the fields of RunAs
				toRunAs.SyncFieldsDuringCreateOrUpdate(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				// Recursively sync the fields of Trigger
				toTrigger.SyncFieldsDuringCreateOrUpdate(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *CreateJob) SyncFieldsDuringRead(ctx context.Context, from CreateJob) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				toContinuous.SyncFieldsDuringRead(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				toDeployment.SyncFieldsDuringRead(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				toRunAs.SyncFieldsDuringRead(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				toTrigger.SyncFieldsDuringRead(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m CreateJob) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetOptional()
	attrs["continuous"] = attrs["continuous"].SetOptional()
	attrs["deployment"] = attrs["deployment"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["edit_mode"] = attrs["edit_mode"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["environment"] = attrs["environment"].SetOptional()
	attrs["format"] = attrs["format"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["health"] = attrs["health"].SetOptional()
	attrs["job_cluster"] = attrs["job_cluster"].SetOptional()
	attrs["max_concurrent_runs"] = attrs["max_concurrent_runs"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["parameter"] = attrs["parameter"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["run_as"] = attrs["run_as"].SetOptional()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["tags"] = attrs["tags"].SetOptional()
	attrs["task"] = attrs["task"].SetOptional()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateJob) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list":   reflect.TypeOf(JobAccessControlRequest{}),
		"continuous":            reflect.TypeOf(Continuous{}),
		"deployment":            reflect.TypeOf(JobDeployment{}),
		"email_notifications":   reflect.TypeOf(JobEmailNotifications{}),
		"environment":           reflect.TypeOf(JobEnvironment{}),
		"git_source":            reflect.TypeOf(GitSource{}),
		"health":                reflect.TypeOf(JobsHealthRules{}),
		"job_cluster":           reflect.TypeOf(JobCluster{}),
		"notification_settings": reflect.TypeOf(JobNotificationSettings{}),
		"parameter":             reflect.TypeOf(JobParameterDefinition{}),
		"queue":                 reflect.TypeOf(QueueSettings{}),
		"run_as":                reflect.TypeOf(JobRunAs{}),
		"schedule":              reflect.TypeOf(CronSchedule{}),
		"tags":                  reflect.TypeOf(types.String{}),
		"task":                  reflect.TypeOf(Task{}),
		"trigger":               reflect.TypeOf(TriggerSettings{}),
		"webhook_notifications": reflect.TypeOf(WebhookNotifications{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateJob
// only implements ToObjectValue() and Type().
func (m CreateJob) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list":   m.AccessControlList,
			"budget_policy_id":      m.BudgetPolicyId,
			"continuous":            m.Continuous,
			"deployment":            m.Deployment,
			"description":           m.Description,
			"edit_mode":             m.EditMode,
			"email_notifications":   m.EmailNotifications,
			"environment":           m.Environments,
			"format":                m.Format,
			"git_source":            m.GitSource,
			"health":                m.Health,
			"job_cluster":           m.JobClusters,
			"max_concurrent_runs":   m.MaxConcurrentRuns,
			"name":                  m.Name,
			"notification_settings": m.NotificationSettings,
			"parameter":             m.Parameters,
			"performance_target":    m.PerformanceTarget,
			"queue":                 m.Queue,
			"run_as":                m.RunAs,
			"schedule":              m.Schedule,
			"tags":                  m.Tags,
			"task":                  m.Tasks,
			"timeout_seconds":       m.TimeoutSeconds,
			"trigger":               m.Trigger,
			"usage_policy_id":       m.UsagePolicyId,
			"webhook_notifications": m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateJob) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlRequest{}.Type(ctx),
			},
			"budget_policy_id":    types.StringType,
			"continuous":          Continuous{}.Type(ctx),
			"deployment":          JobDeployment{}.Type(ctx),
			"description":         types.StringType,
			"edit_mode":           types.StringType,
			"email_notifications": JobEmailNotifications{}.Type(ctx),
			"environment": basetypes.ListType{
				ElemType: JobEnvironment{}.Type(ctx),
			},
			"format":     types.StringType,
			"git_source": GitSource{}.Type(ctx),
			"health":     JobsHealthRules{}.Type(ctx),
			"job_cluster": basetypes.ListType{
				ElemType: JobCluster{}.Type(ctx),
			},
			"max_concurrent_runs":   types.Int64Type,
			"name":                  types.StringType,
			"notification_settings": JobNotificationSettings{}.Type(ctx),
			"parameter": basetypes.ListType{
				ElemType: JobParameterDefinition{}.Type(ctx),
			},
			"performance_target": types.StringType,
			"queue":              QueueSettings{}.Type(ctx),
			"run_as":             JobRunAs{}.Type(ctx),
			"schedule":           CronSchedule{}.Type(ctx),
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"task": basetypes.ListType{
				ElemType: Task{}.Type(ctx),
			},
			"timeout_seconds":       types.Int64Type,
			"trigger":               TriggerSettings{}.Type(ctx),
			"usage_policy_id":       types.StringType,
			"webhook_notifications": WebhookNotifications{}.Type(ctx),
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in CreateJob as
// a slice of JobAccessControlRequest values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetAccessControlList(ctx context.Context) ([]JobAccessControlRequest, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlRequest
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in CreateJob.
func (m *CreateJob) SetAccessControlList(ctx context.Context, v []JobAccessControlRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

// GetContinuous returns the value of the Continuous field in CreateJob as
// a Continuous value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetContinuous(ctx context.Context) (Continuous, bool) {
	var e Continuous
	if m.Continuous.IsNull() || m.Continuous.IsUnknown() {
		return e, false
	}
	var v Continuous
	d := m.Continuous.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetContinuous sets the value of the Continuous field in CreateJob.
func (m *CreateJob) SetContinuous(ctx context.Context, v Continuous) {
	vs := v.ToObjectValue(ctx)
	m.Continuous = vs
}

// GetDeployment returns the value of the Deployment field in CreateJob as
// a JobDeployment value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetDeployment(ctx context.Context) (JobDeployment, bool) {
	var e JobDeployment
	if m.Deployment.IsNull() || m.Deployment.IsUnknown() {
		return e, false
	}
	var v JobDeployment
	d := m.Deployment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDeployment sets the value of the Deployment field in CreateJob.
func (m *CreateJob) SetDeployment(ctx context.Context, v JobDeployment) {
	vs := v.ToObjectValue(ctx)
	m.Deployment = vs
}

// GetEmailNotifications returns the value of the EmailNotifications field in CreateJob as
// a JobEmailNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetEmailNotifications(ctx context.Context) (JobEmailNotifications, bool) {
	var e JobEmailNotifications
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v JobEmailNotifications
	d := m.EmailNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailNotifications sets the value of the EmailNotifications field in CreateJob.
func (m *CreateJob) SetEmailNotifications(ctx context.Context, v JobEmailNotifications) {
	vs := v.ToObjectValue(ctx)
	m.EmailNotifications = vs
}

// GetEnvironments returns the value of the Environments field in CreateJob as
// a slice of JobEnvironment values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetEnvironments(ctx context.Context) ([]JobEnvironment, bool) {
	if m.Environments.IsNull() || m.Environments.IsUnknown() {
		return nil, false
	}
	var v []JobEnvironment
	d := m.Environments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEnvironments sets the value of the Environments field in CreateJob.
func (m *CreateJob) SetEnvironments(ctx context.Context, v []JobEnvironment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["environment"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Environments = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in CreateJob as
// a GitSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetGitSource(ctx context.Context) (GitSource, bool) {
	var e GitSource
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v GitSource
	d := m.GitSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSource sets the value of the GitSource field in CreateJob.
func (m *CreateJob) SetGitSource(ctx context.Context, v GitSource) {
	vs := v.ToObjectValue(ctx)
	m.GitSource = vs
}

// GetHealth returns the value of the Health field in CreateJob as
// a JobsHealthRules value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetHealth(ctx context.Context) (JobsHealthRules, bool) {
	var e JobsHealthRules
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v JobsHealthRules
	d := m.Health.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetHealth sets the value of the Health field in CreateJob.
func (m *CreateJob) SetHealth(ctx context.Context, v JobsHealthRules) {
	vs := v.ToObjectValue(ctx)
	m.Health = vs
}

// GetJobClusters returns the value of the JobClusters field in CreateJob as
// a slice of JobCluster values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetJobClusters(ctx context.Context) ([]JobCluster, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in CreateJob.
func (m *CreateJob) SetJobClusters(ctx context.Context, v []JobCluster) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_cluster"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in CreateJob as
// a JobNotificationSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetNotificationSettings(ctx context.Context) (JobNotificationSettings, bool) {
	var e JobNotificationSettings
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v JobNotificationSettings
	d := m.NotificationSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotificationSettings sets the value of the NotificationSettings field in CreateJob.
func (m *CreateJob) SetNotificationSettings(ctx context.Context, v JobNotificationSettings) {
	vs := v.ToObjectValue(ctx)
	m.NotificationSettings = vs
}

// GetParameters returns the value of the Parameters field in CreateJob as
// a slice of JobParameterDefinition values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetParameters(ctx context.Context) ([]JobParameterDefinition, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameterDefinition
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in CreateJob.
func (m *CreateJob) SetParameters(ctx context.Context, v []JobParameterDefinition) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameter"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in CreateJob as
// a QueueSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetQueue(ctx context.Context) (QueueSettings, bool) {
	var e QueueSettings
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v QueueSettings
	d := m.Queue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueue sets the value of the Queue field in CreateJob.
func (m *CreateJob) SetQueue(ctx context.Context, v QueueSettings) {
	vs := v.ToObjectValue(ctx)
	m.Queue = vs
}

// GetRunAs returns the value of the RunAs field in CreateJob as
// a JobRunAs value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetRunAs(ctx context.Context) (JobRunAs, bool) {
	var e JobRunAs
	if m.RunAs.IsNull() || m.RunAs.IsUnknown() {
		return e, false
	}
	var v JobRunAs
	d := m.RunAs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunAs sets the value of the RunAs field in CreateJob.
func (m *CreateJob) SetRunAs(ctx context.Context, v JobRunAs) {
	vs := v.ToObjectValue(ctx)
	m.RunAs = vs
}

// GetSchedule returns the value of the Schedule field in CreateJob as
// a CronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetSchedule(ctx context.Context) (CronSchedule, bool) {
	var e CronSchedule
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v CronSchedule
	d := m.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in CreateJob.
func (m *CreateJob) SetSchedule(ctx context.Context, v CronSchedule) {
	vs := v.ToObjectValue(ctx)
	m.Schedule = vs
}

// GetTags returns the value of the Tags field in CreateJob as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetTags(ctx context.Context) (map[string]types.String, bool) {
	if m.Tags.IsNull() || m.Tags.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Tags.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTags sets the value of the Tags field in CreateJob.
func (m *CreateJob) SetTags(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tags"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tags = types.MapValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in CreateJob as
// a slice of Task values.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetTasks(ctx context.Context) ([]Task, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []Task
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in CreateJob.
func (m *CreateJob) SetTasks(ctx context.Context, v []Task) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTrigger returns the value of the Trigger field in CreateJob as
// a TriggerSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetTrigger(ctx context.Context) (TriggerSettings, bool) {
	var e TriggerSettings
	if m.Trigger.IsNull() || m.Trigger.IsUnknown() {
		return e, false
	}
	var v TriggerSettings
	d := m.Trigger.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTrigger sets the value of the Trigger field in CreateJob.
func (m *CreateJob) SetTrigger(ctx context.Context, v TriggerSettings) {
	vs := v.ToObjectValue(ctx)
	m.Trigger = vs
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in CreateJob as
// a WebhookNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *CreateJob) GetWebhookNotifications(ctx context.Context) (WebhookNotifications, bool) {
	var e WebhookNotifications
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v WebhookNotifications
	d := m.WebhookNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in CreateJob.
func (m *CreateJob) SetWebhookNotifications(ctx context.Context, v WebhookNotifications) {
	vs := v.ToObjectValue(ctx)
	m.WebhookNotifications = vs
}

// Job was created successfully
type CreateResponse struct {
	// The canonical identifier for the newly created job.
	JobId types.Int64 `tfsdk:"job_id"`
}

func (to *CreateResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CreateResponse) {
}

func (to *CreateResponse) SyncFieldsDuringRead(ctx context.Context, from CreateResponse) {
}

func (m CreateResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CreateResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CreateResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CreateResponse
// only implements ToObjectValue() and Type().
func (m CreateResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CreateResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
		},
	}
}

type CronSchedule struct {
	// Indicate whether this schedule is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// A Cron expression using Quartz syntax that describes the schedule for a
	// job. See [Cron Trigger] for details. This field is required.
	//
	// [Cron Trigger]: http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html
	QuartzCronExpression types.String `tfsdk:"quartz_cron_expression"`
	// A Java timezone ID. The schedule for a job is resolved with respect to
	// this timezone. See [Java TimeZone] for details. This field is required.
	//
	// [Java TimeZone]: https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html
	TimezoneId types.String `tfsdk:"timezone_id"`
}

func (to *CronSchedule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from CronSchedule) {
}

func (to *CronSchedule) SyncFieldsDuringRead(ctx context.Context, from CronSchedule) {
}

func (m CronSchedule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["quartz_cron_expression"] = attrs["quartz_cron_expression"].SetRequired()
	attrs["timezone_id"] = attrs["timezone_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in CronSchedule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m CronSchedule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, CronSchedule
// only implements ToObjectValue() and Type().
func (m CronSchedule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"pause_status":           m.PauseStatus,
			"quartz_cron_expression": m.QuartzCronExpression,
			"timezone_id":            m.TimezoneId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m CronSchedule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"pause_status":           types.StringType,
			"quartz_cron_expression": types.StringType,
			"timezone_id":            types.StringType,
		},
	}
}

type DashboardPageSnapshot struct {
	PageDisplayName types.String `tfsdk:"page_display_name"`

	WidgetErrorDetails types.List `tfsdk:"widget_error_details"`
}

func (to *DashboardPageSnapshot) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DashboardPageSnapshot) {
	if !from.WidgetErrorDetails.IsNull() && !from.WidgetErrorDetails.IsUnknown() && to.WidgetErrorDetails.IsNull() && len(from.WidgetErrorDetails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for WidgetErrorDetails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.WidgetErrorDetails = from.WidgetErrorDetails
	}
}

func (to *DashboardPageSnapshot) SyncFieldsDuringRead(ctx context.Context, from DashboardPageSnapshot) {
	if !from.WidgetErrorDetails.IsNull() && !from.WidgetErrorDetails.IsUnknown() && to.WidgetErrorDetails.IsNull() && len(from.WidgetErrorDetails.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for WidgetErrorDetails, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.WidgetErrorDetails = from.WidgetErrorDetails
	}
}

func (m DashboardPageSnapshot) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_display_name"] = attrs["page_display_name"].SetOptional()
	attrs["widget_error_details"] = attrs["widget_error_details"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DashboardPageSnapshot.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DashboardPageSnapshot) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"widget_error_details": reflect.TypeOf(WidgetErrorDetail{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DashboardPageSnapshot
// only implements ToObjectValue() and Type().
func (m DashboardPageSnapshot) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_display_name":    m.PageDisplayName,
			"widget_error_details": m.WidgetErrorDetails,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DashboardPageSnapshot) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_display_name": types.StringType,
			"widget_error_details": basetypes.ListType{
				ElemType: WidgetErrorDetail{}.Type(ctx),
			},
		},
	}
}

// GetWidgetErrorDetails returns the value of the WidgetErrorDetails field in DashboardPageSnapshot as
// a slice of WidgetErrorDetail values.
// If the field is unknown or null, the boolean return value is false.
func (m *DashboardPageSnapshot) GetWidgetErrorDetails(ctx context.Context) ([]WidgetErrorDetail, bool) {
	if m.WidgetErrorDetails.IsNull() || m.WidgetErrorDetails.IsUnknown() {
		return nil, false
	}
	var v []WidgetErrorDetail
	d := m.WidgetErrorDetails.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWidgetErrorDetails sets the value of the WidgetErrorDetails field in DashboardPageSnapshot.
func (m *DashboardPageSnapshot) SetWidgetErrorDetails(ctx context.Context, v []WidgetErrorDetail) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["widget_error_details"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.WidgetErrorDetails = types.ListValueMust(t, vs)
}

// Configures the Lakeview Dashboard job task type.
type DashboardTask struct {
	// The identifier of the dashboard to refresh.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// Optional: subscription configuration for sending the dashboard snapshot.
	Subscription types.Object `tfsdk:"subscription"`
	// Optional: The warehouse id to execute the dashboard with for the
	// schedule. If not specified, the default warehouse of the dashboard will
	// be used.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *DashboardTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DashboardTask) {
	if !from.Subscription.IsNull() && !from.Subscription.IsUnknown() {
		if toSubscription, ok := to.GetSubscription(ctx); ok {
			if fromSubscription, ok := from.GetSubscription(ctx); ok {
				// Recursively sync the fields of Subscription
				toSubscription.SyncFieldsDuringCreateOrUpdate(ctx, fromSubscription)
				to.SetSubscription(ctx, toSubscription)
			}
		}
	}
}

func (to *DashboardTask) SyncFieldsDuringRead(ctx context.Context, from DashboardTask) {
	if !from.Subscription.IsNull() && !from.Subscription.IsUnknown() {
		if toSubscription, ok := to.GetSubscription(ctx); ok {
			if fromSubscription, ok := from.GetSubscription(ctx); ok {
				toSubscription.SyncFieldsDuringRead(ctx, fromSubscription)
				to.SetSubscription(ctx, toSubscription)
			}
		}
	}
}

func (m DashboardTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dashboard_id"] = attrs["dashboard_id"].SetComputed()
	attrs["subscription"] = attrs["subscription"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DashboardTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DashboardTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscription": reflect.TypeOf(Subscription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DashboardTask
// only implements ToObjectValue() and Type().
func (m DashboardTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dashboard_id": m.DashboardId,
			"subscription": m.Subscription,
			"warehouse_id": m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DashboardTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dashboard_id": types.StringType,
			"subscription": Subscription{}.Type(ctx),
			"warehouse_id": types.StringType,
		},
	}
}

// GetSubscription returns the value of the Subscription field in DashboardTask as
// a Subscription value.
// If the field is unknown or null, the boolean return value is false.
func (m *DashboardTask) GetSubscription(ctx context.Context) (Subscription, bool) {
	var e Subscription
	if m.Subscription.IsNull() || m.Subscription.IsUnknown() {
		return e, false
	}
	var v Subscription
	d := m.Subscription.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscription sets the value of the Subscription field in DashboardTask.
func (m *DashboardTask) SetSubscription(ctx context.Context, v Subscription) {
	vs := v.ToObjectValue(ctx)
	m.Subscription = vs
}

type DashboardTaskOutput struct {
	// Should only be populated for manual PDF download jobs.
	PageSnapshots types.List `tfsdk:"page_snapshots"`
}

func (to *DashboardTaskOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DashboardTaskOutput) {
	if !from.PageSnapshots.IsNull() && !from.PageSnapshots.IsUnknown() && to.PageSnapshots.IsNull() && len(from.PageSnapshots.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PageSnapshots, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PageSnapshots = from.PageSnapshots
	}
}

func (to *DashboardTaskOutput) SyncFieldsDuringRead(ctx context.Context, from DashboardTaskOutput) {
	if !from.PageSnapshots.IsNull() && !from.PageSnapshots.IsUnknown() && to.PageSnapshots.IsNull() && len(from.PageSnapshots.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PageSnapshots, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PageSnapshots = from.PageSnapshots
	}
}

func (m DashboardTaskOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["page_snapshots"] = attrs["page_snapshots"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DashboardTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DashboardTaskOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"page_snapshots": reflect.TypeOf(DashboardPageSnapshot{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DashboardTaskOutput
// only implements ToObjectValue() and Type().
func (m DashboardTaskOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_snapshots": m.PageSnapshots,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DashboardTaskOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_snapshots": basetypes.ListType{
				ElemType: DashboardPageSnapshot{}.Type(ctx),
			},
		},
	}
}

// GetPageSnapshots returns the value of the PageSnapshots field in DashboardTaskOutput as
// a slice of DashboardPageSnapshot values.
// If the field is unknown or null, the boolean return value is false.
func (m *DashboardTaskOutput) GetPageSnapshots(ctx context.Context) ([]DashboardPageSnapshot, bool) {
	if m.PageSnapshots.IsNull() || m.PageSnapshots.IsUnknown() {
		return nil, false
	}
	var v []DashboardPageSnapshot
	d := m.PageSnapshots.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPageSnapshots sets the value of the PageSnapshots field in DashboardTaskOutput.
func (m *DashboardTaskOutput) SetPageSnapshots(ctx context.Context, v []DashboardPageSnapshot) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["page_snapshots"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PageSnapshots = types.ListValueMust(t, vs)
}

// Format of response retrieved from dbt Cloud, for inclusion in output
// Deprecated in favor of DbtPlatformJobRunStep
type DbtCloudJobRunStep struct {
	// Orders the steps in the job
	Index types.Int64 `tfsdk:"index"`
	// Output of the step
	Logs types.String `tfsdk:"logs"`
	// Name of the step in the job
	Name types.String `tfsdk:"name"`
	// State of the step
	Status types.String `tfsdk:"status"`
}

func (to *DbtCloudJobRunStep) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtCloudJobRunStep) {
}

func (to *DbtCloudJobRunStep) SyncFieldsDuringRead(ctx context.Context, from DbtCloudJobRunStep) {
}

func (m DbtCloudJobRunStep) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["index"] = attrs["index"].SetOptional()
	attrs["logs"] = attrs["logs"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtCloudJobRunStep.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtCloudJobRunStep) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtCloudJobRunStep
// only implements ToObjectValue() and Type().
func (m DbtCloudJobRunStep) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"index":  m.Index,
			"logs":   m.Logs,
			"name":   m.Name,
			"status": m.Status,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtCloudJobRunStep) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"index":  types.Int64Type,
			"logs":   types.StringType,
			"name":   types.StringType,
			"status": types.StringType,
		},
	}
}

// Deprecated in favor of DbtPlatformTask
type DbtCloudTask struct {
	// The resource name of the UC connection that authenticates the dbt Cloud
	// for this task
	ConnectionResourceName types.String `tfsdk:"connection_resource_name"`
	// Id of the dbt Cloud job to be triggered
	DbtCloudJobId types.Int64 `tfsdk:"dbt_cloud_job_id"`
}

func (to *DbtCloudTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtCloudTask) {
}

func (to *DbtCloudTask) SyncFieldsDuringRead(ctx context.Context, from DbtCloudTask) {
}

func (m DbtCloudTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_resource_name"] = attrs["connection_resource_name"].SetOptional()
	attrs["dbt_cloud_job_id"] = attrs["dbt_cloud_job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtCloudTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtCloudTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtCloudTask
// only implements ToObjectValue() and Type().
func (m DbtCloudTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_resource_name": m.ConnectionResourceName,
			"dbt_cloud_job_id":         m.DbtCloudJobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtCloudTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_resource_name": types.StringType,
			"dbt_cloud_job_id":         types.Int64Type,
		},
	}
}

// Deprecated in favor of DbtPlatformTaskOutput
type DbtCloudTaskOutput struct {
	// Id of the job run in dbt Cloud
	DbtCloudJobRunId types.Int64 `tfsdk:"dbt_cloud_job_run_id"`
	// Steps of the job run as received from dbt Cloud
	DbtCloudJobRunOutput types.List `tfsdk:"dbt_cloud_job_run_output"`
	// Url where full run details can be viewed
	DbtCloudJobRunUrl types.String `tfsdk:"dbt_cloud_job_run_url"`
}

func (to *DbtCloudTaskOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtCloudTaskOutput) {
	if !from.DbtCloudJobRunOutput.IsNull() && !from.DbtCloudJobRunOutput.IsUnknown() && to.DbtCloudJobRunOutput.IsNull() && len(from.DbtCloudJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCloudJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCloudJobRunOutput = from.DbtCloudJobRunOutput
	}
}

func (to *DbtCloudTaskOutput) SyncFieldsDuringRead(ctx context.Context, from DbtCloudTaskOutput) {
	if !from.DbtCloudJobRunOutput.IsNull() && !from.DbtCloudJobRunOutput.IsUnknown() && to.DbtCloudJobRunOutput.IsNull() && len(from.DbtCloudJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCloudJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCloudJobRunOutput = from.DbtCloudJobRunOutput
	}
}

func (m DbtCloudTaskOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_cloud_job_run_id"] = attrs["dbt_cloud_job_run_id"].SetOptional()
	attrs["dbt_cloud_job_run_output"] = attrs["dbt_cloud_job_run_output"].SetOptional()
	attrs["dbt_cloud_job_run_url"] = attrs["dbt_cloud_job_run_url"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtCloudTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtCloudTaskOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_cloud_job_run_output": reflect.TypeOf(DbtCloudJobRunStep{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtCloudTaskOutput
// only implements ToObjectValue() and Type().
func (m DbtCloudTaskOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_cloud_job_run_id":     m.DbtCloudJobRunId,
			"dbt_cloud_job_run_output": m.DbtCloudJobRunOutput,
			"dbt_cloud_job_run_url":    m.DbtCloudJobRunUrl,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtCloudTaskOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_cloud_job_run_id": types.Int64Type,
			"dbt_cloud_job_run_output": basetypes.ListType{
				ElemType: DbtCloudJobRunStep{}.Type(ctx),
			},
			"dbt_cloud_job_run_url": types.StringType,
		},
	}
}

// GetDbtCloudJobRunOutput returns the value of the DbtCloudJobRunOutput field in DbtCloudTaskOutput as
// a slice of DbtCloudJobRunStep values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtCloudTaskOutput) GetDbtCloudJobRunOutput(ctx context.Context) ([]DbtCloudJobRunStep, bool) {
	if m.DbtCloudJobRunOutput.IsNull() || m.DbtCloudJobRunOutput.IsUnknown() {
		return nil, false
	}
	var v []DbtCloudJobRunStep
	d := m.DbtCloudJobRunOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCloudJobRunOutput sets the value of the DbtCloudJobRunOutput field in DbtCloudTaskOutput.
func (m *DbtCloudTaskOutput) SetDbtCloudJobRunOutput(ctx context.Context, v []DbtCloudJobRunStep) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_cloud_job_run_output"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCloudJobRunOutput = types.ListValueMust(t, vs)
}

type DbtOutput struct {
	// An optional map of headers to send when retrieving the artifact from the
	// `artifacts_link`.
	ArtifactsHeaders types.Map `tfsdk:"artifacts_headers"`
	// A pre-signed URL to download the (compressed) dbt artifacts. This link is
	// valid for a limited time (30 minutes). This information is only available
	// after the run has finished.
	ArtifactsLink types.String `tfsdk:"artifacts_link"`
}

func (to *DbtOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtOutput) {
}

func (to *DbtOutput) SyncFieldsDuringRead(ctx context.Context, from DbtOutput) {
}

func (m DbtOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["artifacts_headers"] = attrs["artifacts_headers"].SetOptional()
	attrs["artifacts_link"] = attrs["artifacts_link"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"artifacts_headers": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtOutput
// only implements ToObjectValue() and Type().
func (m DbtOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"artifacts_headers": m.ArtifactsHeaders,
			"artifacts_link":    m.ArtifactsLink,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"artifacts_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"artifacts_link": types.StringType,
		},
	}
}

// GetArtifactsHeaders returns the value of the ArtifactsHeaders field in DbtOutput as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtOutput) GetArtifactsHeaders(ctx context.Context) (map[string]types.String, bool) {
	if m.ArtifactsHeaders.IsNull() || m.ArtifactsHeaders.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.ArtifactsHeaders.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetArtifactsHeaders sets the value of the ArtifactsHeaders field in DbtOutput.
func (m *DbtOutput) SetArtifactsHeaders(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["artifacts_headers"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ArtifactsHeaders = types.MapValueMust(t, vs)
}

// Format of response retrieved from dbt platform, for inclusion in output
type DbtPlatformJobRunStep struct {
	// Orders the steps in the job
	Index types.Int64 `tfsdk:"index"`
	// Output of the step
	Logs types.String `tfsdk:"logs"`
	// Whether the logs of this step have been truncated. If true, the logs has
	// been truncated to 10000 characters.
	LogsTruncated types.Bool `tfsdk:"logs_truncated"`
	// Name of the step in the job
	Name types.String `tfsdk:"name"`
	// Whether the name of the job has been truncated. If true, the name has
	// been truncated to 100 characters.
	NameTruncated types.Bool `tfsdk:"name_truncated"`
	// State of the step
	Status types.String `tfsdk:"status"`
}

func (to *DbtPlatformJobRunStep) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtPlatformJobRunStep) {
}

func (to *DbtPlatformJobRunStep) SyncFieldsDuringRead(ctx context.Context, from DbtPlatformJobRunStep) {
}

func (m DbtPlatformJobRunStep) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["index"] = attrs["index"].SetOptional()
	attrs["logs"] = attrs["logs"].SetOptional()
	attrs["logs_truncated"] = attrs["logs_truncated"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["name_truncated"] = attrs["name_truncated"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtPlatformJobRunStep.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtPlatformJobRunStep) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtPlatformJobRunStep
// only implements ToObjectValue() and Type().
func (m DbtPlatformJobRunStep) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"index":          m.Index,
			"logs":           m.Logs,
			"logs_truncated": m.LogsTruncated,
			"name":           m.Name,
			"name_truncated": m.NameTruncated,
			"status":         m.Status,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtPlatformJobRunStep) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"index":          types.Int64Type,
			"logs":           types.StringType,
			"logs_truncated": types.BoolType,
			"name":           types.StringType,
			"name_truncated": types.BoolType,
			"status":         types.StringType,
		},
	}
}

type DbtPlatformTask struct {
	// The resource name of the UC connection that authenticates the dbt
	// platform for this task
	ConnectionResourceName types.String `tfsdk:"connection_resource_name"`
	// Id of the dbt platform job to be triggered. Specified as a string for
	// maximum compatibility with clients.
	DbtPlatformJobId types.String `tfsdk:"dbt_platform_job_id"`
}

func (to *DbtPlatformTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtPlatformTask) {
}

func (to *DbtPlatformTask) SyncFieldsDuringRead(ctx context.Context, from DbtPlatformTask) {
}

func (m DbtPlatformTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_resource_name"] = attrs["connection_resource_name"].SetOptional()
	attrs["dbt_platform_job_id"] = attrs["dbt_platform_job_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtPlatformTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtPlatformTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtPlatformTask
// only implements ToObjectValue() and Type().
func (m DbtPlatformTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_resource_name": m.ConnectionResourceName,
			"dbt_platform_job_id":      m.DbtPlatformJobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtPlatformTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_resource_name": types.StringType,
			"dbt_platform_job_id":      types.StringType,
		},
	}
}

type DbtPlatformTaskOutput struct {
	// Id of the job run in dbt platform. Specified as a string for maximum
	// compatibility with clients.
	DbtPlatformJobRunId types.String `tfsdk:"dbt_platform_job_run_id"`
	// Steps of the job run as received from dbt platform
	DbtPlatformJobRunOutput types.List `tfsdk:"dbt_platform_job_run_output"`
	// Url where full run details can be viewed
	DbtPlatformJobRunUrl types.String `tfsdk:"dbt_platform_job_run_url"`
	// Whether the number of steps in the output has been truncated. If true,
	// the output will contain the first 20 steps of the output.
	StepsTruncated types.Bool `tfsdk:"steps_truncated"`
}

func (to *DbtPlatformTaskOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtPlatformTaskOutput) {
	if !from.DbtPlatformJobRunOutput.IsNull() && !from.DbtPlatformJobRunOutput.IsUnknown() && to.DbtPlatformJobRunOutput.IsNull() && len(from.DbtPlatformJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtPlatformJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtPlatformJobRunOutput = from.DbtPlatformJobRunOutput
	}
}

func (to *DbtPlatformTaskOutput) SyncFieldsDuringRead(ctx context.Context, from DbtPlatformTaskOutput) {
	if !from.DbtPlatformJobRunOutput.IsNull() && !from.DbtPlatformJobRunOutput.IsUnknown() && to.DbtPlatformJobRunOutput.IsNull() && len(from.DbtPlatformJobRunOutput.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtPlatformJobRunOutput, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtPlatformJobRunOutput = from.DbtPlatformJobRunOutput
	}
}

func (m DbtPlatformTaskOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_platform_job_run_id"] = attrs["dbt_platform_job_run_id"].SetOptional()
	attrs["dbt_platform_job_run_output"] = attrs["dbt_platform_job_run_output"].SetOptional()
	attrs["dbt_platform_job_run_url"] = attrs["dbt_platform_job_run_url"].SetOptional()
	attrs["steps_truncated"] = attrs["steps_truncated"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtPlatformTaskOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtPlatformTaskOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_platform_job_run_output": reflect.TypeOf(DbtPlatformJobRunStep{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtPlatformTaskOutput
// only implements ToObjectValue() and Type().
func (m DbtPlatformTaskOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_platform_job_run_id":     m.DbtPlatformJobRunId,
			"dbt_platform_job_run_output": m.DbtPlatformJobRunOutput,
			"dbt_platform_job_run_url":    m.DbtPlatformJobRunUrl,
			"steps_truncated":             m.StepsTruncated,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtPlatformTaskOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_platform_job_run_id": types.StringType,
			"dbt_platform_job_run_output": basetypes.ListType{
				ElemType: DbtPlatformJobRunStep{}.Type(ctx),
			},
			"dbt_platform_job_run_url": types.StringType,
			"steps_truncated":          types.BoolType,
		},
	}
}

// GetDbtPlatformJobRunOutput returns the value of the DbtPlatformJobRunOutput field in DbtPlatformTaskOutput as
// a slice of DbtPlatformJobRunStep values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtPlatformTaskOutput) GetDbtPlatformJobRunOutput(ctx context.Context) ([]DbtPlatformJobRunStep, bool) {
	if m.DbtPlatformJobRunOutput.IsNull() || m.DbtPlatformJobRunOutput.IsUnknown() {
		return nil, false
	}
	var v []DbtPlatformJobRunStep
	d := m.DbtPlatformJobRunOutput.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtPlatformJobRunOutput sets the value of the DbtPlatformJobRunOutput field in DbtPlatformTaskOutput.
func (m *DbtPlatformTaskOutput) SetDbtPlatformJobRunOutput(ctx context.Context, v []DbtPlatformJobRunStep) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_platform_job_run_output"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtPlatformJobRunOutput = types.ListValueMust(t, vs)
}

type DbtTask struct {
	// Optional name of the catalog to use. The value is the top level in the
	// 3-level namespace of Unity Catalog (catalog / schema / relation). The
	// catalog value can only be specified if a warehouse_id is specified.
	// Requires dbt-databricks >= 1.1.1.
	Catalog types.String `tfsdk:"catalog"`
	// A list of dbt commands to execute. All commands must start with `dbt`.
	// This parameter must not be empty. A maximum of up to 10 commands can be
	// provided.
	Commands types.List `tfsdk:"commands"`
	// Optional (relative) path to the profiles directory. Can only be specified
	// if no warehouse_id is specified. If no warehouse_id is specified and this
	// folder is unset, the root directory is used.
	ProfilesDirectory types.String `tfsdk:"profiles_directory"`
	// Path to the project directory. Optional for Git sourced tasks, in which
	// case if no value is provided, the root of the Git repository is used.
	ProjectDirectory types.String `tfsdk:"project_directory"`
	// Optional schema to write to. This parameter is only used when a
	// warehouse_id is also provided. If not provided, the `default` schema is
	// used.
	Schema types.String `tfsdk:"schema"`
	// Optional location type of the project directory. When set to `WORKSPACE`,
	// the project will be retrieved from the local Databricks workspace. When
	// set to `GIT`, the project will be retrieved from a Git repository defined
	// in `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise.
	//
	// * `WORKSPACE`: Project is located in Databricks workspace. * `GIT`:
	// Project is located in cloud Git provider.
	Source types.String `tfsdk:"source"`
	// ID of the SQL warehouse to connect to. If provided, we automatically
	// generate and provide the profile and connection details to dbt. It can be
	// overridden on a per-command basis by using the `--profiles-dir` command
	// line argument.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *DbtTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DbtTask) {
}

func (to *DbtTask) SyncFieldsDuringRead(ctx context.Context, from DbtTask) {
}

func (m DbtTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog"] = attrs["catalog"].SetOptional()
	attrs["commands"] = attrs["commands"].SetRequired()
	attrs["profiles_directory"] = attrs["profiles_directory"].SetOptional()
	attrs["project_directory"] = attrs["project_directory"].SetOptional()
	attrs["schema"] = attrs["schema"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DbtTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DbtTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"commands": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DbtTask
// only implements ToObjectValue() and Type().
func (m DbtTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog":            m.Catalog,
			"commands":           m.Commands,
			"profiles_directory": m.ProfilesDirectory,
			"project_directory":  m.ProjectDirectory,
			"schema":             m.Schema,
			"source":             m.Source,
			"warehouse_id":       m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DbtTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog": types.StringType,
			"commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"profiles_directory": types.StringType,
			"project_directory":  types.StringType,
			"schema":             types.StringType,
			"source":             types.StringType,
			"warehouse_id":       types.StringType,
		},
	}
}

// GetCommands returns the value of the Commands field in DbtTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *DbtTask) GetCommands(ctx context.Context) ([]types.String, bool) {
	if m.Commands.IsNull() || m.Commands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Commands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCommands sets the value of the Commands field in DbtTask.
func (m *DbtTask) SetCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Commands = types.ListValueMust(t, vs)
}

type DeleteJob struct {
	// The canonical identifier of the job to delete. This field is required.
	JobId types.Int64 `tfsdk:"job_id"`
}

func (to *DeleteJob) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteJob) {
}

func (to *DeleteJob) SyncFieldsDuringRead(ctx context.Context, from DeleteJob) {
}

func (m DeleteJob) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteJob) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteJob
// only implements ToObjectValue() and Type().
func (m DeleteJob) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteJob) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
		},
	}
}

type DeleteRun struct {
	// ID of the run to delete.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *DeleteRun) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from DeleteRun) {
}

func (to *DeleteRun) SyncFieldsDuringRead(ctx context.Context, from DeleteRun) {
}

func (m DeleteRun) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in DeleteRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m DeleteRun) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, DeleteRun
// only implements ToObjectValue() and Type().
func (m DeleteRun) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m DeleteRun) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

// Represents a change to the job cluster's settings that would be required for
// the job clusters to become compliant with their policies.
type EnforcePolicyComplianceForJobResponseJobClusterSettingsChange struct {
	// The field where this change would be made, prepended with the job cluster
	// key.
	Field types.String `tfsdk:"field"`
	// The new value of this field after enforcing policy compliance (either a
	// number, a boolean, or a string) converted to a string. This is intended
	// to be read by a human. The typed new value of this field can be retrieved
	// by reading the settings field in the API response.
	NewValue types.String `tfsdk:"new_value"`
	// The previous value of this field before enforcing policy compliance
	// (either a number, a boolean, or a string) converted to a string. This is
	// intended to be read by a human. The type of the field can be retrieved by
	// reading the settings field in the API response.
	PreviousValue types.String `tfsdk:"previous_value"`
}

func (to *EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) {
}

func (to *EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) SyncFieldsDuringRead(ctx context.Context, from EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) {
}

func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["field"] = attrs["field"].SetOptional()
	attrs["new_value"] = attrs["new_value"].SetOptional()
	attrs["previous_value"] = attrs["previous_value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnforcePolicyComplianceForJobResponseJobClusterSettingsChange.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnforcePolicyComplianceForJobResponseJobClusterSettingsChange
// only implements ToObjectValue() and Type().
func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"field":          m.Field,
			"new_value":      m.NewValue,
			"previous_value": m.PreviousValue,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"field":          types.StringType,
			"new_value":      types.StringType,
			"previous_value": types.StringType,
		},
	}
}

type EnforcePolicyComplianceRequest struct {
	// The ID of the job you want to enforce policy compliance on.
	JobId types.Int64 `tfsdk:"job_id"`
	// If set, previews changes made to the job to comply with its policy, but
	// does not update the job.
	ValidateOnly types.Bool `tfsdk:"validate_only"`
}

func (to *EnforcePolicyComplianceRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnforcePolicyComplianceRequest) {
}

func (to *EnforcePolicyComplianceRequest) SyncFieldsDuringRead(ctx context.Context, from EnforcePolicyComplianceRequest) {
}

func (m EnforcePolicyComplianceRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["validate_only"] = attrs["validate_only"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnforcePolicyComplianceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnforcePolicyComplianceRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnforcePolicyComplianceRequest
// only implements ToObjectValue() and Type().
func (m EnforcePolicyComplianceRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id":        m.JobId,
			"validate_only": m.ValidateOnly,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnforcePolicyComplianceRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id":        types.Int64Type,
			"validate_only": types.BoolType,
		},
	}
}

type EnforcePolicyComplianceResponse struct {
	// Whether any changes have been made to the job cluster settings for the
	// job to become compliant with its policies.
	HasChanges types.Bool `tfsdk:"has_changes"`
	// A list of job cluster changes that have been made to the job’s cluster
	// settings in order for all job clusters to become compliant with their
	// policies.
	JobClusterChanges types.List `tfsdk:"job_cluster_changes"`
	// Updated job settings after policy enforcement. Policy enforcement only
	// applies to job clusters that are created when running the job (which are
	// specified in new_cluster) and does not apply to existing all-purpose
	// clusters. Updated job settings are derived by applying policy default
	// values to the existing job clusters in order to satisfy policy
	// requirements.
	Settings types.Object `tfsdk:"settings"`
}

func (to *EnforcePolicyComplianceResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from EnforcePolicyComplianceResponse) {
	if !from.JobClusterChanges.IsNull() && !from.JobClusterChanges.IsUnknown() && to.JobClusterChanges.IsNull() && len(from.JobClusterChanges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusterChanges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusterChanges = from.JobClusterChanges
	}
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				// Recursively sync the fields of Settings
				toSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
}

func (to *EnforcePolicyComplianceResponse) SyncFieldsDuringRead(ctx context.Context, from EnforcePolicyComplianceResponse) {
	if !from.JobClusterChanges.IsNull() && !from.JobClusterChanges.IsUnknown() && to.JobClusterChanges.IsNull() && len(from.JobClusterChanges.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusterChanges, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusterChanges = from.JobClusterChanges
	}
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				toSettings.SyncFieldsDuringRead(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
}

func (m EnforcePolicyComplianceResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_changes"] = attrs["has_changes"].SetOptional()
	attrs["job_cluster_changes"] = attrs["job_cluster_changes"].SetOptional()
	attrs["settings"] = attrs["settings"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in EnforcePolicyComplianceResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m EnforcePolicyComplianceResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"job_cluster_changes": reflect.TypeOf(EnforcePolicyComplianceForJobResponseJobClusterSettingsChange{}),
		"settings":            reflect.TypeOf(JobSettings{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, EnforcePolicyComplianceResponse
// only implements ToObjectValue() and Type().
func (m EnforcePolicyComplianceResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_changes":         m.HasChanges,
			"job_cluster_changes": m.JobClusterChanges,
			"settings":            m.Settings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m EnforcePolicyComplianceResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_changes": types.BoolType,
			"job_cluster_changes": basetypes.ListType{
				ElemType: EnforcePolicyComplianceForJobResponseJobClusterSettingsChange{}.Type(ctx),
			},
			"settings": JobSettings{}.Type(ctx),
		},
	}
}

// GetJobClusterChanges returns the value of the JobClusterChanges field in EnforcePolicyComplianceResponse as
// a slice of EnforcePolicyComplianceForJobResponseJobClusterSettingsChange values.
// If the field is unknown or null, the boolean return value is false.
func (m *EnforcePolicyComplianceResponse) GetJobClusterChanges(ctx context.Context) ([]EnforcePolicyComplianceForJobResponseJobClusterSettingsChange, bool) {
	if m.JobClusterChanges.IsNull() || m.JobClusterChanges.IsUnknown() {
		return nil, false
	}
	var v []EnforcePolicyComplianceForJobResponseJobClusterSettingsChange
	d := m.JobClusterChanges.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusterChanges sets the value of the JobClusterChanges field in EnforcePolicyComplianceResponse.
func (m *EnforcePolicyComplianceResponse) SetJobClusterChanges(ctx context.Context, v []EnforcePolicyComplianceForJobResponseJobClusterSettingsChange) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_cluster_changes"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusterChanges = types.ListValueMust(t, vs)
}

// GetSettings returns the value of the Settings field in EnforcePolicyComplianceResponse as
// a JobSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *EnforcePolicyComplianceResponse) GetSettings(ctx context.Context) (JobSettings, bool) {
	var e JobSettings
	if m.Settings.IsNull() || m.Settings.IsUnknown() {
		return e, false
	}
	var v JobSettings
	d := m.Settings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSettings sets the value of the Settings field in EnforcePolicyComplianceResponse.
func (m *EnforcePolicyComplianceResponse) SetSettings(ctx context.Context, v JobSettings) {
	vs := v.ToObjectValue(ctx)
	m.Settings = vs
}

// Run was exported successfully.
type ExportRunOutput struct {
	// The exported content in HTML format (one for every view item). To extract
	// the HTML notebook from the JSON response, download and run this [Python
	// script](/_static/examples/extract.py).
	Views types.List `tfsdk:"views"`
}

func (to *ExportRunOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExportRunOutput) {
	if !from.Views.IsNull() && !from.Views.IsUnknown() && to.Views.IsNull() && len(from.Views.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Views, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Views = from.Views
	}
}

func (to *ExportRunOutput) SyncFieldsDuringRead(ctx context.Context, from ExportRunOutput) {
	if !from.Views.IsNull() && !from.Views.IsUnknown() && to.Views.IsNull() && len(from.Views.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Views, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Views = from.Views
	}
}

func (m ExportRunOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["views"] = attrs["views"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExportRunOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExportRunOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"views": reflect.TypeOf(ViewItem{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExportRunOutput
// only implements ToObjectValue() and Type().
func (m ExportRunOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"views": m.Views,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExportRunOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"views": basetypes.ListType{
				ElemType: ViewItem{}.Type(ctx),
			},
		},
	}
}

// GetViews returns the value of the Views field in ExportRunOutput as
// a slice of ViewItem values.
// If the field is unknown or null, the boolean return value is false.
func (m *ExportRunOutput) GetViews(ctx context.Context) ([]ViewItem, bool) {
	if m.Views.IsNull() || m.Views.IsUnknown() {
		return nil, false
	}
	var v []ViewItem
	d := m.Views.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViews sets the value of the Views field in ExportRunOutput.
func (m *ExportRunOutput) SetViews(ctx context.Context, v []ViewItem) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["views"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Views = types.ListValueMust(t, vs)
}

type ExportRunRequest struct {
	// The canonical identifier for the run. This field is required.
	RunId types.Int64 `tfsdk:"-"`
	// Which views to export (CODE, DASHBOARDS, or ALL). Defaults to CODE.
	ViewsToExport types.String `tfsdk:"-"`
}

func (to *ExportRunRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ExportRunRequest) {
}

func (to *ExportRunRequest) SyncFieldsDuringRead(ctx context.Context, from ExportRunRequest) {
}

func (m ExportRunRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()
	attrs["views_to_export"] = attrs["views_to_export"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ExportRunRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ExportRunRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ExportRunRequest
// only implements ToObjectValue() and Type().
func (m ExportRunRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id":          m.RunId,
			"views_to_export": m.ViewsToExport,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ExportRunRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id":          types.Int64Type,
			"views_to_export": types.StringType,
		},
	}
}

type FileArrivalTriggerConfiguration struct {
	// If set, the trigger starts a run only after the specified amount of time
	// passed since the last time the trigger fired. The minimum allowed value
	// is 60 seconds
	MinTimeBetweenTriggersSeconds types.Int64 `tfsdk:"min_time_between_triggers_seconds"`
	// URL to be monitored for file arrivals. The path must point to the root or
	// a subpath of the external location.
	Url types.String `tfsdk:"url"`
	// If set, the trigger starts a run only after no file activity has occurred
	// for the specified amount of time. This makes it possible to wait for a
	// batch of incoming files to arrive before triggering a run. The minimum
	// allowed value is 60 seconds.
	WaitAfterLastChangeSeconds types.Int64 `tfsdk:"wait_after_last_change_seconds"`
}

func (to *FileArrivalTriggerConfiguration) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FileArrivalTriggerConfiguration) {
}

func (to *FileArrivalTriggerConfiguration) SyncFieldsDuringRead(ctx context.Context, from FileArrivalTriggerConfiguration) {
}

func (m FileArrivalTriggerConfiguration) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["min_time_between_triggers_seconds"] = attrs["min_time_between_triggers_seconds"].SetOptional()
	attrs["url"] = attrs["url"].SetRequired()
	attrs["wait_after_last_change_seconds"] = attrs["wait_after_last_change_seconds"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FileArrivalTriggerConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FileArrivalTriggerConfiguration) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FileArrivalTriggerConfiguration
// only implements ToObjectValue() and Type().
func (m FileArrivalTriggerConfiguration) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"min_time_between_triggers_seconds": m.MinTimeBetweenTriggersSeconds,
			"url":                               m.Url,
			"wait_after_last_change_seconds":    m.WaitAfterLastChangeSeconds,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FileArrivalTriggerConfiguration) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"min_time_between_triggers_seconds": types.Int64Type,
			"url":                               types.StringType,
			"wait_after_last_change_seconds":    types.Int64Type,
		},
	}
}

type FileArrivalTriggerState struct {
	// Indicates whether the trigger leverages file events to detect file
	// arrivals.
	UsingFileEvents types.Bool `tfsdk:"using_file_events"`
}

func (to *FileArrivalTriggerState) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from FileArrivalTriggerState) {
}

func (to *FileArrivalTriggerState) SyncFieldsDuringRead(ctx context.Context, from FileArrivalTriggerState) {
}

func (m FileArrivalTriggerState) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["using_file_events"] = attrs["using_file_events"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in FileArrivalTriggerState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m FileArrivalTriggerState) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, FileArrivalTriggerState
// only implements ToObjectValue() and Type().
func (m FileArrivalTriggerState) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"using_file_events": m.UsingFileEvents,
		})
}

// Type implements basetypes.ObjectValuable.
func (m FileArrivalTriggerState) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"using_file_events": types.BoolType,
		},
	}
}

type ForEachStats struct {
	// Sample of 3 most common error messages occurred during the iteration.
	ErrorMessageStats types.List `tfsdk:"error_message_stats"`
	// Describes stats of the iteration. Only latest retries are considered.
	TaskRunStats types.Object `tfsdk:"task_run_stats"`
}

func (to *ForEachStats) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachStats) {
	if !from.ErrorMessageStats.IsNull() && !from.ErrorMessageStats.IsUnknown() && to.ErrorMessageStats.IsNull() && len(from.ErrorMessageStats.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ErrorMessageStats, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ErrorMessageStats = from.ErrorMessageStats
	}
	if !from.TaskRunStats.IsNull() && !from.TaskRunStats.IsUnknown() {
		if toTaskRunStats, ok := to.GetTaskRunStats(ctx); ok {
			if fromTaskRunStats, ok := from.GetTaskRunStats(ctx); ok {
				// Recursively sync the fields of TaskRunStats
				toTaskRunStats.SyncFieldsDuringCreateOrUpdate(ctx, fromTaskRunStats)
				to.SetTaskRunStats(ctx, toTaskRunStats)
			}
		}
	}
}

func (to *ForEachStats) SyncFieldsDuringRead(ctx context.Context, from ForEachStats) {
	if !from.ErrorMessageStats.IsNull() && !from.ErrorMessageStats.IsUnknown() && to.ErrorMessageStats.IsNull() && len(from.ErrorMessageStats.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for ErrorMessageStats, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.ErrorMessageStats = from.ErrorMessageStats
	}
	if !from.TaskRunStats.IsNull() && !from.TaskRunStats.IsUnknown() {
		if toTaskRunStats, ok := to.GetTaskRunStats(ctx); ok {
			if fromTaskRunStats, ok := from.GetTaskRunStats(ctx); ok {
				toTaskRunStats.SyncFieldsDuringRead(ctx, fromTaskRunStats)
				to.SetTaskRunStats(ctx, toTaskRunStats)
			}
		}
	}
}

func (m ForEachStats) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["error_message_stats"] = attrs["error_message_stats"].SetOptional()
	attrs["task_run_stats"] = attrs["task_run_stats"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachStats.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachStats) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"error_message_stats": reflect.TypeOf(ForEachTaskErrorMessageStats{}),
		"task_run_stats":      reflect.TypeOf(ForEachTaskTaskRunStats{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachStats
// only implements ToObjectValue() and Type().
func (m ForEachStats) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"error_message_stats": m.ErrorMessageStats,
			"task_run_stats":      m.TaskRunStats,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachStats) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"error_message_stats": basetypes.ListType{
				ElemType: ForEachTaskErrorMessageStats{}.Type(ctx),
			},
			"task_run_stats": ForEachTaskTaskRunStats{}.Type(ctx),
		},
	}
}

// GetErrorMessageStats returns the value of the ErrorMessageStats field in ForEachStats as
// a slice of ForEachTaskErrorMessageStats values.
// If the field is unknown or null, the boolean return value is false.
func (m *ForEachStats) GetErrorMessageStats(ctx context.Context) ([]ForEachTaskErrorMessageStats, bool) {
	if m.ErrorMessageStats.IsNull() || m.ErrorMessageStats.IsUnknown() {
		return nil, false
	}
	var v []ForEachTaskErrorMessageStats
	d := m.ErrorMessageStats.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetErrorMessageStats sets the value of the ErrorMessageStats field in ForEachStats.
func (m *ForEachStats) SetErrorMessageStats(ctx context.Context, v []ForEachTaskErrorMessageStats) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["error_message_stats"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.ErrorMessageStats = types.ListValueMust(t, vs)
}

// GetTaskRunStats returns the value of the TaskRunStats field in ForEachStats as
// a ForEachTaskTaskRunStats value.
// If the field is unknown or null, the boolean return value is false.
func (m *ForEachStats) GetTaskRunStats(ctx context.Context) (ForEachTaskTaskRunStats, bool) {
	var e ForEachTaskTaskRunStats
	if m.TaskRunStats.IsNull() || m.TaskRunStats.IsUnknown() {
		return e, false
	}
	var v ForEachTaskTaskRunStats
	d := m.TaskRunStats.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTaskRunStats sets the value of the TaskRunStats field in ForEachStats.
func (m *ForEachStats) SetTaskRunStats(ctx context.Context, v ForEachTaskTaskRunStats) {
	vs := v.ToObjectValue(ctx)
	m.TaskRunStats = vs
}

type ForEachTask struct {
	// An optional maximum allowed number of concurrent runs of the task. Set
	// this value if you want to be able to execute multiple runs of the task
	// concurrently.
	Concurrency types.Int64 `tfsdk:"concurrency"`
	// Array for task to iterate on. This can be a JSON string or a reference to
	// an array parameter.
	Inputs types.String `tfsdk:"inputs"`
	// Configuration for the task that will be run for each element in the array
	Task types.Object `tfsdk:"task"`
}

func (to *ForEachTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachTask) {
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				// Recursively sync the fields of Task
				toTask.SyncFieldsDuringCreateOrUpdate(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (to *ForEachTask) SyncFieldsDuringRead(ctx context.Context, from ForEachTask) {
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				toTask.SyncFieldsDuringRead(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (m ForEachTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["concurrency"] = attrs["concurrency"].SetOptional()
	attrs["inputs"] = attrs["inputs"].SetRequired()
	attrs["task"] = attrs["task"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"task": reflect.TypeOf(Task{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachTask
// only implements ToObjectValue() and Type().
func (m ForEachTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"concurrency": m.Concurrency,
			"inputs":      m.Inputs,
			"task":        m.Task,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"concurrency": types.Int64Type,
			"inputs":      types.StringType,
			"task":        Task{}.Type(ctx),
		},
	}
}

// GetTask returns the value of the Task field in ForEachTask as
// a Task value.
// If the field is unknown or null, the boolean return value is false.
func (m *ForEachTask) GetTask(ctx context.Context) (Task, bool) {
	var e Task
	if m.Task.IsNull() || m.Task.IsUnknown() {
		return e, false
	}
	var v Task
	d := m.Task.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTask sets the value of the Task field in ForEachTask.
func (m *ForEachTask) SetTask(ctx context.Context, v Task) {
	vs := v.ToObjectValue(ctx)
	m.Task = vs
}

type ForEachTaskErrorMessageStats struct {
	// Describes the count of such error message encountered during the
	// iterations.
	Count types.Int64 `tfsdk:"count"`
	// Describes the error message occured during the iterations.
	ErrorMessage types.String `tfsdk:"error_message"`
	// Describes the termination reason for the error message.
	TerminationCategory types.String `tfsdk:"termination_category"`
}

func (to *ForEachTaskErrorMessageStats) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachTaskErrorMessageStats) {
}

func (to *ForEachTaskErrorMessageStats) SyncFieldsDuringRead(ctx context.Context, from ForEachTaskErrorMessageStats) {
}

func (m ForEachTaskErrorMessageStats) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["count"] = attrs["count"].SetOptional()
	attrs["error_message"] = attrs["error_message"].SetOptional()
	attrs["termination_category"] = attrs["termination_category"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachTaskErrorMessageStats.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachTaskErrorMessageStats) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachTaskErrorMessageStats
// only implements ToObjectValue() and Type().
func (m ForEachTaskErrorMessageStats) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"count":                m.Count,
			"error_message":        m.ErrorMessage,
			"termination_category": m.TerminationCategory,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachTaskErrorMessageStats) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"count":                types.Int64Type,
			"error_message":        types.StringType,
			"termination_category": types.StringType,
		},
	}
}

type ForEachTaskTaskRunStats struct {
	// Describes the iteration runs having an active lifecycle state or an
	// active run sub state.
	ActiveIterations types.Int64 `tfsdk:"active_iterations"`
	// Describes the number of failed and succeeded iteration runs.
	CompletedIterations types.Int64 `tfsdk:"completed_iterations"`
	// Describes the number of failed iteration runs.
	FailedIterations types.Int64 `tfsdk:"failed_iterations"`
	// Describes the number of iteration runs that have been scheduled.
	ScheduledIterations types.Int64 `tfsdk:"scheduled_iterations"`
	// Describes the number of succeeded iteration runs.
	SucceededIterations types.Int64 `tfsdk:"succeeded_iterations"`
	// Describes the length of the list of items to iterate over.
	TotalIterations types.Int64 `tfsdk:"total_iterations"`
}

func (to *ForEachTaskTaskRunStats) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ForEachTaskTaskRunStats) {
}

func (to *ForEachTaskTaskRunStats) SyncFieldsDuringRead(ctx context.Context, from ForEachTaskTaskRunStats) {
}

func (m ForEachTaskTaskRunStats) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["active_iterations"] = attrs["active_iterations"].SetOptional()
	attrs["completed_iterations"] = attrs["completed_iterations"].SetOptional()
	attrs["failed_iterations"] = attrs["failed_iterations"].SetOptional()
	attrs["scheduled_iterations"] = attrs["scheduled_iterations"].SetOptional()
	attrs["succeeded_iterations"] = attrs["succeeded_iterations"].SetOptional()
	attrs["total_iterations"] = attrs["total_iterations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ForEachTaskTaskRunStats.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ForEachTaskTaskRunStats) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ForEachTaskTaskRunStats
// only implements ToObjectValue() and Type().
func (m ForEachTaskTaskRunStats) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active_iterations":    m.ActiveIterations,
			"completed_iterations": m.CompletedIterations,
			"failed_iterations":    m.FailedIterations,
			"scheduled_iterations": m.ScheduledIterations,
			"succeeded_iterations": m.SucceededIterations,
			"total_iterations":     m.TotalIterations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ForEachTaskTaskRunStats) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active_iterations":    types.Int64Type,
			"completed_iterations": types.Int64Type,
			"failed_iterations":    types.Int64Type,
			"scheduled_iterations": types.Int64Type,
			"succeeded_iterations": types.Int64Type,
			"total_iterations":     types.Int64Type,
		},
	}
}

type GenAiComputeTask struct {
	// Command launcher to run the actual script, e.g. bash, python etc.
	Command types.String `tfsdk:"command"`

	Compute types.Object `tfsdk:"compute"`
	// Runtime image
	DlRuntimeImage types.String `tfsdk:"dl_runtime_image"`
	// Optional string containing the name of the MLflow experiment to log the
	// run to. If name is not found, backend will create the mlflow experiment
	// using the name.
	MlflowExperimentName types.String `tfsdk:"mlflow_experiment_name"`
	// Optional location type of the training script. When set to `WORKSPACE`,
	// the script will be retrieved from the local Databricks workspace. When
	// set to `GIT`, the script will be retrieved from a Git repository defined
	// in `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise. * `WORKSPACE`: Script
	// is located in Databricks workspace. * `GIT`: Script is located in cloud
	// Git provider.
	Source types.String `tfsdk:"source"`
	// The training script file path to be executed. Cloud file URIs (such as
	// dbfs:/, s3:/, adls:/, gcs:/) and workspace paths are supported. For
	// python files stored in the Databricks workspace, the path must be
	// absolute and begin with `/`. For files stored in a remote repository, the
	// path must be relative. This field is required.
	TrainingScriptPath types.String `tfsdk:"training_script_path"`
	// Optional string containing model parameters passed to the training script
	// in yaml format. If present, then the content in yaml_parameters_file_path
	// will be ignored.
	YamlParameters types.String `tfsdk:"yaml_parameters"`
	// Optional path to a YAML file containing model parameters passed to the
	// training script.
	YamlParametersFilePath types.String `tfsdk:"yaml_parameters_file_path"`
}

func (to *GenAiComputeTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GenAiComputeTask) {
	if !from.Compute.IsNull() && !from.Compute.IsUnknown() {
		if toCompute, ok := to.GetCompute(ctx); ok {
			if fromCompute, ok := from.GetCompute(ctx); ok {
				// Recursively sync the fields of Compute
				toCompute.SyncFieldsDuringCreateOrUpdate(ctx, fromCompute)
				to.SetCompute(ctx, toCompute)
			}
		}
	}
}

func (to *GenAiComputeTask) SyncFieldsDuringRead(ctx context.Context, from GenAiComputeTask) {
	if !from.Compute.IsNull() && !from.Compute.IsUnknown() {
		if toCompute, ok := to.GetCompute(ctx); ok {
			if fromCompute, ok := from.GetCompute(ctx); ok {
				toCompute.SyncFieldsDuringRead(ctx, fromCompute)
				to.SetCompute(ctx, toCompute)
			}
		}
	}
}

func (m GenAiComputeTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["command"] = attrs["command"].SetOptional()
	attrs["compute"] = attrs["compute"].SetOptional()
	attrs["dl_runtime_image"] = attrs["dl_runtime_image"].SetRequired()
	attrs["mlflow_experiment_name"] = attrs["mlflow_experiment_name"].SetOptional()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["training_script_path"] = attrs["training_script_path"].SetOptional()
	attrs["yaml_parameters"] = attrs["yaml_parameters"].SetOptional()
	attrs["yaml_parameters_file_path"] = attrs["yaml_parameters_file_path"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GenAiComputeTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GenAiComputeTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"compute": reflect.TypeOf(ComputeConfig{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GenAiComputeTask
// only implements ToObjectValue() and Type().
func (m GenAiComputeTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"command":                   m.Command,
			"compute":                   m.Compute,
			"dl_runtime_image":          m.DlRuntimeImage,
			"mlflow_experiment_name":    m.MlflowExperimentName,
			"source":                    m.Source,
			"training_script_path":      m.TrainingScriptPath,
			"yaml_parameters":           m.YamlParameters,
			"yaml_parameters_file_path": m.YamlParametersFilePath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GenAiComputeTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"command":                   types.StringType,
			"compute":                   ComputeConfig{}.Type(ctx),
			"dl_runtime_image":          types.StringType,
			"mlflow_experiment_name":    types.StringType,
			"source":                    types.StringType,
			"training_script_path":      types.StringType,
			"yaml_parameters":           types.StringType,
			"yaml_parameters_file_path": types.StringType,
		},
	}
}

// GetCompute returns the value of the Compute field in GenAiComputeTask as
// a ComputeConfig value.
// If the field is unknown or null, the boolean return value is false.
func (m *GenAiComputeTask) GetCompute(ctx context.Context) (ComputeConfig, bool) {
	var e ComputeConfig
	if m.Compute.IsNull() || m.Compute.IsUnknown() {
		return e, false
	}
	var v ComputeConfig
	d := m.Compute.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCompute sets the value of the Compute field in GenAiComputeTask.
func (m *GenAiComputeTask) SetCompute(ctx context.Context, v ComputeConfig) {
	vs := v.ToObjectValue(ctx)
	m.Compute = vs
}

type GetJobPermissionLevelsRequest struct {
	// The job for which to get or manage permissions.
	JobId types.String `tfsdk:"-"`
}

func (to *GetJobPermissionLevelsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobPermissionLevelsRequest) {
}

func (to *GetJobPermissionLevelsRequest) SyncFieldsDuringRead(ctx context.Context, from GetJobPermissionLevelsRequest) {
}

func (m GetJobPermissionLevelsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobPermissionLevelsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobPermissionLevelsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobPermissionLevelsRequest
// only implements ToObjectValue() and Type().
func (m GetJobPermissionLevelsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobPermissionLevelsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.StringType,
		},
	}
}

type GetJobPermissionLevelsResponse struct {
	// Specific permission levels
	PermissionLevels types.List `tfsdk:"permission_levels"`
}

func (to *GetJobPermissionLevelsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobPermissionLevelsResponse) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (to *GetJobPermissionLevelsResponse) SyncFieldsDuringRead(ctx context.Context, from GetJobPermissionLevelsResponse) {
	if !from.PermissionLevels.IsNull() && !from.PermissionLevels.IsUnknown() && to.PermissionLevels.IsNull() && len(from.PermissionLevels.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PermissionLevels, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PermissionLevels = from.PermissionLevels
	}
}

func (m GetJobPermissionLevelsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["permission_levels"] = attrs["permission_levels"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobPermissionLevelsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobPermissionLevelsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"permission_levels": reflect.TypeOf(JobPermissionsDescription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobPermissionLevelsResponse
// only implements ToObjectValue() and Type().
func (m GetJobPermissionLevelsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"permission_levels": m.PermissionLevels,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobPermissionLevelsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"permission_levels": basetypes.ListType{
				ElemType: JobPermissionsDescription{}.Type(ctx),
			},
		},
	}
}

// GetPermissionLevels returns the value of the PermissionLevels field in GetJobPermissionLevelsResponse as
// a slice of JobPermissionsDescription values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetJobPermissionLevelsResponse) GetPermissionLevels(ctx context.Context) ([]JobPermissionsDescription, bool) {
	if m.PermissionLevels.IsNull() || m.PermissionLevels.IsUnknown() {
		return nil, false
	}
	var v []JobPermissionsDescription
	d := m.PermissionLevels.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPermissionLevels sets the value of the PermissionLevels field in GetJobPermissionLevelsResponse.
func (m *GetJobPermissionLevelsResponse) SetPermissionLevels(ctx context.Context, v []JobPermissionsDescription) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["permission_levels"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PermissionLevels = types.ListValueMust(t, vs)
}

type GetJobPermissionsRequest struct {
	// The job for which to get or manage permissions.
	JobId types.String `tfsdk:"-"`
}

func (to *GetJobPermissionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobPermissionsRequest) {
}

func (to *GetJobPermissionsRequest) SyncFieldsDuringRead(ctx context.Context, from GetJobPermissionsRequest) {
}

func (m GetJobPermissionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobPermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobPermissionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobPermissionsRequest
// only implements ToObjectValue() and Type().
func (m GetJobPermissionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobPermissionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.StringType,
		},
	}
}

type GetJobRequest struct {
	// The canonical identifier of the job to retrieve information about. This
	// field is required.
	JobId types.Int64 `tfsdk:"-"`
	// Use `next_page_token` returned from the previous GetJob response to
	// request the next page of the job's array properties.
	PageToken types.String `tfsdk:"-"`
}

func (to *GetJobRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetJobRequest) {
}

func (to *GetJobRequest) SyncFieldsDuringRead(ctx context.Context, from GetJobRequest) {
}

func (m GetJobRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetJobRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetJobRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetJobRequest
// only implements ToObjectValue() and Type().
func (m GetJobRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id":     m.JobId,
			"page_token": m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetJobRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id":     types.Int64Type,
			"page_token": types.StringType,
		},
	}
}

type GetPolicyComplianceRequest struct {
	// The ID of the job whose compliance status you are requesting.
	JobId types.Int64 `tfsdk:"-"`
}

func (to *GetPolicyComplianceRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPolicyComplianceRequest) {
}

func (to *GetPolicyComplianceRequest) SyncFieldsDuringRead(ctx context.Context, from GetPolicyComplianceRequest) {
}

func (m GetPolicyComplianceRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPolicyComplianceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPolicyComplianceRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPolicyComplianceRequest
// only implements ToObjectValue() and Type().
func (m GetPolicyComplianceRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id": m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPolicyComplianceRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id": types.Int64Type,
		},
	}
}

type GetPolicyComplianceResponse struct {
	// Whether the job is compliant with its policies or not. Jobs could be out
	// of compliance if a policy they are using was updated after the job was
	// last edited and some of its job clusters no longer comply with their
	// updated policies.
	IsCompliant types.Bool `tfsdk:"is_compliant"`
	// An object containing key-value mappings representing the first 200 policy
	// validation errors. The keys indicate the path where the policy validation
	// error is occurring. An identifier for the job cluster is prepended to the
	// path. The values indicate an error message describing the policy
	// validation error.
	Violations types.Map `tfsdk:"violations"`
}

func (to *GetPolicyComplianceResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetPolicyComplianceResponse) {
}

func (to *GetPolicyComplianceResponse) SyncFieldsDuringRead(ctx context.Context, from GetPolicyComplianceResponse) {
}

func (m GetPolicyComplianceResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_compliant"] = attrs["is_compliant"].SetOptional()
	attrs["violations"] = attrs["violations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetPolicyComplianceResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetPolicyComplianceResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"violations": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetPolicyComplianceResponse
// only implements ToObjectValue() and Type().
func (m GetPolicyComplianceResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_compliant": m.IsCompliant,
			"violations":   m.Violations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetPolicyComplianceResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_compliant": types.BoolType,
			"violations": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetViolations returns the value of the Violations field in GetPolicyComplianceResponse as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *GetPolicyComplianceResponse) GetViolations(ctx context.Context) (map[string]types.String, bool) {
	if m.Violations.IsNull() || m.Violations.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Violations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViolations sets the value of the Violations field in GetPolicyComplianceResponse.
func (m *GetPolicyComplianceResponse) SetViolations(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["violations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Violations = types.MapValueMust(t, vs)
}

type GetRunOutputRequest struct {
	// The canonical identifier for the run.
	RunId types.Int64 `tfsdk:"-"`
}

func (to *GetRunOutputRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRunOutputRequest) {
}

func (to *GetRunOutputRequest) SyncFieldsDuringRead(ctx context.Context, from GetRunOutputRequest) {
}

func (m GetRunOutputRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRunOutputRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetRunOutputRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRunOutputRequest
// only implements ToObjectValue() and Type().
func (m GetRunOutputRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetRunOutputRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type GetRunRequest struct {
	// Whether to include the repair history in the response.
	IncludeHistory types.Bool `tfsdk:"-"`
	// Whether to include resolved parameter values in the response.
	IncludeResolvedValues types.Bool `tfsdk:"-"`
	// Use `next_page_token` returned from the previous GetRun response to
	// request the next page of the run's array properties.
	PageToken types.String `tfsdk:"-"`
	// The canonical identifier of the run for which to retrieve the metadata.
	// This field is required.
	RunId types.Int64 `tfsdk:"-"`
}

func (to *GetRunRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GetRunRequest) {
}

func (to *GetRunRequest) SyncFieldsDuringRead(ctx context.Context, from GetRunRequest) {
}

func (m GetRunRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetRequired()
	attrs["include_history"] = attrs["include_history"].SetOptional()
	attrs["include_resolved_values"] = attrs["include_resolved_values"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GetRunRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GetRunRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GetRunRequest
// only implements ToObjectValue() and Type().
func (m GetRunRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"include_history":         m.IncludeHistory,
			"include_resolved_values": m.IncludeResolvedValues,
			"page_token":              m.PageToken,
			"run_id":                  m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GetRunRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"include_history":         types.BoolType,
			"include_resolved_values": types.BoolType,
			"page_token":              types.StringType,
			"run_id":                  types.Int64Type,
		},
	}
}

// Read-only state of the remote repository at the time the job was run. This
// field is only included on job runs.
type GitSnapshot struct {
	// Commit that was used to execute the run. If git_branch was specified,
	// this points to the HEAD of the branch at the time of the run; if git_tag
	// was specified, this points to the commit the tag points to.
	UsedCommit types.String `tfsdk:"used_commit"`
}

func (to *GitSnapshot) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GitSnapshot) {
}

func (to *GitSnapshot) SyncFieldsDuringRead(ctx context.Context, from GitSnapshot) {
}

func (m GitSnapshot) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["used_commit"] = attrs["used_commit"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GitSnapshot.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GitSnapshot) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GitSnapshot
// only implements ToObjectValue() and Type().
func (m GitSnapshot) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"used_commit": m.UsedCommit,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GitSnapshot) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"used_commit": types.StringType,
		},
	}
}

// An optional specification for a remote Git repository containing the source
// code used by tasks. Version-controlled source code is supported by notebook,
// dbt, Python script, and SQL File tasks.
//
// If `git_source` is set, these tasks retrieve the file from the remote
// repository by default. However, this behavior can be overridden by setting
// `source` to `WORKSPACE` on the task.
//
// Note: dbt and SQL File tasks support only version-controlled sources. If dbt
// or SQL File tasks are used, `git_source` must be defined on the job.
type GitSource struct {
	// Name of the branch to be checked out and used by this job. This field
	// cannot be specified in conjunction with git_tag or git_commit.
	GitBranch types.String `tfsdk:"branch"`
	// Commit to be checked out and used by this job. This field cannot be
	// specified in conjunction with git_branch or git_tag.
	GitCommit types.String `tfsdk:"commit"`
	// Unique identifier of the service used to host the Git repository. The
	// value is case insensitive.
	GitProvider types.String `tfsdk:"provider"`

	GitSnapshot types.Object `tfsdk:"git_snapshot"`
	// Name of the tag to be checked out and used by this job. This field cannot
	// be specified in conjunction with git_branch or git_commit.
	GitTag types.String `tfsdk:"tag"`
	// URL of the repository to be cloned by this job.
	GitUrl types.String `tfsdk:"url"`
	// The source of the job specification in the remote repository when the job
	// is source controlled.
	JobSource types.Object `tfsdk:"job_source"`
}

func (to *GitSource) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from GitSource) {
	if !from.GitSnapshot.IsNull() && !from.GitSnapshot.IsUnknown() {
		if toGitSnapshot, ok := to.GetGitSnapshot(ctx); ok {
			if fromGitSnapshot, ok := from.GetGitSnapshot(ctx); ok {
				// Recursively sync the fields of GitSnapshot
				toGitSnapshot.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSnapshot)
				to.SetGitSnapshot(ctx, toGitSnapshot)
			}
		}
	}
	if !from.JobSource.IsNull() && !from.JobSource.IsUnknown() {
		if toJobSource, ok := to.GetJobSource(ctx); ok {
			if fromJobSource, ok := from.GetJobSource(ctx); ok {
				// Recursively sync the fields of JobSource
				toJobSource.SyncFieldsDuringCreateOrUpdate(ctx, fromJobSource)
				to.SetJobSource(ctx, toJobSource)
			}
		}
	}
}

func (to *GitSource) SyncFieldsDuringRead(ctx context.Context, from GitSource) {
	if !from.GitSnapshot.IsNull() && !from.GitSnapshot.IsUnknown() {
		if toGitSnapshot, ok := to.GetGitSnapshot(ctx); ok {
			if fromGitSnapshot, ok := from.GetGitSnapshot(ctx); ok {
				toGitSnapshot.SyncFieldsDuringRead(ctx, fromGitSnapshot)
				to.SetGitSnapshot(ctx, toGitSnapshot)
			}
		}
	}
	if !from.JobSource.IsNull() && !from.JobSource.IsUnknown() {
		if toJobSource, ok := to.GetJobSource(ctx); ok {
			if fromJobSource, ok := from.GetJobSource(ctx); ok {
				toJobSource.SyncFieldsDuringRead(ctx, fromJobSource)
				to.SetJobSource(ctx, toJobSource)
			}
		}
	}
}

func (m GitSource) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["branch"] = attrs["branch"].SetOptional()
	attrs["commit"] = attrs["commit"].SetOptional()
	attrs["provider"] = attrs["provider"].SetRequired()
	attrs["git_snapshot"] = attrs["git_snapshot"].SetOptional()
	attrs["tag"] = attrs["tag"].SetOptional()
	attrs["url"] = attrs["url"].SetRequired()
	attrs["job_source"] = attrs["job_source"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in GitSource.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m GitSource) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"git_snapshot": reflect.TypeOf(GitSnapshot{}),
		"job_source":   reflect.TypeOf(JobSource{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, GitSource
// only implements ToObjectValue() and Type().
func (m GitSource) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"branch":       m.GitBranch,
			"commit":       m.GitCommit,
			"provider":     m.GitProvider,
			"git_snapshot": m.GitSnapshot,
			"tag":          m.GitTag,
			"url":          m.GitUrl,
			"job_source":   m.JobSource,
		})
}

// Type implements basetypes.ObjectValuable.
func (m GitSource) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"branch":       types.StringType,
			"commit":       types.StringType,
			"provider":     types.StringType,
			"git_snapshot": GitSnapshot{}.Type(ctx),
			"tag":          types.StringType,
			"url":          types.StringType,
			"job_source":   JobSource{}.Type(ctx),
		},
	}
}

// GetGitSnapshot returns the value of the GitSnapshot field in GitSource as
// a GitSnapshot value.
// If the field is unknown or null, the boolean return value is false.
func (m *GitSource) GetGitSnapshot(ctx context.Context) (GitSnapshot, bool) {
	var e GitSnapshot
	if m.GitSnapshot.IsNull() || m.GitSnapshot.IsUnknown() {
		return e, false
	}
	var v GitSnapshot
	d := m.GitSnapshot.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSnapshot sets the value of the GitSnapshot field in GitSource.
func (m *GitSource) SetGitSnapshot(ctx context.Context, v GitSnapshot) {
	vs := v.ToObjectValue(ctx)
	m.GitSnapshot = vs
}

// GetJobSource returns the value of the JobSource field in GitSource as
// a JobSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *GitSource) GetJobSource(ctx context.Context) (JobSource, bool) {
	var e JobSource
	if m.JobSource.IsNull() || m.JobSource.IsUnknown() {
		return e, false
	}
	var v JobSource
	d := m.JobSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobSource sets the value of the JobSource field in GitSource.
func (m *GitSource) SetJobSource(ctx context.Context, v JobSource) {
	vs := v.ToObjectValue(ctx)
	m.JobSource = vs
}

// Job was retrieved successfully.
type Job struct {
	// The time at which this job was created in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC).
	CreatedTime types.Int64 `tfsdk:"created_time"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// The id of the budget policy used by this job for cost attribution
	// purposes. This may be set through (in order of precedence): 1. Budget
	// admins through the account or workspace console 2. Jobs UI in the job
	// details page and Jobs API using `budget_policy_id` 3. Inferred default
	// based on accessible budget policies of the run_as identity on job
	// creation or modification.
	EffectiveBudgetPolicyId types.String `tfsdk:"effective_budget_policy_id"`
	// The id of the usage policy used by this job for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// Indicates if the job has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/get endpoint.
	// It is only relevant for API 2.2 :method:jobs/list requests with
	// `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// The canonical identifier for this job.
	JobId types.Int64 `tfsdk:"job_id"`
	// A token that can be used to list the next page of array properties.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// The email of an active workspace user or the application ID of a service
	// principal that the job runs as. This value can be changed by setting the
	// `run_as` field when creating or updating a job.
	//
	// By default, `run_as_user_name` is based on the current job settings and
	// is set to the creator of the job if job access control is disabled or to
	// the user with the `is_owner` permission if job access control is enabled.
	RunAsUserName types.String `tfsdk:"run_as_user_name"`
	// Settings for this job and all of its runs. These settings can be updated
	// using the `resetJob` method.
	Settings types.Object `tfsdk:"settings"`
	// State of the trigger associated with the job.
	TriggerState types.Object `tfsdk:"trigger_state"`
}

func (to *Job) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Job) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				// Recursively sync the fields of Settings
				toSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				// Recursively sync the fields of TriggerState
				toTriggerState.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (to *Job) SyncFieldsDuringRead(ctx context.Context, from Job) {
	if !from.Settings.IsNull() && !from.Settings.IsUnknown() {
		if toSettings, ok := to.GetSettings(ctx); ok {
			if fromSettings, ok := from.GetSettings(ctx); ok {
				toSettings.SyncFieldsDuringRead(ctx, fromSettings)
				to.SetSettings(ctx, toSettings)
			}
		}
	}
	if !from.TriggerState.IsNull() && !from.TriggerState.IsUnknown() {
		if toTriggerState, ok := to.GetTriggerState(ctx); ok {
			if fromTriggerState, ok := from.GetTriggerState(ctx); ok {
				toTriggerState.SyncFieldsDuringRead(ctx, fromTriggerState)
				to.SetTriggerState(ctx, toTriggerState)
			}
		}
	}
}

func (m Job) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["created_time"] = attrs["created_time"].SetOptional()
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["effective_budget_policy_id"] = attrs["effective_budget_policy_id"].SetComputed()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["run_as_user_name"] = attrs["run_as_user_name"].SetOptional()
	attrs["settings"] = attrs["settings"].SetOptional()
	attrs["trigger_state"] = attrs["trigger_state"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Job.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Job) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"settings":      reflect.TypeOf(JobSettings{}),
		"trigger_state": reflect.TypeOf(TriggerStateProto{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Job
// only implements ToObjectValue() and Type().
func (m Job) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"created_time":               m.CreatedTime,
			"creator_user_name":          m.CreatorUserName,
			"effective_budget_policy_id": m.EffectiveBudgetPolicyId,
			"effective_usage_policy_id":  m.EffectiveUsagePolicyId,
			"has_more":                   m.HasMore,
			"job_id":                     m.JobId,
			"next_page_token":            m.NextPageToken,
			"run_as_user_name":           m.RunAsUserName,
			"settings":                   m.Settings,
			"trigger_state":              m.TriggerState,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Job) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"created_time":               types.Int64Type,
			"creator_user_name":          types.StringType,
			"effective_budget_policy_id": types.StringType,
			"effective_usage_policy_id":  types.StringType,
			"has_more":                   types.BoolType,
			"job_id":                     types.Int64Type,
			"next_page_token":            types.StringType,
			"run_as_user_name":           types.StringType,
			"settings":                   JobSettings{}.Type(ctx),
			"trigger_state":              TriggerStateProto{}.Type(ctx),
		},
	}
}

// GetSettings returns the value of the Settings field in Job as
// a JobSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *Job) GetSettings(ctx context.Context) (JobSettings, bool) {
	var e JobSettings
	if m.Settings.IsNull() || m.Settings.IsUnknown() {
		return e, false
	}
	var v JobSettings
	d := m.Settings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSettings sets the value of the Settings field in Job.
func (m *Job) SetSettings(ctx context.Context, v JobSettings) {
	vs := v.ToObjectValue(ctx)
	m.Settings = vs
}

// GetTriggerState returns the value of the TriggerState field in Job as
// a TriggerStateProto value.
// If the field is unknown or null, the boolean return value is false.
func (m *Job) GetTriggerState(ctx context.Context) (TriggerStateProto, bool) {
	var e TriggerStateProto
	if m.TriggerState.IsNull() || m.TriggerState.IsUnknown() {
		return e, false
	}
	var v TriggerStateProto
	d := m.TriggerState.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTriggerState sets the value of the TriggerState field in Job.
func (m *Job) SetTriggerState(ctx context.Context, v TriggerStateProto) {
	vs := v.ToObjectValue(ctx)
	m.TriggerState = vs
}

type JobAccessControlRequest struct {
	// name of the group
	GroupName types.String `tfsdk:"group_name"`

	PermissionLevel types.String `tfsdk:"permission_level"`
	// application ID of a service principal
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *JobAccessControlRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobAccessControlRequest) {
}

func (to *JobAccessControlRequest) SyncFieldsDuringRead(ctx context.Context, from JobAccessControlRequest) {
}

func (m JobAccessControlRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobAccessControlRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobAccessControlRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobAccessControlRequest
// only implements ToObjectValue() and Type().
func (m JobAccessControlRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"group_name":             m.GroupName,
			"permission_level":       m.PermissionLevel,
			"service_principal_name": m.ServicePrincipalName,
			"user_name":              m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobAccessControlRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"group_name":             types.StringType,
			"permission_level":       types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type JobAccessControlResponse struct {
	// All permissions.
	AllPermissions types.List `tfsdk:"all_permissions"`
	// Display name of the user or service principal.
	DisplayName types.String `tfsdk:"display_name"`
	// name of the group
	GroupName types.String `tfsdk:"group_name"`
	// Name of the service principal.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// name of the user
	UserName types.String `tfsdk:"user_name"`
}

func (to *JobAccessControlResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobAccessControlResponse) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (to *JobAccessControlResponse) SyncFieldsDuringRead(ctx context.Context, from JobAccessControlResponse) {
	if !from.AllPermissions.IsNull() && !from.AllPermissions.IsUnknown() && to.AllPermissions.IsNull() && len(from.AllPermissions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AllPermissions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AllPermissions = from.AllPermissions
	}
}

func (m JobAccessControlResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["all_permissions"] = attrs["all_permissions"].SetOptional()
	attrs["display_name"] = attrs["display_name"].SetOptional()
	attrs["group_name"] = attrs["group_name"].SetOptional()
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobAccessControlResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobAccessControlResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"all_permissions": reflect.TypeOf(JobPermission{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobAccessControlResponse
// only implements ToObjectValue() and Type().
func (m JobAccessControlResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"all_permissions":        m.AllPermissions,
			"display_name":           m.DisplayName,
			"group_name":             m.GroupName,
			"service_principal_name": m.ServicePrincipalName,
			"user_name":              m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobAccessControlResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"all_permissions": basetypes.ListType{
				ElemType: JobPermission{}.Type(ctx),
			},
			"display_name":           types.StringType,
			"group_name":             types.StringType,
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

// GetAllPermissions returns the value of the AllPermissions field in JobAccessControlResponse as
// a slice of JobPermission values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobAccessControlResponse) GetAllPermissions(ctx context.Context) ([]JobPermission, bool) {
	if m.AllPermissions.IsNull() || m.AllPermissions.IsUnknown() {
		return nil, false
	}
	var v []JobPermission
	d := m.AllPermissions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAllPermissions sets the value of the AllPermissions field in JobAccessControlResponse.
func (m *JobAccessControlResponse) SetAllPermissions(ctx context.Context, v []JobPermission) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["all_permissions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AllPermissions = types.ListValueMust(t, vs)
}

type JobCluster struct {
	// A unique name for the job cluster. This field is required and must be
	// unique within the job. `JobTaskSettings` may refer to this field to
	// determine which cluster to launch for the task execution.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// If new_cluster, a description of a cluster that is created for each task.
	NewCluster types.Object `tfsdk:"new_cluster"`
}

func (to *JobCluster) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobCluster) {
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (to *JobCluster) SyncFieldsDuringRead(ctx context.Context, from JobCluster) {
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
}

func (m JobCluster) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetRequired()
	attrs["new_cluster"] = attrs["new_cluster"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobCluster.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobCluster) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"new_cluster": reflect.TypeOf(compute_tf.ClusterSpec{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobCluster
// only implements ToObjectValue() and Type().
func (m JobCluster) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_cluster_key": m.JobClusterKey,
			"new_cluster":     m.NewCluster,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobCluster) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_cluster_key": types.StringType,
			"new_cluster":     compute_tf.ClusterSpec{}.Type(ctx),
		},
	}
}

// GetNewCluster returns the value of the NewCluster field in JobCluster as
// a compute_tf.ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobCluster) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec, bool) {
	var e compute_tf.ClusterSpec
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v compute_tf.ClusterSpec
	d := m.NewCluster.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewCluster sets the value of the NewCluster field in JobCluster.
func (m *JobCluster) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.NewCluster = vs
}

type JobCompliance struct {
	// Whether this job is in compliance with the latest version of its policy.
	IsCompliant types.Bool `tfsdk:"is_compliant"`
	// Canonical unique identifier for a job.
	JobId types.Int64 `tfsdk:"job_id"`
	// An object containing key-value mappings representing the first 200 policy
	// validation errors. The keys indicate the path where the policy validation
	// error is occurring. An identifier for the job cluster is prepended to the
	// path. The values indicate an error message describing the policy
	// validation error.
	Violations types.Map `tfsdk:"violations"`
}

func (to *JobCompliance) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobCompliance) {
}

func (to *JobCompliance) SyncFieldsDuringRead(ctx context.Context, from JobCompliance) {
}

func (m JobCompliance) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["is_compliant"] = attrs["is_compliant"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["violations"] = attrs["violations"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobCompliance.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobCompliance) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"violations": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobCompliance
// only implements ToObjectValue() and Type().
func (m JobCompliance) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"is_compliant": m.IsCompliant,
			"job_id":       m.JobId,
			"violations":   m.Violations,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobCompliance) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"is_compliant": types.BoolType,
			"job_id":       types.Int64Type,
			"violations": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetViolations returns the value of the Violations field in JobCompliance as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobCompliance) GetViolations(ctx context.Context) (map[string]types.String, bool) {
	if m.Violations.IsNull() || m.Violations.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Violations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetViolations sets the value of the Violations field in JobCompliance.
func (m *JobCompliance) SetViolations(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["violations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Violations = types.MapValueMust(t, vs)
}

type JobDeployment struct {
	// The kind of deployment that manages the job.
	//
	// * `BUNDLE`: The job is managed by Databricks Asset Bundle.
	Kind types.String `tfsdk:"kind"`
	// Path of the file that contains deployment metadata.
	MetadataFilePath types.String `tfsdk:"metadata_file_path"`
}

func (to *JobDeployment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobDeployment) {
}

func (to *JobDeployment) SyncFieldsDuringRead(ctx context.Context, from JobDeployment) {
}

func (m JobDeployment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["kind"] = attrs["kind"].SetRequired()
	attrs["metadata_file_path"] = attrs["metadata_file_path"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobDeployment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobDeployment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobDeployment
// only implements ToObjectValue() and Type().
func (m JobDeployment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"kind":               m.Kind,
			"metadata_file_path": m.MetadataFilePath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobDeployment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"kind":               types.StringType,
			"metadata_file_path": types.StringType,
		},
	}
}

type JobEmailNotifications struct {
	// If true, do not send email to recipients specified in `on_failure` if the
	// run is skipped. This field is `deprecated`. Please use the
	// `notification_settings.no_alert_for_skipped_runs` field.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
	// A list of email addresses to be notified when the duration of a run
	// exceeds the threshold specified for the `RUN_DURATION_SECONDS` metric in
	// the `health` field. If no rule for the `RUN_DURATION_SECONDS` metric is
	// specified in the `health` field for the job, notifications are not sent.
	OnDurationWarningThresholdExceeded types.List `tfsdk:"on_duration_warning_threshold_exceeded"`
	// A list of email addresses to be notified when a run unsuccessfully
	// completes. A run is considered to have completed unsuccessfully if it
	// ends with an `INTERNAL_ERROR` `life_cycle_state` or a `FAILED`, or
	// `TIMED_OUT` result_state. If this is not specified on job creation,
	// reset, or update the list is empty, and notifications are not sent.
	OnFailure types.List `tfsdk:"on_failure"`
	// A list of email addresses to be notified when a run begins. If not
	// specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnStart types.List `tfsdk:"on_start"`
	// A list of email addresses to notify when any streaming backlog thresholds
	// are exceeded for any stream. Streaming backlog thresholds can be set in
	// the `health` field using the following metrics:
	// `STREAMING_BACKLOG_BYTES`, `STREAMING_BACKLOG_RECORDS`,
	// `STREAMING_BACKLOG_SECONDS`, or `STREAMING_BACKLOG_FILES`. Alerting is
	// based on the 10-minute average of these metrics. If the issue persists,
	// notifications are resent every 30 minutes.
	OnStreamingBacklogExceeded types.List `tfsdk:"on_streaming_backlog_exceeded"`
	// A list of email addresses to be notified when a run successfully
	// completes. A run is considered to have completed successfully if it ends
	// with a `TERMINATED` `life_cycle_state` and a `SUCCESS` result_state. If
	// not specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnSuccess types.List `tfsdk:"on_success"`
}

func (to *JobEmailNotifications) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobEmailNotifications) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (to *JobEmailNotifications) SyncFieldsDuringRead(ctx context.Context, from JobEmailNotifications) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (m JobEmailNotifications) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()
	attrs["on_duration_warning_threshold_exceeded"] = attrs["on_duration_warning_threshold_exceeded"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_start"] = attrs["on_start"].SetOptional()
	attrs["on_streaming_backlog_exceeded"] = attrs["on_streaming_backlog_exceeded"].SetOptional()
	attrs["on_success"] = attrs["on_success"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobEmailNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobEmailNotifications) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_duration_warning_threshold_exceeded": reflect.TypeOf(types.String{}),
		"on_failure":                             reflect.TypeOf(types.String{}),
		"on_start":                               reflect.TypeOf(types.String{}),
		"on_streaming_backlog_exceeded":          reflect.TypeOf(types.String{}),
		"on_success":                             reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobEmailNotifications
// only implements ToObjectValue() and Type().
func (m JobEmailNotifications) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"no_alert_for_skipped_runs":              m.NoAlertForSkippedRuns,
			"on_duration_warning_threshold_exceeded": m.OnDurationWarningThresholdExceeded,
			"on_failure":                             m.OnFailure,
			"on_start":                               m.OnStart,
			"on_streaming_backlog_exceeded":          m.OnStreamingBacklogExceeded,
			"on_success":                             m.OnSuccess,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobEmailNotifications) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"no_alert_for_skipped_runs": types.BoolType,
			"on_duration_warning_threshold_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_failure": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_start": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_streaming_backlog_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_success": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOnDurationWarningThresholdExceeded returns the value of the OnDurationWarningThresholdExceeded field in JobEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications) GetOnDurationWarningThresholdExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnDurationWarningThresholdExceeded.IsNull() || m.OnDurationWarningThresholdExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnDurationWarningThresholdExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnDurationWarningThresholdExceeded sets the value of the OnDurationWarningThresholdExceeded field in JobEmailNotifications.
func (m *JobEmailNotifications) SetOnDurationWarningThresholdExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_duration_warning_threshold_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnDurationWarningThresholdExceeded = types.ListValueMust(t, vs)
}

// GetOnFailure returns the value of the OnFailure field in JobEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications) GetOnFailure(ctx context.Context) ([]types.String, bool) {
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in JobEmailNotifications.
func (m *JobEmailNotifications) SetOnFailure(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnStart returns the value of the OnStart field in JobEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications) GetOnStart(ctx context.Context) ([]types.String, bool) {
	if m.OnStart.IsNull() || m.OnStart.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStart.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStart sets the value of the OnStart field in JobEmailNotifications.
func (m *JobEmailNotifications) SetOnStart(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_start"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStart = types.ListValueMust(t, vs)
}

// GetOnStreamingBacklogExceeded returns the value of the OnStreamingBacklogExceeded field in JobEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications) GetOnStreamingBacklogExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnStreamingBacklogExceeded.IsNull() || m.OnStreamingBacklogExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStreamingBacklogExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStreamingBacklogExceeded sets the value of the OnStreamingBacklogExceeded field in JobEmailNotifications.
func (m *JobEmailNotifications) SetOnStreamingBacklogExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_streaming_backlog_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStreamingBacklogExceeded = types.ListValueMust(t, vs)
}

// GetOnSuccess returns the value of the OnSuccess field in JobEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEmailNotifications) GetOnSuccess(ctx context.Context) ([]types.String, bool) {
	if m.OnSuccess.IsNull() || m.OnSuccess.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnSuccess.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnSuccess sets the value of the OnSuccess field in JobEmailNotifications.
func (m *JobEmailNotifications) SetOnSuccess(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_success"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnSuccess = types.ListValueMust(t, vs)
}

type JobEnvironment struct {
	// The key of an environment. It has to be unique within a job.
	EnvironmentKey types.String `tfsdk:"environment_key"`

	Spec types.Object `tfsdk:"spec"`
}

func (to *JobEnvironment) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobEnvironment) {
	if !from.Spec.IsNull() && !from.Spec.IsUnknown() {
		if toSpec, ok := to.GetSpec(ctx); ok {
			if fromSpec, ok := from.GetSpec(ctx); ok {
				// Recursively sync the fields of Spec
				toSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromSpec)
				to.SetSpec(ctx, toSpec)
			}
		}
	}
}

func (to *JobEnvironment) SyncFieldsDuringRead(ctx context.Context, from JobEnvironment) {
	if !from.Spec.IsNull() && !from.Spec.IsUnknown() {
		if toSpec, ok := to.GetSpec(ctx); ok {
			if fromSpec, ok := from.GetSpec(ctx); ok {
				toSpec.SyncFieldsDuringRead(ctx, fromSpec)
				to.SetSpec(ctx, toSpec)
			}
		}
	}
}

func (m JobEnvironment) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["environment_key"] = attrs["environment_key"].SetRequired()
	attrs["spec"] = attrs["spec"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobEnvironment.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobEnvironment) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"spec": reflect.TypeOf(compute_tf.Environment{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobEnvironment
// only implements ToObjectValue() and Type().
func (m JobEnvironment) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"environment_key": m.EnvironmentKey,
			"spec":            m.Spec,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobEnvironment) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"environment_key": types.StringType,
			"spec":            compute_tf.Environment{}.Type(ctx),
		},
	}
}

// GetSpec returns the value of the Spec field in JobEnvironment as
// a compute_tf.Environment value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobEnvironment) GetSpec(ctx context.Context) (compute_tf.Environment, bool) {
	var e compute_tf.Environment
	if m.Spec.IsNull() || m.Spec.IsUnknown() {
		return e, false
	}
	var v compute_tf.Environment
	d := m.Spec.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSpec sets the value of the Spec field in JobEnvironment.
func (m *JobEnvironment) SetSpec(ctx context.Context, v compute_tf.Environment) {
	vs := v.ToObjectValue(ctx)
	m.Spec = vs
}

type JobNotificationSettings struct {
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is canceled.
	NoAlertForCanceledRuns types.Bool `tfsdk:"no_alert_for_canceled_runs"`
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is skipped.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
}

func (to *JobNotificationSettings) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobNotificationSettings) {
}

func (to *JobNotificationSettings) SyncFieldsDuringRead(ctx context.Context, from JobNotificationSettings) {
}

func (m JobNotificationSettings) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["no_alert_for_canceled_runs"] = attrs["no_alert_for_canceled_runs"].SetOptional()
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobNotificationSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobNotificationSettings) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobNotificationSettings
// only implements ToObjectValue() and Type().
func (m JobNotificationSettings) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"no_alert_for_canceled_runs": m.NoAlertForCanceledRuns,
			"no_alert_for_skipped_runs":  m.NoAlertForSkippedRuns,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobNotificationSettings) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"no_alert_for_canceled_runs": types.BoolType,
			"no_alert_for_skipped_runs":  types.BoolType,
		},
	}
}

type JobParameter struct {
	// The optional default value of the parameter
	Default types.String `tfsdk:"default"`
	// The name of the parameter
	Name types.String `tfsdk:"name"`
	// The value used in the run
	Value types.String `tfsdk:"value"`
}

func (to *JobParameter) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobParameter) {
}

func (to *JobParameter) SyncFieldsDuringRead(ctx context.Context, from JobParameter) {
}

func (m JobParameter) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default"] = attrs["default"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["value"] = attrs["value"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobParameter.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobParameter) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobParameter
// only implements ToObjectValue() and Type().
func (m JobParameter) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default": m.Default,
			"name":    m.Name,
			"value":   m.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobParameter) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default": types.StringType,
			"name":    types.StringType,
			"value":   types.StringType,
		},
	}
}

type JobParameterDefinition struct {
	// Default value of the parameter.
	Default types.String `tfsdk:"default"`
	// The name of the defined parameter. May only contain alphanumeric
	// characters, `_`, `-`, and `.`
	Name types.String `tfsdk:"name"`
}

func (to *JobParameterDefinition) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobParameterDefinition) {
}

func (to *JobParameterDefinition) SyncFieldsDuringRead(ctx context.Context, from JobParameterDefinition) {
}

func (m JobParameterDefinition) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["default"] = attrs["default"].SetRequired()
	attrs["name"] = attrs["name"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobParameterDefinition.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobParameterDefinition) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobParameterDefinition
// only implements ToObjectValue() and Type().
func (m JobParameterDefinition) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"default": m.Default,
			"name":    m.Name,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobParameterDefinition) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"default": types.StringType,
			"name":    types.StringType,
		},
	}
}

type JobPermission struct {
	Inherited types.Bool `tfsdk:"inherited"`

	InheritedFromObject types.List `tfsdk:"inherited_from_object"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *JobPermission) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermission) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (to *JobPermission) SyncFieldsDuringRead(ctx context.Context, from JobPermission) {
	if !from.InheritedFromObject.IsNull() && !from.InheritedFromObject.IsUnknown() && to.InheritedFromObject.IsNull() && len(from.InheritedFromObject.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for InheritedFromObject, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.InheritedFromObject = from.InheritedFromObject
	}
}

func (m JobPermission) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["inherited"] = attrs["inherited"].SetOptional()
	attrs["inherited_from_object"] = attrs["inherited_from_object"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermission.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermission) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"inherited_from_object": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermission
// only implements ToObjectValue() and Type().
func (m JobPermission) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"inherited":             m.Inherited,
			"inherited_from_object": m.InheritedFromObject,
			"permission_level":      m.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermission) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"inherited": types.BoolType,
			"inherited_from_object": basetypes.ListType{
				ElemType: types.StringType,
			},
			"permission_level": types.StringType,
		},
	}
}

// GetInheritedFromObject returns the value of the InheritedFromObject field in JobPermission as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobPermission) GetInheritedFromObject(ctx context.Context) ([]types.String, bool) {
	if m.InheritedFromObject.IsNull() || m.InheritedFromObject.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.InheritedFromObject.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetInheritedFromObject sets the value of the InheritedFromObject field in JobPermission.
func (m *JobPermission) SetInheritedFromObject(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["inherited_from_object"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.InheritedFromObject = types.ListValueMust(t, vs)
}

type JobPermissions struct {
	AccessControlList types.List `tfsdk:"access_control_list"`

	ObjectId types.String `tfsdk:"object_id"`

	ObjectType types.String `tfsdk:"object_type"`
}

func (to *JobPermissions) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *JobPermissions) SyncFieldsDuringRead(ctx context.Context, from JobPermissions) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (m JobPermissions) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["object_id"] = attrs["object_id"].SetOptional()
	attrs["object_type"] = attrs["object_type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermissions.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermissions) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(JobAccessControlResponse{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermissions
// only implements ToObjectValue() and Type().
func (m JobPermissions) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": m.AccessControlList,
			"object_id":           m.ObjectId,
			"object_type":         m.ObjectType,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermissions) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlResponse{}.Type(ctx),
			},
			"object_id":   types.StringType,
			"object_type": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in JobPermissions as
// a slice of JobAccessControlResponse values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobPermissions) GetAccessControlList(ctx context.Context) ([]JobAccessControlResponse, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlResponse
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in JobPermissions.
func (m *JobPermissions) SetAccessControlList(ctx context.Context, v []JobAccessControlResponse) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

type JobPermissionsDescription struct {
	Description types.String `tfsdk:"description"`

	PermissionLevel types.String `tfsdk:"permission_level"`
}

func (to *JobPermissionsDescription) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermissionsDescription) {
}

func (to *JobPermissionsDescription) SyncFieldsDuringRead(ctx context.Context, from JobPermissionsDescription) {
}

func (m JobPermissionsDescription) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["description"] = attrs["description"].SetOptional()
	attrs["permission_level"] = attrs["permission_level"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermissionsDescription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermissionsDescription) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermissionsDescription
// only implements ToObjectValue() and Type().
func (m JobPermissionsDescription) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"description":      m.Description,
			"permission_level": m.PermissionLevel,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermissionsDescription) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"description":      types.StringType,
			"permission_level": types.StringType,
		},
	}
}

type JobPermissionsRequest struct {
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The job for which to get or manage permissions.
	JobId types.String `tfsdk:"-"`
}

func (to *JobPermissionsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobPermissionsRequest) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (to *JobPermissionsRequest) SyncFieldsDuringRead(ctx context.Context, from JobPermissionsRequest) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
}

func (m JobPermissionsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobPermissionsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobPermissionsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list": reflect.TypeOf(JobAccessControlRequest{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobPermissionsRequest
// only implements ToObjectValue() and Type().
func (m JobPermissionsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list": m.AccessControlList,
			"job_id":              m.JobId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobPermissionsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlRequest{}.Type(ctx),
			},
			"job_id": types.StringType,
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in JobPermissionsRequest as
// a slice of JobAccessControlRequest values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobPermissionsRequest) GetAccessControlList(ctx context.Context) ([]JobAccessControlRequest, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlRequest
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in JobPermissionsRequest.
func (m *JobPermissionsRequest) SetAccessControlList(ctx context.Context, v []JobAccessControlRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

// Write-only setting. Specifies the user or service principal that the job runs
// as. If not specified, the job runs as the user who created the job.
//
// Either `user_name` or `service_principal_name` should be specified. If not,
// an error is thrown.
type JobRunAs struct {
	// Application ID of an active service principal. Setting this field
	// requires the `servicePrincipal/user` role.
	ServicePrincipalName types.String `tfsdk:"service_principal_name"`
	// The email of an active workspace user. Non-admin users can only set this
	// field to their own email.
	UserName types.String `tfsdk:"user_name"`
}

func (to *JobRunAs) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobRunAs) {
}

func (to *JobRunAs) SyncFieldsDuringRead(ctx context.Context, from JobRunAs) {
}

func (m JobRunAs) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["service_principal_name"] = attrs["service_principal_name"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobRunAs.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobRunAs) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobRunAs
// only implements ToObjectValue() and Type().
func (m JobRunAs) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"service_principal_name": m.ServicePrincipalName,
			"user_name":              m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobRunAs) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"service_principal_name": types.StringType,
			"user_name":              types.StringType,
		},
	}
}

type JobSettings struct {
	// The id of the user specified budget policy to use for this job. If not
	// specified, a default budget policy may be applied when creating or
	// modifying the job. See `effective_budget_policy_id` for the budget policy
	// used by this workload.
	BudgetPolicyId types.String `tfsdk:"budget_policy_id"`
	// An optional continuous property for this job. The continuous property
	// will ensure that there is always one run executing. Only one of
	// `schedule` and `continuous` can be used.
	Continuous types.Object `tfsdk:"continuous"`
	// Deployment information for jobs managed by external sources.
	Deployment types.Object `tfsdk:"deployment"`
	// An optional description for the job. The maximum length is 27700
	// characters in UTF-8 encoding.
	Description types.String `tfsdk:"description"`
	// Edit mode of the job.
	//
	// * `UI_LOCKED`: The job is in a locked UI state and cannot be modified. *
	// `EDITABLE`: The job is in an editable state and can be modified.
	EditMode types.String `tfsdk:"edit_mode"`
	// An optional set of email addresses that is notified when runs of this job
	// begin or complete as well as when this job is deleted.
	EmailNotifications types.Object `tfsdk:"email_notifications"`
	// A list of task execution environment specifications that can be
	// referenced by serverless tasks of this job. An environment is required to
	// be present for serverless tasks. For serverless notebook tasks, the
	// environment is accessible in the notebook environment panel. For other
	// serverless tasks, the task environment is required to be specified using
	// environment_key in the task settings.
	Environments types.List `tfsdk:"environment"`
	// Used to tell what is the format of the job. This field is ignored in
	// Create/Update/Reset calls. When using the Jobs API 2.1 this value is
	// always set to `"MULTI_TASK"`.
	Format types.String `tfsdk:"format"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.Object `tfsdk:"git_source"`

	Health types.Object `tfsdk:"health"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings.
	JobClusters types.List `tfsdk:"job_cluster"`
	// An optional maximum allowed number of concurrent runs of the job. Set
	// this value if you want to be able to execute multiple runs of the same
	// job concurrently. This is useful for example if you trigger your job on a
	// frequent schedule and want to allow consecutive runs to overlap with each
	// other, or if you want to trigger multiple runs which differ by their
	// input parameters. This setting affects only new runs. For example,
	// suppose the job’s concurrency is 4 and there are 4 concurrent active
	// runs. Then setting the concurrency to 3 won’t kill any of the active
	// runs. However, from then on, new runs are skipped unless there are fewer
	// than 3 active runs. This value cannot exceed 1000. Setting this value to
	// `0` causes all new runs to be skipped.
	MaxConcurrentRuns types.Int64 `tfsdk:"max_concurrent_runs"`
	// An optional name for the job. The maximum length is 4096 bytes in UTF-8
	// encoding.
	Name types.String `tfsdk:"name"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// job.
	NotificationSettings types.Object `tfsdk:"notification_settings"`
	// Job-level parameter definitions
	Parameters types.List `tfsdk:"parameter"`
	// The performance mode on a serverless job. This field determines the level
	// of compute performance or cost-efficiency for the run.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// The queue settings of the job.
	Queue types.Object `tfsdk:"queue"`
	// The user or service principal that the job runs as, if specified in the
	// request. This field indicates the explicit configuration of `run_as` for
	// the job. To find the value in all cases, explicit or implicit, use
	// `run_as_user_name`.
	RunAs types.Object `tfsdk:"run_as"`
	// An optional periodic schedule for this job. The default behavior is that
	// the job only runs when triggered by clicking “Run Now” in the Jobs UI
	// or sending an API request to `runNow`.
	Schedule types.Object `tfsdk:"schedule"`
	// A map of tags associated with the job. These are forwarded to the cluster
	// as cluster tags for jobs clusters, and are subject to the same
	// limitations as cluster tags. A maximum of 25 tags can be added to the
	// job.
	Tags types.Map `tfsdk:"tags"`
	// A list of task specifications to be executed by this job. It supports up
	// to 1000 elements in write endpoints (:method:jobs/create,
	// :method:jobs/reset, :method:jobs/update, :method:jobs/submit). Read
	// endpoints return only 100 tasks. If more than 100 tasks are available,
	// you can paginate through them using :method:jobs/get. Use the
	// `next_page_token` field at the object root to determine if more results
	// are available.
	Tasks types.List `tfsdk:"task"`
	// An optional timeout applied to each run of this job. A value of `0` means
	// no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A configuration to trigger a run when certain conditions are met. The
	// default behavior is that the job runs only when triggered by clicking
	// “Run Now” in the Jobs UI or sending an API request to `runNow`.
	Trigger types.Object `tfsdk:"trigger"`
	// The id of the user specified usage policy to use for this job. If not
	// specified, a default usage policy may be applied when creating or
	// modifying the job. See `effective_usage_policy_id` for the usage policy
	// used by this workload.
	UsagePolicyId types.String `tfsdk:"usage_policy_id"`
	// A collection of system notification IDs to notify when runs of this job
	// begin or complete.
	WebhookNotifications types.Object `tfsdk:"webhook_notifications"`
}

func (to *JobSettings) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobSettings) {
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				// Recursively sync the fields of Continuous
				toContinuous.SyncFieldsDuringCreateOrUpdate(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				// Recursively sync the fields of Deployment
				toDeployment.SyncFieldsDuringCreateOrUpdate(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				// Recursively sync the fields of RunAs
				toRunAs.SyncFieldsDuringCreateOrUpdate(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				// Recursively sync the fields of Trigger
				toTrigger.SyncFieldsDuringCreateOrUpdate(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *JobSettings) SyncFieldsDuringRead(ctx context.Context, from JobSettings) {
	if !from.Continuous.IsNull() && !from.Continuous.IsUnknown() {
		if toContinuous, ok := to.GetContinuous(ctx); ok {
			if fromContinuous, ok := from.GetContinuous(ctx); ok {
				toContinuous.SyncFieldsDuringRead(ctx, fromContinuous)
				to.SetContinuous(ctx, toContinuous)
			}
		}
	}
	if !from.Deployment.IsNull() && !from.Deployment.IsUnknown() {
		if toDeployment, ok := to.GetDeployment(ctx); ok {
			if fromDeployment, ok := from.GetDeployment(ctx); ok {
				toDeployment.SyncFieldsDuringRead(ctx, fromDeployment)
				to.SetDeployment(ctx, toDeployment)
			}
		}
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				toRunAs.SyncFieldsDuringRead(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.Trigger.IsNull() && !from.Trigger.IsUnknown() {
		if toTrigger, ok := to.GetTrigger(ctx); ok {
			if fromTrigger, ok := from.GetTrigger(ctx); ok {
				toTrigger.SyncFieldsDuringRead(ctx, fromTrigger)
				to.SetTrigger(ctx, toTrigger)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m JobSettings) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetOptional()
	attrs["continuous"] = attrs["continuous"].SetOptional()
	attrs["deployment"] = attrs["deployment"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["edit_mode"] = attrs["edit_mode"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["environment"] = attrs["environment"].SetOptional()
	attrs["format"] = attrs["format"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["health"] = attrs["health"].SetOptional()
	attrs["job_cluster"] = attrs["job_cluster"].SetOptional()
	attrs["max_concurrent_runs"] = attrs["max_concurrent_runs"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["parameter"] = attrs["parameter"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["run_as"] = attrs["run_as"].SetOptional()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["tags"] = attrs["tags"].SetOptional()
	attrs["task"] = attrs["task"].SetOptional()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobSettings) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"continuous":            reflect.TypeOf(Continuous{}),
		"deployment":            reflect.TypeOf(JobDeployment{}),
		"email_notifications":   reflect.TypeOf(JobEmailNotifications{}),
		"environment":           reflect.TypeOf(JobEnvironment{}),
		"git_source":            reflect.TypeOf(GitSource{}),
		"health":                reflect.TypeOf(JobsHealthRules{}),
		"job_cluster":           reflect.TypeOf(JobCluster{}),
		"notification_settings": reflect.TypeOf(JobNotificationSettings{}),
		"parameter":             reflect.TypeOf(JobParameterDefinition{}),
		"queue":                 reflect.TypeOf(QueueSettings{}),
		"run_as":                reflect.TypeOf(JobRunAs{}),
		"schedule":              reflect.TypeOf(CronSchedule{}),
		"tags":                  reflect.TypeOf(types.String{}),
		"task":                  reflect.TypeOf(Task{}),
		"trigger":               reflect.TypeOf(TriggerSettings{}),
		"webhook_notifications": reflect.TypeOf(WebhookNotifications{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobSettings
// only implements ToObjectValue() and Type().
func (m JobSettings) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"budget_policy_id":      m.BudgetPolicyId,
			"continuous":            m.Continuous,
			"deployment":            m.Deployment,
			"description":           m.Description,
			"edit_mode":             m.EditMode,
			"email_notifications":   m.EmailNotifications,
			"environment":           m.Environments,
			"format":                m.Format,
			"git_source":            m.GitSource,
			"health":                m.Health,
			"job_cluster":           m.JobClusters,
			"max_concurrent_runs":   m.MaxConcurrentRuns,
			"name":                  m.Name,
			"notification_settings": m.NotificationSettings,
			"parameter":             m.Parameters,
			"performance_target":    m.PerformanceTarget,
			"queue":                 m.Queue,
			"run_as":                m.RunAs,
			"schedule":              m.Schedule,
			"tags":                  m.Tags,
			"task":                  m.Tasks,
			"timeout_seconds":       m.TimeoutSeconds,
			"trigger":               m.Trigger,
			"usage_policy_id":       m.UsagePolicyId,
			"webhook_notifications": m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobSettings) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"budget_policy_id":    types.StringType,
			"continuous":          Continuous{}.Type(ctx),
			"deployment":          JobDeployment{}.Type(ctx),
			"description":         types.StringType,
			"edit_mode":           types.StringType,
			"email_notifications": JobEmailNotifications{}.Type(ctx),
			"environment": basetypes.ListType{
				ElemType: JobEnvironment{}.Type(ctx),
			},
			"format":     types.StringType,
			"git_source": GitSource{}.Type(ctx),
			"health":     JobsHealthRules{}.Type(ctx),
			"job_cluster": basetypes.ListType{
				ElemType: JobCluster{}.Type(ctx),
			},
			"max_concurrent_runs":   types.Int64Type,
			"name":                  types.StringType,
			"notification_settings": JobNotificationSettings{}.Type(ctx),
			"parameter": basetypes.ListType{
				ElemType: JobParameterDefinition{}.Type(ctx),
			},
			"performance_target": types.StringType,
			"queue":              QueueSettings{}.Type(ctx),
			"run_as":             JobRunAs{}.Type(ctx),
			"schedule":           CronSchedule{}.Type(ctx),
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"task": basetypes.ListType{
				ElemType: Task{}.Type(ctx),
			},
			"timeout_seconds":       types.Int64Type,
			"trigger":               TriggerSettings{}.Type(ctx),
			"usage_policy_id":       types.StringType,
			"webhook_notifications": WebhookNotifications{}.Type(ctx),
		},
	}
}

// GetContinuous returns the value of the Continuous field in JobSettings as
// a Continuous value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetContinuous(ctx context.Context) (Continuous, bool) {
	var e Continuous
	if m.Continuous.IsNull() || m.Continuous.IsUnknown() {
		return e, false
	}
	var v Continuous
	d := m.Continuous.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetContinuous sets the value of the Continuous field in JobSettings.
func (m *JobSettings) SetContinuous(ctx context.Context, v Continuous) {
	vs := v.ToObjectValue(ctx)
	m.Continuous = vs
}

// GetDeployment returns the value of the Deployment field in JobSettings as
// a JobDeployment value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetDeployment(ctx context.Context) (JobDeployment, bool) {
	var e JobDeployment
	if m.Deployment.IsNull() || m.Deployment.IsUnknown() {
		return e, false
	}
	var v JobDeployment
	d := m.Deployment.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDeployment sets the value of the Deployment field in JobSettings.
func (m *JobSettings) SetDeployment(ctx context.Context, v JobDeployment) {
	vs := v.ToObjectValue(ctx)
	m.Deployment = vs
}

// GetEmailNotifications returns the value of the EmailNotifications field in JobSettings as
// a JobEmailNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetEmailNotifications(ctx context.Context) (JobEmailNotifications, bool) {
	var e JobEmailNotifications
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v JobEmailNotifications
	d := m.EmailNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailNotifications sets the value of the EmailNotifications field in JobSettings.
func (m *JobSettings) SetEmailNotifications(ctx context.Context, v JobEmailNotifications) {
	vs := v.ToObjectValue(ctx)
	m.EmailNotifications = vs
}

// GetEnvironments returns the value of the Environments field in JobSettings as
// a slice of JobEnvironment values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetEnvironments(ctx context.Context) ([]JobEnvironment, bool) {
	if m.Environments.IsNull() || m.Environments.IsUnknown() {
		return nil, false
	}
	var v []JobEnvironment
	d := m.Environments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEnvironments sets the value of the Environments field in JobSettings.
func (m *JobSettings) SetEnvironments(ctx context.Context, v []JobEnvironment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["environment"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Environments = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in JobSettings as
// a GitSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetGitSource(ctx context.Context) (GitSource, bool) {
	var e GitSource
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v GitSource
	d := m.GitSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSource sets the value of the GitSource field in JobSettings.
func (m *JobSettings) SetGitSource(ctx context.Context, v GitSource) {
	vs := v.ToObjectValue(ctx)
	m.GitSource = vs
}

// GetHealth returns the value of the Health field in JobSettings as
// a JobsHealthRules value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetHealth(ctx context.Context) (JobsHealthRules, bool) {
	var e JobsHealthRules
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v JobsHealthRules
	d := m.Health.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetHealth sets the value of the Health field in JobSettings.
func (m *JobSettings) SetHealth(ctx context.Context, v JobsHealthRules) {
	vs := v.ToObjectValue(ctx)
	m.Health = vs
}

// GetJobClusters returns the value of the JobClusters field in JobSettings as
// a slice of JobCluster values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetJobClusters(ctx context.Context) ([]JobCluster, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in JobSettings.
func (m *JobSettings) SetJobClusters(ctx context.Context, v []JobCluster) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_cluster"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetNotificationSettings returns the value of the NotificationSettings field in JobSettings as
// a JobNotificationSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetNotificationSettings(ctx context.Context) (JobNotificationSettings, bool) {
	var e JobNotificationSettings
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v JobNotificationSettings
	d := m.NotificationSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotificationSettings sets the value of the NotificationSettings field in JobSettings.
func (m *JobSettings) SetNotificationSettings(ctx context.Context, v JobNotificationSettings) {
	vs := v.ToObjectValue(ctx)
	m.NotificationSettings = vs
}

// GetParameters returns the value of the Parameters field in JobSettings as
// a slice of JobParameterDefinition values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetParameters(ctx context.Context) ([]JobParameterDefinition, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameterDefinition
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in JobSettings.
func (m *JobSettings) SetParameters(ctx context.Context, v []JobParameterDefinition) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameter"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in JobSettings as
// a QueueSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetQueue(ctx context.Context) (QueueSettings, bool) {
	var e QueueSettings
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v QueueSettings
	d := m.Queue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueue sets the value of the Queue field in JobSettings.
func (m *JobSettings) SetQueue(ctx context.Context, v QueueSettings) {
	vs := v.ToObjectValue(ctx)
	m.Queue = vs
}

// GetRunAs returns the value of the RunAs field in JobSettings as
// a JobRunAs value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetRunAs(ctx context.Context) (JobRunAs, bool) {
	var e JobRunAs
	if m.RunAs.IsNull() || m.RunAs.IsUnknown() {
		return e, false
	}
	var v JobRunAs
	d := m.RunAs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunAs sets the value of the RunAs field in JobSettings.
func (m *JobSettings) SetRunAs(ctx context.Context, v JobRunAs) {
	vs := v.ToObjectValue(ctx)
	m.RunAs = vs
}

// GetSchedule returns the value of the Schedule field in JobSettings as
// a CronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetSchedule(ctx context.Context) (CronSchedule, bool) {
	var e CronSchedule
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v CronSchedule
	d := m.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in JobSettings.
func (m *JobSettings) SetSchedule(ctx context.Context, v CronSchedule) {
	vs := v.ToObjectValue(ctx)
	m.Schedule = vs
}

// GetTags returns the value of the Tags field in JobSettings as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetTags(ctx context.Context) (map[string]types.String, bool) {
	if m.Tags.IsNull() || m.Tags.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Tags.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTags sets the value of the Tags field in JobSettings.
func (m *JobSettings) SetTags(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tags"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tags = types.MapValueMust(t, vs)
}

// GetTasks returns the value of the Tasks field in JobSettings as
// a slice of Task values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetTasks(ctx context.Context) ([]Task, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []Task
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in JobSettings.
func (m *JobSettings) SetTasks(ctx context.Context, v []Task) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTrigger returns the value of the Trigger field in JobSettings as
// a TriggerSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetTrigger(ctx context.Context) (TriggerSettings, bool) {
	var e TriggerSettings
	if m.Trigger.IsNull() || m.Trigger.IsUnknown() {
		return e, false
	}
	var v TriggerSettings
	d := m.Trigger.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTrigger sets the value of the Trigger field in JobSettings.
func (m *JobSettings) SetTrigger(ctx context.Context, v TriggerSettings) {
	vs := v.ToObjectValue(ctx)
	m.Trigger = vs
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in JobSettings as
// a WebhookNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *JobSettings) GetWebhookNotifications(ctx context.Context) (WebhookNotifications, bool) {
	var e WebhookNotifications
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v WebhookNotifications
	d := m.WebhookNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in JobSettings.
func (m *JobSettings) SetWebhookNotifications(ctx context.Context, v WebhookNotifications) {
	vs := v.ToObjectValue(ctx)
	m.WebhookNotifications = vs
}

// The source of the job specification in the remote repository when the job is
// source controlled.
type JobSource struct {
	// Dirty state indicates the job is not fully synced with the job
	// specification in the remote repository.
	//
	// Possible values are: * `NOT_SYNCED`: The job is not yet synced with the
	// remote job specification. Import the remote job specification from UI to
	// make the job fully synced. * `DISCONNECTED`: The job is temporary
	// disconnected from the remote job specification and is allowed for live
	// edit. Import the remote job specification again from UI to make the job
	// fully synced.
	DirtyState types.String `tfsdk:"dirty_state"`
	// Name of the branch which the job is imported from.
	ImportFromGitBranch types.String `tfsdk:"import_from_git_branch"`
	// Path of the job YAML file that contains the job specification.
	JobConfigPath types.String `tfsdk:"job_config_path"`
}

func (to *JobSource) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobSource) {
}

func (to *JobSource) SyncFieldsDuringRead(ctx context.Context, from JobSource) {
}

func (m JobSource) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dirty_state"] = attrs["dirty_state"].SetOptional()
	attrs["import_from_git_branch"] = attrs["import_from_git_branch"].SetRequired()
	attrs["job_config_path"] = attrs["job_config_path"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobSource.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobSource) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobSource
// only implements ToObjectValue() and Type().
func (m JobSource) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dirty_state":            m.DirtyState,
			"import_from_git_branch": m.ImportFromGitBranch,
			"job_config_path":        m.JobConfigPath,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobSource) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dirty_state":            types.StringType,
			"import_from_git_branch": types.StringType,
			"job_config_path":        types.StringType,
		},
	}
}

type JobsHealthRule struct {
	Metric types.String `tfsdk:"metric"`

	Op types.String `tfsdk:"op"`
	// Specifies the threshold value that the health metric should obey to
	// satisfy the health rule.
	Value types.Int64 `tfsdk:"value"`
}

func (to *JobsHealthRule) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobsHealthRule) {
}

func (to *JobsHealthRule) SyncFieldsDuringRead(ctx context.Context, from JobsHealthRule) {
}

func (m JobsHealthRule) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["metric"] = attrs["metric"].SetRequired()
	attrs["op"] = attrs["op"].SetRequired()
	attrs["value"] = attrs["value"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobsHealthRule.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobsHealthRule) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobsHealthRule
// only implements ToObjectValue() and Type().
func (m JobsHealthRule) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"metric": m.Metric,
			"op":     m.Op,
			"value":  m.Value,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobsHealthRule) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"metric": types.StringType,
			"op":     types.StringType,
			"value":  types.Int64Type,
		},
	}
}

// An optional set of health rules that can be defined for this job.
type JobsHealthRules struct {
	Rules types.List `tfsdk:"rules"`
}

func (to *JobsHealthRules) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from JobsHealthRules) {
	if !from.Rules.IsNull() && !from.Rules.IsUnknown() && to.Rules.IsNull() && len(from.Rules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Rules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Rules = from.Rules
	}
}

func (to *JobsHealthRules) SyncFieldsDuringRead(ctx context.Context, from JobsHealthRules) {
	if !from.Rules.IsNull() && !from.Rules.IsUnknown() && to.Rules.IsNull() && len(from.Rules.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Rules, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Rules = from.Rules
	}
}

func (m JobsHealthRules) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["rules"] = attrs["rules"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in JobsHealthRules.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m JobsHealthRules) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"rules": reflect.TypeOf(JobsHealthRule{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, JobsHealthRules
// only implements ToObjectValue() and Type().
func (m JobsHealthRules) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"rules": m.Rules,
		})
}

// Type implements basetypes.ObjectValuable.
func (m JobsHealthRules) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"rules": basetypes.ListType{
				ElemType: JobsHealthRule{}.Type(ctx),
			},
		},
	}
}

// GetRules returns the value of the Rules field in JobsHealthRules as
// a slice of JobsHealthRule values.
// If the field is unknown or null, the boolean return value is false.
func (m *JobsHealthRules) GetRules(ctx context.Context) ([]JobsHealthRule, bool) {
	if m.Rules.IsNull() || m.Rules.IsUnknown() {
		return nil, false
	}
	var v []JobsHealthRule
	d := m.Rules.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRules sets the value of the Rules field in JobsHealthRules.
func (m *JobsHealthRules) SetRules(ctx context.Context, v []JobsHealthRule) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["rules"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Rules = types.ListValueMust(t, vs)
}

type ListJobComplianceForPolicyResponse struct {
	// A list of jobs and their policy compliance statuses.
	Jobs types.List `tfsdk:"jobs"`
	// This field represents the pagination token to retrieve the next page of
	// results. If this field is not in the response, it means no further
	// results for the request.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// This field represents the pagination token to retrieve the previous page
	// of results. If this field is not in the response, it means no further
	// results for the request.
	PrevPageToken types.String `tfsdk:"prev_page_token"`
}

func (to *ListJobComplianceForPolicyResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobComplianceForPolicyResponse) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (to *ListJobComplianceForPolicyResponse) SyncFieldsDuringRead(ctx context.Context, from ListJobComplianceForPolicyResponse) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (m ListJobComplianceForPolicyResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["jobs"] = attrs["jobs"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["prev_page_token"] = attrs["prev_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobComplianceForPolicyResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobComplianceForPolicyResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"jobs": reflect.TypeOf(JobCompliance{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobComplianceForPolicyResponse
// only implements ToObjectValue() and Type().
func (m ListJobComplianceForPolicyResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"jobs":            m.Jobs,
			"next_page_token": m.NextPageToken,
			"prev_page_token": m.PrevPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobComplianceForPolicyResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"jobs": basetypes.ListType{
				ElemType: JobCompliance{}.Type(ctx),
			},
			"next_page_token": types.StringType,
			"prev_page_token": types.StringType,
		},
	}
}

// GetJobs returns the value of the Jobs field in ListJobComplianceForPolicyResponse as
// a slice of JobCompliance values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListJobComplianceForPolicyResponse) GetJobs(ctx context.Context) ([]JobCompliance, bool) {
	if m.Jobs.IsNull() || m.Jobs.IsUnknown() {
		return nil, false
	}
	var v []JobCompliance
	d := m.Jobs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobs sets the value of the Jobs field in ListJobComplianceForPolicyResponse.
func (m *ListJobComplianceForPolicyResponse) SetJobs(ctx context.Context, v []JobCompliance) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jobs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Jobs = types.ListValueMust(t, vs)
}

type ListJobComplianceRequest struct {
	// Use this field to specify the maximum number of results to be returned by
	// the server. The server may further constrain the maximum number of
	// results returned in a single page.
	PageSize types.Int64 `tfsdk:"-"`
	// A page token that can be used to navigate to the next page or previous
	// page as returned by `next_page_token` or `prev_page_token`.
	PageToken types.String `tfsdk:"-"`
	// Canonical unique identifier for the cluster policy.
	PolicyId types.String `tfsdk:"-"`
}

func (to *ListJobComplianceRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobComplianceRequest) {
}

func (to *ListJobComplianceRequest) SyncFieldsDuringRead(ctx context.Context, from ListJobComplianceRequest) {
}

func (m ListJobComplianceRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["policy_id"] = attrs["policy_id"].SetRequired()
	attrs["page_token"] = attrs["page_token"].SetOptional()
	attrs["page_size"] = attrs["page_size"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobComplianceRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobComplianceRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobComplianceRequest
// only implements ToObjectValue() and Type().
func (m ListJobComplianceRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"page_size":  m.PageSize,
			"page_token": m.PageToken,
			"policy_id":  m.PolicyId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobComplianceRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"page_size":  types.Int64Type,
			"page_token": types.StringType,
			"policy_id":  types.StringType,
		},
	}
}

type ListJobsRequest struct {
	// Whether to include task and cluster details in the response. Note that
	// only the first 100 elements will be shown. Use :method:jobs/get to
	// paginate through all tasks and clusters.
	ExpandTasks types.Bool `tfsdk:"-"`
	// The number of jobs to return. This value must be greater than 0 and less
	// or equal to 100. The default value is 20.
	Limit types.Int64 `tfsdk:"-"`
	// A filter on the list based on the exact (case insensitive) job name.
	Name types.String `tfsdk:"-"`
	// The offset of the first job to return, relative to the most recently
	// created job. Deprecated since June 2023. Use `page_token` to iterate
	// through the pages instead.
	Offset types.Int64 `tfsdk:"-"`
	// Use `next_page_token` or `prev_page_token` returned from the previous
	// request to list the next or previous page of jobs respectively.
	PageToken types.String `tfsdk:"-"`
}

func (to *ListJobsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobsRequest) {
}

func (to *ListJobsRequest) SyncFieldsDuringRead(ctx context.Context, from ListJobsRequest) {
}

func (m ListJobsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["offset"] = attrs["offset"].SetOptional()
	attrs["limit"] = attrs["limit"].SetOptional()
	attrs["expand_tasks"] = attrs["expand_tasks"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobsRequest
// only implements ToObjectValue() and Type().
func (m ListJobsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"expand_tasks": m.ExpandTasks,
			"limit":        m.Limit,
			"name":         m.Name,
			"offset":       m.Offset,
			"page_token":   m.PageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"expand_tasks": types.BoolType,
			"limit":        types.Int64Type,
			"name":         types.StringType,
			"offset":       types.Int64Type,
			"page_token":   types.StringType,
		},
	}
}

// List of jobs was retrieved successfully.
type ListJobsResponse struct {
	// If true, additional jobs matching the provided filter are available for
	// listing.
	HasMore types.Bool `tfsdk:"has_more"`
	// The list of jobs. Only included in the response if there are jobs to
	// list.
	Jobs types.List `tfsdk:"jobs"`
	// A token that can be used to list the next page of jobs (if applicable).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// A token that can be used to list the previous page of jobs (if
	// applicable).
	PrevPageToken types.String `tfsdk:"prev_page_token"`
}

func (to *ListJobsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListJobsResponse) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (to *ListJobsResponse) SyncFieldsDuringRead(ctx context.Context, from ListJobsResponse) {
	if !from.Jobs.IsNull() && !from.Jobs.IsUnknown() && to.Jobs.IsNull() && len(from.Jobs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Jobs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Jobs = from.Jobs
	}
}

func (m ListJobsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["jobs"] = attrs["jobs"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["prev_page_token"] = attrs["prev_page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListJobsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListJobsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"jobs": reflect.TypeOf(BaseJob{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListJobsResponse
// only implements ToObjectValue() and Type().
func (m ListJobsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_more":        m.HasMore,
			"jobs":            m.Jobs,
			"next_page_token": m.NextPageToken,
			"prev_page_token": m.PrevPageToken,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListJobsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_more": types.BoolType,
			"jobs": basetypes.ListType{
				ElemType: BaseJob{}.Type(ctx),
			},
			"next_page_token": types.StringType,
			"prev_page_token": types.StringType,
		},
	}
}

// GetJobs returns the value of the Jobs field in ListJobsResponse as
// a slice of BaseJob values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListJobsResponse) GetJobs(ctx context.Context) ([]BaseJob, bool) {
	if m.Jobs.IsNull() || m.Jobs.IsUnknown() {
		return nil, false
	}
	var v []BaseJob
	d := m.Jobs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobs sets the value of the Jobs field in ListJobsResponse.
func (m *ListJobsResponse) SetJobs(ctx context.Context, v []BaseJob) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jobs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Jobs = types.ListValueMust(t, vs)
}

type ListRunsRequest struct {
	// If active_only is `true`, only active runs are included in the results;
	// otherwise, lists both active and completed runs. An active run is a run
	// in the `QUEUED`, `PENDING`, `RUNNING`, or `TERMINATING`. This field
	// cannot be `true` when completed_only is `true`.
	ActiveOnly types.Bool `tfsdk:"-"`
	// If completed_only is `true`, only completed runs are included in the
	// results; otherwise, lists both active and completed runs. This field
	// cannot be `true` when active_only is `true`.
	CompletedOnly types.Bool `tfsdk:"-"`
	// Whether to include task and cluster details in the response. Note that
	// only the first 100 elements will be shown. Use :method:jobs/getrun to
	// paginate through all tasks and clusters.
	ExpandTasks types.Bool `tfsdk:"-"`
	// The job for which to list runs. If omitted, the Jobs service lists runs
	// from all jobs.
	JobId types.Int64 `tfsdk:"-"`
	// The number of runs to return. This value must be greater than 0 and less
	// than 25. The default value is 20. If a request specifies a limit of 0,
	// the service instead uses the maximum limit.
	Limit types.Int64 `tfsdk:"-"`
	// The offset of the first run to return, relative to the most recent run.
	// Deprecated since June 2023. Use `page_token` to iterate through the pages
	// instead.
	Offset types.Int64 `tfsdk:"-"`
	// Use `next_page_token` or `prev_page_token` returned from the previous
	// request to list the next or previous page of runs respectively.
	PageToken types.String `tfsdk:"-"`
	// The type of runs to return. For a description of run types, see
	// :method:jobs/getRun.
	RunType types.String `tfsdk:"-"`
	// Show runs that started _at or after_ this value. The value must be a UTC
	// timestamp in milliseconds. Can be combined with _start_time_to_ to filter
	// by a time range.
	StartTimeFrom types.Int64 `tfsdk:"-"`
	// Show runs that started _at or before_ this value. The value must be a UTC
	// timestamp in milliseconds. Can be combined with _start_time_from_ to
	// filter by a time range.
	StartTimeTo types.Int64 `tfsdk:"-"`
}

func (to *ListRunsRequest) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRunsRequest) {
}

func (to *ListRunsRequest) SyncFieldsDuringRead(ctx context.Context, from ListRunsRequest) {
}

func (m ListRunsRequest) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["active_only"] = attrs["active_only"].SetOptional()
	attrs["completed_only"] = attrs["completed_only"].SetOptional()
	attrs["offset"] = attrs["offset"].SetOptional()
	attrs["limit"] = attrs["limit"].SetOptional()
	attrs["run_type"] = attrs["run_type"].SetOptional()
	attrs["expand_tasks"] = attrs["expand_tasks"].SetOptional()
	attrs["start_time_from"] = attrs["start_time_from"].SetOptional()
	attrs["start_time_to"] = attrs["start_time_to"].SetOptional()
	attrs["page_token"] = attrs["page_token"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRunsRequest.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRunsRequest) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRunsRequest
// only implements ToObjectValue() and Type().
func (m ListRunsRequest) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"active_only":     m.ActiveOnly,
			"completed_only":  m.CompletedOnly,
			"expand_tasks":    m.ExpandTasks,
			"job_id":          m.JobId,
			"limit":           m.Limit,
			"offset":          m.Offset,
			"page_token":      m.PageToken,
			"run_type":        m.RunType,
			"start_time_from": m.StartTimeFrom,
			"start_time_to":   m.StartTimeTo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRunsRequest) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"active_only":     types.BoolType,
			"completed_only":  types.BoolType,
			"expand_tasks":    types.BoolType,
			"job_id":          types.Int64Type,
			"limit":           types.Int64Type,
			"offset":          types.Int64Type,
			"page_token":      types.StringType,
			"run_type":        types.StringType,
			"start_time_from": types.Int64Type,
			"start_time_to":   types.Int64Type,
		},
	}
}

// List of runs was retrieved successfully.
type ListRunsResponse struct {
	// If true, additional runs matching the provided filter are available for
	// listing.
	HasMore types.Bool `tfsdk:"has_more"`
	// A token that can be used to list the next page of runs (if applicable).
	NextPageToken types.String `tfsdk:"next_page_token"`
	// A token that can be used to list the previous page of runs (if
	// applicable).
	PrevPageToken types.String `tfsdk:"prev_page_token"`
	// A list of runs, from most recently started to least. Only included in the
	// response if there are runs to list.
	Runs types.List `tfsdk:"runs"`
}

func (to *ListRunsResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ListRunsResponse) {
	if !from.Runs.IsNull() && !from.Runs.IsUnknown() && to.Runs.IsNull() && len(from.Runs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Runs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Runs = from.Runs
	}
}

func (to *ListRunsResponse) SyncFieldsDuringRead(ctx context.Context, from ListRunsResponse) {
	if !from.Runs.IsNull() && !from.Runs.IsUnknown() && to.Runs.IsNull() && len(from.Runs.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Runs, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Runs = from.Runs
	}
}

func (m ListRunsResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["prev_page_token"] = attrs["prev_page_token"].SetOptional()
	attrs["runs"] = attrs["runs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ListRunsResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ListRunsResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"runs": reflect.TypeOf(BaseRun{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ListRunsResponse
// only implements ToObjectValue() and Type().
func (m ListRunsResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_more":        m.HasMore,
			"next_page_token": m.NextPageToken,
			"prev_page_token": m.PrevPageToken,
			"runs":            m.Runs,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ListRunsResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_more":        types.BoolType,
			"next_page_token": types.StringType,
			"prev_page_token": types.StringType,
			"runs": basetypes.ListType{
				ElemType: BaseRun{}.Type(ctx),
			},
		},
	}
}

// GetRuns returns the value of the Runs field in ListRunsResponse as
// a slice of BaseRun values.
// If the field is unknown or null, the boolean return value is false.
func (m *ListRunsResponse) GetRuns(ctx context.Context) ([]BaseRun, bool) {
	if m.Runs.IsNull() || m.Runs.IsUnknown() {
		return nil, false
	}
	var v []BaseRun
	d := m.Runs.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRuns sets the value of the Runs field in ListRunsResponse.
func (m *ListRunsResponse) SetRuns(ctx context.Context, v []BaseRun) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["runs"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Runs = types.ListValueMust(t, vs)
}

type NotebookOutput struct {
	// The value passed to
	// [dbutils.notebook.exit()](/notebooks/notebook-workflows.html#notebook-workflows-exit).
	// Databricks restricts this API to return the first 5 MB of the value. For
	// a larger result, your job can store the results in a cloud storage
	// service. This field is absent if `dbutils.notebook.exit()` was never
	// called.
	Result types.String `tfsdk:"result"`
	// Whether or not the result was truncated.
	Truncated types.Bool `tfsdk:"truncated"`
}

func (to *NotebookOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from NotebookOutput) {
}

func (to *NotebookOutput) SyncFieldsDuringRead(ctx context.Context, from NotebookOutput) {
}

func (m NotebookOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["result"] = attrs["result"].SetOptional()
	attrs["truncated"] = attrs["truncated"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NotebookOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m NotebookOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NotebookOutput
// only implements ToObjectValue() and Type().
func (m NotebookOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"result":    m.Result,
			"truncated": m.Truncated,
		})
}

// Type implements basetypes.ObjectValuable.
func (m NotebookOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"result":    types.StringType,
			"truncated": types.BoolType,
		},
	}
}

type NotebookTask struct {
	// Base parameters to be used for each run of this job. If the run is
	// initiated by a call to :method:jobs/run Now with parameters specified,
	// the two parameters maps are merged. If the same key is specified in
	// `base_parameters` and in `run-now`, the value from `run-now` is used. Use
	// [Task parameter variables] to set parameters containing information about
	// job runs.
	//
	// If the notebook takes a parameter that is not specified in the job’s
	// `base_parameters` or the `run-now` override parameters, the default value
	// from the notebook is used.
	//
	// Retrieve these parameters in a notebook using [dbutils.widgets.get].
	//
	// The JSON representation of this field cannot exceed 1MB.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html#dbutils-widgets
	BaseParameters types.Map `tfsdk:"base_parameters"`
	// The path of the notebook to be run in the Databricks workspace or remote
	// repository. For notebooks stored in the Databricks workspace, the path
	// must be absolute and begin with a slash. For notebooks stored in a remote
	// repository, the path must be relative. This field is required.
	NotebookPath types.String `tfsdk:"notebook_path"`
	// Optional location type of the notebook. When set to `WORKSPACE`, the
	// notebook will be retrieved from the local Databricks workspace. When set
	// to `GIT`, the notebook will be retrieved from a Git repository defined in
	// `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise. * `WORKSPACE`:
	// Notebook is located in Databricks workspace. * `GIT`: Notebook is located
	// in cloud Git provider.
	Source types.String `tfsdk:"source"`
	// Optional `warehouse_id` to run the notebook on a SQL warehouse. Classic
	// SQL warehouses are NOT supported, please use serverless or pro SQL
	// warehouses.
	//
	// Note that SQL warehouses only support SQL cells; if the notebook contains
	// non-SQL cells, the run will fail.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *NotebookTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from NotebookTask) {
}

func (to *NotebookTask) SyncFieldsDuringRead(ctx context.Context, from NotebookTask) {
}

func (m NotebookTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["base_parameters"] = attrs["base_parameters"].SetOptional()
	attrs["notebook_path"] = attrs["notebook_path"].SetRequired()
	attrs["source"] = attrs["source"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in NotebookTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m NotebookTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"base_parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, NotebookTask
// only implements ToObjectValue() and Type().
func (m NotebookTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"base_parameters": m.BaseParameters,
			"notebook_path":   m.NotebookPath,
			"source":          m.Source,
			"warehouse_id":    m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m NotebookTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"base_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_path": types.StringType,
			"source":        types.StringType,
			"warehouse_id":  types.StringType,
		},
	}
}

// GetBaseParameters returns the value of the BaseParameters field in NotebookTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *NotebookTask) GetBaseParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.BaseParameters.IsNull() || m.BaseParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.BaseParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBaseParameters sets the value of the BaseParameters field in NotebookTask.
func (m *NotebookTask) SetBaseParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["base_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.BaseParameters = types.MapValueMust(t, vs)
}

// Stores the catalog name, schema name, and the output schema expiration time
// for the clean room run.
type OutputSchemaInfo struct {
	CatalogName types.String `tfsdk:"catalog_name"`
	// The expiration time for the output schema as a Unix timestamp in
	// milliseconds.
	ExpirationTime types.Int64 `tfsdk:"expiration_time"`

	SchemaName types.String `tfsdk:"schema_name"`
}

func (to *OutputSchemaInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from OutputSchemaInfo) {
}

func (to *OutputSchemaInfo) SyncFieldsDuringRead(ctx context.Context, from OutputSchemaInfo) {
}

func (m OutputSchemaInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog_name"] = attrs["catalog_name"].SetOptional()
	attrs["expiration_time"] = attrs["expiration_time"].SetOptional()
	attrs["schema_name"] = attrs["schema_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in OutputSchemaInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m OutputSchemaInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, OutputSchemaInfo
// only implements ToObjectValue() and Type().
func (m OutputSchemaInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog_name":    m.CatalogName,
			"expiration_time": m.ExpirationTime,
			"schema_name":     m.SchemaName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m OutputSchemaInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog_name":    types.StringType,
			"expiration_time": types.Int64Type,
			"schema_name":     types.StringType,
		},
	}
}

type PeriodicTriggerConfiguration struct {
	// The interval at which the trigger should run.
	Interval types.Int64 `tfsdk:"interval"`
	// The unit of time for the interval.
	Unit types.String `tfsdk:"unit"`
}

func (to *PeriodicTriggerConfiguration) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PeriodicTriggerConfiguration) {
}

func (to *PeriodicTriggerConfiguration) SyncFieldsDuringRead(ctx context.Context, from PeriodicTriggerConfiguration) {
}

func (m PeriodicTriggerConfiguration) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["interval"] = attrs["interval"].SetRequired()
	attrs["unit"] = attrs["unit"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PeriodicTriggerConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PeriodicTriggerConfiguration) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PeriodicTriggerConfiguration
// only implements ToObjectValue() and Type().
func (m PeriodicTriggerConfiguration) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"interval": m.Interval,
			"unit":     m.Unit,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PeriodicTriggerConfiguration) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"interval": types.Int64Type,
			"unit":     types.StringType,
		},
	}
}

type PipelineParams struct {
	// If true, triggers a full refresh on the delta live table.
	FullRefresh types.Bool `tfsdk:"full_refresh"`
}

func (to *PipelineParams) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PipelineParams) {
}

func (to *PipelineParams) SyncFieldsDuringRead(ctx context.Context, from PipelineParams) {
}

func (m PipelineParams) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_refresh"] = attrs["full_refresh"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PipelineParams.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PipelineParams) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PipelineParams
// only implements ToObjectValue() and Type().
func (m PipelineParams) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_refresh": m.FullRefresh,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PipelineParams) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_refresh": types.BoolType,
		},
	}
}

type PipelineTask struct {
	// If true, triggers a full refresh on the delta live table.
	FullRefresh types.Bool `tfsdk:"full_refresh"`
	// The full name of the pipeline task to execute.
	PipelineId types.String `tfsdk:"pipeline_id"`
}

func (to *PipelineTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PipelineTask) {
}

func (to *PipelineTask) SyncFieldsDuringRead(ctx context.Context, from PipelineTask) {
}

func (m PipelineTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["full_refresh"] = attrs["full_refresh"].SetOptional()
	attrs["pipeline_id"] = attrs["pipeline_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PipelineTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PipelineTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PipelineTask
// only implements ToObjectValue() and Type().
func (m PipelineTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"full_refresh": m.FullRefresh,
			"pipeline_id":  m.PipelineId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PipelineTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"full_refresh": types.BoolType,
			"pipeline_id":  types.StringType,
		},
	}
}

type PowerBiModel struct {
	// How the published Power BI model authenticates to Databricks
	AuthenticationMethod types.String `tfsdk:"authentication_method"`
	// The name of the Power BI model
	ModelName types.String `tfsdk:"model_name"`
	// Whether to overwrite existing Power BI models
	OverwriteExisting types.Bool `tfsdk:"overwrite_existing"`
	// The default storage mode of the Power BI model
	StorageMode types.String `tfsdk:"storage_mode"`
	// The name of the Power BI workspace of the model
	WorkspaceName types.String `tfsdk:"workspace_name"`
}

func (to *PowerBiModel) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PowerBiModel) {
}

func (to *PowerBiModel) SyncFieldsDuringRead(ctx context.Context, from PowerBiModel) {
}

func (m PowerBiModel) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["authentication_method"] = attrs["authentication_method"].SetOptional()
	attrs["model_name"] = attrs["model_name"].SetOptional()
	attrs["overwrite_existing"] = attrs["overwrite_existing"].SetOptional()
	attrs["storage_mode"] = attrs["storage_mode"].SetOptional()
	attrs["workspace_name"] = attrs["workspace_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PowerBiModel.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PowerBiModel) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PowerBiModel
// only implements ToObjectValue() and Type().
func (m PowerBiModel) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"authentication_method": m.AuthenticationMethod,
			"model_name":            m.ModelName,
			"overwrite_existing":    m.OverwriteExisting,
			"storage_mode":          m.StorageMode,
			"workspace_name":        m.WorkspaceName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PowerBiModel) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"authentication_method": types.StringType,
			"model_name":            types.StringType,
			"overwrite_existing":    types.BoolType,
			"storage_mode":          types.StringType,
			"workspace_name":        types.StringType,
		},
	}
}

type PowerBiTable struct {
	// The catalog name in Databricks
	Catalog types.String `tfsdk:"catalog"`
	// The table name in Databricks
	Name types.String `tfsdk:"name"`
	// The schema name in Databricks
	Schema types.String `tfsdk:"schema"`
	// The Power BI storage mode of the table
	StorageMode types.String `tfsdk:"storage_mode"`
}

func (to *PowerBiTable) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PowerBiTable) {
}

func (to *PowerBiTable) SyncFieldsDuringRead(ctx context.Context, from PowerBiTable) {
}

func (m PowerBiTable) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["catalog"] = attrs["catalog"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["schema"] = attrs["schema"].SetOptional()
	attrs["storage_mode"] = attrs["storage_mode"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PowerBiTable.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PowerBiTable) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PowerBiTable
// only implements ToObjectValue() and Type().
func (m PowerBiTable) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"catalog":      m.Catalog,
			"name":         m.Name,
			"schema":       m.Schema,
			"storage_mode": m.StorageMode,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PowerBiTable) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"catalog":      types.StringType,
			"name":         types.StringType,
			"schema":       types.StringType,
			"storage_mode": types.StringType,
		},
	}
}

type PowerBiTask struct {
	// The resource name of the UC connection to authenticate from Databricks to
	// Power BI
	ConnectionResourceName types.String `tfsdk:"connection_resource_name"`
	// The semantic model to update
	PowerBiModel types.Object `tfsdk:"power_bi_model"`
	// Whether the model should be refreshed after the update
	RefreshAfterUpdate types.Bool `tfsdk:"refresh_after_update"`
	// The tables to be exported to Power BI
	Tables types.List `tfsdk:"tables"`
	// The SQL warehouse ID to use as the Power BI data source
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *PowerBiTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PowerBiTask) {
	if !from.PowerBiModel.IsNull() && !from.PowerBiModel.IsUnknown() {
		if toPowerBiModel, ok := to.GetPowerBiModel(ctx); ok {
			if fromPowerBiModel, ok := from.GetPowerBiModel(ctx); ok {
				// Recursively sync the fields of PowerBiModel
				toPowerBiModel.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiModel)
				to.SetPowerBiModel(ctx, toPowerBiModel)
			}
		}
	}
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (to *PowerBiTask) SyncFieldsDuringRead(ctx context.Context, from PowerBiTask) {
	if !from.PowerBiModel.IsNull() && !from.PowerBiModel.IsUnknown() {
		if toPowerBiModel, ok := to.GetPowerBiModel(ctx); ok {
			if fromPowerBiModel, ok := from.GetPowerBiModel(ctx); ok {
				toPowerBiModel.SyncFieldsDuringRead(ctx, fromPowerBiModel)
				to.SetPowerBiModel(ctx, toPowerBiModel)
			}
		}
	}
	if !from.Tables.IsNull() && !from.Tables.IsUnknown() && to.Tables.IsNull() && len(from.Tables.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tables, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tables = from.Tables
	}
}

func (m PowerBiTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["connection_resource_name"] = attrs["connection_resource_name"].SetOptional()
	attrs["power_bi_model"] = attrs["power_bi_model"].SetOptional()
	attrs["refresh_after_update"] = attrs["refresh_after_update"].SetOptional()
	attrs["tables"] = attrs["tables"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PowerBiTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PowerBiTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"power_bi_model": reflect.TypeOf(PowerBiModel{}),
		"tables":         reflect.TypeOf(PowerBiTable{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PowerBiTask
// only implements ToObjectValue() and Type().
func (m PowerBiTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"connection_resource_name": m.ConnectionResourceName,
			"power_bi_model":           m.PowerBiModel,
			"refresh_after_update":     m.RefreshAfterUpdate,
			"tables":                   m.Tables,
			"warehouse_id":             m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PowerBiTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"connection_resource_name": types.StringType,
			"power_bi_model":           PowerBiModel{}.Type(ctx),
			"refresh_after_update":     types.BoolType,
			"tables": basetypes.ListType{
				ElemType: PowerBiTable{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetPowerBiModel returns the value of the PowerBiModel field in PowerBiTask as
// a PowerBiModel value.
// If the field is unknown or null, the boolean return value is false.
func (m *PowerBiTask) GetPowerBiModel(ctx context.Context) (PowerBiModel, bool) {
	var e PowerBiModel
	if m.PowerBiModel.IsNull() || m.PowerBiModel.IsUnknown() {
		return e, false
	}
	var v PowerBiModel
	d := m.PowerBiModel.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPowerBiModel sets the value of the PowerBiModel field in PowerBiTask.
func (m *PowerBiTask) SetPowerBiModel(ctx context.Context, v PowerBiModel) {
	vs := v.ToObjectValue(ctx)
	m.PowerBiModel = vs
}

// GetTables returns the value of the Tables field in PowerBiTask as
// a slice of PowerBiTable values.
// If the field is unknown or null, the boolean return value is false.
func (m *PowerBiTask) GetTables(ctx context.Context) ([]PowerBiTable, bool) {
	if m.Tables.IsNull() || m.Tables.IsUnknown() {
		return nil, false
	}
	var v []PowerBiTable
	d := m.Tables.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTables sets the value of the Tables field in PowerBiTask.
func (m *PowerBiTask) SetTables(ctx context.Context, v []PowerBiTable) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tables"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tables = types.ListValueMust(t, vs)
}

type PythonWheelTask struct {
	// Named entry point to use, if it does not exist in the metadata of the
	// package it executes the function from the package directly using
	// `$packageName.$entryPoint()`
	EntryPoint types.String `tfsdk:"entry_point"`
	// Command-line parameters passed to Python wheel task in the form of
	// `["--name=task", "--data=dbfs:/path/to/data.json"]`. Leave it empty if
	// `parameters` is not null.
	NamedParameters types.Map `tfsdk:"named_parameters"`
	// Name of the package to execute
	PackageName types.String `tfsdk:"package_name"`
	// Command-line parameters passed to Python wheel task. Leave it empty if
	// `named_parameters` is not null.
	Parameters types.List `tfsdk:"parameters"`
}

func (to *PythonWheelTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from PythonWheelTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *PythonWheelTask) SyncFieldsDuringRead(ctx context.Context, from PythonWheelTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m PythonWheelTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["entry_point"] = attrs["entry_point"].SetRequired()
	attrs["named_parameters"] = attrs["named_parameters"].SetOptional()
	attrs["package_name"] = attrs["package_name"].SetRequired()
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in PythonWheelTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m PythonWheelTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"named_parameters": reflect.TypeOf(types.String{}),
		"parameters":       reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, PythonWheelTask
// only implements ToObjectValue() and Type().
func (m PythonWheelTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"entry_point":      m.EntryPoint,
			"named_parameters": m.NamedParameters,
			"package_name":     m.PackageName,
			"parameters":       m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m PythonWheelTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"entry_point": types.StringType,
			"named_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"package_name": types.StringType,
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetNamedParameters returns the value of the NamedParameters field in PythonWheelTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PythonWheelTask) GetNamedParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.NamedParameters.IsNull() || m.NamedParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NamedParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNamedParameters sets the value of the NamedParameters field in PythonWheelTask.
func (m *PythonWheelTask) SetNamedParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["named_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NamedParameters = types.MapValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in PythonWheelTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *PythonWheelTask) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in PythonWheelTask.
func (m *PythonWheelTask) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type QueueDetails struct {
	Code types.String `tfsdk:"code"`
	// A descriptive message with the queuing details. This field is
	// unstructured, and its exact format is subject to change.
	Message types.String `tfsdk:"message"`
}

func (to *QueueDetails) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from QueueDetails) {
}

func (to *QueueDetails) SyncFieldsDuringRead(ctx context.Context, from QueueDetails) {
}

func (m QueueDetails) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["code"] = attrs["code"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QueueDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m QueueDetails) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QueueDetails
// only implements ToObjectValue() and Type().
func (m QueueDetails) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"code":    m.Code,
			"message": m.Message,
		})
}

// Type implements basetypes.ObjectValuable.
func (m QueueDetails) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"code":    types.StringType,
			"message": types.StringType,
		},
	}
}

type QueueSettings struct {
	// If true, enable queueing for the job. This is a required field.
	Enabled types.Bool `tfsdk:"enabled"`
}

func (to *QueueSettings) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from QueueSettings) {
}

func (to *QueueSettings) SyncFieldsDuringRead(ctx context.Context, from QueueSettings) {
}

func (m QueueSettings) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["enabled"] = attrs["enabled"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in QueueSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m QueueSettings) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, QueueSettings
// only implements ToObjectValue() and Type().
func (m QueueSettings) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"enabled": m.Enabled,
		})
}

// Type implements basetypes.ObjectValuable.
func (m QueueSettings) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"enabled": types.BoolType,
		},
	}
}

type RepairHistoryItem struct {
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// The end time of the (repaired) run.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The ID of the repair. Only returned for the items that represent a repair
	// in `repair_history`.
	Id types.Int64 `tfsdk:"id"`
	// The start time of the (repaired) run.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.Object `tfsdk:"state"`

	Status types.Object `tfsdk:"status"`
	// The run IDs of the task runs that ran as part of this repair history
	// item.
	TaskRunIds types.List `tfsdk:"task_run_ids"`
	// The repair history item type. Indicates whether a run is the original run
	// or a repair run.
	Type_ types.String `tfsdk:"type"`
}

func (to *RepairHistoryItem) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RepairHistoryItem) {
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.TaskRunIds.IsNull() && !from.TaskRunIds.IsUnknown() && to.TaskRunIds.IsNull() && len(from.TaskRunIds.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TaskRunIds, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TaskRunIds = from.TaskRunIds
	}
}

func (to *RepairHistoryItem) SyncFieldsDuringRead(ctx context.Context, from RepairHistoryItem) {
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.TaskRunIds.IsNull() && !from.TaskRunIds.IsUnknown() && to.TaskRunIds.IsNull() && len(from.TaskRunIds.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TaskRunIds, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TaskRunIds = from.TaskRunIds
	}
}

func (m RepairHistoryItem) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetOptional()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["id"] = attrs["id"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["task_run_ids"] = attrs["task_run_ids"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RepairHistoryItem.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RepairHistoryItem) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"state":        reflect.TypeOf(RunState{}),
		"status":       reflect.TypeOf(RunStatus{}),
		"task_run_ids": reflect.TypeOf(types.Int64{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RepairHistoryItem
// only implements ToObjectValue() and Type().
func (m RepairHistoryItem) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"effective_performance_target": m.EffectivePerformanceTarget,
			"end_time":                     m.EndTime,
			"id":                           m.Id,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"task_run_ids":                 m.TaskRunIds,
			"type":                         m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RepairHistoryItem) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"effective_performance_target": types.StringType,
			"end_time":                     types.Int64Type,
			"id":                           types.Int64Type,
			"start_time":                   types.Int64Type,
			"state":                        RunState{}.Type(ctx),
			"status":                       RunStatus{}.Type(ctx),
			"task_run_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"type": types.StringType,
		},
	}
}

// GetState returns the value of the State field in RepairHistoryItem as
// a RunState value.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairHistoryItem) GetState(ctx context.Context) (RunState, bool) {
	var e RunState
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v RunState
	d := m.State.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetState sets the value of the State field in RepairHistoryItem.
func (m *RepairHistoryItem) SetState(ctx context.Context, v RunState) {
	vs := v.ToObjectValue(ctx)
	m.State = vs
}

// GetStatus returns the value of the Status field in RepairHistoryItem as
// a RunStatus value.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairHistoryItem) GetStatus(ctx context.Context) (RunStatus, bool) {
	var e RunStatus
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v RunStatus
	d := m.Status.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStatus sets the value of the Status field in RepairHistoryItem.
func (m *RepairHistoryItem) SetStatus(ctx context.Context, v RunStatus) {
	vs := v.ToObjectValue(ctx)
	m.Status = vs
}

// GetTaskRunIds returns the value of the TaskRunIds field in RepairHistoryItem as
// a slice of types.Int64 values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairHistoryItem) GetTaskRunIds(ctx context.Context) ([]types.Int64, bool) {
	if m.TaskRunIds.IsNull() || m.TaskRunIds.IsUnknown() {
		return nil, false
	}
	var v []types.Int64
	d := m.TaskRunIds.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTaskRunIds sets the value of the TaskRunIds field in RepairHistoryItem.
func (m *RepairHistoryItem) SetTaskRunIds(ctx context.Context, v []types.Int64) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["task_run_ids"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TaskRunIds = types.ListValueMust(t, vs)
}

type RepairRun struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// Job-level parameters used in the run. for example `"param":
	// "overriding_val"`
	JobParameters types.Map `tfsdk:"job_parameters"`
	// The ID of the latest repair. This parameter is not required when
	// repairing a run for the first time, but must be provided on subsequent
	// requests to repair the same run.
	LatestRepairId types.Int64 `tfsdk:"latest_repair_id"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// The performance mode on a serverless job. The performance target
	// determines the level of compute performance or cost-efficiency for the
	// run. This field overrides the performance target defined on the job
	// level.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.Object `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// If true, repair all failed tasks. Only one of `rerun_tasks` or
	// `rerun_all_failed_tasks` can be used.
	RerunAllFailedTasks types.Bool `tfsdk:"rerun_all_failed_tasks"`
	// If true, repair all tasks that depend on the tasks in `rerun_tasks`, even
	// if they were previously successful. Can be also used in combination with
	// `rerun_all_failed_tasks`.
	RerunDependentTasks types.Bool `tfsdk:"rerun_dependent_tasks"`
	// The task keys of the task runs to repair.
	RerunTasks types.List `tfsdk:"rerun_tasks"`
	// The job run ID of the run to repair. The run must not be in progress.
	RunId types.Int64 `tfsdk:"run_id"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RepairRun) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RepairRun) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.RerunTasks.IsNull() && !from.RerunTasks.IsUnknown() && to.RerunTasks.IsNull() && len(from.RerunTasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RerunTasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RerunTasks = from.RerunTasks
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RepairRun) SyncFieldsDuringRead(ctx context.Context, from RepairRun) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.RerunTasks.IsNull() && !from.RerunTasks.IsUnknown() && to.RerunTasks.IsNull() && len(from.RerunTasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RerunTasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RerunTasks = from.RerunTasks
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RepairRun) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["latest_repair_id"] = attrs["latest_repair_id"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["rerun_all_failed_tasks"] = attrs["rerun_all_failed_tasks"].SetOptional()
	attrs["rerun_dependent_tasks"] = attrs["rerun_dependent_tasks"].SetOptional()
	attrs["rerun_tasks"] = attrs["rerun_tasks"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetRequired()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RepairRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RepairRun) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"job_parameters":      reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"rerun_tasks":         reflect.TypeOf(types.String{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RepairRun
// only implements ToObjectValue() and Type().
func (m RepairRun) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":           m.DbtCommands,
			"jar_params":             m.JarParams,
			"job_parameters":         m.JobParameters,
			"latest_repair_id":       m.LatestRepairId,
			"notebook_params":        m.NotebookParams,
			"performance_target":     m.PerformanceTarget,
			"pipeline_params":        m.PipelineParams,
			"python_named_params":    m.PythonNamedParams,
			"python_params":          m.PythonParams,
			"rerun_all_failed_tasks": m.RerunAllFailedTasks,
			"rerun_dependent_tasks":  m.RerunDependentTasks,
			"rerun_tasks":            m.RerunTasks,
			"run_id":                 m.RunId,
			"spark_submit_params":    m.SparkSubmitParams,
			"sql_params":             m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RepairRun) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"latest_repair_id": types.Int64Type,
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"performance_target": types.StringType,
			"pipeline_params":    PipelineParams{}.Type(ctx),
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rerun_all_failed_tasks": types.BoolType,
			"rerun_dependent_tasks":  types.BoolType,
			"rerun_tasks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"run_id": types.Int64Type,
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RepairRun as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RepairRun.
func (m *RepairRun) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RepairRun as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RepairRun.
func (m *RepairRun) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in RepairRun as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in RepairRun.
func (m *RepairRun) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RepairRun as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RepairRun.
func (m *RepairRun) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RepairRun as
// a PipelineParams value.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetPipelineParams(ctx context.Context) (PipelineParams, bool) {
	var e PipelineParams
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v PipelineParams
	d := m.PipelineParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineParams sets the value of the PipelineParams field in RepairRun.
func (m *RepairRun) SetPipelineParams(ctx context.Context, v PipelineParams) {
	vs := v.ToObjectValue(ctx)
	m.PipelineParams = vs
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RepairRun as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RepairRun.
func (m *RepairRun) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RepairRun as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RepairRun.
func (m *RepairRun) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetRerunTasks returns the value of the RerunTasks field in RepairRun as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetRerunTasks(ctx context.Context) ([]types.String, bool) {
	if m.RerunTasks.IsNull() || m.RerunTasks.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.RerunTasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRerunTasks sets the value of the RerunTasks field in RepairRun.
func (m *RepairRun) SetRerunTasks(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["rerun_tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RerunTasks = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RepairRun as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RepairRun.
func (m *RepairRun) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RepairRun as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RepairRun) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RepairRun.
func (m *RepairRun) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

// Run repair was initiated.
type RepairRunResponse struct {
	// The ID of the repair. Must be provided in subsequent repairs using the
	// `latest_repair_id` field to ensure sequential repairs.
	RepairId types.Int64 `tfsdk:"repair_id"`
}

func (to *RepairRunResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RepairRunResponse) {
}

func (to *RepairRunResponse) SyncFieldsDuringRead(ctx context.Context, from RepairRunResponse) {
}

func (m RepairRunResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["repair_id"] = attrs["repair_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RepairRunResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RepairRunResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RepairRunResponse
// only implements ToObjectValue() and Type().
func (m RepairRunResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"repair_id": m.RepairId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RepairRunResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"repair_id": types.Int64Type,
		},
	}
}

type ResetJob struct {
	// The canonical identifier of the job to reset. This field is required.
	JobId types.Int64 `tfsdk:"job_id"`
	// The new settings of the job. These settings completely replace the old
	// settings.
	//
	// Changes to the field `JobBaseSettings.timeout_seconds` are applied to
	// active runs. Changes to other fields are applied to future runs only.
	NewSettings types.Object `tfsdk:"new_settings"`
}

func (to *ResetJob) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResetJob) {
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				// Recursively sync the fields of NewSettings
				toNewSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (to *ResetJob) SyncFieldsDuringRead(ctx context.Context, from ResetJob) {
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				toNewSettings.SyncFieldsDuringRead(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (m ResetJob) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["new_settings"] = attrs["new_settings"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResetJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResetJob) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"new_settings": reflect.TypeOf(JobSettings{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResetJob
// only implements ToObjectValue() and Type().
func (m ResetJob) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_id":       m.JobId,
			"new_settings": m.NewSettings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResetJob) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_id":       types.Int64Type,
			"new_settings": JobSettings{}.Type(ctx),
		},
	}
}

// GetNewSettings returns the value of the NewSettings field in ResetJob as
// a JobSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResetJob) GetNewSettings(ctx context.Context) (JobSettings, bool) {
	var e JobSettings
	if m.NewSettings.IsNull() || m.NewSettings.IsUnknown() {
		return e, false
	}
	var v JobSettings
	d := m.NewSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewSettings sets the value of the NewSettings field in ResetJob.
func (m *ResetJob) SetNewSettings(ctx context.Context, v JobSettings) {
	vs := v.ToObjectValue(ctx)
	m.NewSettings = vs
}

type ResolvedConditionTaskValues struct {
	Left types.String `tfsdk:"left"`

	Right types.String `tfsdk:"right"`
}

func (to *ResolvedConditionTaskValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedConditionTaskValues) {
}

func (to *ResolvedConditionTaskValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedConditionTaskValues) {
}

func (m ResolvedConditionTaskValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["left"] = attrs["left"].SetOptional()
	attrs["right"] = attrs["right"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedConditionTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedConditionTaskValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedConditionTaskValues
// only implements ToObjectValue() and Type().
func (m ResolvedConditionTaskValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"left":  m.Left,
			"right": m.Right,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedConditionTaskValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"left":  types.StringType,
			"right": types.StringType,
		},
	}
}

type ResolvedDbtTaskValues struct {
	Commands types.List `tfsdk:"commands"`
}

func (to *ResolvedDbtTaskValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedDbtTaskValues) {
	if !from.Commands.IsNull() && !from.Commands.IsUnknown() && to.Commands.IsNull() && len(from.Commands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Commands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Commands = from.Commands
	}
}

func (to *ResolvedDbtTaskValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedDbtTaskValues) {
	if !from.Commands.IsNull() && !from.Commands.IsUnknown() && to.Commands.IsNull() && len(from.Commands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Commands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Commands = from.Commands
	}
}

func (m ResolvedDbtTaskValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["commands"] = attrs["commands"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedDbtTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedDbtTaskValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"commands": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedDbtTaskValues
// only implements ToObjectValue() and Type().
func (m ResolvedDbtTaskValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"commands": m.Commands,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedDbtTaskValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"commands": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetCommands returns the value of the Commands field in ResolvedDbtTaskValues as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedDbtTaskValues) GetCommands(ctx context.Context) ([]types.String, bool) {
	if m.Commands.IsNull() || m.Commands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Commands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCommands sets the value of the Commands field in ResolvedDbtTaskValues.
func (m *ResolvedDbtTaskValues) SetCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Commands = types.ListValueMust(t, vs)
}

type ResolvedNotebookTaskValues struct {
	BaseParameters types.Map `tfsdk:"base_parameters"`
}

func (to *ResolvedNotebookTaskValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedNotebookTaskValues) {
}

func (to *ResolvedNotebookTaskValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedNotebookTaskValues) {
}

func (m ResolvedNotebookTaskValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["base_parameters"] = attrs["base_parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedNotebookTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedNotebookTaskValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"base_parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedNotebookTaskValues
// only implements ToObjectValue() and Type().
func (m ResolvedNotebookTaskValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"base_parameters": m.BaseParameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedNotebookTaskValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"base_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetBaseParameters returns the value of the BaseParameters field in ResolvedNotebookTaskValues as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedNotebookTaskValues) GetBaseParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.BaseParameters.IsNull() || m.BaseParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.BaseParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetBaseParameters sets the value of the BaseParameters field in ResolvedNotebookTaskValues.
func (m *ResolvedNotebookTaskValues) SetBaseParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["base_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.BaseParameters = types.MapValueMust(t, vs)
}

type ResolvedParamPairValues struct {
	Parameters types.Map `tfsdk:"parameters"`
}

func (to *ResolvedParamPairValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedParamPairValues) {
}

func (to *ResolvedParamPairValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedParamPairValues) {
}

func (m ResolvedParamPairValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedParamPairValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedParamPairValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedParamPairValues
// only implements ToObjectValue() and Type().
func (m ResolvedParamPairValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedParamPairValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in ResolvedParamPairValues as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedParamPairValues) GetParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedParamPairValues.
func (m *ResolvedParamPairValues) SetParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.MapValueMust(t, vs)
}

type ResolvedPythonWheelTaskValues struct {
	NamedParameters types.Map `tfsdk:"named_parameters"`

	Parameters types.List `tfsdk:"parameters"`
}

func (to *ResolvedPythonWheelTaskValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedPythonWheelTaskValues) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *ResolvedPythonWheelTaskValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedPythonWheelTaskValues) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m ResolvedPythonWheelTaskValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["named_parameters"] = attrs["named_parameters"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedPythonWheelTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedPythonWheelTaskValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"named_parameters": reflect.TypeOf(types.String{}),
		"parameters":       reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedPythonWheelTaskValues
// only implements ToObjectValue() and Type().
func (m ResolvedPythonWheelTaskValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"named_parameters": m.NamedParameters,
			"parameters":       m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedPythonWheelTaskValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"named_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetNamedParameters returns the value of the NamedParameters field in ResolvedPythonWheelTaskValues as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedPythonWheelTaskValues) GetNamedParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.NamedParameters.IsNull() || m.NamedParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NamedParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNamedParameters sets the value of the NamedParameters field in ResolvedPythonWheelTaskValues.
func (m *ResolvedPythonWheelTaskValues) SetNamedParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["named_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NamedParameters = types.MapValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in ResolvedPythonWheelTaskValues as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedPythonWheelTaskValues) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedPythonWheelTaskValues.
func (m *ResolvedPythonWheelTaskValues) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type ResolvedRunJobTaskValues struct {
	JobParameters types.Map `tfsdk:"job_parameters"`

	Parameters types.Map `tfsdk:"parameters"`
}

func (to *ResolvedRunJobTaskValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedRunJobTaskValues) {
}

func (to *ResolvedRunJobTaskValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedRunJobTaskValues) {
}

func (m ResolvedRunJobTaskValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedRunJobTaskValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedRunJobTaskValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"job_parameters": reflect.TypeOf(types.String{}),
		"parameters":     reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedRunJobTaskValues
// only implements ToObjectValue() and Type().
func (m ResolvedRunJobTaskValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"job_parameters": m.JobParameters,
			"parameters":     m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedRunJobTaskValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetJobParameters returns the value of the JobParameters field in ResolvedRunJobTaskValues as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedRunJobTaskValues) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in ResolvedRunJobTaskValues.
func (m *ResolvedRunJobTaskValues) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetParameters returns the value of the Parameters field in ResolvedRunJobTaskValues as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedRunJobTaskValues) GetParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedRunJobTaskValues.
func (m *ResolvedRunJobTaskValues) SetParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.MapValueMust(t, vs)
}

type ResolvedStringParamsValues struct {
	Parameters types.List `tfsdk:"parameters"`
}

func (to *ResolvedStringParamsValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedStringParamsValues) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *ResolvedStringParamsValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedStringParamsValues) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m ResolvedStringParamsValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedStringParamsValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedStringParamsValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedStringParamsValues
// only implements ToObjectValue() and Type().
func (m ResolvedStringParamsValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedStringParamsValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in ResolvedStringParamsValues as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedStringParamsValues) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in ResolvedStringParamsValues.
func (m *ResolvedStringParamsValues) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type ResolvedValues struct {
	ConditionTask types.Object `tfsdk:"condition_task"`

	DbtTask types.Object `tfsdk:"dbt_task"`

	NotebookTask types.Object `tfsdk:"notebook_task"`

	PythonWheelTask types.Object `tfsdk:"python_wheel_task"`

	RunJobTask types.Object `tfsdk:"run_job_task"`

	SimulationTask types.Object `tfsdk:"simulation_task"`

	SparkJarTask types.Object `tfsdk:"spark_jar_task"`

	SparkPythonTask types.Object `tfsdk:"spark_python_task"`

	SparkSubmitTask types.Object `tfsdk:"spark_submit_task"`

	SqlTask types.Object `tfsdk:"sql_task"`
}

func (to *ResolvedValues) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ResolvedValues) {
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SimulationTask.IsNull() && !from.SimulationTask.IsUnknown() {
		if toSimulationTask, ok := to.GetSimulationTask(ctx); ok {
			if fromSimulationTask, ok := from.GetSimulationTask(ctx); ok {
				// Recursively sync the fields of SimulationTask
				toSimulationTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSimulationTask)
				to.SetSimulationTask(ctx, toSimulationTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
}

func (to *ResolvedValues) SyncFieldsDuringRead(ctx context.Context, from ResolvedValues) {
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SimulationTask.IsNull() && !from.SimulationTask.IsUnknown() {
		if toSimulationTask, ok := to.GetSimulationTask(ctx); ok {
			if fromSimulationTask, ok := from.GetSimulationTask(ctx); ok {
				toSimulationTask.SyncFieldsDuringRead(ctx, fromSimulationTask)
				to.SetSimulationTask(ctx, toSimulationTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
}

func (m ResolvedValues) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["simulation_task"] = attrs["simulation_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ResolvedValues.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ResolvedValues) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"condition_task":    reflect.TypeOf(ResolvedConditionTaskValues{}),
		"dbt_task":          reflect.TypeOf(ResolvedDbtTaskValues{}),
		"notebook_task":     reflect.TypeOf(ResolvedNotebookTaskValues{}),
		"python_wheel_task": reflect.TypeOf(ResolvedPythonWheelTaskValues{}),
		"run_job_task":      reflect.TypeOf(ResolvedRunJobTaskValues{}),
		"simulation_task":   reflect.TypeOf(ResolvedParamPairValues{}),
		"spark_jar_task":    reflect.TypeOf(ResolvedStringParamsValues{}),
		"spark_python_task": reflect.TypeOf(ResolvedStringParamsValues{}),
		"spark_submit_task": reflect.TypeOf(ResolvedStringParamsValues{}),
		"sql_task":          reflect.TypeOf(ResolvedParamPairValues{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ResolvedValues
// only implements ToObjectValue() and Type().
func (m ResolvedValues) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"condition_task":    m.ConditionTask,
			"dbt_task":          m.DbtTask,
			"notebook_task":     m.NotebookTask,
			"python_wheel_task": m.PythonWheelTask,
			"run_job_task":      m.RunJobTask,
			"simulation_task":   m.SimulationTask,
			"spark_jar_task":    m.SparkJarTask,
			"spark_python_task": m.SparkPythonTask,
			"spark_submit_task": m.SparkSubmitTask,
			"sql_task":          m.SqlTask,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ResolvedValues) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"condition_task":    ResolvedConditionTaskValues{}.Type(ctx),
			"dbt_task":          ResolvedDbtTaskValues{}.Type(ctx),
			"notebook_task":     ResolvedNotebookTaskValues{}.Type(ctx),
			"python_wheel_task": ResolvedPythonWheelTaskValues{}.Type(ctx),
			"run_job_task":      ResolvedRunJobTaskValues{}.Type(ctx),
			"simulation_task":   ResolvedParamPairValues{}.Type(ctx),
			"spark_jar_task":    ResolvedStringParamsValues{}.Type(ctx),
			"spark_python_task": ResolvedStringParamsValues{}.Type(ctx),
			"spark_submit_task": ResolvedStringParamsValues{}.Type(ctx),
			"sql_task":          ResolvedParamPairValues{}.Type(ctx),
		},
	}
}

// GetConditionTask returns the value of the ConditionTask field in ResolvedValues as
// a ResolvedConditionTaskValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetConditionTask(ctx context.Context) (ResolvedConditionTaskValues, bool) {
	var e ResolvedConditionTaskValues
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v ResolvedConditionTaskValues
	d := m.ConditionTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConditionTask sets the value of the ConditionTask field in ResolvedValues.
func (m *ResolvedValues) SetConditionTask(ctx context.Context, v ResolvedConditionTaskValues) {
	vs := v.ToObjectValue(ctx)
	m.ConditionTask = vs
}

// GetDbtTask returns the value of the DbtTask field in ResolvedValues as
// a ResolvedDbtTaskValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetDbtTask(ctx context.Context) (ResolvedDbtTaskValues, bool) {
	var e ResolvedDbtTaskValues
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v ResolvedDbtTaskValues
	d := m.DbtTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtTask sets the value of the DbtTask field in ResolvedValues.
func (m *ResolvedValues) SetDbtTask(ctx context.Context, v ResolvedDbtTaskValues) {
	vs := v.ToObjectValue(ctx)
	m.DbtTask = vs
}

// GetNotebookTask returns the value of the NotebookTask field in ResolvedValues as
// a ResolvedNotebookTaskValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetNotebookTask(ctx context.Context) (ResolvedNotebookTaskValues, bool) {
	var e ResolvedNotebookTaskValues
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v ResolvedNotebookTaskValues
	d := m.NotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookTask sets the value of the NotebookTask field in ResolvedValues.
func (m *ResolvedValues) SetNotebookTask(ctx context.Context, v ResolvedNotebookTaskValues) {
	vs := v.ToObjectValue(ctx)
	m.NotebookTask = vs
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in ResolvedValues as
// a ResolvedPythonWheelTaskValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetPythonWheelTask(ctx context.Context) (ResolvedPythonWheelTaskValues, bool) {
	var e ResolvedPythonWheelTaskValues
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v ResolvedPythonWheelTaskValues
	d := m.PythonWheelTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in ResolvedValues.
func (m *ResolvedValues) SetPythonWheelTask(ctx context.Context, v ResolvedPythonWheelTaskValues) {
	vs := v.ToObjectValue(ctx)
	m.PythonWheelTask = vs
}

// GetRunJobTask returns the value of the RunJobTask field in ResolvedValues as
// a ResolvedRunJobTaskValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetRunJobTask(ctx context.Context) (ResolvedRunJobTaskValues, bool) {
	var e ResolvedRunJobTaskValues
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v ResolvedRunJobTaskValues
	d := m.RunJobTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunJobTask sets the value of the RunJobTask field in ResolvedValues.
func (m *ResolvedValues) SetRunJobTask(ctx context.Context, v ResolvedRunJobTaskValues) {
	vs := v.ToObjectValue(ctx)
	m.RunJobTask = vs
}

// GetSimulationTask returns the value of the SimulationTask field in ResolvedValues as
// a ResolvedParamPairValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetSimulationTask(ctx context.Context) (ResolvedParamPairValues, bool) {
	var e ResolvedParamPairValues
	if m.SimulationTask.IsNull() || m.SimulationTask.IsUnknown() {
		return e, false
	}
	var v ResolvedParamPairValues
	d := m.SimulationTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSimulationTask sets the value of the SimulationTask field in ResolvedValues.
func (m *ResolvedValues) SetSimulationTask(ctx context.Context, v ResolvedParamPairValues) {
	vs := v.ToObjectValue(ctx)
	m.SimulationTask = vs
}

// GetSparkJarTask returns the value of the SparkJarTask field in ResolvedValues as
// a ResolvedStringParamsValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetSparkJarTask(ctx context.Context) (ResolvedStringParamsValues, bool) {
	var e ResolvedStringParamsValues
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v ResolvedStringParamsValues
	d := m.SparkJarTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkJarTask sets the value of the SparkJarTask field in ResolvedValues.
func (m *ResolvedValues) SetSparkJarTask(ctx context.Context, v ResolvedStringParamsValues) {
	vs := v.ToObjectValue(ctx)
	m.SparkJarTask = vs
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in ResolvedValues as
// a ResolvedStringParamsValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetSparkPythonTask(ctx context.Context) (ResolvedStringParamsValues, bool) {
	var e ResolvedStringParamsValues
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v ResolvedStringParamsValues
	d := m.SparkPythonTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in ResolvedValues.
func (m *ResolvedValues) SetSparkPythonTask(ctx context.Context, v ResolvedStringParamsValues) {
	vs := v.ToObjectValue(ctx)
	m.SparkPythonTask = vs
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in ResolvedValues as
// a ResolvedStringParamsValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetSparkSubmitTask(ctx context.Context) (ResolvedStringParamsValues, bool) {
	var e ResolvedStringParamsValues
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v ResolvedStringParamsValues
	d := m.SparkSubmitTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in ResolvedValues.
func (m *ResolvedValues) SetSparkSubmitTask(ctx context.Context, v ResolvedStringParamsValues) {
	vs := v.ToObjectValue(ctx)
	m.SparkSubmitTask = vs
}

// GetSqlTask returns the value of the SqlTask field in ResolvedValues as
// a ResolvedParamPairValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *ResolvedValues) GetSqlTask(ctx context.Context) (ResolvedParamPairValues, bool) {
	var e ResolvedParamPairValues
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v ResolvedParamPairValues
	d := m.SqlTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlTask sets the value of the SqlTask field in ResolvedValues.
func (m *ResolvedValues) SetSqlTask(ctx context.Context, v ResolvedParamPairValues) {
	vs := v.ToObjectValue(ctx)
	m.SqlTask = vs
}

// Run was retrieved successfully
type Run struct {
	// The sequence number of this run attempt for a triggered job run. The
	// initial attempt of a run has an attempt_number of 0. If the initial run
	// attempt fails, and the job has a retry policy (`max_retries` > 0),
	// subsequent runs are created with an `original_attempt_run_id` of the
	// original attempt’s ID and an incrementing `attempt_number`. Runs are
	// retried only until they succeed, and the maximum `attempt_number` is the
	// same as the `max_retries` value for the job.
	AttemptNumber types.Int64 `tfsdk:"attempt_number"`
	// The time in milliseconds it took to terminate the cluster and clean up
	// any associated artifacts. The duration of a task run is the sum of the
	// `setup_duration`, `execution_duration`, and the `cleanup_duration`. The
	// `cleanup_duration` field is set to 0 for multitask job runs. The total
	// duration of a multitask job run is the value of the `run_duration` field.
	CleanupDuration types.Int64 `tfsdk:"cleanup_duration"`
	// The cluster used for this run. If the run is specified to use a new
	// cluster, this field is set once the Jobs service has requested a cluster
	// for the run.
	ClusterInstance types.Object `tfsdk:"cluster_instance"`
	// A snapshot of the job’s cluster specification when this run was
	// created.
	ClusterSpec types.Object `tfsdk:"cluster_spec"`
	// The creator user name. This field won’t be included in the response if
	// the user has already been deleted.
	CreatorUserName types.String `tfsdk:"creator_user_name"`
	// Description of the run
	Description types.String `tfsdk:"description"`
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// The id of the usage policy used by this run for cost attribution
	// purposes.
	EffectiveUsagePolicyId types.String `tfsdk:"effective_usage_policy_id"`
	// The time at which this run ended in epoch milliseconds (milliseconds
	// since 1/1/1970 UTC). This field is set to 0 if the job is still running.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The time in milliseconds it took to execute the commands in the JAR or
	// notebook until they completed, failed, timed out, were cancelled, or
	// encountered an unexpected error. The duration of a task run is the sum of
	// the `setup_duration`, `execution_duration`, and the `cleanup_duration`.
	// The `execution_duration` field is set to 0 for multitask job runs. The
	// total duration of a multitask job run is the value of the `run_duration`
	// field.
	ExecutionDuration types.Int64 `tfsdk:"execution_duration"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.Object `tfsdk:"git_source"`
	// Indicates if the run has more array properties (`tasks`, `job_clusters`)
	// that are not shown. They can be accessed via :method:jobs/getrun
	// endpoint. It is only relevant for API 2.2 :method:jobs/listruns requests
	// with `expand_tasks=true`.
	HasMore types.Bool `tfsdk:"has_more"`
	// Only populated by for-each iterations. The parent for-each task is
	// located in tasks array.
	Iterations types.List `tfsdk:"iterations"`
	// A list of job cluster specifications that can be shared and reused by
	// tasks of this job. Libraries cannot be declared in a shared job cluster.
	// You must declare dependent libraries in task settings. If more than 100
	// job clusters are available, you can paginate through them using
	// :method:jobs/getrun.
	JobClusters types.List `tfsdk:"job_clusters"`
	// The canonical identifier of the job that contains this run.
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used in the run
	JobParameters types.List `tfsdk:"job_parameters"`
	// ID of the job run that this run belongs to. For legacy and single-task
	// job runs the field is populated with the job run ID. For task runs, the
	// field is populated with the ID of the job run that the task run belongs
	// to.
	JobRunId types.Int64 `tfsdk:"job_run_id"`
	// A token that can be used to list the next page of array properties.
	NextPageToken types.String `tfsdk:"next_page_token"`
	// A unique identifier for this job run. This is set to the same value as
	// `run_id`.
	NumberInJob types.Int64 `tfsdk:"number_in_job"`
	// If this run is a retry of a prior run attempt, this field contains the
	// run_id of the original attempt; otherwise, it is the same as the run_id.
	OriginalAttemptRunId types.Int64 `tfsdk:"original_attempt_run_id"`
	// The parameters used for this run.
	OverridingParameters types.Object `tfsdk:"overriding_parameters"`
	// The time in milliseconds that the run has spent in the queue.
	QueueDuration types.Int64 `tfsdk:"queue_duration"`
	// The repair history of the run.
	RepairHistory types.List `tfsdk:"repair_history"`
	// The time in milliseconds it took the job run and all of its repairs to
	// finish.
	RunDuration types.Int64 `tfsdk:"run_duration"`
	// The canonical identifier of the run. This ID is unique across all runs of
	// all jobs.
	RunId types.Int64 `tfsdk:"run_id"`
	// An optional name for the run. The maximum length is 4096 bytes in UTF-8
	// encoding.
	RunName types.String `tfsdk:"run_name"`
	// The URL to the detail page of the run.
	RunPageUrl types.String `tfsdk:"run_page_url"`

	RunType types.String `tfsdk:"run_type"`
	// The cron schedule that triggered this run if it was triggered by the
	// periodic scheduler.
	Schedule types.Object `tfsdk:"schedule"`
	// The time in milliseconds it took to set up the cluster. For runs that run
	// on new clusters this is the cluster creation time, for runs that run on
	// existing clusters this time should be very short. The duration of a task
	// run is the sum of the `setup_duration`, `execution_duration`, and the
	// `cleanup_duration`. The `setup_duration` field is set to 0 for multitask
	// job runs. The total duration of a multitask job run is the value of the
	// `run_duration` field.
	SetupDuration types.Int64 `tfsdk:"setup_duration"`
	// The time at which this run was started in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC). This may not be the time when the job
	// task starts executing, for example, if the job is scheduled to run on a
	// new cluster, this is the time the cluster creation call is issued.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.Object `tfsdk:"state"`

	Status types.Object `tfsdk:"status"`
	// The list of tasks performed by the run. Each task has its own `run_id`
	// which you can use to call `JobsGetOutput` to retrieve the run resutls. If
	// more than 100 tasks are available, you can paginate through them using
	// :method:jobs/getrun. Use the `next_page_token` field at the object root
	// to determine if more results are available.
	Tasks types.List `tfsdk:"tasks"`

	Trigger types.String `tfsdk:"trigger"`

	TriggerInfo types.Object `tfsdk:"trigger_info"`
}

func (to *Run) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Run) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				// Recursively sync the fields of ClusterInstance
				toClusterInstance.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				// Recursively sync the fields of ClusterSpec
				toClusterSpec.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Iterations.IsNull() && !from.Iterations.IsUnknown() && to.Iterations.IsNull() && len(from.Iterations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Iterations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Iterations = from.Iterations
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				// Recursively sync the fields of OverridingParameters
				toOverridingParameters.SyncFieldsDuringCreateOrUpdate(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				// Recursively sync the fields of Schedule
				toSchedule.SyncFieldsDuringCreateOrUpdate(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				// Recursively sync the fields of TriggerInfo
				toTriggerInfo.SyncFieldsDuringCreateOrUpdate(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (to *Run) SyncFieldsDuringRead(ctx context.Context, from Run) {
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				toClusterInstance.SyncFieldsDuringRead(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ClusterSpec.IsNull() && !from.ClusterSpec.IsUnknown() {
		if toClusterSpec, ok := to.GetClusterSpec(ctx); ok {
			if fromClusterSpec, ok := from.GetClusterSpec(ctx); ok {
				toClusterSpec.SyncFieldsDuringRead(ctx, fromClusterSpec)
				to.SetClusterSpec(ctx, toClusterSpec)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Iterations.IsNull() && !from.Iterations.IsUnknown() && to.Iterations.IsNull() && len(from.Iterations.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Iterations, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Iterations = from.Iterations
	}
	if !from.JobClusters.IsNull() && !from.JobClusters.IsUnknown() && to.JobClusters.IsNull() && len(from.JobClusters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobClusters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobClusters = from.JobClusters
	}
	if !from.JobParameters.IsNull() && !from.JobParameters.IsUnknown() && to.JobParameters.IsNull() && len(from.JobParameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JobParameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JobParameters = from.JobParameters
	}
	if !from.OverridingParameters.IsNull() && !from.OverridingParameters.IsUnknown() {
		if toOverridingParameters, ok := to.GetOverridingParameters(ctx); ok {
			if fromOverridingParameters, ok := from.GetOverridingParameters(ctx); ok {
				toOverridingParameters.SyncFieldsDuringRead(ctx, fromOverridingParameters)
				to.SetOverridingParameters(ctx, toOverridingParameters)
			}
		}
	}
	if !from.RepairHistory.IsNull() && !from.RepairHistory.IsUnknown() && to.RepairHistory.IsNull() && len(from.RepairHistory.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for RepairHistory, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.RepairHistory = from.RepairHistory
	}
	if !from.Schedule.IsNull() && !from.Schedule.IsUnknown() {
		if toSchedule, ok := to.GetSchedule(ctx); ok {
			if fromSchedule, ok := from.GetSchedule(ctx); ok {
				toSchedule.SyncFieldsDuringRead(ctx, fromSchedule)
				to.SetSchedule(ctx, toSchedule)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.TriggerInfo.IsNull() && !from.TriggerInfo.IsUnknown() {
		if toTriggerInfo, ok := to.GetTriggerInfo(ctx); ok {
			if fromTriggerInfo, ok := from.GetTriggerInfo(ctx); ok {
				toTriggerInfo.SyncFieldsDuringRead(ctx, fromTriggerInfo)
				to.SetTriggerInfo(ctx, toTriggerInfo)
			}
		}
	}
}

func (m Run) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attempt_number"] = attrs["attempt_number"].SetOptional()
	attrs["cleanup_duration"] = attrs["cleanup_duration"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].SetOptional()
	attrs["cluster_spec"] = attrs["cluster_spec"].SetOptional()
	attrs["creator_user_name"] = attrs["creator_user_name"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetOptional()
	attrs["effective_usage_policy_id"] = attrs["effective_usage_policy_id"].SetComputed()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["execution_duration"] = attrs["execution_duration"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["has_more"] = attrs["has_more"].SetOptional()
	attrs["iterations"] = attrs["iterations"].SetOptional()
	attrs["job_clusters"] = attrs["job_clusters"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetOptional()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["job_run_id"] = attrs["job_run_id"].SetOptional()
	attrs["next_page_token"] = attrs["next_page_token"].SetOptional()
	attrs["number_in_job"] = attrs["number_in_job"].SetOptional()
	attrs["original_attempt_run_id"] = attrs["original_attempt_run_id"].SetOptional()
	attrs["overriding_parameters"] = attrs["overriding_parameters"].SetOptional()
	attrs["queue_duration"] = attrs["queue_duration"].SetOptional()
	attrs["repair_history"] = attrs["repair_history"].SetOptional()
	attrs["run_duration"] = attrs["run_duration"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_name"] = attrs["run_name"].SetOptional()
	attrs["run_page_url"] = attrs["run_page_url"].SetOptional()
	attrs["run_type"] = attrs["run_type"].SetOptional()
	attrs["schedule"] = attrs["schedule"].SetOptional()
	attrs["setup_duration"] = attrs["setup_duration"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["tasks"] = attrs["tasks"].SetOptional()
	attrs["trigger"] = attrs["trigger"].SetOptional()
	attrs["trigger_info"] = attrs["trigger_info"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Run.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Run) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"cluster_instance":      reflect.TypeOf(ClusterInstance{}),
		"cluster_spec":          reflect.TypeOf(ClusterSpec{}),
		"git_source":            reflect.TypeOf(GitSource{}),
		"iterations":            reflect.TypeOf(RunTask{}),
		"job_clusters":          reflect.TypeOf(JobCluster{}),
		"job_parameters":        reflect.TypeOf(JobParameter{}),
		"overriding_parameters": reflect.TypeOf(RunParameters{}),
		"repair_history":        reflect.TypeOf(RepairHistoryItem{}),
		"schedule":              reflect.TypeOf(CronSchedule{}),
		"state":                 reflect.TypeOf(RunState{}),
		"status":                reflect.TypeOf(RunStatus{}),
		"tasks":                 reflect.TypeOf(RunTask{}),
		"trigger_info":          reflect.TypeOf(TriggerInfo{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Run
// only implements ToObjectValue() and Type().
func (m Run) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attempt_number":               m.AttemptNumber,
			"cleanup_duration":             m.CleanupDuration,
			"cluster_instance":             m.ClusterInstance,
			"cluster_spec":                 m.ClusterSpec,
			"creator_user_name":            m.CreatorUserName,
			"description":                  m.Description,
			"effective_performance_target": m.EffectivePerformanceTarget,
			"effective_usage_policy_id":    m.EffectiveUsagePolicyId,
			"end_time":                     m.EndTime,
			"execution_duration":           m.ExecutionDuration,
			"git_source":                   m.GitSource,
			"has_more":                     m.HasMore,
			"iterations":                   m.Iterations,
			"job_clusters":                 m.JobClusters,
			"job_id":                       m.JobId,
			"job_parameters":               m.JobParameters,
			"job_run_id":                   m.JobRunId,
			"next_page_token":              m.NextPageToken,
			"number_in_job":                m.NumberInJob,
			"original_attempt_run_id":      m.OriginalAttemptRunId,
			"overriding_parameters":        m.OverridingParameters,
			"queue_duration":               m.QueueDuration,
			"repair_history":               m.RepairHistory,
			"run_duration":                 m.RunDuration,
			"run_id":                       m.RunId,
			"run_name":                     m.RunName,
			"run_page_url":                 m.RunPageUrl,
			"run_type":                     m.RunType,
			"schedule":                     m.Schedule,
			"setup_duration":               m.SetupDuration,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"tasks":                        m.Tasks,
			"trigger":                      m.Trigger,
			"trigger_info":                 m.TriggerInfo,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Run) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attempt_number":               types.Int64Type,
			"cleanup_duration":             types.Int64Type,
			"cluster_instance":             ClusterInstance{}.Type(ctx),
			"cluster_spec":                 ClusterSpec{}.Type(ctx),
			"creator_user_name":            types.StringType,
			"description":                  types.StringType,
			"effective_performance_target": types.StringType,
			"effective_usage_policy_id":    types.StringType,
			"end_time":                     types.Int64Type,
			"execution_duration":           types.Int64Type,
			"git_source":                   GitSource{}.Type(ctx),
			"has_more":                     types.BoolType,
			"iterations": basetypes.ListType{
				ElemType: RunTask{}.Type(ctx),
			},
			"job_clusters": basetypes.ListType{
				ElemType: JobCluster{}.Type(ctx),
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.ListType{
				ElemType: JobParameter{}.Type(ctx),
			},
			"job_run_id":              types.Int64Type,
			"next_page_token":         types.StringType,
			"number_in_job":           types.Int64Type,
			"original_attempt_run_id": types.Int64Type,
			"overriding_parameters":   RunParameters{}.Type(ctx),
			"queue_duration":          types.Int64Type,
			"repair_history": basetypes.ListType{
				ElemType: RepairHistoryItem{}.Type(ctx),
			},
			"run_duration":   types.Int64Type,
			"run_id":         types.Int64Type,
			"run_name":       types.StringType,
			"run_page_url":   types.StringType,
			"run_type":       types.StringType,
			"schedule":       CronSchedule{}.Type(ctx),
			"setup_duration": types.Int64Type,
			"start_time":     types.Int64Type,
			"state":          RunState{}.Type(ctx),
			"status":         RunStatus{}.Type(ctx),
			"tasks": basetypes.ListType{
				ElemType: RunTask{}.Type(ctx),
			},
			"trigger":      types.StringType,
			"trigger_info": TriggerInfo{}.Type(ctx),
		},
	}
}

// GetClusterInstance returns the value of the ClusterInstance field in Run as
// a ClusterInstance value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetClusterInstance(ctx context.Context) (ClusterInstance, bool) {
	var e ClusterInstance
	if m.ClusterInstance.IsNull() || m.ClusterInstance.IsUnknown() {
		return e, false
	}
	var v ClusterInstance
	d := m.ClusterInstance.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetClusterInstance sets the value of the ClusterInstance field in Run.
func (m *Run) SetClusterInstance(ctx context.Context, v ClusterInstance) {
	vs := v.ToObjectValue(ctx)
	m.ClusterInstance = vs
}

// GetClusterSpec returns the value of the ClusterSpec field in Run as
// a ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetClusterSpec(ctx context.Context) (ClusterSpec, bool) {
	var e ClusterSpec
	if m.ClusterSpec.IsNull() || m.ClusterSpec.IsUnknown() {
		return e, false
	}
	var v ClusterSpec
	d := m.ClusterSpec.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetClusterSpec sets the value of the ClusterSpec field in Run.
func (m *Run) SetClusterSpec(ctx context.Context, v ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.ClusterSpec = vs
}

// GetGitSource returns the value of the GitSource field in Run as
// a GitSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetGitSource(ctx context.Context) (GitSource, bool) {
	var e GitSource
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v GitSource
	d := m.GitSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSource sets the value of the GitSource field in Run.
func (m *Run) SetGitSource(ctx context.Context, v GitSource) {
	vs := v.ToObjectValue(ctx)
	m.GitSource = vs
}

// GetIterations returns the value of the Iterations field in Run as
// a slice of RunTask values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetIterations(ctx context.Context) ([]RunTask, bool) {
	if m.Iterations.IsNull() || m.Iterations.IsUnknown() {
		return nil, false
	}
	var v []RunTask
	d := m.Iterations.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetIterations sets the value of the Iterations field in Run.
func (m *Run) SetIterations(ctx context.Context, v []RunTask) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["iterations"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Iterations = types.ListValueMust(t, vs)
}

// GetJobClusters returns the value of the JobClusters field in Run as
// a slice of JobCluster values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetJobClusters(ctx context.Context) ([]JobCluster, bool) {
	if m.JobClusters.IsNull() || m.JobClusters.IsUnknown() {
		return nil, false
	}
	var v []JobCluster
	d := m.JobClusters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobClusters sets the value of the JobClusters field in Run.
func (m *Run) SetJobClusters(ctx context.Context, v []JobCluster) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_clusters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobClusters = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in Run as
// a slice of JobParameter values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetJobParameters(ctx context.Context) ([]JobParameter, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v []JobParameter
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in Run.
func (m *Run) SetJobParameters(ctx context.Context, v []JobParameter) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.ListValueMust(t, vs)
}

// GetOverridingParameters returns the value of the OverridingParameters field in Run as
// a RunParameters value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetOverridingParameters(ctx context.Context) (RunParameters, bool) {
	var e RunParameters
	if m.OverridingParameters.IsNull() || m.OverridingParameters.IsUnknown() {
		return e, false
	}
	var v RunParameters
	d := m.OverridingParameters.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOverridingParameters sets the value of the OverridingParameters field in Run.
func (m *Run) SetOverridingParameters(ctx context.Context, v RunParameters) {
	vs := v.ToObjectValue(ctx)
	m.OverridingParameters = vs
}

// GetRepairHistory returns the value of the RepairHistory field in Run as
// a slice of RepairHistoryItem values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetRepairHistory(ctx context.Context) ([]RepairHistoryItem, bool) {
	if m.RepairHistory.IsNull() || m.RepairHistory.IsUnknown() {
		return nil, false
	}
	var v []RepairHistoryItem
	d := m.RepairHistory.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRepairHistory sets the value of the RepairHistory field in Run.
func (m *Run) SetRepairHistory(ctx context.Context, v []RepairHistoryItem) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["repair_history"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.RepairHistory = types.ListValueMust(t, vs)
}

// GetSchedule returns the value of the Schedule field in Run as
// a CronSchedule value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetSchedule(ctx context.Context) (CronSchedule, bool) {
	var e CronSchedule
	if m.Schedule.IsNull() || m.Schedule.IsUnknown() {
		return e, false
	}
	var v CronSchedule
	d := m.Schedule.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSchedule sets the value of the Schedule field in Run.
func (m *Run) SetSchedule(ctx context.Context, v CronSchedule) {
	vs := v.ToObjectValue(ctx)
	m.Schedule = vs
}

// GetState returns the value of the State field in Run as
// a RunState value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetState(ctx context.Context) (RunState, bool) {
	var e RunState
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v RunState
	d := m.State.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetState sets the value of the State field in Run.
func (m *Run) SetState(ctx context.Context, v RunState) {
	vs := v.ToObjectValue(ctx)
	m.State = vs
}

// GetStatus returns the value of the Status field in Run as
// a RunStatus value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetStatus(ctx context.Context) (RunStatus, bool) {
	var e RunStatus
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v RunStatus
	d := m.Status.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStatus sets the value of the Status field in Run.
func (m *Run) SetStatus(ctx context.Context, v RunStatus) {
	vs := v.ToObjectValue(ctx)
	m.Status = vs
}

// GetTasks returns the value of the Tasks field in Run as
// a slice of RunTask values.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetTasks(ctx context.Context) ([]RunTask, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []RunTask
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in Run.
func (m *Run) SetTasks(ctx context.Context, v []RunTask) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetTriggerInfo returns the value of the TriggerInfo field in Run as
// a TriggerInfo value.
// If the field is unknown or null, the boolean return value is false.
func (m *Run) GetTriggerInfo(ctx context.Context) (TriggerInfo, bool) {
	var e TriggerInfo
	if m.TriggerInfo.IsNull() || m.TriggerInfo.IsUnknown() {
		return e, false
	}
	var v TriggerInfo
	d := m.TriggerInfo.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTriggerInfo sets the value of the TriggerInfo field in Run.
func (m *Run) SetTriggerInfo(ctx context.Context, v TriggerInfo) {
	vs := v.ToObjectValue(ctx)
	m.TriggerInfo = vs
}

type RunConditionTask struct {
	// The left operand of the condition task. Can be either a string value or a
	// job state or parameter reference.
	Left types.String `tfsdk:"left"`
	// * `EQUAL_TO`, `NOT_EQUAL` operators perform string comparison of their
	// operands. This means that `“12.0” == “12”` will evaluate to
	// `false`. * `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`,
	// `LESS_THAN_OR_EQUAL` operators perform numeric comparison of their
	// operands. `“12.0” >= “12”` will evaluate to `true`, `“10.0”
	// >= “12”` will evaluate to `false`.
	//
	// The boolean comparison to task values can be implemented with operators
	// `EQUAL_TO`, `NOT_EQUAL`. If a task value was set to a boolean value, it
	// will be serialized to `“true”` or `“false”` for the comparison.
	Op types.String `tfsdk:"op"`
	// The condition expression evaluation result. Filled in if the task was
	// successfully completed. Can be `"true"` or `"false"`
	Outcome types.String `tfsdk:"outcome"`
	// The right operand of the condition task. Can be either a string value or
	// a job state or parameter reference.
	Right types.String `tfsdk:"right"`
}

func (to *RunConditionTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunConditionTask) {
}

func (to *RunConditionTask) SyncFieldsDuringRead(ctx context.Context, from RunConditionTask) {
}

func (m RunConditionTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["left"] = attrs["left"].SetRequired()
	attrs["op"] = attrs["op"].SetRequired()
	attrs["outcome"] = attrs["outcome"].SetOptional()
	attrs["right"] = attrs["right"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunConditionTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunConditionTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunConditionTask
// only implements ToObjectValue() and Type().
func (m RunConditionTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"left":    m.Left,
			"op":      m.Op,
			"outcome": m.Outcome,
			"right":   m.Right,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunConditionTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"left":    types.StringType,
			"op":      types.StringType,
			"outcome": types.StringType,
			"right":   types.StringType,
		},
	}
}

type RunForEachTask struct {
	// An optional maximum allowed number of concurrent runs of the task. Set
	// this value if you want to be able to execute multiple runs of the task
	// concurrently.
	Concurrency types.Int64 `tfsdk:"concurrency"`
	// Array for task to iterate on. This can be a JSON string or a reference to
	// an array parameter.
	Inputs types.String `tfsdk:"inputs"`
	// Read only field. Populated for GetRun and ListRuns RPC calls and stores
	// the execution stats of an For each task
	Stats types.Object `tfsdk:"stats"`
	// Configuration for the task that will be run for each element in the array
	Task types.Object `tfsdk:"task"`
}

func (to *RunForEachTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunForEachTask) {
	if !from.Stats.IsNull() && !from.Stats.IsUnknown() {
		if toStats, ok := to.GetStats(ctx); ok {
			if fromStats, ok := from.GetStats(ctx); ok {
				// Recursively sync the fields of Stats
				toStats.SyncFieldsDuringCreateOrUpdate(ctx, fromStats)
				to.SetStats(ctx, toStats)
			}
		}
	}
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				// Recursively sync the fields of Task
				toTask.SyncFieldsDuringCreateOrUpdate(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (to *RunForEachTask) SyncFieldsDuringRead(ctx context.Context, from RunForEachTask) {
	if !from.Stats.IsNull() && !from.Stats.IsUnknown() {
		if toStats, ok := to.GetStats(ctx); ok {
			if fromStats, ok := from.GetStats(ctx); ok {
				toStats.SyncFieldsDuringRead(ctx, fromStats)
				to.SetStats(ctx, toStats)
			}
		}
	}
	if !from.Task.IsNull() && !from.Task.IsUnknown() {
		if toTask, ok := to.GetTask(ctx); ok {
			if fromTask, ok := from.GetTask(ctx); ok {
				toTask.SyncFieldsDuringRead(ctx, fromTask)
				to.SetTask(ctx, toTask)
			}
		}
	}
}

func (m RunForEachTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["concurrency"] = attrs["concurrency"].SetOptional()
	attrs["inputs"] = attrs["inputs"].SetRequired()
	attrs["stats"] = attrs["stats"].SetOptional()
	attrs["task"] = attrs["task"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunForEachTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunForEachTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"stats": reflect.TypeOf(ForEachStats{}),
		"task":  reflect.TypeOf(Task{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunForEachTask
// only implements ToObjectValue() and Type().
func (m RunForEachTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"concurrency": m.Concurrency,
			"inputs":      m.Inputs,
			"stats":       m.Stats,
			"task":        m.Task,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunForEachTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"concurrency": types.Int64Type,
			"inputs":      types.StringType,
			"stats":       ForEachStats{}.Type(ctx),
			"task":        Task{}.Type(ctx),
		},
	}
}

// GetStats returns the value of the Stats field in RunForEachTask as
// a ForEachStats value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunForEachTask) GetStats(ctx context.Context) (ForEachStats, bool) {
	var e ForEachStats
	if m.Stats.IsNull() || m.Stats.IsUnknown() {
		return e, false
	}
	var v ForEachStats
	d := m.Stats.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStats sets the value of the Stats field in RunForEachTask.
func (m *RunForEachTask) SetStats(ctx context.Context, v ForEachStats) {
	vs := v.ToObjectValue(ctx)
	m.Stats = vs
}

// GetTask returns the value of the Task field in RunForEachTask as
// a Task value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunForEachTask) GetTask(ctx context.Context) (Task, bool) {
	var e Task
	if m.Task.IsNull() || m.Task.IsUnknown() {
		return e, false
	}
	var v Task
	d := m.Task.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTask sets the value of the Task field in RunForEachTask.
func (m *RunForEachTask) SetTask(ctx context.Context, v Task) {
	vs := v.ToObjectValue(ctx)
	m.Task = vs
}

type RunJobOutput struct {
	// The run id of the triggered job run
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *RunJobOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunJobOutput) {
}

func (to *RunJobOutput) SyncFieldsDuringRead(ctx context.Context, from RunJobOutput) {
}

func (m RunJobOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunJobOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunJobOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunJobOutput
// only implements ToObjectValue() and Type().
func (m RunJobOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunJobOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type RunJobTask struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// ID of the job to trigger.
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used to trigger the job.
	JobParameters types.Map `tfsdk:"job_parameters"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.Object `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RunJobTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunJobTask) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RunJobTask) SyncFieldsDuringRead(ctx context.Context, from RunJobTask) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RunJobTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunJobTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunJobTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"job_parameters":      reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunJobTask
// only implements ToObjectValue() and Type().
func (m RunJobTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":        m.DbtCommands,
			"jar_params":          m.JarParams,
			"job_id":              m.JobId,
			"job_parameters":      m.JobParameters,
			"notebook_params":     m.NotebookParams,
			"pipeline_params":     m.PipelineParams,
			"python_named_params": m.PythonNamedParams,
			"python_params":       m.PythonParams,
			"spark_submit_params": m.SparkSubmitParams,
			"sql_params":          m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunJobTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"pipeline_params": PipelineParams{}.Type(ctx),
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RunJobTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RunJobTask.
func (m *RunJobTask) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RunJobTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RunJobTask.
func (m *RunJobTask) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in RunJobTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in RunJobTask.
func (m *RunJobTask) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RunJobTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RunJobTask.
func (m *RunJobTask) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RunJobTask as
// a PipelineParams value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetPipelineParams(ctx context.Context) (PipelineParams, bool) {
	var e PipelineParams
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v PipelineParams
	d := m.PipelineParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineParams sets the value of the PipelineParams field in RunJobTask.
func (m *RunJobTask) SetPipelineParams(ctx context.Context, v PipelineParams) {
	vs := v.ToObjectValue(ctx)
	m.PipelineParams = vs
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RunJobTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RunJobTask.
func (m *RunJobTask) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RunJobTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RunJobTask.
func (m *RunJobTask) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RunJobTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RunJobTask.
func (m *RunJobTask) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RunJobTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunJobTask) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RunJobTask.
func (m *RunJobTask) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

type RunNow struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// An optional token to guarantee the idempotency of job run requests. If a
	// run with the provided token already exists, the request does not create a
	// new run but returns the ID of the existing run instead. If a run with the
	// provided token is deleted, an error is returned.
	//
	// If you specify the idempotency token, upon failure you can retry until
	// the request succeeds. Databricks guarantees that exactly one run is
	// launched with that idempotency token.
	//
	// This token must have at most 64 characters.
	//
	// For more information, see [How to ensure idempotency for jobs].
	//
	// [How to ensure idempotency for jobs]: https://kb.databricks.com/jobs/jobs-idempotency.html
	IdempotencyToken types.String `tfsdk:"idempotency_token"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// The ID of the job to be executed
	JobId types.Int64 `tfsdk:"job_id"`
	// Job-level parameters used in the run. for example `"param":
	// "overriding_val"`
	JobParameters types.Map `tfsdk:"job_parameters"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// A list of task keys to run inside of the job. If this field is not
	// provided, all tasks in the job will be run.
	Only types.List `tfsdk:"only"`
	// The performance mode on a serverless job. The performance target
	// determines the level of compute performance or cost-efficiency for the
	// run. This field overrides the performance target defined on the job
	// level.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	PerformanceTarget types.String `tfsdk:"performance_target"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.Object `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// The queue settings of the run.
	Queue types.Object `tfsdk:"queue"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RunNow) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunNow) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.Only.IsNull() && !from.Only.IsUnknown() && to.Only.IsNull() && len(from.Only.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Only, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Only = from.Only
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RunNow) SyncFieldsDuringRead(ctx context.Context, from RunNow) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.Only.IsNull() && !from.Only.IsUnknown() && to.Only.IsNull() && len(from.Only.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Only, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Only = from.Only
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RunNow) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["idempotency_token"] = attrs["idempotency_token"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["job_parameters"] = attrs["job_parameters"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["only"] = attrs["only"].SetOptional()
	attrs["performance_target"] = attrs["performance_target"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunNow.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunNow) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"job_parameters":      reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"only":                reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"queue":               reflect.TypeOf(QueueSettings{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunNow
// only implements ToObjectValue() and Type().
func (m RunNow) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":        m.DbtCommands,
			"idempotency_token":   m.IdempotencyToken,
			"jar_params":          m.JarParams,
			"job_id":              m.JobId,
			"job_parameters":      m.JobParameters,
			"notebook_params":     m.NotebookParams,
			"only":                m.Only,
			"performance_target":  m.PerformanceTarget,
			"pipeline_params":     m.PipelineParams,
			"python_named_params": m.PythonNamedParams,
			"python_params":       m.PythonParams,
			"queue":               m.Queue,
			"spark_submit_params": m.SparkSubmitParams,
			"sql_params":          m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunNow) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"idempotency_token": types.StringType,
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_id": types.Int64Type,
			"job_parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"only": basetypes.ListType{
				ElemType: types.StringType,
			},
			"performance_target": types.StringType,
			"pipeline_params":    PipelineParams{}.Type(ctx),
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"queue": QueueSettings{}.Type(ctx),
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RunNow as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RunNow.
func (m *RunNow) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RunNow as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RunNow.
func (m *RunNow) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetJobParameters returns the value of the JobParameters field in RunNow as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetJobParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.JobParameters.IsNull() || m.JobParameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.JobParameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJobParameters sets the value of the JobParameters field in RunNow.
func (m *RunNow) SetJobParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["job_parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JobParameters = types.MapValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RunNow as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RunNow.
func (m *RunNow) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetOnly returns the value of the Only field in RunNow as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetOnly(ctx context.Context) ([]types.String, bool) {
	if m.Only.IsNull() || m.Only.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Only.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnly sets the value of the Only field in RunNow.
func (m *RunNow) SetOnly(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["only"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Only = types.ListValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RunNow as
// a PipelineParams value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetPipelineParams(ctx context.Context) (PipelineParams, bool) {
	var e PipelineParams
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v PipelineParams
	d := m.PipelineParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineParams sets the value of the PipelineParams field in RunNow.
func (m *RunNow) SetPipelineParams(ctx context.Context, v PipelineParams) {
	vs := v.ToObjectValue(ctx)
	m.PipelineParams = vs
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RunNow as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RunNow.
func (m *RunNow) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RunNow as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RunNow.
func (m *RunNow) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetQueue returns the value of the Queue field in RunNow as
// a QueueSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetQueue(ctx context.Context) (QueueSettings, bool) {
	var e QueueSettings
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v QueueSettings
	d := m.Queue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueue sets the value of the Queue field in RunNow.
func (m *RunNow) SetQueue(ctx context.Context, v QueueSettings) {
	vs := v.ToObjectValue(ctx)
	m.Queue = vs
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RunNow as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RunNow.
func (m *RunNow) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RunNow as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunNow) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RunNow.
func (m *RunNow) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

// Run was started successfully.
type RunNowResponse struct {
	// A unique identifier for this job run. This is set to the same value as
	// `run_id`.
	NumberInJob types.Int64 `tfsdk:"number_in_job"`
	// The globally unique ID of the newly triggered run.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *RunNowResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunNowResponse) {
}

func (to *RunNowResponse) SyncFieldsDuringRead(ctx context.Context, from RunNowResponse) {
}

func (m RunNowResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["number_in_job"] = attrs["number_in_job"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunNowResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunNowResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunNowResponse
// only implements ToObjectValue() and Type().
func (m RunNowResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"number_in_job": m.NumberInJob,
			"run_id":        m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunNowResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"number_in_job": types.Int64Type,
			"run_id":        types.Int64Type,
		},
	}
}

// Run output was retrieved successfully.
type RunOutput struct {
	// The output of a clean rooms notebook task, if available
	CleanRoomsNotebookOutput types.Object `tfsdk:"clean_rooms_notebook_output"`
	// The output of a dashboard task, if available
	DashboardOutput types.Object `tfsdk:"dashboard_output"`
	// Deprecated in favor of the new dbt_platform_output
	DbtCloudOutput types.Object `tfsdk:"dbt_cloud_output"`
	// The output of a dbt task, if available.
	DbtOutput types.Object `tfsdk:"dbt_output"`

	DbtPlatformOutput types.Object `tfsdk:"dbt_platform_output"`
	// An error message indicating why a task failed or why output is not
	// available. The message is unstructured, and its exact format is subject
	// to change.
	Error types.String `tfsdk:"error"`
	// If there was an error executing the run, this field contains any
	// available stack traces.
	ErrorTrace types.String `tfsdk:"error_trace"`

	Info types.String `tfsdk:"info"`
	// The output from tasks that write to standard streams (stdout/stderr) such
	// as spark_jar_task, spark_python_task, python_wheel_task.
	//
	// It's not supported for the notebook_task, pipeline_task or
	// spark_submit_task.
	//
	// Databricks restricts this API to return the last 5 MB of these logs.
	Logs types.String `tfsdk:"logs"`
	// Whether the logs are truncated.
	LogsTruncated types.Bool `tfsdk:"logs_truncated"`
	// All details of the run except for its output.
	Metadata types.Object `tfsdk:"metadata"`
	// The output of a notebook task, if available. A notebook task that
	// terminates (either successfully or with a failure) without calling
	// `dbutils.notebook.exit()` is considered to have an empty output. This
	// field is set but its result value is empty. Databricks restricts this API
	// to return the first 5 MB of the output. To return a larger result, use
	// the [ClusterLogConf] field to configure log storage for the job cluster.
	//
	// [ClusterLogConf]: https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterlogconf
	NotebookOutput types.Object `tfsdk:"notebook_output"`
	// The output of a run job task, if available
	RunJobOutput types.Object `tfsdk:"run_job_output"`
	// The output of a SQL task, if available.
	SqlOutput types.Object `tfsdk:"sql_output"`
}

func (to *RunOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunOutput) {
	if !from.CleanRoomsNotebookOutput.IsNull() && !from.CleanRoomsNotebookOutput.IsUnknown() {
		if toCleanRoomsNotebookOutput, ok := to.GetCleanRoomsNotebookOutput(ctx); ok {
			if fromCleanRoomsNotebookOutput, ok := from.GetCleanRoomsNotebookOutput(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookOutput
				toCleanRoomsNotebookOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookOutput)
				to.SetCleanRoomsNotebookOutput(ctx, toCleanRoomsNotebookOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				// Recursively sync the fields of DashboardOutput
				toDashboardOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.DbtCloudOutput.IsNull() && !from.DbtCloudOutput.IsUnknown() {
		if toDbtCloudOutput, ok := to.GetDbtCloudOutput(ctx); ok {
			if fromDbtCloudOutput, ok := from.GetDbtCloudOutput(ctx); ok {
				// Recursively sync the fields of DbtCloudOutput
				toDbtCloudOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudOutput)
				to.SetDbtCloudOutput(ctx, toDbtCloudOutput)
			}
		}
	}
	if !from.DbtOutput.IsNull() && !from.DbtOutput.IsUnknown() {
		if toDbtOutput, ok := to.GetDbtOutput(ctx); ok {
			if fromDbtOutput, ok := from.GetDbtOutput(ctx); ok {
				// Recursively sync the fields of DbtOutput
				toDbtOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtOutput)
				to.SetDbtOutput(ctx, toDbtOutput)
			}
		}
	}
	if !from.DbtPlatformOutput.IsNull() && !from.DbtPlatformOutput.IsUnknown() {
		if toDbtPlatformOutput, ok := to.GetDbtPlatformOutput(ctx); ok {
			if fromDbtPlatformOutput, ok := from.GetDbtPlatformOutput(ctx); ok {
				// Recursively sync the fields of DbtPlatformOutput
				toDbtPlatformOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformOutput)
				to.SetDbtPlatformOutput(ctx, toDbtPlatformOutput)
			}
		}
	}
	if !from.Metadata.IsNull() && !from.Metadata.IsUnknown() {
		if toMetadata, ok := to.GetMetadata(ctx); ok {
			if fromMetadata, ok := from.GetMetadata(ctx); ok {
				// Recursively sync the fields of Metadata
				toMetadata.SyncFieldsDuringCreateOrUpdate(ctx, fromMetadata)
				to.SetMetadata(ctx, toMetadata)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				// Recursively sync the fields of NotebookOutput
				toNotebookOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.RunJobOutput.IsNull() && !from.RunJobOutput.IsUnknown() {
		if toRunJobOutput, ok := to.GetRunJobOutput(ctx); ok {
			if fromRunJobOutput, ok := from.GetRunJobOutput(ctx); ok {
				// Recursively sync the fields of RunJobOutput
				toRunJobOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobOutput)
				to.SetRunJobOutput(ctx, toRunJobOutput)
			}
		}
	}
	if !from.SqlOutput.IsNull() && !from.SqlOutput.IsUnknown() {
		if toSqlOutput, ok := to.GetSqlOutput(ctx); ok {
			if fromSqlOutput, ok := from.GetSqlOutput(ctx); ok {
				// Recursively sync the fields of SqlOutput
				toSqlOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlOutput)
				to.SetSqlOutput(ctx, toSqlOutput)
			}
		}
	}
}

func (to *RunOutput) SyncFieldsDuringRead(ctx context.Context, from RunOutput) {
	if !from.CleanRoomsNotebookOutput.IsNull() && !from.CleanRoomsNotebookOutput.IsUnknown() {
		if toCleanRoomsNotebookOutput, ok := to.GetCleanRoomsNotebookOutput(ctx); ok {
			if fromCleanRoomsNotebookOutput, ok := from.GetCleanRoomsNotebookOutput(ctx); ok {
				toCleanRoomsNotebookOutput.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookOutput)
				to.SetCleanRoomsNotebookOutput(ctx, toCleanRoomsNotebookOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				toDashboardOutput.SyncFieldsDuringRead(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.DbtCloudOutput.IsNull() && !from.DbtCloudOutput.IsUnknown() {
		if toDbtCloudOutput, ok := to.GetDbtCloudOutput(ctx); ok {
			if fromDbtCloudOutput, ok := from.GetDbtCloudOutput(ctx); ok {
				toDbtCloudOutput.SyncFieldsDuringRead(ctx, fromDbtCloudOutput)
				to.SetDbtCloudOutput(ctx, toDbtCloudOutput)
			}
		}
	}
	if !from.DbtOutput.IsNull() && !from.DbtOutput.IsUnknown() {
		if toDbtOutput, ok := to.GetDbtOutput(ctx); ok {
			if fromDbtOutput, ok := from.GetDbtOutput(ctx); ok {
				toDbtOutput.SyncFieldsDuringRead(ctx, fromDbtOutput)
				to.SetDbtOutput(ctx, toDbtOutput)
			}
		}
	}
	if !from.DbtPlatformOutput.IsNull() && !from.DbtPlatformOutput.IsUnknown() {
		if toDbtPlatformOutput, ok := to.GetDbtPlatformOutput(ctx); ok {
			if fromDbtPlatformOutput, ok := from.GetDbtPlatformOutput(ctx); ok {
				toDbtPlatformOutput.SyncFieldsDuringRead(ctx, fromDbtPlatformOutput)
				to.SetDbtPlatformOutput(ctx, toDbtPlatformOutput)
			}
		}
	}
	if !from.Metadata.IsNull() && !from.Metadata.IsUnknown() {
		if toMetadata, ok := to.GetMetadata(ctx); ok {
			if fromMetadata, ok := from.GetMetadata(ctx); ok {
				toMetadata.SyncFieldsDuringRead(ctx, fromMetadata)
				to.SetMetadata(ctx, toMetadata)
			}
		}
	}
	if !from.NotebookOutput.IsNull() && !from.NotebookOutput.IsUnknown() {
		if toNotebookOutput, ok := to.GetNotebookOutput(ctx); ok {
			if fromNotebookOutput, ok := from.GetNotebookOutput(ctx); ok {
				toNotebookOutput.SyncFieldsDuringRead(ctx, fromNotebookOutput)
				to.SetNotebookOutput(ctx, toNotebookOutput)
			}
		}
	}
	if !from.RunJobOutput.IsNull() && !from.RunJobOutput.IsUnknown() {
		if toRunJobOutput, ok := to.GetRunJobOutput(ctx); ok {
			if fromRunJobOutput, ok := from.GetRunJobOutput(ctx); ok {
				toRunJobOutput.SyncFieldsDuringRead(ctx, fromRunJobOutput)
				to.SetRunJobOutput(ctx, toRunJobOutput)
			}
		}
	}
	if !from.SqlOutput.IsNull() && !from.SqlOutput.IsUnknown() {
		if toSqlOutput, ok := to.GetSqlOutput(ctx); ok {
			if fromSqlOutput, ok := from.GetSqlOutput(ctx); ok {
				toSqlOutput.SyncFieldsDuringRead(ctx, fromSqlOutput)
				to.SetSqlOutput(ctx, toSqlOutput)
			}
		}
	}
}

func (m RunOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_rooms_notebook_output"] = attrs["clean_rooms_notebook_output"].SetOptional()
	attrs["dashboard_output"] = attrs["dashboard_output"].SetOptional()
	attrs["dbt_cloud_output"] = attrs["dbt_cloud_output"].SetOptional()
	attrs["dbt_output"] = attrs["dbt_output"].SetOptional()
	attrs["dbt_platform_output"] = attrs["dbt_platform_output"].SetOptional()
	attrs["error"] = attrs["error"].SetOptional()
	attrs["error_trace"] = attrs["error_trace"].SetOptional()
	attrs["info"] = attrs["info"].SetOptional()
	attrs["logs"] = attrs["logs"].SetOptional()
	attrs["logs_truncated"] = attrs["logs_truncated"].SetOptional()
	attrs["metadata"] = attrs["metadata"].SetOptional()
	attrs["notebook_output"] = attrs["notebook_output"].SetOptional()
	attrs["run_job_output"] = attrs["run_job_output"].SetOptional()
	attrs["sql_output"] = attrs["sql_output"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_output": reflect.TypeOf(CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput{}),
		"dashboard_output":            reflect.TypeOf(DashboardTaskOutput{}),
		"dbt_cloud_output":            reflect.TypeOf(DbtCloudTaskOutput{}),
		"dbt_output":                  reflect.TypeOf(DbtOutput{}),
		"dbt_platform_output":         reflect.TypeOf(DbtPlatformTaskOutput{}),
		"metadata":                    reflect.TypeOf(Run{}),
		"notebook_output":             reflect.TypeOf(NotebookOutput{}),
		"run_job_output":              reflect.TypeOf(RunJobOutput{}),
		"sql_output":                  reflect.TypeOf(SqlOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunOutput
// only implements ToObjectValue() and Type().
func (m RunOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_rooms_notebook_output": m.CleanRoomsNotebookOutput,
			"dashboard_output":            m.DashboardOutput,
			"dbt_cloud_output":            m.DbtCloudOutput,
			"dbt_output":                  m.DbtOutput,
			"dbt_platform_output":         m.DbtPlatformOutput,
			"error":                       m.Error,
			"error_trace":                 m.ErrorTrace,
			"info":                        m.Info,
			"logs":                        m.Logs,
			"logs_truncated":              m.LogsTruncated,
			"metadata":                    m.Metadata,
			"notebook_output":             m.NotebookOutput,
			"run_job_output":              m.RunJobOutput,
			"sql_output":                  m.SqlOutput,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_rooms_notebook_output": CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput{}.Type(ctx),
			"dashboard_output":            DashboardTaskOutput{}.Type(ctx),
			"dbt_cloud_output":            DbtCloudTaskOutput{}.Type(ctx),
			"dbt_output":                  DbtOutput{}.Type(ctx),
			"dbt_platform_output":         DbtPlatformTaskOutput{}.Type(ctx),
			"error":                       types.StringType,
			"error_trace":                 types.StringType,
			"info":                        types.StringType,
			"logs":                        types.StringType,
			"logs_truncated":              types.BoolType,
			"metadata":                    Run{}.Type(ctx),
			"notebook_output":             NotebookOutput{}.Type(ctx),
			"run_job_output":              RunJobOutput{}.Type(ctx),
			"sql_output":                  SqlOutput{}.Type(ctx),
		},
	}
}

// GetCleanRoomsNotebookOutput returns the value of the CleanRoomsNotebookOutput field in RunOutput as
// a CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetCleanRoomsNotebookOutput(ctx context.Context) (CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput, bool) {
	var e CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput
	if m.CleanRoomsNotebookOutput.IsNull() || m.CleanRoomsNotebookOutput.IsUnknown() {
		return e, false
	}
	var v CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput
	d := m.CleanRoomsNotebookOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCleanRoomsNotebookOutput sets the value of the CleanRoomsNotebookOutput field in RunOutput.
func (m *RunOutput) SetCleanRoomsNotebookOutput(ctx context.Context, v CleanRoomsNotebookTaskCleanRoomsNotebookTaskOutput) {
	vs := v.ToObjectValue(ctx)
	m.CleanRoomsNotebookOutput = vs
}

// GetDashboardOutput returns the value of the DashboardOutput field in RunOutput as
// a DashboardTaskOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetDashboardOutput(ctx context.Context) (DashboardTaskOutput, bool) {
	var e DashboardTaskOutput
	if m.DashboardOutput.IsNull() || m.DashboardOutput.IsUnknown() {
		return e, false
	}
	var v DashboardTaskOutput
	d := m.DashboardOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboardOutput sets the value of the DashboardOutput field in RunOutput.
func (m *RunOutput) SetDashboardOutput(ctx context.Context, v DashboardTaskOutput) {
	vs := v.ToObjectValue(ctx)
	m.DashboardOutput = vs
}

// GetDbtCloudOutput returns the value of the DbtCloudOutput field in RunOutput as
// a DbtCloudTaskOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetDbtCloudOutput(ctx context.Context) (DbtCloudTaskOutput, bool) {
	var e DbtCloudTaskOutput
	if m.DbtCloudOutput.IsNull() || m.DbtCloudOutput.IsUnknown() {
		return e, false
	}
	var v DbtCloudTaskOutput
	d := m.DbtCloudOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCloudOutput sets the value of the DbtCloudOutput field in RunOutput.
func (m *RunOutput) SetDbtCloudOutput(ctx context.Context, v DbtCloudTaskOutput) {
	vs := v.ToObjectValue(ctx)
	m.DbtCloudOutput = vs
}

// GetDbtOutput returns the value of the DbtOutput field in RunOutput as
// a DbtOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetDbtOutput(ctx context.Context) (DbtOutput, bool) {
	var e DbtOutput
	if m.DbtOutput.IsNull() || m.DbtOutput.IsUnknown() {
		return e, false
	}
	var v DbtOutput
	d := m.DbtOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtOutput sets the value of the DbtOutput field in RunOutput.
func (m *RunOutput) SetDbtOutput(ctx context.Context, v DbtOutput) {
	vs := v.ToObjectValue(ctx)
	m.DbtOutput = vs
}

// GetDbtPlatformOutput returns the value of the DbtPlatformOutput field in RunOutput as
// a DbtPlatformTaskOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetDbtPlatformOutput(ctx context.Context) (DbtPlatformTaskOutput, bool) {
	var e DbtPlatformTaskOutput
	if m.DbtPlatformOutput.IsNull() || m.DbtPlatformOutput.IsUnknown() {
		return e, false
	}
	var v DbtPlatformTaskOutput
	d := m.DbtPlatformOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtPlatformOutput sets the value of the DbtPlatformOutput field in RunOutput.
func (m *RunOutput) SetDbtPlatformOutput(ctx context.Context, v DbtPlatformTaskOutput) {
	vs := v.ToObjectValue(ctx)
	m.DbtPlatformOutput = vs
}

// GetMetadata returns the value of the Metadata field in RunOutput as
// a Run value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetMetadata(ctx context.Context) (Run, bool) {
	var e Run
	if m.Metadata.IsNull() || m.Metadata.IsUnknown() {
		return e, false
	}
	var v Run
	d := m.Metadata.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetMetadata sets the value of the Metadata field in RunOutput.
func (m *RunOutput) SetMetadata(ctx context.Context, v Run) {
	vs := v.ToObjectValue(ctx)
	m.Metadata = vs
}

// GetNotebookOutput returns the value of the NotebookOutput field in RunOutput as
// a NotebookOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetNotebookOutput(ctx context.Context) (NotebookOutput, bool) {
	var e NotebookOutput
	if m.NotebookOutput.IsNull() || m.NotebookOutput.IsUnknown() {
		return e, false
	}
	var v NotebookOutput
	d := m.NotebookOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookOutput sets the value of the NotebookOutput field in RunOutput.
func (m *RunOutput) SetNotebookOutput(ctx context.Context, v NotebookOutput) {
	vs := v.ToObjectValue(ctx)
	m.NotebookOutput = vs
}

// GetRunJobOutput returns the value of the RunJobOutput field in RunOutput as
// a RunJobOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetRunJobOutput(ctx context.Context) (RunJobOutput, bool) {
	var e RunJobOutput
	if m.RunJobOutput.IsNull() || m.RunJobOutput.IsUnknown() {
		return e, false
	}
	var v RunJobOutput
	d := m.RunJobOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunJobOutput sets the value of the RunJobOutput field in RunOutput.
func (m *RunOutput) SetRunJobOutput(ctx context.Context, v RunJobOutput) {
	vs := v.ToObjectValue(ctx)
	m.RunJobOutput = vs
}

// GetSqlOutput returns the value of the SqlOutput field in RunOutput as
// a SqlOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunOutput) GetSqlOutput(ctx context.Context) (SqlOutput, bool) {
	var e SqlOutput
	if m.SqlOutput.IsNull() || m.SqlOutput.IsUnknown() {
		return e, false
	}
	var v SqlOutput
	d := m.SqlOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlOutput sets the value of the SqlOutput field in RunOutput.
func (m *RunOutput) SetSqlOutput(ctx context.Context, v SqlOutput) {
	vs := v.ToObjectValue(ctx)
	m.SqlOutput = vs
}

type RunParameters struct {
	// An array of commands to execute for jobs with the dbt task, for example
	// `"dbt_commands": ["dbt deps", "dbt seed", "dbt deps", "dbt seed", "dbt
	// run"]`
	DbtCommands types.List `tfsdk:"dbt_commands"`
	// A list of parameters for jobs with Spark JAR tasks, for example
	// `"jar_params": ["john doe", "35"]`. The parameters are used to invoke the
	// main function of the main class specified in the Spark JAR task. If not
	// specified upon `run-now`, it defaults to an empty list. jar_params cannot
	// be specified in conjunction with notebook_params. The JSON representation
	// of this field (for example `{"jar_params":["john doe","35"]}`) cannot
	// exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	JarParams types.List `tfsdk:"jar_params"`
	// A map from keys to values for jobs with notebook task, for example
	// `"notebook_params": {"name": "john doe", "age": "35"}`. The map is passed
	// to the notebook and is accessible through the [dbutils.widgets.get]
	// function.
	//
	// If not specified upon `run-now`, the triggered run uses the job’s base
	// parameters.
	//
	// notebook_params cannot be specified in conjunction with jar_params.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// The JSON representation of this field (for example
	// `{"notebook_params":{"name":"john doe","age":"35"}}`) cannot exceed
	// 10,000 bytes.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	// [dbutils.widgets.get]: https://docs.databricks.com/dev-tools/databricks-utils.html
	NotebookParams types.Map `tfsdk:"notebook_params"`
	// Controls whether the pipeline should perform a full refresh
	PipelineParams types.Object `tfsdk:"pipeline_params"`

	PythonNamedParams types.Map `tfsdk:"python_named_params"`
	// A list of parameters for jobs with Python tasks, for example
	// `"python_params": ["john doe", "35"]`. The parameters are passed to
	// Python file as command-line parameters. If specified upon `run-now`, it
	// would overwrite the parameters specified in job setting. The JSON
	// representation of this field (for example `{"python_params":["john
	// doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	PythonParams types.List `tfsdk:"python_params"`
	// A list of parameters for jobs with spark submit task, for example
	// `"spark_submit_params": ["--class",
	// "org.apache.spark.examples.SparkPi"]`. The parameters are passed to
	// spark-submit script as command-line parameters. If specified upon
	// `run-now`, it would overwrite the parameters specified in job setting.
	// The JSON representation of this field (for example
	// `{"python_params":["john doe","35"]}`) cannot exceed 10,000 bytes.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs
	//
	// Important
	//
	// These parameters accept only Latin characters (ASCII character set).
	// Using non-ASCII characters returns an error. Examples of invalid,
	// non-ASCII characters are Chinese, Japanese kanjis, and emojis.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	SparkSubmitParams types.List `tfsdk:"spark_submit_params"`
	// A map from keys to values for jobs with SQL task, for example
	// `"sql_params": {"name": "john doe", "age": "35"}`. The SQL alert task
	// does not support custom parameters.
	SqlParams types.Map `tfsdk:"sql_params"`
}

func (to *RunParameters) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunParameters) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				// Recursively sync the fields of PipelineParams
				toPipelineParams.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (to *RunParameters) SyncFieldsDuringRead(ctx context.Context, from RunParameters) {
	if !from.DbtCommands.IsNull() && !from.DbtCommands.IsUnknown() && to.DbtCommands.IsNull() && len(from.DbtCommands.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DbtCommands, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DbtCommands = from.DbtCommands
	}
	if !from.JarParams.IsNull() && !from.JarParams.IsUnknown() && to.JarParams.IsNull() && len(from.JarParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for JarParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.JarParams = from.JarParams
	}
	if !from.PipelineParams.IsNull() && !from.PipelineParams.IsUnknown() {
		if toPipelineParams, ok := to.GetPipelineParams(ctx); ok {
			if fromPipelineParams, ok := from.GetPipelineParams(ctx); ok {
				toPipelineParams.SyncFieldsDuringRead(ctx, fromPipelineParams)
				to.SetPipelineParams(ctx, toPipelineParams)
			}
		}
	}
	if !from.PythonParams.IsNull() && !from.PythonParams.IsUnknown() && to.PythonParams.IsNull() && len(from.PythonParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for PythonParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.PythonParams = from.PythonParams
	}
	if !from.SparkSubmitParams.IsNull() && !from.SparkSubmitParams.IsUnknown() && to.SparkSubmitParams.IsNull() && len(from.SparkSubmitParams.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SparkSubmitParams, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SparkSubmitParams = from.SparkSubmitParams
	}
}

func (m RunParameters) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["dbt_commands"] = attrs["dbt_commands"].SetOptional()
	attrs["jar_params"] = attrs["jar_params"].SetOptional()
	attrs["notebook_params"] = attrs["notebook_params"].SetOptional()
	attrs["pipeline_params"] = attrs["pipeline_params"].SetOptional()
	attrs["python_named_params"] = attrs["python_named_params"].SetOptional()
	attrs["python_params"] = attrs["python_params"].SetOptional()
	attrs["spark_submit_params"] = attrs["spark_submit_params"].SetOptional()
	attrs["sql_params"] = attrs["sql_params"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunParameters.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunParameters) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"dbt_commands":        reflect.TypeOf(types.String{}),
		"jar_params":          reflect.TypeOf(types.String{}),
		"notebook_params":     reflect.TypeOf(types.String{}),
		"pipeline_params":     reflect.TypeOf(PipelineParams{}),
		"python_named_params": reflect.TypeOf(types.String{}),
		"python_params":       reflect.TypeOf(types.String{}),
		"spark_submit_params": reflect.TypeOf(types.String{}),
		"sql_params":          reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunParameters
// only implements ToObjectValue() and Type().
func (m RunParameters) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"dbt_commands":        m.DbtCommands,
			"jar_params":          m.JarParams,
			"notebook_params":     m.NotebookParams,
			"pipeline_params":     m.PipelineParams,
			"python_named_params": m.PythonNamedParams,
			"python_params":       m.PythonParams,
			"spark_submit_params": m.SparkSubmitParams,
			"sql_params":          m.SqlParams,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunParameters) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"dbt_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"jar_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notebook_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"pipeline_params": PipelineParams{}.Type(ctx),
			"python_named_params": basetypes.MapType{
				ElemType: types.StringType,
			},
			"python_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"spark_submit_params": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sql_params": basetypes.MapType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetDbtCommands returns the value of the DbtCommands field in RunParameters as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetDbtCommands(ctx context.Context) ([]types.String, bool) {
	if m.DbtCommands.IsNull() || m.DbtCommands.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.DbtCommands.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCommands sets the value of the DbtCommands field in RunParameters.
func (m *RunParameters) SetDbtCommands(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["dbt_commands"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DbtCommands = types.ListValueMust(t, vs)
}

// GetJarParams returns the value of the JarParams field in RunParameters as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetJarParams(ctx context.Context) ([]types.String, bool) {
	if m.JarParams.IsNull() || m.JarParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.JarParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetJarParams sets the value of the JarParams field in RunParameters.
func (m *RunParameters) SetJarParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["jar_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.JarParams = types.ListValueMust(t, vs)
}

// GetNotebookParams returns the value of the NotebookParams field in RunParameters as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetNotebookParams(ctx context.Context) (map[string]types.String, bool) {
	if m.NotebookParams.IsNull() || m.NotebookParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.NotebookParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookParams sets the value of the NotebookParams field in RunParameters.
func (m *RunParameters) SetNotebookParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["notebook_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.NotebookParams = types.MapValueMust(t, vs)
}

// GetPipelineParams returns the value of the PipelineParams field in RunParameters as
// a PipelineParams value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetPipelineParams(ctx context.Context) (PipelineParams, bool) {
	var e PipelineParams
	if m.PipelineParams.IsNull() || m.PipelineParams.IsUnknown() {
		return e, false
	}
	var v PipelineParams
	d := m.PipelineParams.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineParams sets the value of the PipelineParams field in RunParameters.
func (m *RunParameters) SetPipelineParams(ctx context.Context, v PipelineParams) {
	vs := v.ToObjectValue(ctx)
	m.PipelineParams = vs
}

// GetPythonNamedParams returns the value of the PythonNamedParams field in RunParameters as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetPythonNamedParams(ctx context.Context) (map[string]types.String, bool) {
	if m.PythonNamedParams.IsNull() || m.PythonNamedParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.PythonNamedParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonNamedParams sets the value of the PythonNamedParams field in RunParameters.
func (m *RunParameters) SetPythonNamedParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_named_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonNamedParams = types.MapValueMust(t, vs)
}

// GetPythonParams returns the value of the PythonParams field in RunParameters as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetPythonParams(ctx context.Context) ([]types.String, bool) {
	if m.PythonParams.IsNull() || m.PythonParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.PythonParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonParams sets the value of the PythonParams field in RunParameters.
func (m *RunParameters) SetPythonParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["python_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.PythonParams = types.ListValueMust(t, vs)
}

// GetSparkSubmitParams returns the value of the SparkSubmitParams field in RunParameters as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetSparkSubmitParams(ctx context.Context) ([]types.String, bool) {
	if m.SparkSubmitParams.IsNull() || m.SparkSubmitParams.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.SparkSubmitParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitParams sets the value of the SparkSubmitParams field in RunParameters.
func (m *RunParameters) SetSparkSubmitParams(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["spark_submit_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SparkSubmitParams = types.ListValueMust(t, vs)
}

// GetSqlParams returns the value of the SqlParams field in RunParameters as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunParameters) GetSqlParams(ctx context.Context) (map[string]types.String, bool) {
	if m.SqlParams.IsNull() || m.SqlParams.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.SqlParams.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlParams sets the value of the SqlParams field in RunParameters.
func (m *RunParameters) SetSqlParams(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_params"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlParams = types.MapValueMust(t, vs)
}

// The current state of the run.
type RunState struct {
	// A value indicating the run's current lifecycle state. This field is
	// always available in the response. Note: Additional states might be
	// introduced in future releases.
	LifeCycleState types.String `tfsdk:"life_cycle_state"`
	// The reason indicating why the run was queued.
	QueueReason types.String `tfsdk:"queue_reason"`
	// A value indicating the run's result. This field is only available for
	// terminal lifecycle states. Note: Additional states might be introduced in
	// future releases.
	ResultState types.String `tfsdk:"result_state"`
	// A descriptive message for the current state. This field is unstructured,
	// and its exact format is subject to change.
	StateMessage types.String `tfsdk:"state_message"`
	// A value indicating whether a run was canceled manually by a user or by
	// the scheduler because the run timed out.
	UserCancelledOrTimedout types.Bool `tfsdk:"user_cancelled_or_timedout"`
}

func (to *RunState) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunState) {
}

func (to *RunState) SyncFieldsDuringRead(ctx context.Context, from RunState) {
}

func (m RunState) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["life_cycle_state"] = attrs["life_cycle_state"].SetOptional()
	attrs["queue_reason"] = attrs["queue_reason"].SetOptional()
	attrs["result_state"] = attrs["result_state"].SetOptional()
	attrs["state_message"] = attrs["state_message"].SetOptional()
	attrs["user_cancelled_or_timedout"] = attrs["user_cancelled_or_timedout"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunState) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunState
// only implements ToObjectValue() and Type().
func (m RunState) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"life_cycle_state":           m.LifeCycleState,
			"queue_reason":               m.QueueReason,
			"result_state":               m.ResultState,
			"state_message":              m.StateMessage,
			"user_cancelled_or_timedout": m.UserCancelledOrTimedout,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunState) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"life_cycle_state":           types.StringType,
			"queue_reason":               types.StringType,
			"result_state":               types.StringType,
			"state_message":              types.StringType,
			"user_cancelled_or_timedout": types.BoolType,
		},
	}
}

// The current status of the run
type RunStatus struct {
	// If the run was queued, details about the reason for queuing the run.
	QueueDetails types.Object `tfsdk:"queue_details"`

	State types.String `tfsdk:"state"`
	// If the run is in a TERMINATING or TERMINATED state, details about the
	// reason for terminating the run.
	TerminationDetails types.Object `tfsdk:"termination_details"`
}

func (to *RunStatus) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunStatus) {
	if !from.QueueDetails.IsNull() && !from.QueueDetails.IsUnknown() {
		if toQueueDetails, ok := to.GetQueueDetails(ctx); ok {
			if fromQueueDetails, ok := from.GetQueueDetails(ctx); ok {
				// Recursively sync the fields of QueueDetails
				toQueueDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromQueueDetails)
				to.SetQueueDetails(ctx, toQueueDetails)
			}
		}
	}
	if !from.TerminationDetails.IsNull() && !from.TerminationDetails.IsUnknown() {
		if toTerminationDetails, ok := to.GetTerminationDetails(ctx); ok {
			if fromTerminationDetails, ok := from.GetTerminationDetails(ctx); ok {
				// Recursively sync the fields of TerminationDetails
				toTerminationDetails.SyncFieldsDuringCreateOrUpdate(ctx, fromTerminationDetails)
				to.SetTerminationDetails(ctx, toTerminationDetails)
			}
		}
	}
}

func (to *RunStatus) SyncFieldsDuringRead(ctx context.Context, from RunStatus) {
	if !from.QueueDetails.IsNull() && !from.QueueDetails.IsUnknown() {
		if toQueueDetails, ok := to.GetQueueDetails(ctx); ok {
			if fromQueueDetails, ok := from.GetQueueDetails(ctx); ok {
				toQueueDetails.SyncFieldsDuringRead(ctx, fromQueueDetails)
				to.SetQueueDetails(ctx, toQueueDetails)
			}
		}
	}
	if !from.TerminationDetails.IsNull() && !from.TerminationDetails.IsUnknown() {
		if toTerminationDetails, ok := to.GetTerminationDetails(ctx); ok {
			if fromTerminationDetails, ok := from.GetTerminationDetails(ctx); ok {
				toTerminationDetails.SyncFieldsDuringRead(ctx, fromTerminationDetails)
				to.SetTerminationDetails(ctx, toTerminationDetails)
			}
		}
	}
}

func (m RunStatus) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["queue_details"] = attrs["queue_details"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["termination_details"] = attrs["termination_details"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunStatus.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunStatus) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"queue_details":       reflect.TypeOf(QueueDetails{}),
		"termination_details": reflect.TypeOf(TerminationDetails{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunStatus
// only implements ToObjectValue() and Type().
func (m RunStatus) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"queue_details":       m.QueueDetails,
			"state":               m.State,
			"termination_details": m.TerminationDetails,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunStatus) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"queue_details":       QueueDetails{}.Type(ctx),
			"state":               types.StringType,
			"termination_details": TerminationDetails{}.Type(ctx),
		},
	}
}

// GetQueueDetails returns the value of the QueueDetails field in RunStatus as
// a QueueDetails value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunStatus) GetQueueDetails(ctx context.Context) (QueueDetails, bool) {
	var e QueueDetails
	if m.QueueDetails.IsNull() || m.QueueDetails.IsUnknown() {
		return e, false
	}
	var v QueueDetails
	d := m.QueueDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueueDetails sets the value of the QueueDetails field in RunStatus.
func (m *RunStatus) SetQueueDetails(ctx context.Context, v QueueDetails) {
	vs := v.ToObjectValue(ctx)
	m.QueueDetails = vs
}

// GetTerminationDetails returns the value of the TerminationDetails field in RunStatus as
// a TerminationDetails value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunStatus) GetTerminationDetails(ctx context.Context) (TerminationDetails, bool) {
	var e TerminationDetails
	if m.TerminationDetails.IsNull() || m.TerminationDetails.IsUnknown() {
		return e, false
	}
	var v TerminationDetails
	d := m.TerminationDetails.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTerminationDetails sets the value of the TerminationDetails field in RunStatus.
func (m *RunStatus) SetTerminationDetails(ctx context.Context, v TerminationDetails) {
	vs := v.ToObjectValue(ctx)
	m.TerminationDetails = vs
}

// Used when outputting a child run, in GetRun or ListRuns.
type RunTask struct {
	// The sequence number of this run attempt for a triggered job run. The
	// initial attempt of a run has an attempt_number of 0. If the initial run
	// attempt fails, and the job has a retry policy (`max_retries` > 0),
	// subsequent runs are created with an `original_attempt_run_id` of the
	// original attempt’s ID and an incrementing `attempt_number`. Runs are
	// retried only until they succeed, and the maximum `attempt_number` is the
	// same as the `max_retries` value for the job.
	AttemptNumber types.Int64 `tfsdk:"attempt_number"`
	// The task runs a [clean rooms] notebook when the
	// `clean_rooms_notebook_task` field is present.
	//
	// [clean rooms]: https://docs.databricks.com/clean-rooms/index.html
	CleanRoomsNotebookTask types.Object `tfsdk:"clean_rooms_notebook_task"`
	// The time in milliseconds it took to terminate the cluster and clean up
	// any associated artifacts. The duration of a task run is the sum of the
	// `setup_duration`, `execution_duration`, and the `cleanup_duration`. The
	// `cleanup_duration` field is set to 0 for multitask job runs. The total
	// duration of a multitask job run is the value of the `run_duration` field.
	CleanupDuration types.Int64 `tfsdk:"cleanup_duration"`
	// The cluster used for this run. If the run is specified to use a new
	// cluster, this field is set once the Jobs service has requested a cluster
	// for the run.
	ClusterInstance types.Object `tfsdk:"cluster_instance"`
	// The task evaluates a condition that can be used to control the execution
	// of other tasks when the `condition_task` field is present. The condition
	// task does not require a cluster to execute and does not support retries
	// or notifications.
	ConditionTask types.Object `tfsdk:"condition_task"`
	// The task refreshes a dashboard and sends a snapshot to subscribers.
	DashboardTask types.Object `tfsdk:"dashboard_task"`
	// Task type for dbt cloud, deprecated in favor of the new name
	// dbt_platform_task
	DbtCloudTask types.Object `tfsdk:"dbt_cloud_task"`

	DbtPlatformTask types.Object `tfsdk:"dbt_platform_task"`
	// The task runs one or more dbt commands when the `dbt_task` field is
	// present. The dbt task requires both Databricks SQL and the ability to use
	// a serverless or a pro SQL warehouse.
	DbtTask types.Object `tfsdk:"dbt_task"`
	// An optional array of objects specifying the dependency graph of the task.
	// All tasks specified in this field must complete successfully before
	// executing this task. The key is `task_key`, and the value is the name
	// assigned to the dependent task.
	DependsOn types.List `tfsdk:"depends_on"`
	// An optional description for this task.
	Description types.String `tfsdk:"description"`
	// The actual performance target used by the serverless run during
	// execution. This can differ from the client-set performance target on the
	// request depending on whether the performance mode is supported by the job
	// type.
	//
	// * `STANDARD`: Enables cost-efficient execution of serverless workloads. *
	// `PERFORMANCE_OPTIMIZED`: Prioritizes fast startup and execution times
	// through rapid scaling and optimized cluster performance.
	EffectivePerformanceTarget types.String `tfsdk:"effective_performance_target"`
	// An optional set of email addresses notified when the task run begins or
	// completes. The default behavior is to not send any emails.
	EmailNotifications types.Object `tfsdk:"email_notifications"`
	// The time at which this run ended in epoch milliseconds (milliseconds
	// since 1/1/1970 UTC). This field is set to 0 if the job is still running.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The key that references an environment spec in a job. This field is
	// required for Python script, Python wheel and dbt tasks when using
	// serverless compute.
	EnvironmentKey types.String `tfsdk:"environment_key"`
	// The time in milliseconds it took to execute the commands in the JAR or
	// notebook until they completed, failed, timed out, were cancelled, or
	// encountered an unexpected error. The duration of a task run is the sum of
	// the `setup_duration`, `execution_duration`, and the `cleanup_duration`.
	// The `execution_duration` field is set to 0 for multitask job runs. The
	// total duration of a multitask job run is the value of the `run_duration`
	// field.
	ExecutionDuration types.Int64 `tfsdk:"execution_duration"`
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// The task executes a nested task for every input provided when the
	// `for_each_task` field is present.
	ForEachTask types.Object `tfsdk:"for_each_task"`

	GenAiComputeTask types.Object `tfsdk:"gen_ai_compute_task"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks. If `git_source` is set,
	// these tasks retrieve the file from the remote repository by default.
	// However, this behavior can be overridden by setting `source` to
	// `WORKSPACE` on the task. Note: dbt and SQL File tasks support only
	// version-controlled sources. If dbt or SQL File tasks are used,
	// `git_source` must be defined on the job.
	GitSource types.Object `tfsdk:"git_source"`
	// If job_cluster_key, this task is executed reusing the cluster specified
	// in `job.settings.job_clusters`.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.Object `tfsdk:"new_cluster"`
	// The task runs a notebook when the `notebook_task` field is present.
	NotebookTask types.Object `tfsdk:"notebook_task"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// task run.
	NotificationSettings types.Object `tfsdk:"notification_settings"`
	// The task triggers a pipeline update when the `pipeline_task` field is
	// present. Only pipelines configured to use triggered more are supported.
	PipelineTask types.Object `tfsdk:"pipeline_task"`
	// The task triggers a Power BI semantic model update when the
	// `power_bi_task` field is present.
	PowerBiTask types.Object `tfsdk:"power_bi_task"`
	// The task runs a Python wheel when the `python_wheel_task` field is
	// present.
	PythonWheelTask types.Object `tfsdk:"python_wheel_task"`
	// The time in milliseconds that the run has spent in the queue.
	QueueDuration types.Int64 `tfsdk:"queue_duration"`
	// Parameter values including resolved references
	ResolvedValues types.Object `tfsdk:"resolved_values"`
	// The time in milliseconds it took the job run and all of its repairs to
	// finish.
	RunDuration types.Int64 `tfsdk:"run_duration"`
	// The ID of the task run.
	RunId types.Int64 `tfsdk:"run_id"`
	// An optional value indicating the condition that determines whether the
	// task should be run once its dependencies have been completed. When
	// omitted, defaults to `ALL_SUCCESS`. See :method:jobs/create for a list of
	// possible values.
	RunIf types.String `tfsdk:"run_if"`
	// The task triggers another job when the `run_job_task` field is present.
	RunJobTask types.Object `tfsdk:"run_job_task"`

	RunPageUrl types.String `tfsdk:"run_page_url"`
	// The time in milliseconds it took to set up the cluster. For runs that run
	// on new clusters this is the cluster creation time, for runs that run on
	// existing clusters this time should be very short. The duration of a task
	// run is the sum of the `setup_duration`, `execution_duration`, and the
	// `cleanup_duration`. The `setup_duration` field is set to 0 for multitask
	// job runs. The total duration of a multitask job run is the value of the
	// `run_duration` field.
	SetupDuration types.Int64 `tfsdk:"setup_duration"`
	// The task runs a JAR when the `spark_jar_task` field is present.
	SparkJarTask types.Object `tfsdk:"spark_jar_task"`
	// The task runs a Python file when the `spark_python_task` field is
	// present.
	SparkPythonTask types.Object `tfsdk:"spark_python_task"`
	// (Legacy) The task runs the spark-submit script when the spark_submit_task
	// field is present. Databricks recommends using the spark_jar_task instead;
	// see [Spark Submit task for jobs](/jobs/spark-submit).
	SparkSubmitTask types.Object `tfsdk:"spark_submit_task"`
	// The task runs a SQL query or file, or it refreshes a SQL alert or a
	// legacy SQL dashboard when the `sql_task` field is present.
	SqlTask types.Object `tfsdk:"sql_task"`
	// The time at which this run was started in epoch milliseconds
	// (milliseconds since 1/1/1970 UTC). This may not be the time when the job
	// task starts executing, for example, if the job is scheduled to run on a
	// new cluster, this is the time the cluster creation call is issued.
	StartTime types.Int64 `tfsdk:"start_time"`
	// Deprecated. Please use the `status` field instead.
	State types.Object `tfsdk:"state"`

	Status types.Object `tfsdk:"status"`
	// A unique name for the task. This field is used to refer to this task from
	// other tasks. This field is required and must be unique within its parent
	// job. On Update or Reset, this field is used to reference the tasks to be
	// updated or reset.
	TaskKey types.String `tfsdk:"task_key"`
	// An optional timeout applied to each run of this job task. A value of `0`
	// means no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A collection of system notification IDs to notify when the run begins or
	// completes. The default behavior is to not send any system notifications.
	// Task webhooks respect the task notification settings.
	WebhookNotifications types.Object `tfsdk:"webhook_notifications"`
}

func (to *RunTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from RunTask) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookTask
				toCleanRoomsNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				// Recursively sync the fields of ClusterInstance
				toClusterInstance.SyncFieldsDuringCreateOrUpdate(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				// Recursively sync the fields of DashboardTask
				toDashboardTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				// Recursively sync the fields of DbtCloudTask
				toDbtCloudTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				// Recursively sync the fields of DbtPlatformTask
				toDbtPlatformTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				// Recursively sync the fields of ForEachTask
				toForEachTask.SyncFieldsDuringCreateOrUpdate(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				// Recursively sync the fields of GenAiComputeTask
				toGenAiComputeTask.SyncFieldsDuringCreateOrUpdate(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				// Recursively sync the fields of PipelineTask
				toPipelineTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				// Recursively sync the fields of PowerBiTask
				toPowerBiTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.ResolvedValues.IsNull() && !from.ResolvedValues.IsUnknown() {
		if toResolvedValues, ok := to.GetResolvedValues(ctx); ok {
			if fromResolvedValues, ok := from.GetResolvedValues(ctx); ok {
				// Recursively sync the fields of ResolvedValues
				toResolvedValues.SyncFieldsDuringCreateOrUpdate(ctx, fromResolvedValues)
				to.SetResolvedValues(ctx, toResolvedValues)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				// Recursively sync the fields of State
				toState.SyncFieldsDuringCreateOrUpdate(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				// Recursively sync the fields of Status
				toStatus.SyncFieldsDuringCreateOrUpdate(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *RunTask) SyncFieldsDuringRead(ctx context.Context, from RunTask) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				toCleanRoomsNotebookTask.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ClusterInstance.IsNull() && !from.ClusterInstance.IsUnknown() {
		if toClusterInstance, ok := to.GetClusterInstance(ctx); ok {
			if fromClusterInstance, ok := from.GetClusterInstance(ctx); ok {
				toClusterInstance.SyncFieldsDuringRead(ctx, fromClusterInstance)
				to.SetClusterInstance(ctx, toClusterInstance)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				toDashboardTask.SyncFieldsDuringRead(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				toDbtCloudTask.SyncFieldsDuringRead(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				toDbtPlatformTask.SyncFieldsDuringRead(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				toForEachTask.SyncFieldsDuringRead(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				toGenAiComputeTask.SyncFieldsDuringRead(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				toPipelineTask.SyncFieldsDuringRead(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				toPowerBiTask.SyncFieldsDuringRead(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.ResolvedValues.IsNull() && !from.ResolvedValues.IsUnknown() {
		if toResolvedValues, ok := to.GetResolvedValues(ctx); ok {
			if fromResolvedValues, ok := from.GetResolvedValues(ctx); ok {
				toResolvedValues.SyncFieldsDuringRead(ctx, fromResolvedValues)
				to.SetResolvedValues(ctx, toResolvedValues)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.State.IsNull() && !from.State.IsUnknown() {
		if toState, ok := to.GetState(ctx); ok {
			if fromState, ok := from.GetState(ctx); ok {
				toState.SyncFieldsDuringRead(ctx, fromState)
				to.SetState(ctx, toState)
			}
		}
	}
	if !from.Status.IsNull() && !from.Status.IsUnknown() {
		if toStatus, ok := to.GetStatus(ctx); ok {
			if fromStatus, ok := from.GetStatus(ctx); ok {
				toStatus.SyncFieldsDuringRead(ctx, fromStatus)
				to.SetStatus(ctx, toStatus)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m RunTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["attempt_number"] = attrs["attempt_number"].SetOptional()
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].SetOptional()
	attrs["cleanup_duration"] = attrs["cleanup_duration"].SetOptional()
	attrs["cluster_instance"] = attrs["cluster_instance"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["dashboard_task"] = attrs["dashboard_task"].SetOptional()
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].SetOptional()
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["depends_on"] = attrs["depends_on"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["effective_performance_target"] = attrs["effective_performance_target"].SetComputed()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["environment_key"] = attrs["environment_key"].SetOptional()
	attrs["execution_duration"] = attrs["execution_duration"].SetOptional()
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].SetOptional()
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["pipeline_task"] = attrs["pipeline_task"].SetOptional()
	attrs["power_bi_task"] = attrs["power_bi_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["queue_duration"] = attrs["queue_duration"].SetOptional()
	attrs["resolved_values"] = attrs["resolved_values"].SetOptional()
	attrs["run_duration"] = attrs["run_duration"].SetOptional()
	attrs["run_id"] = attrs["run_id"].SetOptional()
	attrs["run_if"] = attrs["run_if"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["run_page_url"] = attrs["run_page_url"].SetOptional()
	attrs["setup_duration"] = attrs["setup_duration"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["state"] = attrs["state"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["task_key"] = attrs["task_key"].SetRequired()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in RunTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m RunTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_task": reflect.TypeOf(CleanRoomsNotebookTask{}),
		"cluster_instance":          reflect.TypeOf(ClusterInstance{}),
		"condition_task":            reflect.TypeOf(RunConditionTask{}),
		"dashboard_task":            reflect.TypeOf(DashboardTask{}),
		"dbt_cloud_task":            reflect.TypeOf(DbtCloudTask{}),
		"dbt_platform_task":         reflect.TypeOf(DbtPlatformTask{}),
		"dbt_task":                  reflect.TypeOf(DbtTask{}),
		"depends_on":                reflect.TypeOf(TaskDependency{}),
		"email_notifications":       reflect.TypeOf(JobEmailNotifications{}),
		"for_each_task":             reflect.TypeOf(RunForEachTask{}),
		"gen_ai_compute_task":       reflect.TypeOf(GenAiComputeTask{}),
		"git_source":                reflect.TypeOf(GitSource{}),
		"library":                   reflect.TypeOf(compute_tf.Library{}),
		"new_cluster":               reflect.TypeOf(compute_tf.ClusterSpec{}),
		"notebook_task":             reflect.TypeOf(NotebookTask{}),
		"notification_settings":     reflect.TypeOf(TaskNotificationSettings{}),
		"pipeline_task":             reflect.TypeOf(PipelineTask{}),
		"power_bi_task":             reflect.TypeOf(PowerBiTask{}),
		"python_wheel_task":         reflect.TypeOf(PythonWheelTask{}),
		"resolved_values":           reflect.TypeOf(ResolvedValues{}),
		"run_job_task":              reflect.TypeOf(RunJobTask{}),
		"spark_jar_task":            reflect.TypeOf(SparkJarTask{}),
		"spark_python_task":         reflect.TypeOf(SparkPythonTask{}),
		"spark_submit_task":         reflect.TypeOf(SparkSubmitTask{}),
		"sql_task":                  reflect.TypeOf(SqlTask{}),
		"state":                     reflect.TypeOf(RunState{}),
		"status":                    reflect.TypeOf(RunStatus{}),
		"webhook_notifications":     reflect.TypeOf(WebhookNotifications{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, RunTask
// only implements ToObjectValue() and Type().
func (m RunTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"attempt_number":               m.AttemptNumber,
			"clean_rooms_notebook_task":    m.CleanRoomsNotebookTask,
			"cleanup_duration":             m.CleanupDuration,
			"cluster_instance":             m.ClusterInstance,
			"condition_task":               m.ConditionTask,
			"dashboard_task":               m.DashboardTask,
			"dbt_cloud_task":               m.DbtCloudTask,
			"dbt_platform_task":            m.DbtPlatformTask,
			"dbt_task":                     m.DbtTask,
			"depends_on":                   m.DependsOn,
			"description":                  m.Description,
			"effective_performance_target": m.EffectivePerformanceTarget,
			"email_notifications":          m.EmailNotifications,
			"end_time":                     m.EndTime,
			"environment_key":              m.EnvironmentKey,
			"execution_duration":           m.ExecutionDuration,
			"existing_cluster_id":          m.ExistingClusterId,
			"for_each_task":                m.ForEachTask,
			"gen_ai_compute_task":          m.GenAiComputeTask,
			"git_source":                   m.GitSource,
			"job_cluster_key":              m.JobClusterKey,
			"library":                      m.Libraries,
			"new_cluster":                  m.NewCluster,
			"notebook_task":                m.NotebookTask,
			"notification_settings":        m.NotificationSettings,
			"pipeline_task":                m.PipelineTask,
			"power_bi_task":                m.PowerBiTask,
			"python_wheel_task":            m.PythonWheelTask,
			"queue_duration":               m.QueueDuration,
			"resolved_values":              m.ResolvedValues,
			"run_duration":                 m.RunDuration,
			"run_id":                       m.RunId,
			"run_if":                       m.RunIf,
			"run_job_task":                 m.RunJobTask,
			"run_page_url":                 m.RunPageUrl,
			"setup_duration":               m.SetupDuration,
			"spark_jar_task":               m.SparkJarTask,
			"spark_python_task":            m.SparkPythonTask,
			"spark_submit_task":            m.SparkSubmitTask,
			"sql_task":                     m.SqlTask,
			"start_time":                   m.StartTime,
			"state":                        m.State,
			"status":                       m.Status,
			"task_key":                     m.TaskKey,
			"timeout_seconds":              m.TimeoutSeconds,
			"webhook_notifications":        m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m RunTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"attempt_number":            types.Int64Type,
			"clean_rooms_notebook_task": CleanRoomsNotebookTask{}.Type(ctx),
			"cleanup_duration":          types.Int64Type,
			"cluster_instance":          ClusterInstance{}.Type(ctx),
			"condition_task":            RunConditionTask{}.Type(ctx),
			"dashboard_task":            DashboardTask{}.Type(ctx),
			"dbt_cloud_task":            DbtCloudTask{}.Type(ctx),
			"dbt_platform_task":         DbtPlatformTask{}.Type(ctx),
			"dbt_task":                  DbtTask{}.Type(ctx),
			"depends_on": basetypes.ListType{
				ElemType: TaskDependency{}.Type(ctx),
			},
			"description":                  types.StringType,
			"effective_performance_target": types.StringType,
			"email_notifications":          JobEmailNotifications{}.Type(ctx),
			"end_time":                     types.Int64Type,
			"environment_key":              types.StringType,
			"execution_duration":           types.Int64Type,
			"existing_cluster_id":          types.StringType,
			"for_each_task":                RunForEachTask{}.Type(ctx),
			"gen_ai_compute_task":          GenAiComputeTask{}.Type(ctx),
			"git_source":                   GitSource{}.Type(ctx),
			"job_cluster_key":              types.StringType,
			"library": basetypes.ListType{
				ElemType: compute_tf.Library{}.Type(ctx),
			},
			"new_cluster":           compute_tf.ClusterSpec{}.Type(ctx),
			"notebook_task":         NotebookTask{}.Type(ctx),
			"notification_settings": TaskNotificationSettings{}.Type(ctx),
			"pipeline_task":         PipelineTask{}.Type(ctx),
			"power_bi_task":         PowerBiTask{}.Type(ctx),
			"python_wheel_task":     PythonWheelTask{}.Type(ctx),
			"queue_duration":        types.Int64Type,
			"resolved_values":       ResolvedValues{}.Type(ctx),
			"run_duration":          types.Int64Type,
			"run_id":                types.Int64Type,
			"run_if":                types.StringType,
			"run_job_task":          RunJobTask{}.Type(ctx),
			"run_page_url":          types.StringType,
			"setup_duration":        types.Int64Type,
			"spark_jar_task":        SparkJarTask{}.Type(ctx),
			"spark_python_task":     SparkPythonTask{}.Type(ctx),
			"spark_submit_task":     SparkSubmitTask{}.Type(ctx),
			"sql_task":              SqlTask{}.Type(ctx),
			"start_time":            types.Int64Type,
			"state":                 RunState{}.Type(ctx),
			"status":                RunStatus{}.Type(ctx),
			"task_key":              types.StringType,
			"timeout_seconds":       types.Int64Type,
			"webhook_notifications": WebhookNotifications{}.Type(ctx),
		},
	}
}

// GetCleanRoomsNotebookTask returns the value of the CleanRoomsNotebookTask field in RunTask as
// a CleanRoomsNotebookTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetCleanRoomsNotebookTask(ctx context.Context) (CleanRoomsNotebookTask, bool) {
	var e CleanRoomsNotebookTask
	if m.CleanRoomsNotebookTask.IsNull() || m.CleanRoomsNotebookTask.IsUnknown() {
		return e, false
	}
	var v CleanRoomsNotebookTask
	d := m.CleanRoomsNotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCleanRoomsNotebookTask sets the value of the CleanRoomsNotebookTask field in RunTask.
func (m *RunTask) SetCleanRoomsNotebookTask(ctx context.Context, v CleanRoomsNotebookTask) {
	vs := v.ToObjectValue(ctx)
	m.CleanRoomsNotebookTask = vs
}

// GetClusterInstance returns the value of the ClusterInstance field in RunTask as
// a ClusterInstance value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetClusterInstance(ctx context.Context) (ClusterInstance, bool) {
	var e ClusterInstance
	if m.ClusterInstance.IsNull() || m.ClusterInstance.IsUnknown() {
		return e, false
	}
	var v ClusterInstance
	d := m.ClusterInstance.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetClusterInstance sets the value of the ClusterInstance field in RunTask.
func (m *RunTask) SetClusterInstance(ctx context.Context, v ClusterInstance) {
	vs := v.ToObjectValue(ctx)
	m.ClusterInstance = vs
}

// GetConditionTask returns the value of the ConditionTask field in RunTask as
// a RunConditionTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetConditionTask(ctx context.Context) (RunConditionTask, bool) {
	var e RunConditionTask
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v RunConditionTask
	d := m.ConditionTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConditionTask sets the value of the ConditionTask field in RunTask.
func (m *RunTask) SetConditionTask(ctx context.Context, v RunConditionTask) {
	vs := v.ToObjectValue(ctx)
	m.ConditionTask = vs
}

// GetDashboardTask returns the value of the DashboardTask field in RunTask as
// a DashboardTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetDashboardTask(ctx context.Context) (DashboardTask, bool) {
	var e DashboardTask
	if m.DashboardTask.IsNull() || m.DashboardTask.IsUnknown() {
		return e, false
	}
	var v DashboardTask
	d := m.DashboardTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboardTask sets the value of the DashboardTask field in RunTask.
func (m *RunTask) SetDashboardTask(ctx context.Context, v DashboardTask) {
	vs := v.ToObjectValue(ctx)
	m.DashboardTask = vs
}

// GetDbtCloudTask returns the value of the DbtCloudTask field in RunTask as
// a DbtCloudTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetDbtCloudTask(ctx context.Context) (DbtCloudTask, bool) {
	var e DbtCloudTask
	if m.DbtCloudTask.IsNull() || m.DbtCloudTask.IsUnknown() {
		return e, false
	}
	var v DbtCloudTask
	d := m.DbtCloudTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCloudTask sets the value of the DbtCloudTask field in RunTask.
func (m *RunTask) SetDbtCloudTask(ctx context.Context, v DbtCloudTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtCloudTask = vs
}

// GetDbtPlatformTask returns the value of the DbtPlatformTask field in RunTask as
// a DbtPlatformTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetDbtPlatformTask(ctx context.Context) (DbtPlatformTask, bool) {
	var e DbtPlatformTask
	if m.DbtPlatformTask.IsNull() || m.DbtPlatformTask.IsUnknown() {
		return e, false
	}
	var v DbtPlatformTask
	d := m.DbtPlatformTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtPlatformTask sets the value of the DbtPlatformTask field in RunTask.
func (m *RunTask) SetDbtPlatformTask(ctx context.Context, v DbtPlatformTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtPlatformTask = vs
}

// GetDbtTask returns the value of the DbtTask field in RunTask as
// a DbtTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetDbtTask(ctx context.Context) (DbtTask, bool) {
	var e DbtTask
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v DbtTask
	d := m.DbtTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtTask sets the value of the DbtTask field in RunTask.
func (m *RunTask) SetDbtTask(ctx context.Context, v DbtTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtTask = vs
}

// GetDependsOn returns the value of the DependsOn field in RunTask as
// a slice of TaskDependency values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetDependsOn(ctx context.Context) ([]TaskDependency, bool) {
	if m.DependsOn.IsNull() || m.DependsOn.IsUnknown() {
		return nil, false
	}
	var v []TaskDependency
	d := m.DependsOn.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependsOn sets the value of the DependsOn field in RunTask.
func (m *RunTask) SetDependsOn(ctx context.Context, v []TaskDependency) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["depends_on"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DependsOn = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in RunTask as
// a JobEmailNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetEmailNotifications(ctx context.Context) (JobEmailNotifications, bool) {
	var e JobEmailNotifications
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v JobEmailNotifications
	d := m.EmailNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailNotifications sets the value of the EmailNotifications field in RunTask.
func (m *RunTask) SetEmailNotifications(ctx context.Context, v JobEmailNotifications) {
	vs := v.ToObjectValue(ctx)
	m.EmailNotifications = vs
}

// GetForEachTask returns the value of the ForEachTask field in RunTask as
// a RunForEachTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetForEachTask(ctx context.Context) (RunForEachTask, bool) {
	var e RunForEachTask
	if m.ForEachTask.IsNull() || m.ForEachTask.IsUnknown() {
		return e, false
	}
	var v RunForEachTask
	d := m.ForEachTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetForEachTask sets the value of the ForEachTask field in RunTask.
func (m *RunTask) SetForEachTask(ctx context.Context, v RunForEachTask) {
	vs := v.ToObjectValue(ctx)
	m.ForEachTask = vs
}

// GetGenAiComputeTask returns the value of the GenAiComputeTask field in RunTask as
// a GenAiComputeTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetGenAiComputeTask(ctx context.Context) (GenAiComputeTask, bool) {
	var e GenAiComputeTask
	if m.GenAiComputeTask.IsNull() || m.GenAiComputeTask.IsUnknown() {
		return e, false
	}
	var v GenAiComputeTask
	d := m.GenAiComputeTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGenAiComputeTask sets the value of the GenAiComputeTask field in RunTask.
func (m *RunTask) SetGenAiComputeTask(ctx context.Context, v GenAiComputeTask) {
	vs := v.ToObjectValue(ctx)
	m.GenAiComputeTask = vs
}

// GetGitSource returns the value of the GitSource field in RunTask as
// a GitSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetGitSource(ctx context.Context) (GitSource, bool) {
	var e GitSource
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v GitSource
	d := m.GitSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSource sets the value of the GitSource field in RunTask.
func (m *RunTask) SetGitSource(ctx context.Context, v GitSource) {
	vs := v.ToObjectValue(ctx)
	m.GitSource = vs
}

// GetLibraries returns the value of the Libraries field in RunTask as
// a slice of compute_tf.Library values.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetLibraries(ctx context.Context) ([]compute_tf.Library, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in RunTask.
func (m *RunTask) SetLibraries(ctx context.Context, v []compute_tf.Library) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in RunTask as
// a compute_tf.ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec, bool) {
	var e compute_tf.ClusterSpec
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v compute_tf.ClusterSpec
	d := m.NewCluster.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewCluster sets the value of the NewCluster field in RunTask.
func (m *RunTask) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.NewCluster = vs
}

// GetNotebookTask returns the value of the NotebookTask field in RunTask as
// a NotebookTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetNotebookTask(ctx context.Context) (NotebookTask, bool) {
	var e NotebookTask
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v NotebookTask
	d := m.NotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookTask sets the value of the NotebookTask field in RunTask.
func (m *RunTask) SetNotebookTask(ctx context.Context, v NotebookTask) {
	vs := v.ToObjectValue(ctx)
	m.NotebookTask = vs
}

// GetNotificationSettings returns the value of the NotificationSettings field in RunTask as
// a TaskNotificationSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetNotificationSettings(ctx context.Context) (TaskNotificationSettings, bool) {
	var e TaskNotificationSettings
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v TaskNotificationSettings
	d := m.NotificationSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotificationSettings sets the value of the NotificationSettings field in RunTask.
func (m *RunTask) SetNotificationSettings(ctx context.Context, v TaskNotificationSettings) {
	vs := v.ToObjectValue(ctx)
	m.NotificationSettings = vs
}

// GetPipelineTask returns the value of the PipelineTask field in RunTask as
// a PipelineTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetPipelineTask(ctx context.Context) (PipelineTask, bool) {
	var e PipelineTask
	if m.PipelineTask.IsNull() || m.PipelineTask.IsUnknown() {
		return e, false
	}
	var v PipelineTask
	d := m.PipelineTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineTask sets the value of the PipelineTask field in RunTask.
func (m *RunTask) SetPipelineTask(ctx context.Context, v PipelineTask) {
	vs := v.ToObjectValue(ctx)
	m.PipelineTask = vs
}

// GetPowerBiTask returns the value of the PowerBiTask field in RunTask as
// a PowerBiTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetPowerBiTask(ctx context.Context) (PowerBiTask, bool) {
	var e PowerBiTask
	if m.PowerBiTask.IsNull() || m.PowerBiTask.IsUnknown() {
		return e, false
	}
	var v PowerBiTask
	d := m.PowerBiTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPowerBiTask sets the value of the PowerBiTask field in RunTask.
func (m *RunTask) SetPowerBiTask(ctx context.Context, v PowerBiTask) {
	vs := v.ToObjectValue(ctx)
	m.PowerBiTask = vs
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in RunTask as
// a PythonWheelTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetPythonWheelTask(ctx context.Context) (PythonWheelTask, bool) {
	var e PythonWheelTask
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v PythonWheelTask
	d := m.PythonWheelTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in RunTask.
func (m *RunTask) SetPythonWheelTask(ctx context.Context, v PythonWheelTask) {
	vs := v.ToObjectValue(ctx)
	m.PythonWheelTask = vs
}

// GetResolvedValues returns the value of the ResolvedValues field in RunTask as
// a ResolvedValues value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetResolvedValues(ctx context.Context) (ResolvedValues, bool) {
	var e ResolvedValues
	if m.ResolvedValues.IsNull() || m.ResolvedValues.IsUnknown() {
		return e, false
	}
	var v ResolvedValues
	d := m.ResolvedValues.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetResolvedValues sets the value of the ResolvedValues field in RunTask.
func (m *RunTask) SetResolvedValues(ctx context.Context, v ResolvedValues) {
	vs := v.ToObjectValue(ctx)
	m.ResolvedValues = vs
}

// GetRunJobTask returns the value of the RunJobTask field in RunTask as
// a RunJobTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetRunJobTask(ctx context.Context) (RunJobTask, bool) {
	var e RunJobTask
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v RunJobTask
	d := m.RunJobTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunJobTask sets the value of the RunJobTask field in RunTask.
func (m *RunTask) SetRunJobTask(ctx context.Context, v RunJobTask) {
	vs := v.ToObjectValue(ctx)
	m.RunJobTask = vs
}

// GetSparkJarTask returns the value of the SparkJarTask field in RunTask as
// a SparkJarTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetSparkJarTask(ctx context.Context) (SparkJarTask, bool) {
	var e SparkJarTask
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v SparkJarTask
	d := m.SparkJarTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkJarTask sets the value of the SparkJarTask field in RunTask.
func (m *RunTask) SetSparkJarTask(ctx context.Context, v SparkJarTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkJarTask = vs
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in RunTask as
// a SparkPythonTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetSparkPythonTask(ctx context.Context) (SparkPythonTask, bool) {
	var e SparkPythonTask
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v SparkPythonTask
	d := m.SparkPythonTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in RunTask.
func (m *RunTask) SetSparkPythonTask(ctx context.Context, v SparkPythonTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkPythonTask = vs
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in RunTask as
// a SparkSubmitTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetSparkSubmitTask(ctx context.Context) (SparkSubmitTask, bool) {
	var e SparkSubmitTask
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v SparkSubmitTask
	d := m.SparkSubmitTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in RunTask.
func (m *RunTask) SetSparkSubmitTask(ctx context.Context, v SparkSubmitTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkSubmitTask = vs
}

// GetSqlTask returns the value of the SqlTask field in RunTask as
// a SqlTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetSqlTask(ctx context.Context) (SqlTask, bool) {
	var e SqlTask
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v SqlTask
	d := m.SqlTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlTask sets the value of the SqlTask field in RunTask.
func (m *RunTask) SetSqlTask(ctx context.Context, v SqlTask) {
	vs := v.ToObjectValue(ctx)
	m.SqlTask = vs
}

// GetState returns the value of the State field in RunTask as
// a RunState value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetState(ctx context.Context) (RunState, bool) {
	var e RunState
	if m.State.IsNull() || m.State.IsUnknown() {
		return e, false
	}
	var v RunState
	d := m.State.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetState sets the value of the State field in RunTask.
func (m *RunTask) SetState(ctx context.Context, v RunState) {
	vs := v.ToObjectValue(ctx)
	m.State = vs
}

// GetStatus returns the value of the Status field in RunTask as
// a RunStatus value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetStatus(ctx context.Context) (RunStatus, bool) {
	var e RunStatus
	if m.Status.IsNull() || m.Status.IsUnknown() {
		return e, false
	}
	var v RunStatus
	d := m.Status.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetStatus sets the value of the Status field in RunTask.
func (m *RunTask) SetStatus(ctx context.Context, v RunStatus) {
	vs := v.ToObjectValue(ctx)
	m.Status = vs
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in RunTask as
// a WebhookNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *RunTask) GetWebhookNotifications(ctx context.Context) (WebhookNotifications, bool) {
	var e WebhookNotifications
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v WebhookNotifications
	d := m.WebhookNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in RunTask.
func (m *RunTask) SetWebhookNotifications(ctx context.Context, v WebhookNotifications) {
	vs := v.ToObjectValue(ctx)
	m.WebhookNotifications = vs
}

type SparkJarTask struct {
	// Deprecated since 04/2016. Provide a `jar` through the `libraries` field
	// instead. For an example, see :method:jobs/create.
	JarUri types.String `tfsdk:"jar_uri"`
	// The full name of the class containing the main method to be executed.
	// This class must be contained in a JAR provided as a library.
	//
	// The code must use `SparkContext.getOrCreate` to obtain a Spark context;
	// otherwise, runs of the job fail.
	MainClassName types.String `tfsdk:"main_class_name"`
	// Parameters passed to the main method.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	Parameters types.List `tfsdk:"parameters"`
	// Deprecated. A value of `false` is no longer supported.
	RunAsRepl types.Bool `tfsdk:"run_as_repl"`
}

func (to *SparkJarTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SparkJarTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *SparkJarTask) SyncFieldsDuringRead(ctx context.Context, from SparkJarTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m SparkJarTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["jar_uri"] = attrs["jar_uri"].SetOptional()
	attrs["main_class_name"] = attrs["main_class_name"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()
	attrs["run_as_repl"] = attrs["run_as_repl"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SparkJarTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SparkJarTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SparkJarTask
// only implements ToObjectValue() and Type().
func (m SparkJarTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"jar_uri":         m.JarUri,
			"main_class_name": m.MainClassName,
			"parameters":      m.Parameters,
			"run_as_repl":     m.RunAsRepl,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SparkJarTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"jar_uri":         types.StringType,
			"main_class_name": types.StringType,
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"run_as_repl": types.BoolType,
		},
	}
}

// GetParameters returns the value of the Parameters field in SparkJarTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SparkJarTask) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SparkJarTask.
func (m *SparkJarTask) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type SparkPythonTask struct {
	// Command line parameters passed to the Python file.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	Parameters types.List `tfsdk:"parameters"`
	// The Python file to be executed. Cloud file URIs (such as dbfs:/, s3:/,
	// adls:/, gcs:/) and workspace paths are supported. For python files stored
	// in the Databricks workspace, the path must be absolute and begin with
	// `/`. For files stored in a remote repository, the path must be relative.
	// This field is required.
	PythonFile types.String `tfsdk:"python_file"`
	// Optional location type of the Python file. When set to `WORKSPACE` or not
	// specified, the file will be retrieved from the local Databricks workspace
	// or cloud location (if the `python_file` has a URI format). When set to
	// `GIT`, the Python file will be retrieved from a Git repository defined in
	// `git_source`.
	//
	// * `WORKSPACE`: The Python file is located in a Databricks workspace or at
	// a cloud filesystem URI. * `GIT`: The Python file is located in a remote
	// Git repository.
	Source types.String `tfsdk:"source"`
}

func (to *SparkPythonTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SparkPythonTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *SparkPythonTask) SyncFieldsDuringRead(ctx context.Context, from SparkPythonTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m SparkPythonTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()
	attrs["python_file"] = attrs["python_file"].SetRequired()
	attrs["source"] = attrs["source"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SparkPythonTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SparkPythonTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SparkPythonTask
// only implements ToObjectValue() and Type().
func (m SparkPythonTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters":  m.Parameters,
			"python_file": m.PythonFile,
			"source":      m.Source,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SparkPythonTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"python_file": types.StringType,
			"source":      types.StringType,
		},
	}
}

// GetParameters returns the value of the Parameters field in SparkPythonTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SparkPythonTask) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SparkPythonTask.
func (m *SparkPythonTask) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type SparkSubmitTask struct {
	// Command-line parameters passed to spark submit.
	//
	// Use [Task parameter variables] to set parameters containing information
	// about job runs.
	//
	// [Task parameter variables]: https://docs.databricks.com/jobs.html#parameter-variables
	Parameters types.List `tfsdk:"parameters"`
}

func (to *SparkSubmitTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SparkSubmitTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (to *SparkSubmitTask) SyncFieldsDuringRead(ctx context.Context, from SparkSubmitTask) {
	if !from.Parameters.IsNull() && !from.Parameters.IsUnknown() && to.Parameters.IsNull() && len(from.Parameters.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Parameters, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Parameters = from.Parameters
	}
}

func (m SparkSubmitTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["parameters"] = attrs["parameters"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SparkSubmitTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SparkSubmitTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"parameters": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SparkSubmitTask
// only implements ToObjectValue() and Type().
func (m SparkSubmitTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"parameters": m.Parameters,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SparkSubmitTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"parameters": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetParameters returns the value of the Parameters field in SparkSubmitTask as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SparkSubmitTask) GetParameters(ctx context.Context) ([]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SparkSubmitTask.
func (m *SparkSubmitTask) SetParameters(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.ListValueMust(t, vs)
}

type SqlAlertOutput struct {
	AlertState types.String `tfsdk:"alert_state"`
	// The link to find the output results.
	OutputLink types.String `tfsdk:"output_link"`
	// The text of the SQL query. Can Run permission of the SQL query associated
	// with the SQL alert is required to view this field.
	QueryText types.String `tfsdk:"query_text"`
	// Information about SQL statements executed in the run.
	SqlStatements types.List `tfsdk:"sql_statements"`
	// The canonical identifier of the SQL warehouse.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *SqlAlertOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlAlertOutput) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (to *SqlAlertOutput) SyncFieldsDuringRead(ctx context.Context, from SqlAlertOutput) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (m SqlAlertOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_state"] = attrs["alert_state"].SetOptional()
	attrs["output_link"] = attrs["output_link"].SetOptional()
	attrs["query_text"] = attrs["query_text"].SetOptional()
	attrs["sql_statements"] = attrs["sql_statements"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlAlertOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlAlertOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"sql_statements": reflect.TypeOf(SqlStatementOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlAlertOutput
// only implements ToObjectValue() and Type().
func (m SqlAlertOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_state":    m.AlertState,
			"output_link":    m.OutputLink,
			"query_text":     m.QueryText,
			"sql_statements": m.SqlStatements,
			"warehouse_id":   m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlAlertOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_state": types.StringType,
			"output_link": types.StringType,
			"query_text":  types.StringType,
			"sql_statements": basetypes.ListType{
				ElemType: SqlStatementOutput{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetSqlStatements returns the value of the SqlStatements field in SqlAlertOutput as
// a slice of SqlStatementOutput values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlAlertOutput) GetSqlStatements(ctx context.Context) ([]SqlStatementOutput, bool) {
	if m.SqlStatements.IsNull() || m.SqlStatements.IsUnknown() {
		return nil, false
	}
	var v []SqlStatementOutput
	d := m.SqlStatements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlStatements sets the value of the SqlStatements field in SqlAlertOutput.
func (m *SqlAlertOutput) SetSqlStatements(ctx context.Context, v []SqlStatementOutput) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_statements"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlStatements = types.ListValueMust(t, vs)
}

type SqlDashboardOutput struct {
	// The canonical identifier of the SQL warehouse.
	WarehouseId types.String `tfsdk:"warehouse_id"`
	// Widgets executed in the run. Only SQL query based widgets are listed.
	Widgets types.List `tfsdk:"widgets"`
}

func (to *SqlDashboardOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlDashboardOutput) {
	if !from.Widgets.IsNull() && !from.Widgets.IsUnknown() && to.Widgets.IsNull() && len(from.Widgets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Widgets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Widgets = from.Widgets
	}
}

func (to *SqlDashboardOutput) SyncFieldsDuringRead(ctx context.Context, from SqlDashboardOutput) {
	if !from.Widgets.IsNull() && !from.Widgets.IsUnknown() && to.Widgets.IsNull() && len(from.Widgets.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Widgets, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Widgets = from.Widgets
	}
}

func (m SqlDashboardOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()
	attrs["widgets"] = attrs["widgets"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlDashboardOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlDashboardOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"widgets": reflect.TypeOf(SqlDashboardWidgetOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlDashboardOutput
// only implements ToObjectValue() and Type().
func (m SqlDashboardOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"warehouse_id": m.WarehouseId,
			"widgets":      m.Widgets,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlDashboardOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"warehouse_id": types.StringType,
			"widgets": basetypes.ListType{
				ElemType: SqlDashboardWidgetOutput{}.Type(ctx),
			},
		},
	}
}

// GetWidgets returns the value of the Widgets field in SqlDashboardOutput as
// a slice of SqlDashboardWidgetOutput values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlDashboardOutput) GetWidgets(ctx context.Context) ([]SqlDashboardWidgetOutput, bool) {
	if m.Widgets.IsNull() || m.Widgets.IsUnknown() {
		return nil, false
	}
	var v []SqlDashboardWidgetOutput
	d := m.Widgets.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWidgets sets the value of the Widgets field in SqlDashboardOutput.
func (m *SqlDashboardOutput) SetWidgets(ctx context.Context, v []SqlDashboardWidgetOutput) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["widgets"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Widgets = types.ListValueMust(t, vs)
}

type SqlDashboardWidgetOutput struct {
	// Time (in epoch milliseconds) when execution of the SQL widget ends.
	EndTime types.Int64 `tfsdk:"end_time"`
	// The information about the error when execution fails.
	Error types.Object `tfsdk:"error"`
	// The link to find the output results.
	OutputLink types.String `tfsdk:"output_link"`
	// Time (in epoch milliseconds) when execution of the SQL widget starts.
	StartTime types.Int64 `tfsdk:"start_time"`
	// The execution status of the SQL widget.
	Status types.String `tfsdk:"status"`
	// The canonical identifier of the SQL widget.
	WidgetId types.String `tfsdk:"widget_id"`
	// The title of the SQL widget.
	WidgetTitle types.String `tfsdk:"widget_title"`
}

func (to *SqlDashboardWidgetOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlDashboardWidgetOutput) {
	if !from.Error.IsNull() && !from.Error.IsUnknown() {
		if toError, ok := to.GetError(ctx); ok {
			if fromError, ok := from.GetError(ctx); ok {
				// Recursively sync the fields of Error
				toError.SyncFieldsDuringCreateOrUpdate(ctx, fromError)
				to.SetError(ctx, toError)
			}
		}
	}
}

func (to *SqlDashboardWidgetOutput) SyncFieldsDuringRead(ctx context.Context, from SqlDashboardWidgetOutput) {
	if !from.Error.IsNull() && !from.Error.IsUnknown() {
		if toError, ok := to.GetError(ctx); ok {
			if fromError, ok := from.GetError(ctx); ok {
				toError.SyncFieldsDuringRead(ctx, fromError)
				to.SetError(ctx, toError)
			}
		}
	}
}

func (m SqlDashboardWidgetOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["end_time"] = attrs["end_time"].SetOptional()
	attrs["error"] = attrs["error"].SetOptional()
	attrs["output_link"] = attrs["output_link"].SetOptional()
	attrs["start_time"] = attrs["start_time"].SetOptional()
	attrs["status"] = attrs["status"].SetOptional()
	attrs["widget_id"] = attrs["widget_id"].SetOptional()
	attrs["widget_title"] = attrs["widget_title"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlDashboardWidgetOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlDashboardWidgetOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"error": reflect.TypeOf(SqlOutputError{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlDashboardWidgetOutput
// only implements ToObjectValue() and Type().
func (m SqlDashboardWidgetOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"end_time":     m.EndTime,
			"error":        m.Error,
			"output_link":  m.OutputLink,
			"start_time":   m.StartTime,
			"status":       m.Status,
			"widget_id":    m.WidgetId,
			"widget_title": m.WidgetTitle,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlDashboardWidgetOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"end_time":     types.Int64Type,
			"error":        SqlOutputError{}.Type(ctx),
			"output_link":  types.StringType,
			"start_time":   types.Int64Type,
			"status":       types.StringType,
			"widget_id":    types.StringType,
			"widget_title": types.StringType,
		},
	}
}

// GetError returns the value of the Error field in SqlDashboardWidgetOutput as
// a SqlOutputError value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlDashboardWidgetOutput) GetError(ctx context.Context) (SqlOutputError, bool) {
	var e SqlOutputError
	if m.Error.IsNull() || m.Error.IsUnknown() {
		return e, false
	}
	var v SqlOutputError
	d := m.Error.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetError sets the value of the Error field in SqlDashboardWidgetOutput.
func (m *SqlDashboardWidgetOutput) SetError(ctx context.Context, v SqlOutputError) {
	vs := v.ToObjectValue(ctx)
	m.Error = vs
}

type SqlOutput struct {
	// The output of a SQL alert task, if available.
	AlertOutput types.Object `tfsdk:"alert_output"`
	// The output of a SQL dashboard task, if available.
	DashboardOutput types.Object `tfsdk:"dashboard_output"`
	// The output of a SQL query task, if available.
	QueryOutput types.Object `tfsdk:"query_output"`
}

func (to *SqlOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlOutput) {
	if !from.AlertOutput.IsNull() && !from.AlertOutput.IsUnknown() {
		if toAlertOutput, ok := to.GetAlertOutput(ctx); ok {
			if fromAlertOutput, ok := from.GetAlertOutput(ctx); ok {
				// Recursively sync the fields of AlertOutput
				toAlertOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromAlertOutput)
				to.SetAlertOutput(ctx, toAlertOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				// Recursively sync the fields of DashboardOutput
				toDashboardOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.QueryOutput.IsNull() && !from.QueryOutput.IsUnknown() {
		if toQueryOutput, ok := to.GetQueryOutput(ctx); ok {
			if fromQueryOutput, ok := from.GetQueryOutput(ctx); ok {
				// Recursively sync the fields of QueryOutput
				toQueryOutput.SyncFieldsDuringCreateOrUpdate(ctx, fromQueryOutput)
				to.SetQueryOutput(ctx, toQueryOutput)
			}
		}
	}
}

func (to *SqlOutput) SyncFieldsDuringRead(ctx context.Context, from SqlOutput) {
	if !from.AlertOutput.IsNull() && !from.AlertOutput.IsUnknown() {
		if toAlertOutput, ok := to.GetAlertOutput(ctx); ok {
			if fromAlertOutput, ok := from.GetAlertOutput(ctx); ok {
				toAlertOutput.SyncFieldsDuringRead(ctx, fromAlertOutput)
				to.SetAlertOutput(ctx, toAlertOutput)
			}
		}
	}
	if !from.DashboardOutput.IsNull() && !from.DashboardOutput.IsUnknown() {
		if toDashboardOutput, ok := to.GetDashboardOutput(ctx); ok {
			if fromDashboardOutput, ok := from.GetDashboardOutput(ctx); ok {
				toDashboardOutput.SyncFieldsDuringRead(ctx, fromDashboardOutput)
				to.SetDashboardOutput(ctx, toDashboardOutput)
			}
		}
	}
	if !from.QueryOutput.IsNull() && !from.QueryOutput.IsUnknown() {
		if toQueryOutput, ok := to.GetQueryOutput(ctx); ok {
			if fromQueryOutput, ok := from.GetQueryOutput(ctx); ok {
				toQueryOutput.SyncFieldsDuringRead(ctx, fromQueryOutput)
				to.SetQueryOutput(ctx, toQueryOutput)
			}
		}
	}
}

func (m SqlOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_output"] = attrs["alert_output"].SetOptional()
	attrs["dashboard_output"] = attrs["dashboard_output"].SetOptional()
	attrs["query_output"] = attrs["query_output"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"alert_output":     reflect.TypeOf(SqlAlertOutput{}),
		"dashboard_output": reflect.TypeOf(SqlDashboardOutput{}),
		"query_output":     reflect.TypeOf(SqlQueryOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlOutput
// only implements ToObjectValue() and Type().
func (m SqlOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_output":     m.AlertOutput,
			"dashboard_output": m.DashboardOutput,
			"query_output":     m.QueryOutput,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_output":     SqlAlertOutput{}.Type(ctx),
			"dashboard_output": SqlDashboardOutput{}.Type(ctx),
			"query_output":     SqlQueryOutput{}.Type(ctx),
		},
	}
}

// GetAlertOutput returns the value of the AlertOutput field in SqlOutput as
// a SqlAlertOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlOutput) GetAlertOutput(ctx context.Context) (SqlAlertOutput, bool) {
	var e SqlAlertOutput
	if m.AlertOutput.IsNull() || m.AlertOutput.IsUnknown() {
		return e, false
	}
	var v SqlAlertOutput
	d := m.AlertOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAlertOutput sets the value of the AlertOutput field in SqlOutput.
func (m *SqlOutput) SetAlertOutput(ctx context.Context, v SqlAlertOutput) {
	vs := v.ToObjectValue(ctx)
	m.AlertOutput = vs
}

// GetDashboardOutput returns the value of the DashboardOutput field in SqlOutput as
// a SqlDashboardOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlOutput) GetDashboardOutput(ctx context.Context) (SqlDashboardOutput, bool) {
	var e SqlDashboardOutput
	if m.DashboardOutput.IsNull() || m.DashboardOutput.IsUnknown() {
		return e, false
	}
	var v SqlDashboardOutput
	d := m.DashboardOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboardOutput sets the value of the DashboardOutput field in SqlOutput.
func (m *SqlOutput) SetDashboardOutput(ctx context.Context, v SqlDashboardOutput) {
	vs := v.ToObjectValue(ctx)
	m.DashboardOutput = vs
}

// GetQueryOutput returns the value of the QueryOutput field in SqlOutput as
// a SqlQueryOutput value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlOutput) GetQueryOutput(ctx context.Context) (SqlQueryOutput, bool) {
	var e SqlQueryOutput
	if m.QueryOutput.IsNull() || m.QueryOutput.IsUnknown() {
		return e, false
	}
	var v SqlQueryOutput
	d := m.QueryOutput.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueryOutput sets the value of the QueryOutput field in SqlOutput.
func (m *SqlOutput) SetQueryOutput(ctx context.Context, v SqlQueryOutput) {
	vs := v.ToObjectValue(ctx)
	m.QueryOutput = vs
}

type SqlOutputError struct {
	// The error message when execution fails.
	Message types.String `tfsdk:"message"`
}

func (to *SqlOutputError) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlOutputError) {
}

func (to *SqlOutputError) SyncFieldsDuringRead(ctx context.Context, from SqlOutputError) {
}

func (m SqlOutputError) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlOutputError.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlOutputError) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlOutputError
// only implements ToObjectValue() and Type().
func (m SqlOutputError) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message": m.Message,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlOutputError) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message": types.StringType,
		},
	}
}

type SqlQueryOutput struct {
	EndpointId types.String `tfsdk:"endpoint_id"`
	// The link to find the output results.
	OutputLink types.String `tfsdk:"output_link"`
	// The text of the SQL query. Can Run permission of the SQL query is
	// required to view this field.
	QueryText types.String `tfsdk:"query_text"`
	// Information about SQL statements executed in the run.
	SqlStatements types.List `tfsdk:"sql_statements"`
	// The canonical identifier of the SQL warehouse.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *SqlQueryOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlQueryOutput) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (to *SqlQueryOutput) SyncFieldsDuringRead(ctx context.Context, from SqlQueryOutput) {
	if !from.SqlStatements.IsNull() && !from.SqlStatements.IsUnknown() && to.SqlStatements.IsNull() && len(from.SqlStatements.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for SqlStatements, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.SqlStatements = from.SqlStatements
	}
}

func (m SqlQueryOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["endpoint_id"] = attrs["endpoint_id"].SetOptional()
	attrs["output_link"] = attrs["output_link"].SetOptional()
	attrs["query_text"] = attrs["query_text"].SetOptional()
	attrs["sql_statements"] = attrs["sql_statements"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlQueryOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlQueryOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"sql_statements": reflect.TypeOf(SqlStatementOutput{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlQueryOutput
// only implements ToObjectValue() and Type().
func (m SqlQueryOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"endpoint_id":    m.EndpointId,
			"output_link":    m.OutputLink,
			"query_text":     m.QueryText,
			"sql_statements": m.SqlStatements,
			"warehouse_id":   m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlQueryOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"endpoint_id": types.StringType,
			"output_link": types.StringType,
			"query_text":  types.StringType,
			"sql_statements": basetypes.ListType{
				ElemType: SqlStatementOutput{}.Type(ctx),
			},
			"warehouse_id": types.StringType,
		},
	}
}

// GetSqlStatements returns the value of the SqlStatements field in SqlQueryOutput as
// a slice of SqlStatementOutput values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlQueryOutput) GetSqlStatements(ctx context.Context) ([]SqlStatementOutput, bool) {
	if m.SqlStatements.IsNull() || m.SqlStatements.IsUnknown() {
		return nil, false
	}
	var v []SqlStatementOutput
	d := m.SqlStatements.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlStatements sets the value of the SqlStatements field in SqlQueryOutput.
func (m *SqlQueryOutput) SetSqlStatements(ctx context.Context, v []SqlStatementOutput) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["sql_statements"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.SqlStatements = types.ListValueMust(t, vs)
}

type SqlStatementOutput struct {
	// A key that can be used to look up query details.
	LookupKey types.String `tfsdk:"lookup_key"`
}

func (to *SqlStatementOutput) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlStatementOutput) {
}

func (to *SqlStatementOutput) SyncFieldsDuringRead(ctx context.Context, from SqlStatementOutput) {
}

func (m SqlStatementOutput) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["lookup_key"] = attrs["lookup_key"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlStatementOutput.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlStatementOutput) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlStatementOutput
// only implements ToObjectValue() and Type().
func (m SqlStatementOutput) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"lookup_key": m.LookupKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlStatementOutput) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"lookup_key": types.StringType,
		},
	}
}

type SqlTask struct {
	// If alert, indicates that this job must refresh a SQL alert.
	Alert types.Object `tfsdk:"alert"`
	// If dashboard, indicates that this job must refresh a SQL dashboard.
	Dashboard types.Object `tfsdk:"dashboard"`
	// If file, indicates that this job runs a SQL file in a remote Git
	// repository.
	File types.Object `tfsdk:"file"`
	// Parameters to be used for each run of this job. The SQL alert task does
	// not support custom parameters.
	Parameters types.Map `tfsdk:"parameters"`
	// If query, indicates that this job must execute a SQL query.
	Query types.Object `tfsdk:"query"`
	// The canonical identifier of the SQL warehouse. Recommended to use with
	// serverless or pro SQL warehouses. Classic SQL warehouses are only
	// supported for SQL alert, dashboard and query tasks and are limited to
	// scheduled single-task jobs.
	WarehouseId types.String `tfsdk:"warehouse_id"`
}

func (to *SqlTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTask) {
	if !from.Alert.IsNull() && !from.Alert.IsUnknown() {
		if toAlert, ok := to.GetAlert(ctx); ok {
			if fromAlert, ok := from.GetAlert(ctx); ok {
				// Recursively sync the fields of Alert
				toAlert.SyncFieldsDuringCreateOrUpdate(ctx, fromAlert)
				to.SetAlert(ctx, toAlert)
			}
		}
	}
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				// Recursively sync the fields of Dashboard
				toDashboard.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
	if !from.File.IsNull() && !from.File.IsUnknown() {
		if toFile, ok := to.GetFile(ctx); ok {
			if fromFile, ok := from.GetFile(ctx); ok {
				// Recursively sync the fields of File
				toFile.SyncFieldsDuringCreateOrUpdate(ctx, fromFile)
				to.SetFile(ctx, toFile)
			}
		}
	}
	if !from.Query.IsNull() && !from.Query.IsUnknown() {
		if toQuery, ok := to.GetQuery(ctx); ok {
			if fromQuery, ok := from.GetQuery(ctx); ok {
				// Recursively sync the fields of Query
				toQuery.SyncFieldsDuringCreateOrUpdate(ctx, fromQuery)
				to.SetQuery(ctx, toQuery)
			}
		}
	}
}

func (to *SqlTask) SyncFieldsDuringRead(ctx context.Context, from SqlTask) {
	if !from.Alert.IsNull() && !from.Alert.IsUnknown() {
		if toAlert, ok := to.GetAlert(ctx); ok {
			if fromAlert, ok := from.GetAlert(ctx); ok {
				toAlert.SyncFieldsDuringRead(ctx, fromAlert)
				to.SetAlert(ctx, toAlert)
			}
		}
	}
	if !from.Dashboard.IsNull() && !from.Dashboard.IsUnknown() {
		if toDashboard, ok := to.GetDashboard(ctx); ok {
			if fromDashboard, ok := from.GetDashboard(ctx); ok {
				toDashboard.SyncFieldsDuringRead(ctx, fromDashboard)
				to.SetDashboard(ctx, toDashboard)
			}
		}
	}
	if !from.File.IsNull() && !from.File.IsUnknown() {
		if toFile, ok := to.GetFile(ctx); ok {
			if fromFile, ok := from.GetFile(ctx); ok {
				toFile.SyncFieldsDuringRead(ctx, fromFile)
				to.SetFile(ctx, toFile)
			}
		}
	}
	if !from.Query.IsNull() && !from.Query.IsUnknown() {
		if toQuery, ok := to.GetQuery(ctx); ok {
			if fromQuery, ok := from.GetQuery(ctx); ok {
				toQuery.SyncFieldsDuringRead(ctx, fromQuery)
				to.SetQuery(ctx, toQuery)
			}
		}
	}
}

func (m SqlTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert"] = attrs["alert"].SetOptional()
	attrs["dashboard"] = attrs["dashboard"].SetOptional()
	attrs["file"] = attrs["file"].SetOptional()
	attrs["parameters"] = attrs["parameters"].SetOptional()
	attrs["query"] = attrs["query"].SetOptional()
	attrs["warehouse_id"] = attrs["warehouse_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"alert":      reflect.TypeOf(SqlTaskAlert{}),
		"dashboard":  reflect.TypeOf(SqlTaskDashboard{}),
		"file":       reflect.TypeOf(SqlTaskFile{}),
		"parameters": reflect.TypeOf(types.String{}),
		"query":      reflect.TypeOf(SqlTaskQuery{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTask
// only implements ToObjectValue() and Type().
func (m SqlTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert":        m.Alert,
			"dashboard":    m.Dashboard,
			"file":         m.File,
			"parameters":   m.Parameters,
			"query":        m.Query,
			"warehouse_id": m.WarehouseId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert":     SqlTaskAlert{}.Type(ctx),
			"dashboard": SqlTaskDashboard{}.Type(ctx),
			"file":      SqlTaskFile{}.Type(ctx),
			"parameters": basetypes.MapType{
				ElemType: types.StringType,
			},
			"query":        SqlTaskQuery{}.Type(ctx),
			"warehouse_id": types.StringType,
		},
	}
}

// GetAlert returns the value of the Alert field in SqlTask as
// a SqlTaskAlert value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask) GetAlert(ctx context.Context) (SqlTaskAlert, bool) {
	var e SqlTaskAlert
	if m.Alert.IsNull() || m.Alert.IsUnknown() {
		return e, false
	}
	var v SqlTaskAlert
	d := m.Alert.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAlert sets the value of the Alert field in SqlTask.
func (m *SqlTask) SetAlert(ctx context.Context, v SqlTaskAlert) {
	vs := v.ToObjectValue(ctx)
	m.Alert = vs
}

// GetDashboard returns the value of the Dashboard field in SqlTask as
// a SqlTaskDashboard value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask) GetDashboard(ctx context.Context) (SqlTaskDashboard, bool) {
	var e SqlTaskDashboard
	if m.Dashboard.IsNull() || m.Dashboard.IsUnknown() {
		return e, false
	}
	var v SqlTaskDashboard
	d := m.Dashboard.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboard sets the value of the Dashboard field in SqlTask.
func (m *SqlTask) SetDashboard(ctx context.Context, v SqlTaskDashboard) {
	vs := v.ToObjectValue(ctx)
	m.Dashboard = vs
}

// GetFile returns the value of the File field in SqlTask as
// a SqlTaskFile value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask) GetFile(ctx context.Context) (SqlTaskFile, bool) {
	var e SqlTaskFile
	if m.File.IsNull() || m.File.IsUnknown() {
		return e, false
	}
	var v SqlTaskFile
	d := m.File.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFile sets the value of the File field in SqlTask.
func (m *SqlTask) SetFile(ctx context.Context, v SqlTaskFile) {
	vs := v.ToObjectValue(ctx)
	m.File = vs
}

// GetParameters returns the value of the Parameters field in SqlTask as
// a map of string to types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask) GetParameters(ctx context.Context) (map[string]types.String, bool) {
	if m.Parameters.IsNull() || m.Parameters.IsUnknown() {
		return nil, false
	}
	var v map[string]types.String
	d := m.Parameters.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetParameters sets the value of the Parameters field in SqlTask.
func (m *SqlTask) SetParameters(ctx context.Context, v map[string]types.String) {
	vs := make(map[string]attr.Value, len(v))
	for k, e := range v {
		vs[k] = e
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["parameters"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Parameters = types.MapValueMust(t, vs)
}

// GetQuery returns the value of the Query field in SqlTask as
// a SqlTaskQuery value.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTask) GetQuery(ctx context.Context) (SqlTaskQuery, bool) {
	var e SqlTaskQuery
	if m.Query.IsNull() || m.Query.IsUnknown() {
		return e, false
	}
	var v SqlTaskQuery
	d := m.Query.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQuery sets the value of the Query field in SqlTask.
func (m *SqlTask) SetQuery(ctx context.Context, v SqlTaskQuery) {
	vs := v.ToObjectValue(ctx)
	m.Query = vs
}

type SqlTaskAlert struct {
	// The canonical identifier of the SQL alert.
	AlertId types.String `tfsdk:"alert_id"`
	// If true, the alert notifications are not sent to subscribers.
	PauseSubscriptions types.Bool `tfsdk:"pause_subscriptions"`
	// If specified, alert notifications are sent to subscribers.
	Subscriptions types.List `tfsdk:"subscriptions"`
}

func (to *SqlTaskAlert) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskAlert) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (to *SqlTaskAlert) SyncFieldsDuringRead(ctx context.Context, from SqlTaskAlert) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (m SqlTaskAlert) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_id"] = attrs["alert_id"].SetRequired()
	attrs["pause_subscriptions"] = attrs["pause_subscriptions"].SetOptional()
	attrs["subscriptions"] = attrs["subscriptions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskAlert.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskAlert) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscriptions": reflect.TypeOf(SqlTaskSubscription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskAlert
// only implements ToObjectValue() and Type().
func (m SqlTaskAlert) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_id":            m.AlertId,
			"pause_subscriptions": m.PauseSubscriptions,
			"subscriptions":       m.Subscriptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskAlert) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_id":            types.StringType,
			"pause_subscriptions": types.BoolType,
			"subscriptions": basetypes.ListType{
				ElemType: SqlTaskSubscription{}.Type(ctx),
			},
		},
	}
}

// GetSubscriptions returns the value of the Subscriptions field in SqlTaskAlert as
// a slice of SqlTaskSubscription values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTaskAlert) GetSubscriptions(ctx context.Context) ([]SqlTaskSubscription, bool) {
	if m.Subscriptions.IsNull() || m.Subscriptions.IsUnknown() {
		return nil, false
	}
	var v []SqlTaskSubscription
	d := m.Subscriptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscriptions sets the value of the Subscriptions field in SqlTaskAlert.
func (m *SqlTaskAlert) SetSubscriptions(ctx context.Context, v []SqlTaskSubscription) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscriptions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscriptions = types.ListValueMust(t, vs)
}

type SqlTaskDashboard struct {
	// Subject of the email sent to subscribers of this task.
	CustomSubject types.String `tfsdk:"custom_subject"`
	// The canonical identifier of the SQL dashboard.
	DashboardId types.String `tfsdk:"dashboard_id"`
	// If true, the dashboard snapshot is not taken, and emails are not sent to
	// subscribers.
	PauseSubscriptions types.Bool `tfsdk:"pause_subscriptions"`
	// If specified, dashboard snapshots are sent to subscriptions.
	Subscriptions types.List `tfsdk:"subscriptions"`
}

func (to *SqlTaskDashboard) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskDashboard) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (to *SqlTaskDashboard) SyncFieldsDuringRead(ctx context.Context, from SqlTaskDashboard) {
	if !from.Subscriptions.IsNull() && !from.Subscriptions.IsUnknown() && to.Subscriptions.IsNull() && len(from.Subscriptions.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscriptions, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscriptions = from.Subscriptions
	}
}

func (m SqlTaskDashboard) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["custom_subject"] = attrs["custom_subject"].SetOptional()
	attrs["dashboard_id"] = attrs["dashboard_id"].SetRequired()
	attrs["pause_subscriptions"] = attrs["pause_subscriptions"].SetOptional()
	attrs["subscriptions"] = attrs["subscriptions"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskDashboard.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskDashboard) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscriptions": reflect.TypeOf(SqlTaskSubscription{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskDashboard
// only implements ToObjectValue() and Type().
func (m SqlTaskDashboard) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"custom_subject":      m.CustomSubject,
			"dashboard_id":        m.DashboardId,
			"pause_subscriptions": m.PauseSubscriptions,
			"subscriptions":       m.Subscriptions,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskDashboard) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"custom_subject":      types.StringType,
			"dashboard_id":        types.StringType,
			"pause_subscriptions": types.BoolType,
			"subscriptions": basetypes.ListType{
				ElemType: SqlTaskSubscription{}.Type(ctx),
			},
		},
	}
}

// GetSubscriptions returns the value of the Subscriptions field in SqlTaskDashboard as
// a slice of SqlTaskSubscription values.
// If the field is unknown or null, the boolean return value is false.
func (m *SqlTaskDashboard) GetSubscriptions(ctx context.Context) ([]SqlTaskSubscription, bool) {
	if m.Subscriptions.IsNull() || m.Subscriptions.IsUnknown() {
		return nil, false
	}
	var v []SqlTaskSubscription
	d := m.Subscriptions.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscriptions sets the value of the Subscriptions field in SqlTaskDashboard.
func (m *SqlTaskDashboard) SetSubscriptions(ctx context.Context, v []SqlTaskSubscription) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscriptions"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscriptions = types.ListValueMust(t, vs)
}

type SqlTaskFile struct {
	// Path of the SQL file. Must be relative if the source is a remote Git
	// repository and absolute for workspace paths.
	Path types.String `tfsdk:"path"`
	// Optional location type of the SQL file. When set to `WORKSPACE`, the SQL
	// file will be retrieved from the local Databricks workspace. When set to
	// `GIT`, the SQL file will be retrieved from a Git repository defined in
	// `git_source`. If the value is empty, the task will use `GIT` if
	// `git_source` is defined and `WORKSPACE` otherwise.
	//
	// * `WORKSPACE`: SQL file is located in Databricks workspace. * `GIT`: SQL
	// file is located in cloud Git provider.
	Source types.String `tfsdk:"source"`
}

func (to *SqlTaskFile) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskFile) {
}

func (to *SqlTaskFile) SyncFieldsDuringRead(ctx context.Context, from SqlTaskFile) {
}

func (m SqlTaskFile) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["path"] = attrs["path"].SetRequired()
	attrs["source"] = attrs["source"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskFile.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskFile) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskFile
// only implements ToObjectValue() and Type().
func (m SqlTaskFile) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"path":   m.Path,
			"source": m.Source,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskFile) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"path":   types.StringType,
			"source": types.StringType,
		},
	}
}

type SqlTaskQuery struct {
	// The canonical identifier of the SQL query.
	QueryId types.String `tfsdk:"query_id"`
}

func (to *SqlTaskQuery) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskQuery) {
}

func (to *SqlTaskQuery) SyncFieldsDuringRead(ctx context.Context, from SqlTaskQuery) {
}

func (m SqlTaskQuery) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["query_id"] = attrs["query_id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskQuery.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskQuery) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskQuery
// only implements ToObjectValue() and Type().
func (m SqlTaskQuery) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"query_id": m.QueryId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskQuery) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"query_id": types.StringType,
		},
	}
}

type SqlTaskSubscription struct {
	// The canonical identifier of the destination to receive email
	// notification. This parameter is mutually exclusive with user_name. You
	// cannot set both destination_id and user_name for subscription
	// notifications.
	DestinationId types.String `tfsdk:"destination_id"`
	// The user name to receive the subscription email. This parameter is
	// mutually exclusive with destination_id. You cannot set both
	// destination_id and user_name for subscription notifications.
	UserName types.String `tfsdk:"user_name"`
}

func (to *SqlTaskSubscription) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SqlTaskSubscription) {
}

func (to *SqlTaskSubscription) SyncFieldsDuringRead(ctx context.Context, from SqlTaskSubscription) {
}

func (m SqlTaskSubscription) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetOptional()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SqlTaskSubscription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SqlTaskSubscription) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SqlTaskSubscription
// only implements ToObjectValue() and Type().
func (m SqlTaskSubscription) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id": m.DestinationId,
			"user_name":      m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SqlTaskSubscription) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id": types.StringType,
			"user_name":      types.StringType,
		},
	}
}

type SubmitRun struct {
	// List of permissions to set on the job.
	AccessControlList types.List `tfsdk:"access_control_list"`
	// The user specified id of the budget policy to use for this one-time run.
	// If not specified, the run will be not be attributed to any budget policy.
	BudgetPolicyId types.String `tfsdk:"budget_policy_id"`
	// An optional set of email addresses notified when the run begins or
	// completes.
	EmailNotifications types.Object `tfsdk:"email_notifications"`
	// A list of task execution environment specifications that can be
	// referenced by tasks of this run.
	Environments types.List `tfsdk:"environments"`
	// An optional specification for a remote Git repository containing the
	// source code used by tasks. Version-controlled source code is supported by
	// notebook, dbt, Python script, and SQL File tasks.
	//
	// If `git_source` is set, these tasks retrieve the file from the remote
	// repository by default. However, this behavior can be overridden by
	// setting `source` to `WORKSPACE` on the task.
	//
	// Note: dbt and SQL File tasks support only version-controlled sources. If
	// dbt or SQL File tasks are used, `git_source` must be defined on the job.
	GitSource types.Object `tfsdk:"git_source"`

	Health types.Object `tfsdk:"health"`
	// An optional token that can be used to guarantee the idempotency of job
	// run requests. If a run with the provided token already exists, the
	// request does not create a new run but returns the ID of the existing run
	// instead. If a run with the provided token is deleted, an error is
	// returned.
	//
	// If you specify the idempotency token, upon failure you can retry until
	// the request succeeds. Databricks guarantees that exactly one run is
	// launched with that idempotency token.
	//
	// This token must have at most 64 characters.
	//
	// For more information, see [How to ensure idempotency for jobs].
	//
	// [How to ensure idempotency for jobs]: https://kb.databricks.com/jobs/jobs-idempotency.html
	IdempotencyToken types.String `tfsdk:"idempotency_token"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// run.
	NotificationSettings types.Object `tfsdk:"notification_settings"`
	// The queue settings of the one-time run.
	Queue types.Object `tfsdk:"queue"`
	// Specifies the user or service principal that the job runs as. If not
	// specified, the job runs as the user who submits the request.
	RunAs types.Object `tfsdk:"run_as"`
	// An optional name for the run. The default value is `Untitled`.
	RunName types.String `tfsdk:"run_name"`

	Tasks types.List `tfsdk:"tasks"`
	// An optional timeout applied to each run of this job. A value of `0` means
	// no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// The user specified id of the usage policy to use for this one-time run.
	// If not specified, a default usage policy may be applied when creating or
	// modifying the job.
	UsagePolicyId types.String `tfsdk:"usage_policy_id"`
	// A collection of system notification IDs to notify when the run begins or
	// completes.
	WebhookNotifications types.Object `tfsdk:"webhook_notifications"`
}

func (to *SubmitRun) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubmitRun) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.BudgetPolicyId.IsUnknown() && !from.BudgetPolicyId.IsNull() {
		// BudgetPolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.BudgetPolicyId = from.BudgetPolicyId
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				// Recursively sync the fields of GitSource
				toGitSource.SyncFieldsDuringCreateOrUpdate(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				// Recursively sync the fields of Queue
				toQueue.SyncFieldsDuringCreateOrUpdate(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				// Recursively sync the fields of RunAs
				toRunAs.SyncFieldsDuringCreateOrUpdate(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.UsagePolicyId.IsUnknown() && !from.UsagePolicyId.IsNull() {
		// UsagePolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.UsagePolicyId = from.UsagePolicyId
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *SubmitRun) SyncFieldsDuringRead(ctx context.Context, from SubmitRun) {
	if !from.AccessControlList.IsNull() && !from.AccessControlList.IsUnknown() && to.AccessControlList.IsNull() && len(from.AccessControlList.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for AccessControlList, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.AccessControlList = from.AccessControlList
	}
	if !from.BudgetPolicyId.IsUnknown() && !from.BudgetPolicyId.IsNull() {
		// BudgetPolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.BudgetPolicyId = from.BudgetPolicyId
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.Environments.IsNull() && !from.Environments.IsUnknown() && to.Environments.IsNull() && len(from.Environments.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Environments, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Environments = from.Environments
	}
	if !from.GitSource.IsNull() && !from.GitSource.IsUnknown() {
		if toGitSource, ok := to.GetGitSource(ctx); ok {
			if fromGitSource, ok := from.GetGitSource(ctx); ok {
				toGitSource.SyncFieldsDuringRead(ctx, fromGitSource)
				to.SetGitSource(ctx, toGitSource)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.Queue.IsNull() && !from.Queue.IsUnknown() {
		if toQueue, ok := to.GetQueue(ctx); ok {
			if fromQueue, ok := from.GetQueue(ctx); ok {
				toQueue.SyncFieldsDuringRead(ctx, fromQueue)
				to.SetQueue(ctx, toQueue)
			}
		}
	}
	if !from.RunAs.IsNull() && !from.RunAs.IsUnknown() {
		if toRunAs, ok := to.GetRunAs(ctx); ok {
			if fromRunAs, ok := from.GetRunAs(ctx); ok {
				toRunAs.SyncFieldsDuringRead(ctx, fromRunAs)
				to.SetRunAs(ctx, toRunAs)
			}
		}
	}
	if !from.Tasks.IsNull() && !from.Tasks.IsUnknown() && to.Tasks.IsNull() && len(from.Tasks.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Tasks, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Tasks = from.Tasks
	}
	if !from.UsagePolicyId.IsUnknown() && !from.UsagePolicyId.IsNull() {
		// UsagePolicyId is an input only field and not returned by the service, so we keep the value from the prior state.
		to.UsagePolicyId = from.UsagePolicyId
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m SubmitRun) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["access_control_list"] = attrs["access_control_list"].SetOptional()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetOptional()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].SetComputed()
	attrs["budget_policy_id"] = attrs["budget_policy_id"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["environments"] = attrs["environments"].SetOptional()
	attrs["git_source"] = attrs["git_source"].SetOptional()
	attrs["health"] = attrs["health"].SetOptional()
	attrs["idempotency_token"] = attrs["idempotency_token"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["queue"] = attrs["queue"].SetOptional()
	attrs["run_as"] = attrs["run_as"].SetOptional()
	attrs["run_name"] = attrs["run_name"].SetOptional()
	attrs["tasks"] = attrs["tasks"].SetOptional()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetOptional()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].SetComputed()
	attrs["usage_policy_id"] = attrs["usage_policy_id"].(tfschema.StringAttributeBuilder).AddPlanModifier(stringplanmodifier.UseStateForUnknown()).(tfschema.AttributeBuilder)
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubmitRun.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubmitRun) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"access_control_list":   reflect.TypeOf(JobAccessControlRequest{}),
		"email_notifications":   reflect.TypeOf(JobEmailNotifications{}),
		"environments":          reflect.TypeOf(JobEnvironment{}),
		"git_source":            reflect.TypeOf(GitSource{}),
		"health":                reflect.TypeOf(JobsHealthRules{}),
		"notification_settings": reflect.TypeOf(JobNotificationSettings{}),
		"queue":                 reflect.TypeOf(QueueSettings{}),
		"run_as":                reflect.TypeOf(JobRunAs{}),
		"tasks":                 reflect.TypeOf(SubmitTask{}),
		"webhook_notifications": reflect.TypeOf(WebhookNotifications{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubmitRun
// only implements ToObjectValue() and Type().
func (m SubmitRun) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"access_control_list":   m.AccessControlList,
			"budget_policy_id":      m.BudgetPolicyId,
			"email_notifications":   m.EmailNotifications,
			"environments":          m.Environments,
			"git_source":            m.GitSource,
			"health":                m.Health,
			"idempotency_token":     m.IdempotencyToken,
			"notification_settings": m.NotificationSettings,
			"queue":                 m.Queue,
			"run_as":                m.RunAs,
			"run_name":              m.RunName,
			"tasks":                 m.Tasks,
			"timeout_seconds":       m.TimeoutSeconds,
			"usage_policy_id":       m.UsagePolicyId,
			"webhook_notifications": m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubmitRun) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"access_control_list": basetypes.ListType{
				ElemType: JobAccessControlRequest{}.Type(ctx),
			},
			"budget_policy_id":    types.StringType,
			"email_notifications": JobEmailNotifications{}.Type(ctx),
			"environments": basetypes.ListType{
				ElemType: JobEnvironment{}.Type(ctx),
			},
			"git_source":            GitSource{}.Type(ctx),
			"health":                JobsHealthRules{}.Type(ctx),
			"idempotency_token":     types.StringType,
			"notification_settings": JobNotificationSettings{}.Type(ctx),
			"queue":                 QueueSettings{}.Type(ctx),
			"run_as":                JobRunAs{}.Type(ctx),
			"run_name":              types.StringType,
			"tasks": basetypes.ListType{
				ElemType: SubmitTask{}.Type(ctx),
			},
			"timeout_seconds":       types.Int64Type,
			"usage_policy_id":       types.StringType,
			"webhook_notifications": WebhookNotifications{}.Type(ctx),
		},
	}
}

// GetAccessControlList returns the value of the AccessControlList field in SubmitRun as
// a slice of JobAccessControlRequest values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetAccessControlList(ctx context.Context) ([]JobAccessControlRequest, bool) {
	if m.AccessControlList.IsNull() || m.AccessControlList.IsUnknown() {
		return nil, false
	}
	var v []JobAccessControlRequest
	d := m.AccessControlList.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetAccessControlList sets the value of the AccessControlList field in SubmitRun.
func (m *SubmitRun) SetAccessControlList(ctx context.Context, v []JobAccessControlRequest) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["access_control_list"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.AccessControlList = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in SubmitRun as
// a JobEmailNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetEmailNotifications(ctx context.Context) (JobEmailNotifications, bool) {
	var e JobEmailNotifications
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v JobEmailNotifications
	d := m.EmailNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailNotifications sets the value of the EmailNotifications field in SubmitRun.
func (m *SubmitRun) SetEmailNotifications(ctx context.Context, v JobEmailNotifications) {
	vs := v.ToObjectValue(ctx)
	m.EmailNotifications = vs
}

// GetEnvironments returns the value of the Environments field in SubmitRun as
// a slice of JobEnvironment values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetEnvironments(ctx context.Context) ([]JobEnvironment, bool) {
	if m.Environments.IsNull() || m.Environments.IsUnknown() {
		return nil, false
	}
	var v []JobEnvironment
	d := m.Environments.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEnvironments sets the value of the Environments field in SubmitRun.
func (m *SubmitRun) SetEnvironments(ctx context.Context, v []JobEnvironment) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["environments"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Environments = types.ListValueMust(t, vs)
}

// GetGitSource returns the value of the GitSource field in SubmitRun as
// a GitSource value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetGitSource(ctx context.Context) (GitSource, bool) {
	var e GitSource
	if m.GitSource.IsNull() || m.GitSource.IsUnknown() {
		return e, false
	}
	var v GitSource
	d := m.GitSource.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGitSource sets the value of the GitSource field in SubmitRun.
func (m *SubmitRun) SetGitSource(ctx context.Context, v GitSource) {
	vs := v.ToObjectValue(ctx)
	m.GitSource = vs
}

// GetHealth returns the value of the Health field in SubmitRun as
// a JobsHealthRules value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetHealth(ctx context.Context) (JobsHealthRules, bool) {
	var e JobsHealthRules
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v JobsHealthRules
	d := m.Health.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetHealth sets the value of the Health field in SubmitRun.
func (m *SubmitRun) SetHealth(ctx context.Context, v JobsHealthRules) {
	vs := v.ToObjectValue(ctx)
	m.Health = vs
}

// GetNotificationSettings returns the value of the NotificationSettings field in SubmitRun as
// a JobNotificationSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetNotificationSettings(ctx context.Context) (JobNotificationSettings, bool) {
	var e JobNotificationSettings
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v JobNotificationSettings
	d := m.NotificationSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotificationSettings sets the value of the NotificationSettings field in SubmitRun.
func (m *SubmitRun) SetNotificationSettings(ctx context.Context, v JobNotificationSettings) {
	vs := v.ToObjectValue(ctx)
	m.NotificationSettings = vs
}

// GetQueue returns the value of the Queue field in SubmitRun as
// a QueueSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetQueue(ctx context.Context) (QueueSettings, bool) {
	var e QueueSettings
	if m.Queue.IsNull() || m.Queue.IsUnknown() {
		return e, false
	}
	var v QueueSettings
	d := m.Queue.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetQueue sets the value of the Queue field in SubmitRun.
func (m *SubmitRun) SetQueue(ctx context.Context, v QueueSettings) {
	vs := v.ToObjectValue(ctx)
	m.Queue = vs
}

// GetRunAs returns the value of the RunAs field in SubmitRun as
// a JobRunAs value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetRunAs(ctx context.Context) (JobRunAs, bool) {
	var e JobRunAs
	if m.RunAs.IsNull() || m.RunAs.IsUnknown() {
		return e, false
	}
	var v JobRunAs
	d := m.RunAs.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunAs sets the value of the RunAs field in SubmitRun.
func (m *SubmitRun) SetRunAs(ctx context.Context, v JobRunAs) {
	vs := v.ToObjectValue(ctx)
	m.RunAs = vs
}

// GetTasks returns the value of the Tasks field in SubmitRun as
// a slice of SubmitTask values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetTasks(ctx context.Context) ([]SubmitTask, bool) {
	if m.Tasks.IsNull() || m.Tasks.IsUnknown() {
		return nil, false
	}
	var v []SubmitTask
	d := m.Tasks.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTasks sets the value of the Tasks field in SubmitRun.
func (m *SubmitRun) SetTasks(ctx context.Context, v []SubmitTask) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["tasks"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Tasks = types.ListValueMust(t, vs)
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in SubmitRun as
// a WebhookNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitRun) GetWebhookNotifications(ctx context.Context) (WebhookNotifications, bool) {
	var e WebhookNotifications
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v WebhookNotifications
	d := m.WebhookNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in SubmitRun.
func (m *SubmitRun) SetWebhookNotifications(ctx context.Context, v WebhookNotifications) {
	vs := v.ToObjectValue(ctx)
	m.WebhookNotifications = vs
}

// Run was created and started successfully.
type SubmitRunResponse struct {
	// The canonical identifier for the newly submitted run.
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *SubmitRunResponse) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubmitRunResponse) {
}

func (to *SubmitRunResponse) SyncFieldsDuringRead(ctx context.Context, from SubmitRunResponse) {
}

func (m SubmitRunResponse) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubmitRunResponse.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubmitRunResponse) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubmitRunResponse
// only implements ToObjectValue() and Type().
func (m SubmitRunResponse) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubmitRunResponse) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type SubmitTask struct {
	// The task runs a [clean rooms] notebook when the
	// `clean_rooms_notebook_task` field is present.
	//
	// [clean rooms]: https://docs.databricks.com/clean-rooms/index.html
	CleanRoomsNotebookTask types.Object `tfsdk:"clean_rooms_notebook_task"`
	// The task evaluates a condition that can be used to control the execution
	// of other tasks when the `condition_task` field is present. The condition
	// task does not require a cluster to execute and does not support retries
	// or notifications.
	ConditionTask types.Object `tfsdk:"condition_task"`
	// The task refreshes a dashboard and sends a snapshot to subscribers.
	DashboardTask types.Object `tfsdk:"dashboard_task"`
	// Task type for dbt cloud, deprecated in favor of the new name
	// dbt_platform_task
	DbtCloudTask types.Object `tfsdk:"dbt_cloud_task"`

	DbtPlatformTask types.Object `tfsdk:"dbt_platform_task"`
	// The task runs one or more dbt commands when the `dbt_task` field is
	// present. The dbt task requires both Databricks SQL and the ability to use
	// a serverless or a pro SQL warehouse.
	DbtTask types.Object `tfsdk:"dbt_task"`
	// An optional array of objects specifying the dependency graph of the task.
	// All tasks specified in this field must complete successfully before
	// executing this task. The key is `task_key`, and the value is the name
	// assigned to the dependent task.
	DependsOn types.List `tfsdk:"depends_on"`
	// An optional description for this task.
	Description types.String `tfsdk:"description"`
	// An optional set of email addresses notified when the task run begins or
	// completes. The default behavior is to not send any emails.
	EmailNotifications types.Object `tfsdk:"email_notifications"`
	// The key that references an environment spec in a job. This field is
	// required for Python script, Python wheel and dbt tasks when using
	// serverless compute.
	EnvironmentKey types.String `tfsdk:"environment_key"`
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// The task executes a nested task for every input provided when the
	// `for_each_task` field is present.
	ForEachTask types.Object `tfsdk:"for_each_task"`

	GenAiComputeTask types.Object `tfsdk:"gen_ai_compute_task"`

	Health types.Object `tfsdk:"health"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.Object `tfsdk:"new_cluster"`
	// The task runs a notebook when the `notebook_task` field is present.
	NotebookTask types.Object `tfsdk:"notebook_task"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// task run.
	NotificationSettings types.Object `tfsdk:"notification_settings"`
	// The task triggers a pipeline update when the `pipeline_task` field is
	// present. Only pipelines configured to use triggered more are supported.
	PipelineTask types.Object `tfsdk:"pipeline_task"`
	// The task triggers a Power BI semantic model update when the
	// `power_bi_task` field is present.
	PowerBiTask types.Object `tfsdk:"power_bi_task"`
	// The task runs a Python wheel when the `python_wheel_task` field is
	// present.
	PythonWheelTask types.Object `tfsdk:"python_wheel_task"`
	// An optional value indicating the condition that determines whether the
	// task should be run once its dependencies have been completed. When
	// omitted, defaults to `ALL_SUCCESS`. See :method:jobs/create for a list of
	// possible values.
	RunIf types.String `tfsdk:"run_if"`
	// The task triggers another job when the `run_job_task` field is present.
	RunJobTask types.Object `tfsdk:"run_job_task"`
	// The task runs a JAR when the `spark_jar_task` field is present.
	SparkJarTask types.Object `tfsdk:"spark_jar_task"`
	// The task runs a Python file when the `spark_python_task` field is
	// present.
	SparkPythonTask types.Object `tfsdk:"spark_python_task"`
	// (Legacy) The task runs the spark-submit script when the spark_submit_task
	// field is present. Databricks recommends using the spark_jar_task instead;
	// see [Spark Submit task for jobs](/jobs/spark-submit).
	SparkSubmitTask types.Object `tfsdk:"spark_submit_task"`
	// The task runs a SQL query or file, or it refreshes a SQL alert or a
	// legacy SQL dashboard when the `sql_task` field is present.
	SqlTask types.Object `tfsdk:"sql_task"`
	// A unique name for the task. This field is used to refer to this task from
	// other tasks. This field is required and must be unique within its parent
	// job. On Update or Reset, this field is used to reference the tasks to be
	// updated or reset.
	TaskKey types.String `tfsdk:"task_key"`
	// An optional timeout applied to each run of this job task. A value of `0`
	// means no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A collection of system notification IDs to notify when the run begins or
	// completes. The default behavior is to not send any system notifications.
	// Task webhooks respect the task notification settings.
	WebhookNotifications types.Object `tfsdk:"webhook_notifications"`
}

func (to *SubmitTask) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubmitTask) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookTask
				toCleanRoomsNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				// Recursively sync the fields of DashboardTask
				toDashboardTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				// Recursively sync the fields of DbtCloudTask
				toDbtCloudTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				// Recursively sync the fields of DbtPlatformTask
				toDbtPlatformTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				// Recursively sync the fields of ForEachTask
				toForEachTask.SyncFieldsDuringCreateOrUpdate(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				// Recursively sync the fields of GenAiComputeTask
				toGenAiComputeTask.SyncFieldsDuringCreateOrUpdate(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				// Recursively sync the fields of PipelineTask
				toPipelineTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				// Recursively sync the fields of PowerBiTask
				toPowerBiTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *SubmitTask) SyncFieldsDuringRead(ctx context.Context, from SubmitTask) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				toCleanRoomsNotebookTask.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				toDashboardTask.SyncFieldsDuringRead(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				toDbtCloudTask.SyncFieldsDuringRead(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				toDbtPlatformTask.SyncFieldsDuringRead(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				toForEachTask.SyncFieldsDuringRead(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				toGenAiComputeTask.SyncFieldsDuringRead(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				toPipelineTask.SyncFieldsDuringRead(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				toPowerBiTask.SyncFieldsDuringRead(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m SubmitTask) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["dashboard_task"] = attrs["dashboard_task"].SetOptional()
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].SetOptional()
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["depends_on"] = attrs["depends_on"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["environment_key"] = attrs["environment_key"].SetOptional()
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].SetOptional()
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].SetOptional()
	attrs["health"] = attrs["health"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["pipeline_task"] = attrs["pipeline_task"].SetOptional()
	attrs["power_bi_task"] = attrs["power_bi_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["run_if"] = attrs["run_if"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["task_key"] = attrs["task_key"].SetRequired()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubmitTask.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubmitTask) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_task": reflect.TypeOf(CleanRoomsNotebookTask{}),
		"condition_task":            reflect.TypeOf(ConditionTask{}),
		"dashboard_task":            reflect.TypeOf(DashboardTask{}),
		"dbt_cloud_task":            reflect.TypeOf(DbtCloudTask{}),
		"dbt_platform_task":         reflect.TypeOf(DbtPlatformTask{}),
		"dbt_task":                  reflect.TypeOf(DbtTask{}),
		"depends_on":                reflect.TypeOf(TaskDependency{}),
		"email_notifications":       reflect.TypeOf(JobEmailNotifications{}),
		"for_each_task":             reflect.TypeOf(ForEachTask{}),
		"gen_ai_compute_task":       reflect.TypeOf(GenAiComputeTask{}),
		"health":                    reflect.TypeOf(JobsHealthRules{}),
		"library":                   reflect.TypeOf(compute_tf.Library{}),
		"new_cluster":               reflect.TypeOf(compute_tf.ClusterSpec{}),
		"notebook_task":             reflect.TypeOf(NotebookTask{}),
		"notification_settings":     reflect.TypeOf(TaskNotificationSettings{}),
		"pipeline_task":             reflect.TypeOf(PipelineTask{}),
		"power_bi_task":             reflect.TypeOf(PowerBiTask{}),
		"python_wheel_task":         reflect.TypeOf(PythonWheelTask{}),
		"run_job_task":              reflect.TypeOf(RunJobTask{}),
		"spark_jar_task":            reflect.TypeOf(SparkJarTask{}),
		"spark_python_task":         reflect.TypeOf(SparkPythonTask{}),
		"spark_submit_task":         reflect.TypeOf(SparkSubmitTask{}),
		"sql_task":                  reflect.TypeOf(SqlTask{}),
		"webhook_notifications":     reflect.TypeOf(WebhookNotifications{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubmitTask
// only implements ToObjectValue() and Type().
func (m SubmitTask) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_rooms_notebook_task": m.CleanRoomsNotebookTask,
			"condition_task":            m.ConditionTask,
			"dashboard_task":            m.DashboardTask,
			"dbt_cloud_task":            m.DbtCloudTask,
			"dbt_platform_task":         m.DbtPlatformTask,
			"dbt_task":                  m.DbtTask,
			"depends_on":                m.DependsOn,
			"description":               m.Description,
			"email_notifications":       m.EmailNotifications,
			"environment_key":           m.EnvironmentKey,
			"existing_cluster_id":       m.ExistingClusterId,
			"for_each_task":             m.ForEachTask,
			"gen_ai_compute_task":       m.GenAiComputeTask,
			"health":                    m.Health,
			"library":                   m.Libraries,
			"new_cluster":               m.NewCluster,
			"notebook_task":             m.NotebookTask,
			"notification_settings":     m.NotificationSettings,
			"pipeline_task":             m.PipelineTask,
			"power_bi_task":             m.PowerBiTask,
			"python_wheel_task":         m.PythonWheelTask,
			"run_if":                    m.RunIf,
			"run_job_task":              m.RunJobTask,
			"spark_jar_task":            m.SparkJarTask,
			"spark_python_task":         m.SparkPythonTask,
			"spark_submit_task":         m.SparkSubmitTask,
			"sql_task":                  m.SqlTask,
			"task_key":                  m.TaskKey,
			"timeout_seconds":           m.TimeoutSeconds,
			"webhook_notifications":     m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubmitTask) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_rooms_notebook_task": CleanRoomsNotebookTask{}.Type(ctx),
			"condition_task":            ConditionTask{}.Type(ctx),
			"dashboard_task":            DashboardTask{}.Type(ctx),
			"dbt_cloud_task":            DbtCloudTask{}.Type(ctx),
			"dbt_platform_task":         DbtPlatformTask{}.Type(ctx),
			"dbt_task":                  DbtTask{}.Type(ctx),
			"depends_on": basetypes.ListType{
				ElemType: TaskDependency{}.Type(ctx),
			},
			"description":         types.StringType,
			"email_notifications": JobEmailNotifications{}.Type(ctx),
			"environment_key":     types.StringType,
			"existing_cluster_id": types.StringType,
			"for_each_task":       ForEachTask{}.Type(ctx),
			"gen_ai_compute_task": GenAiComputeTask{}.Type(ctx),
			"health":              JobsHealthRules{}.Type(ctx),
			"library": basetypes.ListType{
				ElemType: compute_tf.Library{}.Type(ctx),
			},
			"new_cluster":           compute_tf.ClusterSpec{}.Type(ctx),
			"notebook_task":         NotebookTask{}.Type(ctx),
			"notification_settings": TaskNotificationSettings{}.Type(ctx),
			"pipeline_task":         PipelineTask{}.Type(ctx),
			"power_bi_task":         PowerBiTask{}.Type(ctx),
			"python_wheel_task":     PythonWheelTask{}.Type(ctx),
			"run_if":                types.StringType,
			"run_job_task":          RunJobTask{}.Type(ctx),
			"spark_jar_task":        SparkJarTask{}.Type(ctx),
			"spark_python_task":     SparkPythonTask{}.Type(ctx),
			"spark_submit_task":     SparkSubmitTask{}.Type(ctx),
			"sql_task":              SqlTask{}.Type(ctx),
			"task_key":              types.StringType,
			"timeout_seconds":       types.Int64Type,
			"webhook_notifications": WebhookNotifications{}.Type(ctx),
		},
	}
}

// GetCleanRoomsNotebookTask returns the value of the CleanRoomsNotebookTask field in SubmitTask as
// a CleanRoomsNotebookTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetCleanRoomsNotebookTask(ctx context.Context) (CleanRoomsNotebookTask, bool) {
	var e CleanRoomsNotebookTask
	if m.CleanRoomsNotebookTask.IsNull() || m.CleanRoomsNotebookTask.IsUnknown() {
		return e, false
	}
	var v CleanRoomsNotebookTask
	d := m.CleanRoomsNotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCleanRoomsNotebookTask sets the value of the CleanRoomsNotebookTask field in SubmitTask.
func (m *SubmitTask) SetCleanRoomsNotebookTask(ctx context.Context, v CleanRoomsNotebookTask) {
	vs := v.ToObjectValue(ctx)
	m.CleanRoomsNotebookTask = vs
}

// GetConditionTask returns the value of the ConditionTask field in SubmitTask as
// a ConditionTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetConditionTask(ctx context.Context) (ConditionTask, bool) {
	var e ConditionTask
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v ConditionTask
	d := m.ConditionTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConditionTask sets the value of the ConditionTask field in SubmitTask.
func (m *SubmitTask) SetConditionTask(ctx context.Context, v ConditionTask) {
	vs := v.ToObjectValue(ctx)
	m.ConditionTask = vs
}

// GetDashboardTask returns the value of the DashboardTask field in SubmitTask as
// a DashboardTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetDashboardTask(ctx context.Context) (DashboardTask, bool) {
	var e DashboardTask
	if m.DashboardTask.IsNull() || m.DashboardTask.IsUnknown() {
		return e, false
	}
	var v DashboardTask
	d := m.DashboardTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboardTask sets the value of the DashboardTask field in SubmitTask.
func (m *SubmitTask) SetDashboardTask(ctx context.Context, v DashboardTask) {
	vs := v.ToObjectValue(ctx)
	m.DashboardTask = vs
}

// GetDbtCloudTask returns the value of the DbtCloudTask field in SubmitTask as
// a DbtCloudTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetDbtCloudTask(ctx context.Context) (DbtCloudTask, bool) {
	var e DbtCloudTask
	if m.DbtCloudTask.IsNull() || m.DbtCloudTask.IsUnknown() {
		return e, false
	}
	var v DbtCloudTask
	d := m.DbtCloudTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCloudTask sets the value of the DbtCloudTask field in SubmitTask.
func (m *SubmitTask) SetDbtCloudTask(ctx context.Context, v DbtCloudTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtCloudTask = vs
}

// GetDbtPlatformTask returns the value of the DbtPlatformTask field in SubmitTask as
// a DbtPlatformTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetDbtPlatformTask(ctx context.Context) (DbtPlatformTask, bool) {
	var e DbtPlatformTask
	if m.DbtPlatformTask.IsNull() || m.DbtPlatformTask.IsUnknown() {
		return e, false
	}
	var v DbtPlatformTask
	d := m.DbtPlatformTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtPlatformTask sets the value of the DbtPlatformTask field in SubmitTask.
func (m *SubmitTask) SetDbtPlatformTask(ctx context.Context, v DbtPlatformTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtPlatformTask = vs
}

// GetDbtTask returns the value of the DbtTask field in SubmitTask as
// a DbtTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetDbtTask(ctx context.Context) (DbtTask, bool) {
	var e DbtTask
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v DbtTask
	d := m.DbtTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtTask sets the value of the DbtTask field in SubmitTask.
func (m *SubmitTask) SetDbtTask(ctx context.Context, v DbtTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtTask = vs
}

// GetDependsOn returns the value of the DependsOn field in SubmitTask as
// a slice of TaskDependency values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetDependsOn(ctx context.Context) ([]TaskDependency, bool) {
	if m.DependsOn.IsNull() || m.DependsOn.IsUnknown() {
		return nil, false
	}
	var v []TaskDependency
	d := m.DependsOn.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependsOn sets the value of the DependsOn field in SubmitTask.
func (m *SubmitTask) SetDependsOn(ctx context.Context, v []TaskDependency) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["depends_on"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DependsOn = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in SubmitTask as
// a JobEmailNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetEmailNotifications(ctx context.Context) (JobEmailNotifications, bool) {
	var e JobEmailNotifications
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v JobEmailNotifications
	d := m.EmailNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailNotifications sets the value of the EmailNotifications field in SubmitTask.
func (m *SubmitTask) SetEmailNotifications(ctx context.Context, v JobEmailNotifications) {
	vs := v.ToObjectValue(ctx)
	m.EmailNotifications = vs
}

// GetForEachTask returns the value of the ForEachTask field in SubmitTask as
// a ForEachTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetForEachTask(ctx context.Context) (ForEachTask, bool) {
	var e ForEachTask
	if m.ForEachTask.IsNull() || m.ForEachTask.IsUnknown() {
		return e, false
	}
	var v ForEachTask
	d := m.ForEachTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetForEachTask sets the value of the ForEachTask field in SubmitTask.
func (m *SubmitTask) SetForEachTask(ctx context.Context, v ForEachTask) {
	vs := v.ToObjectValue(ctx)
	m.ForEachTask = vs
}

// GetGenAiComputeTask returns the value of the GenAiComputeTask field in SubmitTask as
// a GenAiComputeTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetGenAiComputeTask(ctx context.Context) (GenAiComputeTask, bool) {
	var e GenAiComputeTask
	if m.GenAiComputeTask.IsNull() || m.GenAiComputeTask.IsUnknown() {
		return e, false
	}
	var v GenAiComputeTask
	d := m.GenAiComputeTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGenAiComputeTask sets the value of the GenAiComputeTask field in SubmitTask.
func (m *SubmitTask) SetGenAiComputeTask(ctx context.Context, v GenAiComputeTask) {
	vs := v.ToObjectValue(ctx)
	m.GenAiComputeTask = vs
}

// GetHealth returns the value of the Health field in SubmitTask as
// a JobsHealthRules value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetHealth(ctx context.Context) (JobsHealthRules, bool) {
	var e JobsHealthRules
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v JobsHealthRules
	d := m.Health.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetHealth sets the value of the Health field in SubmitTask.
func (m *SubmitTask) SetHealth(ctx context.Context, v JobsHealthRules) {
	vs := v.ToObjectValue(ctx)
	m.Health = vs
}

// GetLibraries returns the value of the Libraries field in SubmitTask as
// a slice of compute_tf.Library values.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetLibraries(ctx context.Context) ([]compute_tf.Library, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in SubmitTask.
func (m *SubmitTask) SetLibraries(ctx context.Context, v []compute_tf.Library) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in SubmitTask as
// a compute_tf.ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec, bool) {
	var e compute_tf.ClusterSpec
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v compute_tf.ClusterSpec
	d := m.NewCluster.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewCluster sets the value of the NewCluster field in SubmitTask.
func (m *SubmitTask) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.NewCluster = vs
}

// GetNotebookTask returns the value of the NotebookTask field in SubmitTask as
// a NotebookTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetNotebookTask(ctx context.Context) (NotebookTask, bool) {
	var e NotebookTask
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v NotebookTask
	d := m.NotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookTask sets the value of the NotebookTask field in SubmitTask.
func (m *SubmitTask) SetNotebookTask(ctx context.Context, v NotebookTask) {
	vs := v.ToObjectValue(ctx)
	m.NotebookTask = vs
}

// GetNotificationSettings returns the value of the NotificationSettings field in SubmitTask as
// a TaskNotificationSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetNotificationSettings(ctx context.Context) (TaskNotificationSettings, bool) {
	var e TaskNotificationSettings
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v TaskNotificationSettings
	d := m.NotificationSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotificationSettings sets the value of the NotificationSettings field in SubmitTask.
func (m *SubmitTask) SetNotificationSettings(ctx context.Context, v TaskNotificationSettings) {
	vs := v.ToObjectValue(ctx)
	m.NotificationSettings = vs
}

// GetPipelineTask returns the value of the PipelineTask field in SubmitTask as
// a PipelineTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetPipelineTask(ctx context.Context) (PipelineTask, bool) {
	var e PipelineTask
	if m.PipelineTask.IsNull() || m.PipelineTask.IsUnknown() {
		return e, false
	}
	var v PipelineTask
	d := m.PipelineTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineTask sets the value of the PipelineTask field in SubmitTask.
func (m *SubmitTask) SetPipelineTask(ctx context.Context, v PipelineTask) {
	vs := v.ToObjectValue(ctx)
	m.PipelineTask = vs
}

// GetPowerBiTask returns the value of the PowerBiTask field in SubmitTask as
// a PowerBiTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetPowerBiTask(ctx context.Context) (PowerBiTask, bool) {
	var e PowerBiTask
	if m.PowerBiTask.IsNull() || m.PowerBiTask.IsUnknown() {
		return e, false
	}
	var v PowerBiTask
	d := m.PowerBiTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPowerBiTask sets the value of the PowerBiTask field in SubmitTask.
func (m *SubmitTask) SetPowerBiTask(ctx context.Context, v PowerBiTask) {
	vs := v.ToObjectValue(ctx)
	m.PowerBiTask = vs
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in SubmitTask as
// a PythonWheelTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetPythonWheelTask(ctx context.Context) (PythonWheelTask, bool) {
	var e PythonWheelTask
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v PythonWheelTask
	d := m.PythonWheelTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in SubmitTask.
func (m *SubmitTask) SetPythonWheelTask(ctx context.Context, v PythonWheelTask) {
	vs := v.ToObjectValue(ctx)
	m.PythonWheelTask = vs
}

// GetRunJobTask returns the value of the RunJobTask field in SubmitTask as
// a RunJobTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetRunJobTask(ctx context.Context) (RunJobTask, bool) {
	var e RunJobTask
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v RunJobTask
	d := m.RunJobTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunJobTask sets the value of the RunJobTask field in SubmitTask.
func (m *SubmitTask) SetRunJobTask(ctx context.Context, v RunJobTask) {
	vs := v.ToObjectValue(ctx)
	m.RunJobTask = vs
}

// GetSparkJarTask returns the value of the SparkJarTask field in SubmitTask as
// a SparkJarTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetSparkJarTask(ctx context.Context) (SparkJarTask, bool) {
	var e SparkJarTask
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v SparkJarTask
	d := m.SparkJarTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkJarTask sets the value of the SparkJarTask field in SubmitTask.
func (m *SubmitTask) SetSparkJarTask(ctx context.Context, v SparkJarTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkJarTask = vs
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in SubmitTask as
// a SparkPythonTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetSparkPythonTask(ctx context.Context) (SparkPythonTask, bool) {
	var e SparkPythonTask
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v SparkPythonTask
	d := m.SparkPythonTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in SubmitTask.
func (m *SubmitTask) SetSparkPythonTask(ctx context.Context, v SparkPythonTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkPythonTask = vs
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in SubmitTask as
// a SparkSubmitTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetSparkSubmitTask(ctx context.Context) (SparkSubmitTask, bool) {
	var e SparkSubmitTask
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v SparkSubmitTask
	d := m.SparkSubmitTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in SubmitTask.
func (m *SubmitTask) SetSparkSubmitTask(ctx context.Context, v SparkSubmitTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkSubmitTask = vs
}

// GetSqlTask returns the value of the SqlTask field in SubmitTask as
// a SqlTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetSqlTask(ctx context.Context) (SqlTask, bool) {
	var e SqlTask
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v SqlTask
	d := m.SqlTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlTask sets the value of the SqlTask field in SubmitTask.
func (m *SubmitTask) SetSqlTask(ctx context.Context, v SqlTask) {
	vs := v.ToObjectValue(ctx)
	m.SqlTask = vs
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in SubmitTask as
// a WebhookNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *SubmitTask) GetWebhookNotifications(ctx context.Context) (WebhookNotifications, bool) {
	var e WebhookNotifications
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v WebhookNotifications
	d := m.WebhookNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in SubmitTask.
func (m *SubmitTask) SetWebhookNotifications(ctx context.Context, v WebhookNotifications) {
	vs := v.ToObjectValue(ctx)
	m.WebhookNotifications = vs
}

type Subscription struct {
	// Optional: Allows users to specify a custom subject line on the email sent
	// to subscribers.
	CustomSubject types.String `tfsdk:"custom_subject"`
	// When true, the subscription will not send emails.
	Paused types.Bool `tfsdk:"paused"`
	// The list of subscribers to send the snapshot of the dashboard to.
	Subscribers types.List `tfsdk:"subscribers"`
}

func (to *Subscription) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Subscription) {
	if !from.Subscribers.IsNull() && !from.Subscribers.IsUnknown() && to.Subscribers.IsNull() && len(from.Subscribers.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscribers, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscribers = from.Subscribers
	}
}

func (to *Subscription) SyncFieldsDuringRead(ctx context.Context, from Subscription) {
	if !from.Subscribers.IsNull() && !from.Subscribers.IsUnknown() && to.Subscribers.IsNull() && len(from.Subscribers.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Subscribers, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Subscribers = from.Subscribers
	}
}

func (m Subscription) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["custom_subject"] = attrs["custom_subject"].SetOptional()
	attrs["paused"] = attrs["paused"].SetOptional()
	attrs["subscribers"] = attrs["subscribers"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Subscription.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Subscription) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"subscribers": reflect.TypeOf(SubscriptionSubscriber{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Subscription
// only implements ToObjectValue() and Type().
func (m Subscription) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"custom_subject": m.CustomSubject,
			"paused":         m.Paused,
			"subscribers":    m.Subscribers,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Subscription) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"custom_subject": types.StringType,
			"paused":         types.BoolType,
			"subscribers": basetypes.ListType{
				ElemType: SubscriptionSubscriber{}.Type(ctx),
			},
		},
	}
}

// GetSubscribers returns the value of the Subscribers field in Subscription as
// a slice of SubscriptionSubscriber values.
// If the field is unknown or null, the boolean return value is false.
func (m *Subscription) GetSubscribers(ctx context.Context) ([]SubscriptionSubscriber, bool) {
	if m.Subscribers.IsNull() || m.Subscribers.IsUnknown() {
		return nil, false
	}
	var v []SubscriptionSubscriber
	d := m.Subscribers.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSubscribers sets the value of the Subscribers field in Subscription.
func (m *Subscription) SetSubscribers(ctx context.Context, v []SubscriptionSubscriber) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["subscribers"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Subscribers = types.ListValueMust(t, vs)
}

type SubscriptionSubscriber struct {
	// A snapshot of the dashboard will be sent to the destination when the
	// `destination_id` field is present.
	DestinationId types.String `tfsdk:"destination_id"`
	// A snapshot of the dashboard will be sent to the user's email when the
	// `user_name` field is present.
	UserName types.String `tfsdk:"user_name"`
}

func (to *SubscriptionSubscriber) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from SubscriptionSubscriber) {
}

func (to *SubscriptionSubscriber) SyncFieldsDuringRead(ctx context.Context, from SubscriptionSubscriber) {
}

func (m SubscriptionSubscriber) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["destination_id"] = attrs["destination_id"].SetComputed()
	attrs["user_name"] = attrs["user_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in SubscriptionSubscriber.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m SubscriptionSubscriber) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, SubscriptionSubscriber
// only implements ToObjectValue() and Type().
func (m SubscriptionSubscriber) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"destination_id": m.DestinationId,
			"user_name":      m.UserName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m SubscriptionSubscriber) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"destination_id": types.StringType,
			"user_name":      types.StringType,
		},
	}
}

type TableState struct {
	// Whether or not the table has seen updates since either the creation of
	// the trigger or the last successful evaluation of the trigger
	HasSeenUpdates types.Bool `tfsdk:"has_seen_updates"`
	// Full table name of the table to monitor, e.g.
	// `mycatalog.myschema.mytable`
	TableName types.String `tfsdk:"table_name"`
}

func (to *TableState) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableState) {
}

func (to *TableState) SyncFieldsDuringRead(ctx context.Context, from TableState) {
}

func (m TableState) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["has_seen_updates"] = attrs["has_seen_updates"].SetOptional()
	attrs["table_name"] = attrs["table_name"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableState) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableState
// only implements ToObjectValue() and Type().
func (m TableState) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"has_seen_updates": m.HasSeenUpdates,
			"table_name":       m.TableName,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableState) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"has_seen_updates": types.BoolType,
			"table_name":       types.StringType,
		},
	}
}

type TableTriggerState struct {
	LastSeenTableStates types.List `tfsdk:"last_seen_table_states"`
	// Indicates whether the trigger is using scalable monitoring.
	UsingScalableMonitoring types.Bool `tfsdk:"using_scalable_monitoring"`
}

func (to *TableTriggerState) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableTriggerState) {
	if !from.LastSeenTableStates.IsNull() && !from.LastSeenTableStates.IsUnknown() && to.LastSeenTableStates.IsNull() && len(from.LastSeenTableStates.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for LastSeenTableStates, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.LastSeenTableStates = from.LastSeenTableStates
	}
}

func (to *TableTriggerState) SyncFieldsDuringRead(ctx context.Context, from TableTriggerState) {
	if !from.LastSeenTableStates.IsNull() && !from.LastSeenTableStates.IsUnknown() && to.LastSeenTableStates.IsNull() && len(from.LastSeenTableStates.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for LastSeenTableStates, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.LastSeenTableStates = from.LastSeenTableStates
	}
}

func (m TableTriggerState) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["last_seen_table_states"] = attrs["last_seen_table_states"].SetOptional()
	attrs["using_scalable_monitoring"] = attrs["using_scalable_monitoring"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableTriggerState.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableTriggerState) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"last_seen_table_states": reflect.TypeOf(TableState{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableTriggerState
// only implements ToObjectValue() and Type().
func (m TableTriggerState) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"last_seen_table_states":    m.LastSeenTableStates,
			"using_scalable_monitoring": m.UsingScalableMonitoring,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableTriggerState) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"last_seen_table_states": basetypes.ListType{
				ElemType: TableState{}.Type(ctx),
			},
			"using_scalable_monitoring": types.BoolType,
		},
	}
}

// GetLastSeenTableStates returns the value of the LastSeenTableStates field in TableTriggerState as
// a slice of TableState values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableTriggerState) GetLastSeenTableStates(ctx context.Context) ([]TableState, bool) {
	if m.LastSeenTableStates.IsNull() || m.LastSeenTableStates.IsUnknown() {
		return nil, false
	}
	var v []TableState
	d := m.LastSeenTableStates.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLastSeenTableStates sets the value of the LastSeenTableStates field in TableTriggerState.
func (m *TableTriggerState) SetLastSeenTableStates(ctx context.Context, v []TableState) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["last_seen_table_states"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.LastSeenTableStates = types.ListValueMust(t, vs)
}

type TableUpdateTriggerConfiguration struct {
	// The table(s) condition based on which to trigger a job run.
	Condition types.String `tfsdk:"condition"`
	// If set, the trigger starts a run only after the specified amount of time
	// has passed since the last time the trigger fired. The minimum allowed
	// value is 60 seconds.
	MinTimeBetweenTriggersSeconds types.Int64 `tfsdk:"min_time_between_triggers_seconds"`
	// A list of tables to monitor for changes. The table name must be in the
	// format `catalog_name.schema_name.table_name`.
	TableNames types.List `tfsdk:"table_names"`
	// If set, the trigger starts a run only after no table updates have
	// occurred for the specified time and can be used to wait for a series of
	// table updates before triggering a run. The minimum allowed value is 60
	// seconds.
	WaitAfterLastChangeSeconds types.Int64 `tfsdk:"wait_after_last_change_seconds"`
}

func (to *TableUpdateTriggerConfiguration) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TableUpdateTriggerConfiguration) {
	if !from.TableNames.IsNull() && !from.TableNames.IsUnknown() && to.TableNames.IsNull() && len(from.TableNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TableNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TableNames = from.TableNames
	}
}

func (to *TableUpdateTriggerConfiguration) SyncFieldsDuringRead(ctx context.Context, from TableUpdateTriggerConfiguration) {
	if !from.TableNames.IsNull() && !from.TableNames.IsUnknown() && to.TableNames.IsNull() && len(from.TableNames.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for TableNames, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.TableNames = from.TableNames
	}
}

func (m TableUpdateTriggerConfiguration) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["condition"] = attrs["condition"].SetOptional()
	attrs["min_time_between_triggers_seconds"] = attrs["min_time_between_triggers_seconds"].SetOptional()
	attrs["table_names"] = attrs["table_names"].SetOptional()
	attrs["wait_after_last_change_seconds"] = attrs["wait_after_last_change_seconds"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TableUpdateTriggerConfiguration.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TableUpdateTriggerConfiguration) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"table_names": reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TableUpdateTriggerConfiguration
// only implements ToObjectValue() and Type().
func (m TableUpdateTriggerConfiguration) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"condition":                         m.Condition,
			"min_time_between_triggers_seconds": m.MinTimeBetweenTriggersSeconds,
			"table_names":                       m.TableNames,
			"wait_after_last_change_seconds":    m.WaitAfterLastChangeSeconds,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TableUpdateTriggerConfiguration) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"condition":                         types.StringType,
			"min_time_between_triggers_seconds": types.Int64Type,
			"table_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wait_after_last_change_seconds": types.Int64Type,
		},
	}
}

// GetTableNames returns the value of the TableNames field in TableUpdateTriggerConfiguration as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TableUpdateTriggerConfiguration) GetTableNames(ctx context.Context) ([]types.String, bool) {
	if m.TableNames.IsNull() || m.TableNames.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.TableNames.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTableNames sets the value of the TableNames field in TableUpdateTriggerConfiguration.
func (m *TableUpdateTriggerConfiguration) SetTableNames(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["table_names"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.TableNames = types.ListValueMust(t, vs)
}

type Task struct {
	// The task runs a [clean rooms] notebook when the
	// `clean_rooms_notebook_task` field is present.
	//
	// [clean rooms]: https://docs.databricks.com/clean-rooms/index.html
	CleanRoomsNotebookTask types.Object `tfsdk:"clean_rooms_notebook_task"`
	// The task evaluates a condition that can be used to control the execution
	// of other tasks when the `condition_task` field is present. The condition
	// task does not require a cluster to execute and does not support retries
	// or notifications.
	ConditionTask types.Object `tfsdk:"condition_task"`
	// The task refreshes a dashboard and sends a snapshot to subscribers.
	DashboardTask types.Object `tfsdk:"dashboard_task"`
	// Task type for dbt cloud, deprecated in favor of the new name
	// dbt_platform_task
	DbtCloudTask types.Object `tfsdk:"dbt_cloud_task"`

	DbtPlatformTask types.Object `tfsdk:"dbt_platform_task"`
	// The task runs one or more dbt commands when the `dbt_task` field is
	// present. The dbt task requires both Databricks SQL and the ability to use
	// a serverless or a pro SQL warehouse.
	DbtTask types.Object `tfsdk:"dbt_task"`
	// An optional array of objects specifying the dependency graph of the task.
	// All tasks specified in this field must complete before executing this
	// task. The task will run only if the `run_if` condition is true. The key
	// is `task_key`, and the value is the name assigned to the dependent task.
	DependsOn types.List `tfsdk:"depends_on"`
	// An optional description for this task.
	Description types.String `tfsdk:"description"`
	// An option to disable auto optimization in serverless
	DisableAutoOptimization types.Bool `tfsdk:"disable_auto_optimization"`
	// An optional flag to disable the task. If set to true, the task will not
	// run even if it is part of a job.
	Disabled types.Bool `tfsdk:"disabled"`
	// An optional set of email addresses that is notified when runs of this
	// task begin or complete as well as when this task is deleted. The default
	// behavior is to not send any emails.
	EmailNotifications types.Object `tfsdk:"email_notifications"`
	// The key that references an environment spec in a job. This field is
	// required for Python script, Python wheel and dbt tasks when using
	// serverless compute.
	EnvironmentKey types.String `tfsdk:"environment_key"`
	// If existing_cluster_id, the ID of an existing cluster that is used for
	// all runs. When running jobs or tasks on an existing cluster, you may need
	// to manually restart the cluster if it stops responding. We suggest
	// running jobs and tasks on new clusters for greater reliability
	ExistingClusterId types.String `tfsdk:"existing_cluster_id"`
	// The task executes a nested task for every input provided when the
	// `for_each_task` field is present.
	ForEachTask types.Object `tfsdk:"for_each_task"`

	GenAiComputeTask types.Object `tfsdk:"gen_ai_compute_task"`

	Health types.Object `tfsdk:"health"`
	// If job_cluster_key, this task is executed reusing the cluster specified
	// in `job.settings.job_clusters`.
	JobClusterKey types.String `tfsdk:"job_cluster_key"`
	// An optional list of libraries to be installed on the cluster. The default
	// value is an empty list.
	Libraries types.List `tfsdk:"library"`
	// An optional maximum number of times to retry an unsuccessful run. A run
	// is considered to be unsuccessful if it completes with the `FAILED`
	// result_state or `INTERNAL_ERROR` `life_cycle_state`. The value `-1` means
	// to retry indefinitely and the value `0` means to never retry.
	MaxRetries types.Int64 `tfsdk:"max_retries"`
	// An optional minimal interval in milliseconds between the start of the
	// failed run and the subsequent retry run. The default behavior is that
	// unsuccessful runs are immediately retried.
	MinRetryIntervalMillis types.Int64 `tfsdk:"min_retry_interval_millis"`
	// If new_cluster, a description of a new cluster that is created for each
	// run.
	NewCluster types.Object `tfsdk:"new_cluster"`
	// The task runs a notebook when the `notebook_task` field is present.
	NotebookTask types.Object `tfsdk:"notebook_task"`
	// Optional notification settings that are used when sending notifications
	// to each of the `email_notifications` and `webhook_notifications` for this
	// task.
	NotificationSettings types.Object `tfsdk:"notification_settings"`
	// The task triggers a pipeline update when the `pipeline_task` field is
	// present. Only pipelines configured to use triggered more are supported.
	PipelineTask types.Object `tfsdk:"pipeline_task"`
	// The task triggers a Power BI semantic model update when the
	// `power_bi_task` field is present.
	PowerBiTask types.Object `tfsdk:"power_bi_task"`
	// The task runs a Python wheel when the `python_wheel_task` field is
	// present.
	PythonWheelTask types.Object `tfsdk:"python_wheel_task"`
	// An optional policy to specify whether to retry a job when it times out.
	// The default behavior is to not retry on timeout.
	RetryOnTimeout types.Bool `tfsdk:"retry_on_timeout"`
	// An optional value specifying the condition determining whether the task
	// is run once its dependencies have been completed.
	//
	// * `ALL_SUCCESS`: All dependencies have executed and succeeded *
	// `AT_LEAST_ONE_SUCCESS`: At least one dependency has succeeded *
	// `NONE_FAILED`: None of the dependencies have failed and at least one was
	// executed * `ALL_DONE`: All dependencies have been completed *
	// `AT_LEAST_ONE_FAILED`: At least one dependency failed * `ALL_FAILED`: ALl
	// dependencies have failed
	RunIf types.String `tfsdk:"run_if"`
	// The task triggers another job when the `run_job_task` field is present.
	RunJobTask types.Object `tfsdk:"run_job_task"`
	// The task runs a JAR when the `spark_jar_task` field is present.
	SparkJarTask types.Object `tfsdk:"spark_jar_task"`
	// The task runs a Python file when the `spark_python_task` field is
	// present.
	SparkPythonTask types.Object `tfsdk:"spark_python_task"`
	// (Legacy) The task runs the spark-submit script when the spark_submit_task
	// field is present. Databricks recommends using the spark_jar_task instead;
	// see [Spark Submit task for jobs](/jobs/spark-submit).
	SparkSubmitTask types.Object `tfsdk:"spark_submit_task"`
	// The task runs a SQL query or file, or it refreshes a SQL alert or a
	// legacy SQL dashboard when the `sql_task` field is present.
	SqlTask types.Object `tfsdk:"sql_task"`
	// A unique name for the task. This field is used to refer to this task from
	// other tasks. This field is required and must be unique within its parent
	// job. On Update or Reset, this field is used to reference the tasks to be
	// updated or reset.
	TaskKey types.String `tfsdk:"task_key"`
	// An optional timeout applied to each run of this job task. A value of `0`
	// means no timeout.
	TimeoutSeconds types.Int64 `tfsdk:"timeout_seconds"`
	// A collection of system notification IDs to notify when runs of this task
	// begin or complete. The default behavior is to not send any system
	// notifications.
	WebhookNotifications types.Object `tfsdk:"webhook_notifications"`
}

func (to *Task) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Task) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				// Recursively sync the fields of CleanRoomsNotebookTask
				toCleanRoomsNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				// Recursively sync the fields of ConditionTask
				toConditionTask.SyncFieldsDuringCreateOrUpdate(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				// Recursively sync the fields of DashboardTask
				toDashboardTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				// Recursively sync the fields of DbtCloudTask
				toDbtCloudTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				// Recursively sync the fields of DbtPlatformTask
				toDbtPlatformTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				// Recursively sync the fields of DbtTask
				toDbtTask.SyncFieldsDuringCreateOrUpdate(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				// Recursively sync the fields of EmailNotifications
				toEmailNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				// Recursively sync the fields of ForEachTask
				toForEachTask.SyncFieldsDuringCreateOrUpdate(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				// Recursively sync the fields of GenAiComputeTask
				toGenAiComputeTask.SyncFieldsDuringCreateOrUpdate(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				// Recursively sync the fields of Health
				toHealth.SyncFieldsDuringCreateOrUpdate(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				// Recursively sync the fields of NewCluster
				toNewCluster.SyncFieldsDuringCreateOrUpdate(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				// Recursively sync the fields of NotebookTask
				toNotebookTask.SyncFieldsDuringCreateOrUpdate(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				// Recursively sync the fields of NotificationSettings
				toNotificationSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				// Recursively sync the fields of PipelineTask
				toPipelineTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				// Recursively sync the fields of PowerBiTask
				toPowerBiTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				// Recursively sync the fields of PythonWheelTask
				toPythonWheelTask.SyncFieldsDuringCreateOrUpdate(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				// Recursively sync the fields of RunJobTask
				toRunJobTask.SyncFieldsDuringCreateOrUpdate(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				// Recursively sync the fields of SparkJarTask
				toSparkJarTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				// Recursively sync the fields of SparkPythonTask
				toSparkPythonTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				// Recursively sync the fields of SparkSubmitTask
				toSparkSubmitTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				// Recursively sync the fields of SqlTask
				toSqlTask.SyncFieldsDuringCreateOrUpdate(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				// Recursively sync the fields of WebhookNotifications
				toWebhookNotifications.SyncFieldsDuringCreateOrUpdate(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (to *Task) SyncFieldsDuringRead(ctx context.Context, from Task) {
	if !from.CleanRoomsNotebookTask.IsNull() && !from.CleanRoomsNotebookTask.IsUnknown() {
		if toCleanRoomsNotebookTask, ok := to.GetCleanRoomsNotebookTask(ctx); ok {
			if fromCleanRoomsNotebookTask, ok := from.GetCleanRoomsNotebookTask(ctx); ok {
				toCleanRoomsNotebookTask.SyncFieldsDuringRead(ctx, fromCleanRoomsNotebookTask)
				to.SetCleanRoomsNotebookTask(ctx, toCleanRoomsNotebookTask)
			}
		}
	}
	if !from.ConditionTask.IsNull() && !from.ConditionTask.IsUnknown() {
		if toConditionTask, ok := to.GetConditionTask(ctx); ok {
			if fromConditionTask, ok := from.GetConditionTask(ctx); ok {
				toConditionTask.SyncFieldsDuringRead(ctx, fromConditionTask)
				to.SetConditionTask(ctx, toConditionTask)
			}
		}
	}
	if !from.DashboardTask.IsNull() && !from.DashboardTask.IsUnknown() {
		if toDashboardTask, ok := to.GetDashboardTask(ctx); ok {
			if fromDashboardTask, ok := from.GetDashboardTask(ctx); ok {
				toDashboardTask.SyncFieldsDuringRead(ctx, fromDashboardTask)
				to.SetDashboardTask(ctx, toDashboardTask)
			}
		}
	}
	if !from.DbtCloudTask.IsNull() && !from.DbtCloudTask.IsUnknown() {
		if toDbtCloudTask, ok := to.GetDbtCloudTask(ctx); ok {
			if fromDbtCloudTask, ok := from.GetDbtCloudTask(ctx); ok {
				toDbtCloudTask.SyncFieldsDuringRead(ctx, fromDbtCloudTask)
				to.SetDbtCloudTask(ctx, toDbtCloudTask)
			}
		}
	}
	if !from.DbtPlatformTask.IsNull() && !from.DbtPlatformTask.IsUnknown() {
		if toDbtPlatformTask, ok := to.GetDbtPlatformTask(ctx); ok {
			if fromDbtPlatformTask, ok := from.GetDbtPlatformTask(ctx); ok {
				toDbtPlatformTask.SyncFieldsDuringRead(ctx, fromDbtPlatformTask)
				to.SetDbtPlatformTask(ctx, toDbtPlatformTask)
			}
		}
	}
	if !from.DbtTask.IsNull() && !from.DbtTask.IsUnknown() {
		if toDbtTask, ok := to.GetDbtTask(ctx); ok {
			if fromDbtTask, ok := from.GetDbtTask(ctx); ok {
				toDbtTask.SyncFieldsDuringRead(ctx, fromDbtTask)
				to.SetDbtTask(ctx, toDbtTask)
			}
		}
	}
	if !from.DependsOn.IsNull() && !from.DependsOn.IsUnknown() && to.DependsOn.IsNull() && len(from.DependsOn.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for DependsOn, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.DependsOn = from.DependsOn
	}
	if !from.EmailNotifications.IsNull() && !from.EmailNotifications.IsUnknown() {
		if toEmailNotifications, ok := to.GetEmailNotifications(ctx); ok {
			if fromEmailNotifications, ok := from.GetEmailNotifications(ctx); ok {
				toEmailNotifications.SyncFieldsDuringRead(ctx, fromEmailNotifications)
				to.SetEmailNotifications(ctx, toEmailNotifications)
			}
		}
	}
	if !from.ForEachTask.IsNull() && !from.ForEachTask.IsUnknown() {
		if toForEachTask, ok := to.GetForEachTask(ctx); ok {
			if fromForEachTask, ok := from.GetForEachTask(ctx); ok {
				toForEachTask.SyncFieldsDuringRead(ctx, fromForEachTask)
				to.SetForEachTask(ctx, toForEachTask)
			}
		}
	}
	if !from.GenAiComputeTask.IsNull() && !from.GenAiComputeTask.IsUnknown() {
		if toGenAiComputeTask, ok := to.GetGenAiComputeTask(ctx); ok {
			if fromGenAiComputeTask, ok := from.GetGenAiComputeTask(ctx); ok {
				toGenAiComputeTask.SyncFieldsDuringRead(ctx, fromGenAiComputeTask)
				to.SetGenAiComputeTask(ctx, toGenAiComputeTask)
			}
		}
	}
	if !from.Health.IsNull() && !from.Health.IsUnknown() {
		if toHealth, ok := to.GetHealth(ctx); ok {
			if fromHealth, ok := from.GetHealth(ctx); ok {
				toHealth.SyncFieldsDuringRead(ctx, fromHealth)
				to.SetHealth(ctx, toHealth)
			}
		}
	}
	if !from.Libraries.IsNull() && !from.Libraries.IsUnknown() && to.Libraries.IsNull() && len(from.Libraries.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for Libraries, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.Libraries = from.Libraries
	}
	if !from.NewCluster.IsNull() && !from.NewCluster.IsUnknown() {
		if toNewCluster, ok := to.GetNewCluster(ctx); ok {
			if fromNewCluster, ok := from.GetNewCluster(ctx); ok {
				toNewCluster.SyncFieldsDuringRead(ctx, fromNewCluster)
				to.SetNewCluster(ctx, toNewCluster)
			}
		}
	}
	if !from.NotebookTask.IsNull() && !from.NotebookTask.IsUnknown() {
		if toNotebookTask, ok := to.GetNotebookTask(ctx); ok {
			if fromNotebookTask, ok := from.GetNotebookTask(ctx); ok {
				toNotebookTask.SyncFieldsDuringRead(ctx, fromNotebookTask)
				to.SetNotebookTask(ctx, toNotebookTask)
			}
		}
	}
	if !from.NotificationSettings.IsNull() && !from.NotificationSettings.IsUnknown() {
		if toNotificationSettings, ok := to.GetNotificationSettings(ctx); ok {
			if fromNotificationSettings, ok := from.GetNotificationSettings(ctx); ok {
				toNotificationSettings.SyncFieldsDuringRead(ctx, fromNotificationSettings)
				to.SetNotificationSettings(ctx, toNotificationSettings)
			}
		}
	}
	if !from.PipelineTask.IsNull() && !from.PipelineTask.IsUnknown() {
		if toPipelineTask, ok := to.GetPipelineTask(ctx); ok {
			if fromPipelineTask, ok := from.GetPipelineTask(ctx); ok {
				toPipelineTask.SyncFieldsDuringRead(ctx, fromPipelineTask)
				to.SetPipelineTask(ctx, toPipelineTask)
			}
		}
	}
	if !from.PowerBiTask.IsNull() && !from.PowerBiTask.IsUnknown() {
		if toPowerBiTask, ok := to.GetPowerBiTask(ctx); ok {
			if fromPowerBiTask, ok := from.GetPowerBiTask(ctx); ok {
				toPowerBiTask.SyncFieldsDuringRead(ctx, fromPowerBiTask)
				to.SetPowerBiTask(ctx, toPowerBiTask)
			}
		}
	}
	if !from.PythonWheelTask.IsNull() && !from.PythonWheelTask.IsUnknown() {
		if toPythonWheelTask, ok := to.GetPythonWheelTask(ctx); ok {
			if fromPythonWheelTask, ok := from.GetPythonWheelTask(ctx); ok {
				toPythonWheelTask.SyncFieldsDuringRead(ctx, fromPythonWheelTask)
				to.SetPythonWheelTask(ctx, toPythonWheelTask)
			}
		}
	}
	if !from.RunJobTask.IsNull() && !from.RunJobTask.IsUnknown() {
		if toRunJobTask, ok := to.GetRunJobTask(ctx); ok {
			if fromRunJobTask, ok := from.GetRunJobTask(ctx); ok {
				toRunJobTask.SyncFieldsDuringRead(ctx, fromRunJobTask)
				to.SetRunJobTask(ctx, toRunJobTask)
			}
		}
	}
	if !from.SparkJarTask.IsNull() && !from.SparkJarTask.IsUnknown() {
		if toSparkJarTask, ok := to.GetSparkJarTask(ctx); ok {
			if fromSparkJarTask, ok := from.GetSparkJarTask(ctx); ok {
				toSparkJarTask.SyncFieldsDuringRead(ctx, fromSparkJarTask)
				to.SetSparkJarTask(ctx, toSparkJarTask)
			}
		}
	}
	if !from.SparkPythonTask.IsNull() && !from.SparkPythonTask.IsUnknown() {
		if toSparkPythonTask, ok := to.GetSparkPythonTask(ctx); ok {
			if fromSparkPythonTask, ok := from.GetSparkPythonTask(ctx); ok {
				toSparkPythonTask.SyncFieldsDuringRead(ctx, fromSparkPythonTask)
				to.SetSparkPythonTask(ctx, toSparkPythonTask)
			}
		}
	}
	if !from.SparkSubmitTask.IsNull() && !from.SparkSubmitTask.IsUnknown() {
		if toSparkSubmitTask, ok := to.GetSparkSubmitTask(ctx); ok {
			if fromSparkSubmitTask, ok := from.GetSparkSubmitTask(ctx); ok {
				toSparkSubmitTask.SyncFieldsDuringRead(ctx, fromSparkSubmitTask)
				to.SetSparkSubmitTask(ctx, toSparkSubmitTask)
			}
		}
	}
	if !from.SqlTask.IsNull() && !from.SqlTask.IsUnknown() {
		if toSqlTask, ok := to.GetSqlTask(ctx); ok {
			if fromSqlTask, ok := from.GetSqlTask(ctx); ok {
				toSqlTask.SyncFieldsDuringRead(ctx, fromSqlTask)
				to.SetSqlTask(ctx, toSqlTask)
			}
		}
	}
	if !from.WebhookNotifications.IsNull() && !from.WebhookNotifications.IsUnknown() {
		if toWebhookNotifications, ok := to.GetWebhookNotifications(ctx); ok {
			if fromWebhookNotifications, ok := from.GetWebhookNotifications(ctx); ok {
				toWebhookNotifications.SyncFieldsDuringRead(ctx, fromWebhookNotifications)
				to.SetWebhookNotifications(ctx, toWebhookNotifications)
			}
		}
	}
}

func (m Task) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["clean_rooms_notebook_task"] = attrs["clean_rooms_notebook_task"].SetOptional()
	attrs["condition_task"] = attrs["condition_task"].SetOptional()
	attrs["dashboard_task"] = attrs["dashboard_task"].SetOptional()
	attrs["dbt_cloud_task"] = attrs["dbt_cloud_task"].SetOptional()
	attrs["dbt_platform_task"] = attrs["dbt_platform_task"].SetOptional()
	attrs["dbt_task"] = attrs["dbt_task"].SetOptional()
	attrs["depends_on"] = attrs["depends_on"].SetOptional()
	attrs["description"] = attrs["description"].SetOptional()
	attrs["disable_auto_optimization"] = attrs["disable_auto_optimization"].SetOptional()
	attrs["disabled"] = attrs["disabled"].SetOptional()
	attrs["email_notifications"] = attrs["email_notifications"].SetOptional()
	attrs["environment_key"] = attrs["environment_key"].SetOptional()
	attrs["existing_cluster_id"] = attrs["existing_cluster_id"].SetOptional()
	attrs["for_each_task"] = attrs["for_each_task"].SetOptional()
	attrs["gen_ai_compute_task"] = attrs["gen_ai_compute_task"].SetOptional()
	attrs["health"] = attrs["health"].SetOptional()
	attrs["job_cluster_key"] = attrs["job_cluster_key"].SetOptional()
	attrs["library"] = attrs["library"].SetOptional()
	attrs["max_retries"] = attrs["max_retries"].SetOptional()
	attrs["min_retry_interval_millis"] = attrs["min_retry_interval_millis"].SetOptional()
	attrs["new_cluster"] = attrs["new_cluster"].SetOptional()
	attrs["notebook_task"] = attrs["notebook_task"].SetOptional()
	attrs["notification_settings"] = attrs["notification_settings"].SetOptional()
	attrs["pipeline_task"] = attrs["pipeline_task"].SetOptional()
	attrs["power_bi_task"] = attrs["power_bi_task"].SetOptional()
	attrs["python_wheel_task"] = attrs["python_wheel_task"].SetOptional()
	attrs["retry_on_timeout"] = attrs["retry_on_timeout"].SetOptional()
	attrs["run_if"] = attrs["run_if"].SetOptional()
	attrs["run_job_task"] = attrs["run_job_task"].SetOptional()
	attrs["spark_jar_task"] = attrs["spark_jar_task"].SetOptional()
	attrs["spark_python_task"] = attrs["spark_python_task"].SetOptional()
	attrs["spark_submit_task"] = attrs["spark_submit_task"].SetOptional()
	attrs["sql_task"] = attrs["sql_task"].SetOptional()
	attrs["task_key"] = attrs["task_key"].SetRequired()
	attrs["timeout_seconds"] = attrs["timeout_seconds"].SetOptional()
	attrs["webhook_notifications"] = attrs["webhook_notifications"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Task.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Task) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"clean_rooms_notebook_task": reflect.TypeOf(CleanRoomsNotebookTask{}),
		"condition_task":            reflect.TypeOf(ConditionTask{}),
		"dashboard_task":            reflect.TypeOf(DashboardTask{}),
		"dbt_cloud_task":            reflect.TypeOf(DbtCloudTask{}),
		"dbt_platform_task":         reflect.TypeOf(DbtPlatformTask{}),
		"dbt_task":                  reflect.TypeOf(DbtTask{}),
		"depends_on":                reflect.TypeOf(TaskDependency{}),
		"email_notifications":       reflect.TypeOf(TaskEmailNotifications{}),
		"for_each_task":             reflect.TypeOf(ForEachTask{}),
		"gen_ai_compute_task":       reflect.TypeOf(GenAiComputeTask{}),
		"health":                    reflect.TypeOf(JobsHealthRules{}),
		"library":                   reflect.TypeOf(compute_tf.Library{}),
		"new_cluster":               reflect.TypeOf(compute_tf.ClusterSpec{}),
		"notebook_task":             reflect.TypeOf(NotebookTask{}),
		"notification_settings":     reflect.TypeOf(TaskNotificationSettings{}),
		"pipeline_task":             reflect.TypeOf(PipelineTask{}),
		"power_bi_task":             reflect.TypeOf(PowerBiTask{}),
		"python_wheel_task":         reflect.TypeOf(PythonWheelTask{}),
		"run_job_task":              reflect.TypeOf(RunJobTask{}),
		"spark_jar_task":            reflect.TypeOf(SparkJarTask{}),
		"spark_python_task":         reflect.TypeOf(SparkPythonTask{}),
		"spark_submit_task":         reflect.TypeOf(SparkSubmitTask{}),
		"sql_task":                  reflect.TypeOf(SqlTask{}),
		"webhook_notifications":     reflect.TypeOf(WebhookNotifications{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Task
// only implements ToObjectValue() and Type().
func (m Task) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"clean_rooms_notebook_task": m.CleanRoomsNotebookTask,
			"condition_task":            m.ConditionTask,
			"dashboard_task":            m.DashboardTask,
			"dbt_cloud_task":            m.DbtCloudTask,
			"dbt_platform_task":         m.DbtPlatformTask,
			"dbt_task":                  m.DbtTask,
			"depends_on":                m.DependsOn,
			"description":               m.Description,
			"disable_auto_optimization": m.DisableAutoOptimization,
			"disabled":                  m.Disabled,
			"email_notifications":       m.EmailNotifications,
			"environment_key":           m.EnvironmentKey,
			"existing_cluster_id":       m.ExistingClusterId,
			"for_each_task":             m.ForEachTask,
			"gen_ai_compute_task":       m.GenAiComputeTask,
			"health":                    m.Health,
			"job_cluster_key":           m.JobClusterKey,
			"library":                   m.Libraries,
			"max_retries":               m.MaxRetries,
			"min_retry_interval_millis": m.MinRetryIntervalMillis,
			"new_cluster":               m.NewCluster,
			"notebook_task":             m.NotebookTask,
			"notification_settings":     m.NotificationSettings,
			"pipeline_task":             m.PipelineTask,
			"power_bi_task":             m.PowerBiTask,
			"python_wheel_task":         m.PythonWheelTask,
			"retry_on_timeout":          m.RetryOnTimeout,
			"run_if":                    m.RunIf,
			"run_job_task":              m.RunJobTask,
			"spark_jar_task":            m.SparkJarTask,
			"spark_python_task":         m.SparkPythonTask,
			"spark_submit_task":         m.SparkSubmitTask,
			"sql_task":                  m.SqlTask,
			"task_key":                  m.TaskKey,
			"timeout_seconds":           m.TimeoutSeconds,
			"webhook_notifications":     m.WebhookNotifications,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Task) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"clean_rooms_notebook_task": CleanRoomsNotebookTask{}.Type(ctx),
			"condition_task":            ConditionTask{}.Type(ctx),
			"dashboard_task":            DashboardTask{}.Type(ctx),
			"dbt_cloud_task":            DbtCloudTask{}.Type(ctx),
			"dbt_platform_task":         DbtPlatformTask{}.Type(ctx),
			"dbt_task":                  DbtTask{}.Type(ctx),
			"depends_on": basetypes.ListType{
				ElemType: TaskDependency{}.Type(ctx),
			},
			"description":               types.StringType,
			"disable_auto_optimization": types.BoolType,
			"disabled":                  types.BoolType,
			"email_notifications":       TaskEmailNotifications{}.Type(ctx),
			"environment_key":           types.StringType,
			"existing_cluster_id":       types.StringType,
			"for_each_task":             ForEachTask{}.Type(ctx),
			"gen_ai_compute_task":       GenAiComputeTask{}.Type(ctx),
			"health":                    JobsHealthRules{}.Type(ctx),
			"job_cluster_key":           types.StringType,
			"library": basetypes.ListType{
				ElemType: compute_tf.Library{}.Type(ctx),
			},
			"max_retries":               types.Int64Type,
			"min_retry_interval_millis": types.Int64Type,
			"new_cluster":               compute_tf.ClusterSpec{}.Type(ctx),
			"notebook_task":             NotebookTask{}.Type(ctx),
			"notification_settings":     TaskNotificationSettings{}.Type(ctx),
			"pipeline_task":             PipelineTask{}.Type(ctx),
			"power_bi_task":             PowerBiTask{}.Type(ctx),
			"python_wheel_task":         PythonWheelTask{}.Type(ctx),
			"retry_on_timeout":          types.BoolType,
			"run_if":                    types.StringType,
			"run_job_task":              RunJobTask{}.Type(ctx),
			"spark_jar_task":            SparkJarTask{}.Type(ctx),
			"spark_python_task":         SparkPythonTask{}.Type(ctx),
			"spark_submit_task":         SparkSubmitTask{}.Type(ctx),
			"sql_task":                  SqlTask{}.Type(ctx),
			"task_key":                  types.StringType,
			"timeout_seconds":           types.Int64Type,
			"webhook_notifications":     WebhookNotifications{}.Type(ctx),
		},
	}
}

// GetCleanRoomsNotebookTask returns the value of the CleanRoomsNotebookTask field in Task as
// a CleanRoomsNotebookTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetCleanRoomsNotebookTask(ctx context.Context) (CleanRoomsNotebookTask, bool) {
	var e CleanRoomsNotebookTask
	if m.CleanRoomsNotebookTask.IsNull() || m.CleanRoomsNotebookTask.IsUnknown() {
		return e, false
	}
	var v CleanRoomsNotebookTask
	d := m.CleanRoomsNotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetCleanRoomsNotebookTask sets the value of the CleanRoomsNotebookTask field in Task.
func (m *Task) SetCleanRoomsNotebookTask(ctx context.Context, v CleanRoomsNotebookTask) {
	vs := v.ToObjectValue(ctx)
	m.CleanRoomsNotebookTask = vs
}

// GetConditionTask returns the value of the ConditionTask field in Task as
// a ConditionTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetConditionTask(ctx context.Context) (ConditionTask, bool) {
	var e ConditionTask
	if m.ConditionTask.IsNull() || m.ConditionTask.IsUnknown() {
		return e, false
	}
	var v ConditionTask
	d := m.ConditionTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetConditionTask sets the value of the ConditionTask field in Task.
func (m *Task) SetConditionTask(ctx context.Context, v ConditionTask) {
	vs := v.ToObjectValue(ctx)
	m.ConditionTask = vs
}

// GetDashboardTask returns the value of the DashboardTask field in Task as
// a DashboardTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetDashboardTask(ctx context.Context) (DashboardTask, bool) {
	var e DashboardTask
	if m.DashboardTask.IsNull() || m.DashboardTask.IsUnknown() {
		return e, false
	}
	var v DashboardTask
	d := m.DashboardTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDashboardTask sets the value of the DashboardTask field in Task.
func (m *Task) SetDashboardTask(ctx context.Context, v DashboardTask) {
	vs := v.ToObjectValue(ctx)
	m.DashboardTask = vs
}

// GetDbtCloudTask returns the value of the DbtCloudTask field in Task as
// a DbtCloudTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetDbtCloudTask(ctx context.Context) (DbtCloudTask, bool) {
	var e DbtCloudTask
	if m.DbtCloudTask.IsNull() || m.DbtCloudTask.IsUnknown() {
		return e, false
	}
	var v DbtCloudTask
	d := m.DbtCloudTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtCloudTask sets the value of the DbtCloudTask field in Task.
func (m *Task) SetDbtCloudTask(ctx context.Context, v DbtCloudTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtCloudTask = vs
}

// GetDbtPlatformTask returns the value of the DbtPlatformTask field in Task as
// a DbtPlatformTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetDbtPlatformTask(ctx context.Context) (DbtPlatformTask, bool) {
	var e DbtPlatformTask
	if m.DbtPlatformTask.IsNull() || m.DbtPlatformTask.IsUnknown() {
		return e, false
	}
	var v DbtPlatformTask
	d := m.DbtPlatformTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtPlatformTask sets the value of the DbtPlatformTask field in Task.
func (m *Task) SetDbtPlatformTask(ctx context.Context, v DbtPlatformTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtPlatformTask = vs
}

// GetDbtTask returns the value of the DbtTask field in Task as
// a DbtTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetDbtTask(ctx context.Context) (DbtTask, bool) {
	var e DbtTask
	if m.DbtTask.IsNull() || m.DbtTask.IsUnknown() {
		return e, false
	}
	var v DbtTask
	d := m.DbtTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDbtTask sets the value of the DbtTask field in Task.
func (m *Task) SetDbtTask(ctx context.Context, v DbtTask) {
	vs := v.ToObjectValue(ctx)
	m.DbtTask = vs
}

// GetDependsOn returns the value of the DependsOn field in Task as
// a slice of TaskDependency values.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetDependsOn(ctx context.Context) ([]TaskDependency, bool) {
	if m.DependsOn.IsNull() || m.DependsOn.IsUnknown() {
		return nil, false
	}
	var v []TaskDependency
	d := m.DependsOn.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetDependsOn sets the value of the DependsOn field in Task.
func (m *Task) SetDependsOn(ctx context.Context, v []TaskDependency) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["depends_on"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.DependsOn = types.ListValueMust(t, vs)
}

// GetEmailNotifications returns the value of the EmailNotifications field in Task as
// a TaskEmailNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetEmailNotifications(ctx context.Context) (TaskEmailNotifications, bool) {
	var e TaskEmailNotifications
	if m.EmailNotifications.IsNull() || m.EmailNotifications.IsUnknown() {
		return e, false
	}
	var v TaskEmailNotifications
	d := m.EmailNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetEmailNotifications sets the value of the EmailNotifications field in Task.
func (m *Task) SetEmailNotifications(ctx context.Context, v TaskEmailNotifications) {
	vs := v.ToObjectValue(ctx)
	m.EmailNotifications = vs
}

// GetForEachTask returns the value of the ForEachTask field in Task as
// a ForEachTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetForEachTask(ctx context.Context) (ForEachTask, bool) {
	var e ForEachTask
	if m.ForEachTask.IsNull() || m.ForEachTask.IsUnknown() {
		return e, false
	}
	var v ForEachTask
	d := m.ForEachTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetForEachTask sets the value of the ForEachTask field in Task.
func (m *Task) SetForEachTask(ctx context.Context, v ForEachTask) {
	vs := v.ToObjectValue(ctx)
	m.ForEachTask = vs
}

// GetGenAiComputeTask returns the value of the GenAiComputeTask field in Task as
// a GenAiComputeTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetGenAiComputeTask(ctx context.Context) (GenAiComputeTask, bool) {
	var e GenAiComputeTask
	if m.GenAiComputeTask.IsNull() || m.GenAiComputeTask.IsUnknown() {
		return e, false
	}
	var v GenAiComputeTask
	d := m.GenAiComputeTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetGenAiComputeTask sets the value of the GenAiComputeTask field in Task.
func (m *Task) SetGenAiComputeTask(ctx context.Context, v GenAiComputeTask) {
	vs := v.ToObjectValue(ctx)
	m.GenAiComputeTask = vs
}

// GetHealth returns the value of the Health field in Task as
// a JobsHealthRules value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetHealth(ctx context.Context) (JobsHealthRules, bool) {
	var e JobsHealthRules
	if m.Health.IsNull() || m.Health.IsUnknown() {
		return e, false
	}
	var v JobsHealthRules
	d := m.Health.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetHealth sets the value of the Health field in Task.
func (m *Task) SetHealth(ctx context.Context, v JobsHealthRules) {
	vs := v.ToObjectValue(ctx)
	m.Health = vs
}

// GetLibraries returns the value of the Libraries field in Task as
// a slice of compute_tf.Library values.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetLibraries(ctx context.Context) ([]compute_tf.Library, bool) {
	if m.Libraries.IsNull() || m.Libraries.IsUnknown() {
		return nil, false
	}
	var v []compute_tf.Library
	d := m.Libraries.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetLibraries sets the value of the Libraries field in Task.
func (m *Task) SetLibraries(ctx context.Context, v []compute_tf.Library) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["library"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.Libraries = types.ListValueMust(t, vs)
}

// GetNewCluster returns the value of the NewCluster field in Task as
// a compute_tf.ClusterSpec value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetNewCluster(ctx context.Context) (compute_tf.ClusterSpec, bool) {
	var e compute_tf.ClusterSpec
	if m.NewCluster.IsNull() || m.NewCluster.IsUnknown() {
		return e, false
	}
	var v compute_tf.ClusterSpec
	d := m.NewCluster.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewCluster sets the value of the NewCluster field in Task.
func (m *Task) SetNewCluster(ctx context.Context, v compute_tf.ClusterSpec) {
	vs := v.ToObjectValue(ctx)
	m.NewCluster = vs
}

// GetNotebookTask returns the value of the NotebookTask field in Task as
// a NotebookTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetNotebookTask(ctx context.Context) (NotebookTask, bool) {
	var e NotebookTask
	if m.NotebookTask.IsNull() || m.NotebookTask.IsUnknown() {
		return e, false
	}
	var v NotebookTask
	d := m.NotebookTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotebookTask sets the value of the NotebookTask field in Task.
func (m *Task) SetNotebookTask(ctx context.Context, v NotebookTask) {
	vs := v.ToObjectValue(ctx)
	m.NotebookTask = vs
}

// GetNotificationSettings returns the value of the NotificationSettings field in Task as
// a TaskNotificationSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetNotificationSettings(ctx context.Context) (TaskNotificationSettings, bool) {
	var e TaskNotificationSettings
	if m.NotificationSettings.IsNull() || m.NotificationSettings.IsUnknown() {
		return e, false
	}
	var v TaskNotificationSettings
	d := m.NotificationSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNotificationSettings sets the value of the NotificationSettings field in Task.
func (m *Task) SetNotificationSettings(ctx context.Context, v TaskNotificationSettings) {
	vs := v.ToObjectValue(ctx)
	m.NotificationSettings = vs
}

// GetPipelineTask returns the value of the PipelineTask field in Task as
// a PipelineTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetPipelineTask(ctx context.Context) (PipelineTask, bool) {
	var e PipelineTask
	if m.PipelineTask.IsNull() || m.PipelineTask.IsUnknown() {
		return e, false
	}
	var v PipelineTask
	d := m.PipelineTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPipelineTask sets the value of the PipelineTask field in Task.
func (m *Task) SetPipelineTask(ctx context.Context, v PipelineTask) {
	vs := v.ToObjectValue(ctx)
	m.PipelineTask = vs
}

// GetPowerBiTask returns the value of the PowerBiTask field in Task as
// a PowerBiTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetPowerBiTask(ctx context.Context) (PowerBiTask, bool) {
	var e PowerBiTask
	if m.PowerBiTask.IsNull() || m.PowerBiTask.IsUnknown() {
		return e, false
	}
	var v PowerBiTask
	d := m.PowerBiTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPowerBiTask sets the value of the PowerBiTask field in Task.
func (m *Task) SetPowerBiTask(ctx context.Context, v PowerBiTask) {
	vs := v.ToObjectValue(ctx)
	m.PowerBiTask = vs
}

// GetPythonWheelTask returns the value of the PythonWheelTask field in Task as
// a PythonWheelTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetPythonWheelTask(ctx context.Context) (PythonWheelTask, bool) {
	var e PythonWheelTask
	if m.PythonWheelTask.IsNull() || m.PythonWheelTask.IsUnknown() {
		return e, false
	}
	var v PythonWheelTask
	d := m.PythonWheelTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPythonWheelTask sets the value of the PythonWheelTask field in Task.
func (m *Task) SetPythonWheelTask(ctx context.Context, v PythonWheelTask) {
	vs := v.ToObjectValue(ctx)
	m.PythonWheelTask = vs
}

// GetRunJobTask returns the value of the RunJobTask field in Task as
// a RunJobTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetRunJobTask(ctx context.Context) (RunJobTask, bool) {
	var e RunJobTask
	if m.RunJobTask.IsNull() || m.RunJobTask.IsUnknown() {
		return e, false
	}
	var v RunJobTask
	d := m.RunJobTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetRunJobTask sets the value of the RunJobTask field in Task.
func (m *Task) SetRunJobTask(ctx context.Context, v RunJobTask) {
	vs := v.ToObjectValue(ctx)
	m.RunJobTask = vs
}

// GetSparkJarTask returns the value of the SparkJarTask field in Task as
// a SparkJarTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetSparkJarTask(ctx context.Context) (SparkJarTask, bool) {
	var e SparkJarTask
	if m.SparkJarTask.IsNull() || m.SparkJarTask.IsUnknown() {
		return e, false
	}
	var v SparkJarTask
	d := m.SparkJarTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkJarTask sets the value of the SparkJarTask field in Task.
func (m *Task) SetSparkJarTask(ctx context.Context, v SparkJarTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkJarTask = vs
}

// GetSparkPythonTask returns the value of the SparkPythonTask field in Task as
// a SparkPythonTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetSparkPythonTask(ctx context.Context) (SparkPythonTask, bool) {
	var e SparkPythonTask
	if m.SparkPythonTask.IsNull() || m.SparkPythonTask.IsUnknown() {
		return e, false
	}
	var v SparkPythonTask
	d := m.SparkPythonTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkPythonTask sets the value of the SparkPythonTask field in Task.
func (m *Task) SetSparkPythonTask(ctx context.Context, v SparkPythonTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkPythonTask = vs
}

// GetSparkSubmitTask returns the value of the SparkSubmitTask field in Task as
// a SparkSubmitTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetSparkSubmitTask(ctx context.Context) (SparkSubmitTask, bool) {
	var e SparkSubmitTask
	if m.SparkSubmitTask.IsNull() || m.SparkSubmitTask.IsUnknown() {
		return e, false
	}
	var v SparkSubmitTask
	d := m.SparkSubmitTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSparkSubmitTask sets the value of the SparkSubmitTask field in Task.
func (m *Task) SetSparkSubmitTask(ctx context.Context, v SparkSubmitTask) {
	vs := v.ToObjectValue(ctx)
	m.SparkSubmitTask = vs
}

// GetSqlTask returns the value of the SqlTask field in Task as
// a SqlTask value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetSqlTask(ctx context.Context) (SqlTask, bool) {
	var e SqlTask
	if m.SqlTask.IsNull() || m.SqlTask.IsUnknown() {
		return e, false
	}
	var v SqlTask
	d := m.SqlTask.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetSqlTask sets the value of the SqlTask field in Task.
func (m *Task) SetSqlTask(ctx context.Context, v SqlTask) {
	vs := v.ToObjectValue(ctx)
	m.SqlTask = vs
}

// GetWebhookNotifications returns the value of the WebhookNotifications field in Task as
// a WebhookNotifications value.
// If the field is unknown or null, the boolean return value is false.
func (m *Task) GetWebhookNotifications(ctx context.Context) (WebhookNotifications, bool) {
	var e WebhookNotifications
	if m.WebhookNotifications.IsNull() || m.WebhookNotifications.IsUnknown() {
		return e, false
	}
	var v WebhookNotifications
	d := m.WebhookNotifications.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetWebhookNotifications sets the value of the WebhookNotifications field in Task.
func (m *Task) SetWebhookNotifications(ctx context.Context, v WebhookNotifications) {
	vs := v.ToObjectValue(ctx)
	m.WebhookNotifications = vs
}

type TaskDependency struct {
	// Can only be specified on condition task dependencies. The outcome of the
	// dependent task that must be met for this task to run.
	Outcome types.String `tfsdk:"outcome"`
	// The name of the task this task depends on.
	TaskKey types.String `tfsdk:"task_key"`
}

func (to *TaskDependency) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TaskDependency) {
}

func (to *TaskDependency) SyncFieldsDuringRead(ctx context.Context, from TaskDependency) {
}

func (m TaskDependency) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["outcome"] = attrs["outcome"].SetOptional()
	attrs["task_key"] = attrs["task_key"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TaskDependency.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TaskDependency) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TaskDependency
// only implements ToObjectValue() and Type().
func (m TaskDependency) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"outcome":  m.Outcome,
			"task_key": m.TaskKey,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TaskDependency) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"outcome":  types.StringType,
			"task_key": types.StringType,
		},
	}
}

type TaskEmailNotifications struct {
	// If true, do not send email to recipients specified in `on_failure` if the
	// run is skipped. This field is `deprecated`. Please use the
	// `notification_settings.no_alert_for_skipped_runs` field.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
	// A list of email addresses to be notified when the duration of a run
	// exceeds the threshold specified for the `RUN_DURATION_SECONDS` metric in
	// the `health` field. If no rule for the `RUN_DURATION_SECONDS` metric is
	// specified in the `health` field for the job, notifications are not sent.
	OnDurationWarningThresholdExceeded types.List `tfsdk:"on_duration_warning_threshold_exceeded"`
	// A list of email addresses to be notified when a run unsuccessfully
	// completes. A run is considered to have completed unsuccessfully if it
	// ends with an `INTERNAL_ERROR` `life_cycle_state` or a `FAILED`, or
	// `TIMED_OUT` result_state. If this is not specified on job creation,
	// reset, or update the list is empty, and notifications are not sent.
	OnFailure types.List `tfsdk:"on_failure"`
	// A list of email addresses to be notified when a run begins. If not
	// specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnStart types.List `tfsdk:"on_start"`
	// A list of email addresses to notify when any streaming backlog thresholds
	// are exceeded for any stream. Streaming backlog thresholds can be set in
	// the `health` field using the following metrics:
	// `STREAMING_BACKLOG_BYTES`, `STREAMING_BACKLOG_RECORDS`,
	// `STREAMING_BACKLOG_SECONDS`, or `STREAMING_BACKLOG_FILES`. Alerting is
	// based on the 10-minute average of these metrics. If the issue persists,
	// notifications are resent every 30 minutes.
	OnStreamingBacklogExceeded types.List `tfsdk:"on_streaming_backlog_exceeded"`
	// A list of email addresses to be notified when a run successfully
	// completes. A run is considered to have completed successfully if it ends
	// with a `TERMINATED` `life_cycle_state` and a `SUCCESS` result_state. If
	// not specified on job creation, reset, or update, the list is empty, and
	// notifications are not sent.
	OnSuccess types.List `tfsdk:"on_success"`
}

func (to *TaskEmailNotifications) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TaskEmailNotifications) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (to *TaskEmailNotifications) SyncFieldsDuringRead(ctx context.Context, from TaskEmailNotifications) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (m TaskEmailNotifications) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()
	attrs["on_duration_warning_threshold_exceeded"] = attrs["on_duration_warning_threshold_exceeded"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_start"] = attrs["on_start"].SetOptional()
	attrs["on_streaming_backlog_exceeded"] = attrs["on_streaming_backlog_exceeded"].SetOptional()
	attrs["on_success"] = attrs["on_success"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TaskEmailNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TaskEmailNotifications) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_duration_warning_threshold_exceeded": reflect.TypeOf(types.String{}),
		"on_failure":                             reflect.TypeOf(types.String{}),
		"on_start":                               reflect.TypeOf(types.String{}),
		"on_streaming_backlog_exceeded":          reflect.TypeOf(types.String{}),
		"on_success":                             reflect.TypeOf(types.String{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TaskEmailNotifications
// only implements ToObjectValue() and Type().
func (m TaskEmailNotifications) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"no_alert_for_skipped_runs":              m.NoAlertForSkippedRuns,
			"on_duration_warning_threshold_exceeded": m.OnDurationWarningThresholdExceeded,
			"on_failure":                             m.OnFailure,
			"on_start":                               m.OnStart,
			"on_streaming_backlog_exceeded":          m.OnStreamingBacklogExceeded,
			"on_success":                             m.OnSuccess,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TaskEmailNotifications) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"no_alert_for_skipped_runs": types.BoolType,
			"on_duration_warning_threshold_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_failure": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_start": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_streaming_backlog_exceeded": basetypes.ListType{
				ElemType: types.StringType,
			},
			"on_success": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

// GetOnDurationWarningThresholdExceeded returns the value of the OnDurationWarningThresholdExceeded field in TaskEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications) GetOnDurationWarningThresholdExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnDurationWarningThresholdExceeded.IsNull() || m.OnDurationWarningThresholdExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnDurationWarningThresholdExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnDurationWarningThresholdExceeded sets the value of the OnDurationWarningThresholdExceeded field in TaskEmailNotifications.
func (m *TaskEmailNotifications) SetOnDurationWarningThresholdExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_duration_warning_threshold_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnDurationWarningThresholdExceeded = types.ListValueMust(t, vs)
}

// GetOnFailure returns the value of the OnFailure field in TaskEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications) GetOnFailure(ctx context.Context) ([]types.String, bool) {
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in TaskEmailNotifications.
func (m *TaskEmailNotifications) SetOnFailure(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnStart returns the value of the OnStart field in TaskEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications) GetOnStart(ctx context.Context) ([]types.String, bool) {
	if m.OnStart.IsNull() || m.OnStart.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStart.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStart sets the value of the OnStart field in TaskEmailNotifications.
func (m *TaskEmailNotifications) SetOnStart(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_start"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStart = types.ListValueMust(t, vs)
}

// GetOnStreamingBacklogExceeded returns the value of the OnStreamingBacklogExceeded field in TaskEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications) GetOnStreamingBacklogExceeded(ctx context.Context) ([]types.String, bool) {
	if m.OnStreamingBacklogExceeded.IsNull() || m.OnStreamingBacklogExceeded.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnStreamingBacklogExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStreamingBacklogExceeded sets the value of the OnStreamingBacklogExceeded field in TaskEmailNotifications.
func (m *TaskEmailNotifications) SetOnStreamingBacklogExceeded(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_streaming_backlog_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStreamingBacklogExceeded = types.ListValueMust(t, vs)
}

// GetOnSuccess returns the value of the OnSuccess field in TaskEmailNotifications as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *TaskEmailNotifications) GetOnSuccess(ctx context.Context) ([]types.String, bool) {
	if m.OnSuccess.IsNull() || m.OnSuccess.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.OnSuccess.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnSuccess sets the value of the OnSuccess field in TaskEmailNotifications.
func (m *TaskEmailNotifications) SetOnSuccess(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_success"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnSuccess = types.ListValueMust(t, vs)
}

type TaskNotificationSettings struct {
	// If true, do not send notifications to recipients specified in `on_start`
	// for the retried runs and do not send notifications to recipients
	// specified in `on_failure` until the last retry of the run.
	AlertOnLastAttempt types.Bool `tfsdk:"alert_on_last_attempt"`
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is canceled.
	NoAlertForCanceledRuns types.Bool `tfsdk:"no_alert_for_canceled_runs"`
	// If true, do not send notifications to recipients specified in
	// `on_failure` if the run is skipped.
	NoAlertForSkippedRuns types.Bool `tfsdk:"no_alert_for_skipped_runs"`
}

func (to *TaskNotificationSettings) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TaskNotificationSettings) {
}

func (to *TaskNotificationSettings) SyncFieldsDuringRead(ctx context.Context, from TaskNotificationSettings) {
}

func (m TaskNotificationSettings) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["alert_on_last_attempt"] = attrs["alert_on_last_attempt"].SetOptional()
	attrs["no_alert_for_canceled_runs"] = attrs["no_alert_for_canceled_runs"].SetOptional()
	attrs["no_alert_for_skipped_runs"] = attrs["no_alert_for_skipped_runs"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TaskNotificationSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TaskNotificationSettings) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TaskNotificationSettings
// only implements ToObjectValue() and Type().
func (m TaskNotificationSettings) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"alert_on_last_attempt":      m.AlertOnLastAttempt,
			"no_alert_for_canceled_runs": m.NoAlertForCanceledRuns,
			"no_alert_for_skipped_runs":  m.NoAlertForSkippedRuns,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TaskNotificationSettings) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"alert_on_last_attempt":      types.BoolType,
			"no_alert_for_canceled_runs": types.BoolType,
			"no_alert_for_skipped_runs":  types.BoolType,
		},
	}
}

type TerminationDetails struct {
	Code types.String `tfsdk:"code"`
	// A descriptive message with the termination details. This field is
	// unstructured and the format might change.
	Message types.String `tfsdk:"message"`

	Type_ types.String `tfsdk:"type"`
}

func (to *TerminationDetails) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TerminationDetails) {
}

func (to *TerminationDetails) SyncFieldsDuringRead(ctx context.Context, from TerminationDetails) {
}

func (m TerminationDetails) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["code"] = attrs["code"].SetOptional()
	attrs["message"] = attrs["message"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TerminationDetails.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TerminationDetails) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TerminationDetails
// only implements ToObjectValue() and Type().
func (m TerminationDetails) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"code":    m.Code,
			"message": m.Message,
			"type":    m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TerminationDetails) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"code":    types.StringType,
			"message": types.StringType,
			"type":    types.StringType,
		},
	}
}

// Additional details about what triggered the run
type TriggerInfo struct {
	// The run id of the Run Job task run
	RunId types.Int64 `tfsdk:"run_id"`
}

func (to *TriggerInfo) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggerInfo) {
}

func (to *TriggerInfo) SyncFieldsDuringRead(ctx context.Context, from TriggerInfo) {
}

func (m TriggerInfo) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["run_id"] = attrs["run_id"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggerInfo.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggerInfo) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggerInfo
// only implements ToObjectValue() and Type().
func (m TriggerInfo) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"run_id": m.RunId,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggerInfo) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"run_id": types.Int64Type,
		},
	}
}

type TriggerSettings struct {
	// File arrival trigger settings.
	FileArrival types.Object `tfsdk:"file_arrival"`
	// Whether this trigger is paused or not.
	PauseStatus types.String `tfsdk:"pause_status"`
	// Periodic trigger settings.
	Periodic types.Object `tfsdk:"periodic"`
	// Old table trigger settings name. Deprecated in favor of `table_update`.
	Table types.Object `tfsdk:"table"`

	TableUpdate types.Object `tfsdk:"table_update"`
}

func (to *TriggerSettings) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggerSettings) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				// Recursively sync the fields of FileArrival
				toFileArrival.SyncFieldsDuringCreateOrUpdate(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Periodic.IsNull() && !from.Periodic.IsUnknown() {
		if toPeriodic, ok := to.GetPeriodic(ctx); ok {
			if fromPeriodic, ok := from.GetPeriodic(ctx); ok {
				// Recursively sync the fields of Periodic
				toPeriodic.SyncFieldsDuringCreateOrUpdate(ctx, fromPeriodic)
				to.SetPeriodic(ctx, toPeriodic)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
	if !from.TableUpdate.IsNull() && !from.TableUpdate.IsUnknown() {
		if toTableUpdate, ok := to.GetTableUpdate(ctx); ok {
			if fromTableUpdate, ok := from.GetTableUpdate(ctx); ok {
				// Recursively sync the fields of TableUpdate
				toTableUpdate.SyncFieldsDuringCreateOrUpdate(ctx, fromTableUpdate)
				to.SetTableUpdate(ctx, toTableUpdate)
			}
		}
	}
}

func (to *TriggerSettings) SyncFieldsDuringRead(ctx context.Context, from TriggerSettings) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				toFileArrival.SyncFieldsDuringRead(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Periodic.IsNull() && !from.Periodic.IsUnknown() {
		if toPeriodic, ok := to.GetPeriodic(ctx); ok {
			if fromPeriodic, ok := from.GetPeriodic(ctx); ok {
				toPeriodic.SyncFieldsDuringRead(ctx, fromPeriodic)
				to.SetPeriodic(ctx, toPeriodic)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
	if !from.TableUpdate.IsNull() && !from.TableUpdate.IsUnknown() {
		if toTableUpdate, ok := to.GetTableUpdate(ctx); ok {
			if fromTableUpdate, ok := from.GetTableUpdate(ctx); ok {
				toTableUpdate.SyncFieldsDuringRead(ctx, fromTableUpdate)
				to.SetTableUpdate(ctx, toTableUpdate)
			}
		}
	}
}

func (m TriggerSettings) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["file_arrival"] = attrs["file_arrival"].SetOptional()
	attrs["pause_status"] = attrs["pause_status"].SetOptional()
	attrs["periodic"] = attrs["periodic"].SetOptional()
	attrs["table"] = attrs["table"].SetOptional()
	attrs["table_update"] = attrs["table_update"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggerSettings.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggerSettings) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"file_arrival": reflect.TypeOf(FileArrivalTriggerConfiguration{}),
		"periodic":     reflect.TypeOf(PeriodicTriggerConfiguration{}),
		"table":        reflect.TypeOf(TableUpdateTriggerConfiguration{}),
		"table_update": reflect.TypeOf(TableUpdateTriggerConfiguration{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggerSettings
// only implements ToObjectValue() and Type().
func (m TriggerSettings) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"file_arrival": m.FileArrival,
			"pause_status": m.PauseStatus,
			"periodic":     m.Periodic,
			"table":        m.Table,
			"table_update": m.TableUpdate,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggerSettings) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"file_arrival": FileArrivalTriggerConfiguration{}.Type(ctx),
			"pause_status": types.StringType,
			"periodic":     PeriodicTriggerConfiguration{}.Type(ctx),
			"table":        TableUpdateTriggerConfiguration{}.Type(ctx),
			"table_update": TableUpdateTriggerConfiguration{}.Type(ctx),
		},
	}
}

// GetFileArrival returns the value of the FileArrival field in TriggerSettings as
// a FileArrivalTriggerConfiguration value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings) GetFileArrival(ctx context.Context) (FileArrivalTriggerConfiguration, bool) {
	var e FileArrivalTriggerConfiguration
	if m.FileArrival.IsNull() || m.FileArrival.IsUnknown() {
		return e, false
	}
	var v FileArrivalTriggerConfiguration
	d := m.FileArrival.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFileArrival sets the value of the FileArrival field in TriggerSettings.
func (m *TriggerSettings) SetFileArrival(ctx context.Context, v FileArrivalTriggerConfiguration) {
	vs := v.ToObjectValue(ctx)
	m.FileArrival = vs
}

// GetPeriodic returns the value of the Periodic field in TriggerSettings as
// a PeriodicTriggerConfiguration value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings) GetPeriodic(ctx context.Context) (PeriodicTriggerConfiguration, bool) {
	var e PeriodicTriggerConfiguration
	if m.Periodic.IsNull() || m.Periodic.IsUnknown() {
		return e, false
	}
	var v PeriodicTriggerConfiguration
	d := m.Periodic.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetPeriodic sets the value of the Periodic field in TriggerSettings.
func (m *TriggerSettings) SetPeriodic(ctx context.Context, v PeriodicTriggerConfiguration) {
	vs := v.ToObjectValue(ctx)
	m.Periodic = vs
}

// GetTable returns the value of the Table field in TriggerSettings as
// a TableUpdateTriggerConfiguration value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings) GetTable(ctx context.Context) (TableUpdateTriggerConfiguration, bool) {
	var e TableUpdateTriggerConfiguration
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v TableUpdateTriggerConfiguration
	d := m.Table.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTable sets the value of the Table field in TriggerSettings.
func (m *TriggerSettings) SetTable(ctx context.Context, v TableUpdateTriggerConfiguration) {
	vs := v.ToObjectValue(ctx)
	m.Table = vs
}

// GetTableUpdate returns the value of the TableUpdate field in TriggerSettings as
// a TableUpdateTriggerConfiguration value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerSettings) GetTableUpdate(ctx context.Context) (TableUpdateTriggerConfiguration, bool) {
	var e TableUpdateTriggerConfiguration
	if m.TableUpdate.IsNull() || m.TableUpdate.IsUnknown() {
		return e, false
	}
	var v TableUpdateTriggerConfiguration
	d := m.TableUpdate.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTableUpdate sets the value of the TableUpdate field in TriggerSettings.
func (m *TriggerSettings) SetTableUpdate(ctx context.Context, v TableUpdateTriggerConfiguration) {
	vs := v.ToObjectValue(ctx)
	m.TableUpdate = vs
}

type TriggerStateProto struct {
	FileArrival types.Object `tfsdk:"file_arrival"`

	Table types.Object `tfsdk:"table"`
}

func (to *TriggerStateProto) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from TriggerStateProto) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				// Recursively sync the fields of FileArrival
				toFileArrival.SyncFieldsDuringCreateOrUpdate(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				// Recursively sync the fields of Table
				toTable.SyncFieldsDuringCreateOrUpdate(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (to *TriggerStateProto) SyncFieldsDuringRead(ctx context.Context, from TriggerStateProto) {
	if !from.FileArrival.IsNull() && !from.FileArrival.IsUnknown() {
		if toFileArrival, ok := to.GetFileArrival(ctx); ok {
			if fromFileArrival, ok := from.GetFileArrival(ctx); ok {
				toFileArrival.SyncFieldsDuringRead(ctx, fromFileArrival)
				to.SetFileArrival(ctx, toFileArrival)
			}
		}
	}
	if !from.Table.IsNull() && !from.Table.IsUnknown() {
		if toTable, ok := to.GetTable(ctx); ok {
			if fromTable, ok := from.GetTable(ctx); ok {
				toTable.SyncFieldsDuringRead(ctx, fromTable)
				to.SetTable(ctx, toTable)
			}
		}
	}
}

func (m TriggerStateProto) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["file_arrival"] = attrs["file_arrival"].SetOptional()
	attrs["table"] = attrs["table"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in TriggerStateProto.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m TriggerStateProto) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"file_arrival": reflect.TypeOf(FileArrivalTriggerState{}),
		"table":        reflect.TypeOf(TableTriggerState{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, TriggerStateProto
// only implements ToObjectValue() and Type().
func (m TriggerStateProto) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"file_arrival": m.FileArrival,
			"table":        m.Table,
		})
}

// Type implements basetypes.ObjectValuable.
func (m TriggerStateProto) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"file_arrival": FileArrivalTriggerState{}.Type(ctx),
			"table":        TableTriggerState{}.Type(ctx),
		},
	}
}

// GetFileArrival returns the value of the FileArrival field in TriggerStateProto as
// a FileArrivalTriggerState value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerStateProto) GetFileArrival(ctx context.Context) (FileArrivalTriggerState, bool) {
	var e FileArrivalTriggerState
	if m.FileArrival.IsNull() || m.FileArrival.IsUnknown() {
		return e, false
	}
	var v FileArrivalTriggerState
	d := m.FileArrival.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFileArrival sets the value of the FileArrival field in TriggerStateProto.
func (m *TriggerStateProto) SetFileArrival(ctx context.Context, v FileArrivalTriggerState) {
	vs := v.ToObjectValue(ctx)
	m.FileArrival = vs
}

// GetTable returns the value of the Table field in TriggerStateProto as
// a TableTriggerState value.
// If the field is unknown or null, the boolean return value is false.
func (m *TriggerStateProto) GetTable(ctx context.Context) (TableTriggerState, bool) {
	var e TableTriggerState
	if m.Table.IsNull() || m.Table.IsUnknown() {
		return e, false
	}
	var v TableTriggerState
	d := m.Table.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetTable sets the value of the Table field in TriggerStateProto.
func (m *TriggerStateProto) SetTable(ctx context.Context, v TableTriggerState) {
	vs := v.ToObjectValue(ctx)
	m.Table = vs
}

type UpdateJob struct {
	// Remove top-level fields in the job settings. Removing nested fields is
	// not supported, except for tasks and job clusters (`tasks/task_1`). This
	// field is optional.
	FieldsToRemove types.List `tfsdk:"fields_to_remove"`
	// The canonical identifier of the job to update. This field is required.
	JobId types.Int64 `tfsdk:"job_id"`
	// The new settings for the job.
	//
	// Top-level fields specified in `new_settings` are completely replaced,
	// except for arrays which are merged. That is, new and existing entries are
	// completely replaced based on the respective key fields, i.e. `task_key`
	// or `job_cluster_key`, while previous entries are kept.
	//
	// Partially updating nested fields is not supported.
	//
	// Changes to the field `JobSettings.timeout_seconds` are applied to active
	// runs. Changes to other fields are applied to future runs only.
	NewSettings types.Object `tfsdk:"new_settings"`
}

func (to *UpdateJob) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from UpdateJob) {
	if !from.FieldsToRemove.IsNull() && !from.FieldsToRemove.IsUnknown() && to.FieldsToRemove.IsNull() && len(from.FieldsToRemove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for FieldsToRemove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.FieldsToRemove = from.FieldsToRemove
	}
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				// Recursively sync the fields of NewSettings
				toNewSettings.SyncFieldsDuringCreateOrUpdate(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (to *UpdateJob) SyncFieldsDuringRead(ctx context.Context, from UpdateJob) {
	if !from.FieldsToRemove.IsNull() && !from.FieldsToRemove.IsUnknown() && to.FieldsToRemove.IsNull() && len(from.FieldsToRemove.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for FieldsToRemove, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.FieldsToRemove = from.FieldsToRemove
	}
	if !from.NewSettings.IsNull() && !from.NewSettings.IsUnknown() {
		if toNewSettings, ok := to.GetNewSettings(ctx); ok {
			if fromNewSettings, ok := from.GetNewSettings(ctx); ok {
				toNewSettings.SyncFieldsDuringRead(ctx, fromNewSettings)
				to.SetNewSettings(ctx, toNewSettings)
			}
		}
	}
}

func (m UpdateJob) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["fields_to_remove"] = attrs["fields_to_remove"].SetOptional()
	attrs["job_id"] = attrs["job_id"].SetRequired()
	attrs["new_settings"] = attrs["new_settings"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in UpdateJob.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m UpdateJob) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"fields_to_remove": reflect.TypeOf(types.String{}),
		"new_settings":     reflect.TypeOf(JobSettings{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, UpdateJob
// only implements ToObjectValue() and Type().
func (m UpdateJob) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"fields_to_remove": m.FieldsToRemove,
			"job_id":           m.JobId,
			"new_settings":     m.NewSettings,
		})
}

// Type implements basetypes.ObjectValuable.
func (m UpdateJob) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"fields_to_remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"job_id":       types.Int64Type,
			"new_settings": JobSettings{}.Type(ctx),
		},
	}
}

// GetFieldsToRemove returns the value of the FieldsToRemove field in UpdateJob as
// a slice of types.String values.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateJob) GetFieldsToRemove(ctx context.Context) ([]types.String, bool) {
	if m.FieldsToRemove.IsNull() || m.FieldsToRemove.IsUnknown() {
		return nil, false
	}
	var v []types.String
	d := m.FieldsToRemove.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetFieldsToRemove sets the value of the FieldsToRemove field in UpdateJob.
func (m *UpdateJob) SetFieldsToRemove(ctx context.Context, v []types.String) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e)
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["fields_to_remove"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.FieldsToRemove = types.ListValueMust(t, vs)
}

// GetNewSettings returns the value of the NewSettings field in UpdateJob as
// a JobSettings value.
// If the field is unknown or null, the boolean return value is false.
func (m *UpdateJob) GetNewSettings(ctx context.Context) (JobSettings, bool) {
	var e JobSettings
	if m.NewSettings.IsNull() || m.NewSettings.IsUnknown() {
		return e, false
	}
	var v JobSettings
	d := m.NewSettings.As(ctx, &v, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetNewSettings sets the value of the NewSettings field in UpdateJob.
func (m *UpdateJob) SetNewSettings(ctx context.Context, v JobSettings) {
	vs := v.ToObjectValue(ctx)
	m.NewSettings = vs
}

type ViewItem struct {
	// Content of the view.
	Content types.String `tfsdk:"content"`
	// Name of the view item. In the case of code view, it would be the
	// notebook’s name. In the case of dashboard view, it would be the
	// dashboard’s name.
	Name types.String `tfsdk:"name"`
	// Type of the view item.
	Type_ types.String `tfsdk:"type"`
}

func (to *ViewItem) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from ViewItem) {
}

func (to *ViewItem) SyncFieldsDuringRead(ctx context.Context, from ViewItem) {
}

func (m ViewItem) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["content"] = attrs["content"].SetOptional()
	attrs["name"] = attrs["name"].SetOptional()
	attrs["type"] = attrs["type"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in ViewItem.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m ViewItem) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, ViewItem
// only implements ToObjectValue() and Type().
func (m ViewItem) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"content": m.Content,
			"name":    m.Name,
			"type":    m.Type_,
		})
}

// Type implements basetypes.ObjectValuable.
func (m ViewItem) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"content": types.StringType,
			"name":    types.StringType,
			"type":    types.StringType,
		},
	}
}

type Webhook struct {
	Id types.String `tfsdk:"id"`
}

func (to *Webhook) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from Webhook) {
}

func (to *Webhook) SyncFieldsDuringRead(ctx context.Context, from Webhook) {
}

func (m Webhook) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["id"] = attrs["id"].SetRequired()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in Webhook.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m Webhook) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, Webhook
// only implements ToObjectValue() and Type().
func (m Webhook) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"id": m.Id,
		})
}

// Type implements basetypes.ObjectValuable.
func (m Webhook) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id": types.StringType,
		},
	}
}

type WebhookNotifications struct {
	// An optional list of system notification IDs to call when the duration of
	// a run exceeds the threshold specified for the `RUN_DURATION_SECONDS`
	// metric in the `health` field. A maximum of 3 destinations can be
	// specified for the `on_duration_warning_threshold_exceeded` property.
	OnDurationWarningThresholdExceeded types.List `tfsdk:"on_duration_warning_threshold_exceeded"`
	// An optional list of system notification IDs to call when the run fails. A
	// maximum of 3 destinations can be specified for the `on_failure` property.
	OnFailure types.List `tfsdk:"on_failure"`
	// An optional list of system notification IDs to call when the run starts.
	// A maximum of 3 destinations can be specified for the `on_start` property.
	OnStart types.List `tfsdk:"on_start"`
	// An optional list of system notification IDs to call when any streaming
	// backlog thresholds are exceeded for any stream. Streaming backlog
	// thresholds can be set in the `health` field using the following metrics:
	// `STREAMING_BACKLOG_BYTES`, `STREAMING_BACKLOG_RECORDS`,
	// `STREAMING_BACKLOG_SECONDS`, or `STREAMING_BACKLOG_FILES`. Alerting is
	// based on the 10-minute average of these metrics. If the issue persists,
	// notifications are resent every 30 minutes. A maximum of 3 destinations
	// can be specified for the `on_streaming_backlog_exceeded` property.
	OnStreamingBacklogExceeded types.List `tfsdk:"on_streaming_backlog_exceeded"`
	// An optional list of system notification IDs to call when the run
	// completes successfully. A maximum of 3 destinations can be specified for
	// the `on_success` property.
	OnSuccess types.List `tfsdk:"on_success"`
}

func (to *WebhookNotifications) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from WebhookNotifications) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (to *WebhookNotifications) SyncFieldsDuringRead(ctx context.Context, from WebhookNotifications) {
	if !from.OnDurationWarningThresholdExceeded.IsNull() && !from.OnDurationWarningThresholdExceeded.IsUnknown() && to.OnDurationWarningThresholdExceeded.IsNull() && len(from.OnDurationWarningThresholdExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnDurationWarningThresholdExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnDurationWarningThresholdExceeded = from.OnDurationWarningThresholdExceeded
	}
	if !from.OnFailure.IsNull() && !from.OnFailure.IsUnknown() && to.OnFailure.IsNull() && len(from.OnFailure.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnFailure, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnFailure = from.OnFailure
	}
	if !from.OnStart.IsNull() && !from.OnStart.IsUnknown() && to.OnStart.IsNull() && len(from.OnStart.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStart, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStart = from.OnStart
	}
	if !from.OnStreamingBacklogExceeded.IsNull() && !from.OnStreamingBacklogExceeded.IsUnknown() && to.OnStreamingBacklogExceeded.IsNull() && len(from.OnStreamingBacklogExceeded.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnStreamingBacklogExceeded, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnStreamingBacklogExceeded = from.OnStreamingBacklogExceeded
	}
	if !from.OnSuccess.IsNull() && !from.OnSuccess.IsUnknown() && to.OnSuccess.IsNull() && len(from.OnSuccess.Elements()) == 0 {
		// The default representation of an empty list for TF autogenerated resources in the resource state is Null.
		// If a user specified a non-Null, empty list for OnSuccess, and the deserialized field value is Null,
		// set the resulting resource state to the empty list to match the planned value.
		to.OnSuccess = from.OnSuccess
	}
}

func (m WebhookNotifications) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["on_duration_warning_threshold_exceeded"] = attrs["on_duration_warning_threshold_exceeded"].SetOptional()
	attrs["on_failure"] = attrs["on_failure"].SetOptional()
	attrs["on_start"] = attrs["on_start"].SetOptional()
	attrs["on_streaming_backlog_exceeded"] = attrs["on_streaming_backlog_exceeded"].SetOptional()
	attrs["on_success"] = attrs["on_success"].SetOptional()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WebhookNotifications.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m WebhookNotifications) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{
		"on_duration_warning_threshold_exceeded": reflect.TypeOf(Webhook{}),
		"on_failure":                             reflect.TypeOf(Webhook{}),
		"on_start":                               reflect.TypeOf(Webhook{}),
		"on_streaming_backlog_exceeded":          reflect.TypeOf(Webhook{}),
		"on_success":                             reflect.TypeOf(Webhook{}),
	}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WebhookNotifications
// only implements ToObjectValue() and Type().
func (m WebhookNotifications) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"on_duration_warning_threshold_exceeded": m.OnDurationWarningThresholdExceeded,
			"on_failure":                             m.OnFailure,
			"on_start":                               m.OnStart,
			"on_streaming_backlog_exceeded":          m.OnStreamingBacklogExceeded,
			"on_success":                             m.OnSuccess,
		})
}

// Type implements basetypes.ObjectValuable.
func (m WebhookNotifications) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"on_duration_warning_threshold_exceeded": basetypes.ListType{
				ElemType: Webhook{}.Type(ctx),
			},
			"on_failure": basetypes.ListType{
				ElemType: Webhook{}.Type(ctx),
			},
			"on_start": basetypes.ListType{
				ElemType: Webhook{}.Type(ctx),
			},
			"on_streaming_backlog_exceeded": basetypes.ListType{
				ElemType: Webhook{}.Type(ctx),
			},
			"on_success": basetypes.ListType{
				ElemType: Webhook{}.Type(ctx),
			},
		},
	}
}

// GetOnDurationWarningThresholdExceeded returns the value of the OnDurationWarningThresholdExceeded field in WebhookNotifications as
// a slice of Webhook values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications) GetOnDurationWarningThresholdExceeded(ctx context.Context) ([]Webhook, bool) {
	if m.OnDurationWarningThresholdExceeded.IsNull() || m.OnDurationWarningThresholdExceeded.IsUnknown() {
		return nil, false
	}
	var v []Webhook
	d := m.OnDurationWarningThresholdExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnDurationWarningThresholdExceeded sets the value of the OnDurationWarningThresholdExceeded field in WebhookNotifications.
func (m *WebhookNotifications) SetOnDurationWarningThresholdExceeded(ctx context.Context, v []Webhook) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_duration_warning_threshold_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnDurationWarningThresholdExceeded = types.ListValueMust(t, vs)
}

// GetOnFailure returns the value of the OnFailure field in WebhookNotifications as
// a slice of Webhook values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications) GetOnFailure(ctx context.Context) ([]Webhook, bool) {
	if m.OnFailure.IsNull() || m.OnFailure.IsUnknown() {
		return nil, false
	}
	var v []Webhook
	d := m.OnFailure.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnFailure sets the value of the OnFailure field in WebhookNotifications.
func (m *WebhookNotifications) SetOnFailure(ctx context.Context, v []Webhook) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_failure"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnFailure = types.ListValueMust(t, vs)
}

// GetOnStart returns the value of the OnStart field in WebhookNotifications as
// a slice of Webhook values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications) GetOnStart(ctx context.Context) ([]Webhook, bool) {
	if m.OnStart.IsNull() || m.OnStart.IsUnknown() {
		return nil, false
	}
	var v []Webhook
	d := m.OnStart.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStart sets the value of the OnStart field in WebhookNotifications.
func (m *WebhookNotifications) SetOnStart(ctx context.Context, v []Webhook) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_start"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStart = types.ListValueMust(t, vs)
}

// GetOnStreamingBacklogExceeded returns the value of the OnStreamingBacklogExceeded field in WebhookNotifications as
// a slice of Webhook values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications) GetOnStreamingBacklogExceeded(ctx context.Context) ([]Webhook, bool) {
	if m.OnStreamingBacklogExceeded.IsNull() || m.OnStreamingBacklogExceeded.IsUnknown() {
		return nil, false
	}
	var v []Webhook
	d := m.OnStreamingBacklogExceeded.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnStreamingBacklogExceeded sets the value of the OnStreamingBacklogExceeded field in WebhookNotifications.
func (m *WebhookNotifications) SetOnStreamingBacklogExceeded(ctx context.Context, v []Webhook) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_streaming_backlog_exceeded"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnStreamingBacklogExceeded = types.ListValueMust(t, vs)
}

// GetOnSuccess returns the value of the OnSuccess field in WebhookNotifications as
// a slice of Webhook values.
// If the field is unknown or null, the boolean return value is false.
func (m *WebhookNotifications) GetOnSuccess(ctx context.Context) ([]Webhook, bool) {
	if m.OnSuccess.IsNull() || m.OnSuccess.IsUnknown() {
		return nil, false
	}
	var v []Webhook
	d := m.OnSuccess.ElementsAs(ctx, &v, true)
	if d.HasError() {
		panic(pluginfwcommon.DiagToString(d))
	}
	return v, true
}

// SetOnSuccess sets the value of the OnSuccess field in WebhookNotifications.
func (m *WebhookNotifications) SetOnSuccess(ctx context.Context, v []Webhook) {
	vs := make([]attr.Value, 0, len(v))
	for _, e := range v {
		vs = append(vs, e.ToObjectValue(ctx))
	}
	t := m.Type(ctx).(basetypes.ObjectType).AttrTypes["on_success"]
	t = t.(attr.TypeWithElementType).ElementType()
	m.OnSuccess = types.ListValueMust(t, vs)
}

type WidgetErrorDetail struct {
	Message types.String `tfsdk:"message"`
}

func (to *WidgetErrorDetail) SyncFieldsDuringCreateOrUpdate(ctx context.Context, from WidgetErrorDetail) {
}

func (to *WidgetErrorDetail) SyncFieldsDuringRead(ctx context.Context, from WidgetErrorDetail) {
}

func (m WidgetErrorDetail) ApplySchemaCustomizations(attrs map[string]tfschema.AttributeBuilder) map[string]tfschema.AttributeBuilder {
	attrs["message"] = attrs["message"].SetComputed()

	return attrs
}

// GetComplexFieldTypes returns a map of the types of elements in complex fields in WidgetErrorDetail.
// Container types (types.Map, types.List, types.Set) and object types (types.Object) do not carry
// the type information of their elements in the Go type system. This function provides a way to
// retrieve the type information of the elements in complex fields at runtime. The values of the map
// are the reflected types of the contained elements. They must be either primitive values from the
// plugin framework type system (types.String{}, types.Bool{}, types.Int64{}, types.Float64{}) or TF
// SDK values.
func (m WidgetErrorDetail) GetComplexFieldTypes(ctx context.Context) map[string]reflect.Type {
	return map[string]reflect.Type{}
}

// TFSDK types cannot implement the ObjectValuable interface directly, as it would otherwise
// interfere with how the plugin framework retrieves and sets values in state. Thus, WidgetErrorDetail
// only implements ToObjectValue() and Type().
func (m WidgetErrorDetail) ToObjectValue(ctx context.Context) basetypes.ObjectValue {
	return types.ObjectValueMust(
		m.Type(ctx).(basetypes.ObjectType).AttrTypes,
		map[string]attr.Value{
			"message": m.Message,
		})
}

// Type implements basetypes.ObjectValuable.
func (m WidgetErrorDetail) Type(ctx context.Context) attr.Type {
	return types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"message": types.StringType,
		},
	}
}
